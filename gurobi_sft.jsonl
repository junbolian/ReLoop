{"meta": {"source_path": "/Users/sunyujun03/Desktop/ReLoop/gurobi-modeling-examples/efficiency_analysis/efficiency_analysis.ipynb", "kind": "ipynb", "title": "Efficiency Analysis"}, "messages": [{"role": "system", "content": "You are an optimization engineer. Write correct and runnable Python code using gurobipy (Gurobi Python API). Be concise. Output only what is requested."}, {"role": "user", "content": "    Task: Reproduce the following Gurobi modeling example in Python using gurobipy.\n\n    Scenario description (from source):\n    # Efficiency Analysis \n\n## Objective and Prerequisites\n\nHow can mathematical optimization be used to measure the efficiency of an organization? Find out in this example, where you’ll learn how to formulate an Efficiency Analysis model as a linear programming problem using the Gurobi Python API and then generate an optimal solution with the Gurobi Optimizer.\n\nThis model is example 22 from the fifth edition of Model Building in Mathematical Programming by H. Paul Williams on pages 278-280 and 335-336.\n\nThis example is at the intermediate level, where we assume that you know Python and the Gurobi Python API and that you have some knowledge of building mathematical optimization models.\n\n**Download the Repository** <br /> \nYou can download the repository containing this and other examples by clicking [here](https://github.com/Gurobi/modeling-examples/archive/master.zip). \n\n## Background\n\n The Data Envelopment Analysis (DEA) is a nonparametric problem in operations research and economics whose solution is an estimation of production frontiers. It is used to empirically measure the productive efficiency of decision making units (DMUs). There are a number of linear programming formulations of the DEA problem. Fuller coverage of the subject can be found in Farrell (1957), Charnes et al. (1978) and Thanassoulis et al. (1987). The formulation given by H.P. Williams is described in Land (1991). This formulation is the dual model of a model  commonly used that relies on finding weighted ratios of outputs to inputs. We will use the formulation that is commonly used and can be found in Cooper et al. (2007).\n\nThe Data Envelopment Analysis has been used to evaluate the performance of many different kinds of entities engaged in many different activities, and in many different contexts in many different countries. Examples include the maintenance activities of U.S. Air Force bases in different geographic locations, or police forces in England and Wales as well as the performance of branch banks in Cyprus and Canada and the efficiency of universities in performing their education and research functions in the U.S., England and France. \n\nThe DEA approach is concerned with evaluations of *efficiency*. The most common measure of efficiency takes the form of a ratio like the following one:\n\n$$\n\\text{efficiency} = \\frac{\\text{output}}{\\text{input}}\n$$\n\n## Model Formulation\n\nAssume there is a set of DMUs. Some common input and output items for each of these DMUs are selected as follows:\n1. Numerical data are available for each input and output, with the data assumed to be positive, for all DMUs.\n2. The items (inputs, outputs and choice of DMUs) should reflect an analyst's or a manager's interest in the components that will enter into the relative efficiency evaluations of the DMUs.\n3. In principle, smaller input amounts are preferable and larger output amounts are preferable so the efficiency scores should reflect these principles.\n4. The measurement units of the different inputs and outputs do not need to be congruent. Some may involve a number of persons, or areas of floor space, money expended, etc.\n\n### Fractional problem formulation\nThe proposed measure of the efficiency of a target DMU $k$ is obtained as the maximum of a ratio of weighted outputs to weighted inputs subject to the condition that the similar ratios for every DMU be less than or equal to one.\n\n### Sets and indices\n\n$j,k \\in \\text{DMUS}$: Indices and set of DMUs, where $k$ represents the target DMU.\n\n$i \\in \\text{Inputs}$: Index and set of inputs.\n\n$r \\in \\text{Outputs}$: Index and set of outputs.\n\n### Parameters\n\n$\\text{invalue}_{i,j} > 0$: Value of input $i$ for DMU $j$.\n\n$\\text{outvalue}_{r,j} > 0$: Value of output $r$ for DMU $j$.\n\n### Decision Variables\n\n$u_{r} \\geq 0$: Weight of output $r$.\n\n$v_{i} \\geq 0$: Weight of input  $i$.\n\n### Objective function\n\n**Target DMU Efficiency**: Maximize efficiency at the target DMU $k$.\n\n$$\n\\text{Maximize} \\quad E_k = \n\\frac{\\sum_{r \\in \\text{Outputs}} \\text{outvalue}_{r,k}*u_{r}}{\\sum_{i \\in \\text{Inputs}} \\text{invalue}_{i,k}*v_{i}}\n\\tag{FP0}\n$$\n\n### Constraints\n\n**Efficiency ratios**: The efficiency of a DMU is a number between $[0,1]$.\n\n\\begin{equation}\n\\frac{\\sum_{r \\in \\text{Outputs}} \\text{outvalue}_{r,j}*u_{r}}{\\sum_{i \\in \\text{Inputs}} \\text{invalue}_{i,j}*v_{i}}\n \\leq 1 \\quad \\forall j \\in \\text{DMUS}\n \\tag{FP1}\n\\end{equation}\n\n### Linear programming problem formulation\n\nThis linear programming formulation can be found in the book by Cooper et al. (2007).\n\n### Objective function\n\n**Target DMU Efficiency**: Maximize efficiency at the target DMU $k$.\n\n$$\n\\text{Maximize} \\quad E_k = \\sum_{r \\in \\text{Outputs}} \\text{outvalue}_{r,k}*u_{r}\n\\tag{LP0}\n$$\n\n### Constraints\n\n**Efficiency ratio**: The efficiency of a DMU is a number between $[0,1]$.\n\n\\begin{equation}\n\\sum_{r \\in \\text{Outputs}} \\text{outvalue}_{r,j}*u_{r} -\n\\sum_{i \\in \\text{Inputs}} \\text{invalue}_{i,k}*v_{i}\n \\leq 0  \\quad \\forall j \\in \\text{DMUS}\n\\tag{LP1}\n\\end{equation}\n\n**Normalization**: This constraint ensures that the denominator of the objective function of the fractional problem is equal to one.\n\n\\begin{equation}\n\\sum_{i \\in \\text{Inputs}} \\text{invalue}_{i,k}*v_{i} = 1 \n\\tag{LP2}\n\\end{equation}\n\nIt is easy to verify that the fractional problem and the linear programming problem are equivalent. Let's assume that the denominator of the efficiency ratio constraints of the fractional problem is positive for all DMUs, then we can obtain the constraints $LP1$ by multiplying both sides of the constraints $FP1$ by the denominator. Next, we set the denominator of $FP0$ eqaul to 1 and define constraint $LP2$, and then maximize the numerator, resulting in the objective function $LP0$.\n\n### Definition of efficiency\n\n1. $DMU_k$ is efficient if the optimal objective function value $E_{k}^{*} = 1$.\n2. Otherwise, $DMU_k$ is inefficient.\n\n    Requirements:\n    - Use gurobipy (Model, GRB, addVar/addConstr, etc.)\n    - Make the script runnable as a standalone Python file if possible.\n    - Keep the code faithful to the example.\n"}, {"role": "assistant", "content": "import pandas as pd\nfrom itertools import product\n\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# tested with Python 3.7.0 & Gurobi 9.1.0\n\ndef solve_DEA(target, verbose=True):\n    # input-output values for the garages\n    inattr = ['staff', 'showRoom', 'Population1', 'Population2', 'alphaEnquiries', 'betaEnquiries']\n    outattr = ['alphaSales', 'BetaSales', 'profit']\n    \n    dmus, inputs, outputs = gp.multidict({\n        'Winchester': [{'staff': 7, 'showRoom': 8, 'Population1': 10, 'Population2': 12, 'alphaEnquiries': 8.5, 'betaEnquiries': 4}, {'alphaSales': 2, 'BetaSales': 0.6, 'profit': 1.5}],\n        'Andover': [{'staff': 6, 'showRoom': 6, 'Population1': 20, 'Population2': 30, 'alphaEnquiries': 9, 'betaEnquiries': 4.5}, {'alphaSales': 2.3, 'BetaSales': 0.7, 'profit': 1.6}],\n        'Basingstoke': [{'staff': 2, 'showRoom': 3, 'Population1': 40, 'Population2': 40, 'alphaEnquiries': 2, 'betaEnquiries': 1.5}, {'alphaSales': 0.8, 'BetaSales': 0.25, 'profit': 0.5}],\n        'Poole': [{'staff': 14, 'showRoom': 9, 'Population1': 20, 'Population2': 25, 'alphaEnquiries': 10, 'betaEnquiries': 6}, {'alphaSales': 2.6, 'BetaSales': 0.86, 'profit': 1.9}],\n        'Woking': [{'staff': 10, 'showRoom': 9, 'Population1': 10, 'Population2': 10, 'alphaEnquiries': 11, 'betaEnquiries': 5}, {'alphaSales': 2.4, 'BetaSales': 1, 'profit': 2}],\n        'Newbury': [{'staff': 24, 'showRoom': 15, 'Population1': 15, 'Population2': 13, 'alphaEnquiries': 25, 'betaEnquiries': 1.9}, {'alphaSales': 8, 'BetaSales': 2.6, 'profit': 4.5}],\n        'Portsmouth': [{'staff': 6, 'showRoom': 7, 'Population1': 50, 'Population2': 40, 'alphaEnquiries': 8.5, 'betaEnquiries': 3}, {'alphaSales': 2.5, 'BetaSales': 0.9, 'profit': 1.6}],\n        'Alresford': [{'staff': 8, 'showRoom': 7.5, 'Population1': 5, 'Population2': 8, 'alphaEnquiries': 9, 'betaEnquiries': 4}, {'alphaSales': 2.1, 'BetaSales': 0.85, 'profit': 2}],\n        'Salisbury': [{'staff': 5, 'showRoom': 5, 'Population1': 10, 'Population2': 10, 'alphaEnquiries': 5, 'betaEnquiries': 2.5}, {'alphaSales': 2, 'BetaSales': 0.65, 'profit': 0.9}],\n        'Guildford': [{'staff': 8, 'showRoom': 10, 'Population1': 30, 'Population2': 35, 'alphaEnquiries': 9.5, 'betaEnquiries': 4.5}, {'alphaSales': 2.05, 'BetaSales': 0.75, 'profit': 1.7}],\n        'Alton': [{'staff': 7, 'showRoom': 8, 'Population1': 7, 'Population2': 8, 'alphaEnquiries': 3, 'betaEnquiries': 2}, {'alphaSales': 1.9, 'BetaSales': 0.70, 'profit': 0.5}],\n        'Weybridge': [{'staff': 5, 'showRoom': 6.5, 'Population1': 9, 'Population2': 12, 'alphaEnquiries': 8, 'betaEnquiries': 4.5}, {'alphaSales': 1.8, 'BetaSales': 0.63, 'profit': 1.4}],\n        'Dorchester': [{'staff': 6, 'showRoom': 7.5, 'Population1': 10, 'Population2': 10, 'alphaEnquiries': 7.5, 'betaEnquiries': 4}, {'alphaSales': 1.5, 'BetaSales': 0.45, 'profit': 1.45}],\n        'Bridport': [{'staff': 11, 'showRoom': 8, 'Population1': 8, 'Population2': 10, 'alphaEnquiries': 10, 'betaEnquiries': 6}, {'alphaSales': 2.2, 'BetaSales': 0.65, 'profit': 2.2}],\n        'Weymouth': [{'staff': 4, 'showRoom': 5, 'Population1': 10, 'Population2': 10, 'alphaEnquiries': 7.5, 'betaEnquiries': 3.5}, {'alphaSales': 1.8, 'BetaSales': 0.62, 'profit': 1.6}],\n        'Portland': [{'staff': 3, 'showRoom': 3.5, 'Population1': 3, 'Population2': 20, 'alphaEnquiries': 2, 'betaEnquiries': 1.5}, {'alphaSales': 0.9, 'BetaSales': 0.35, 'profit': 0.5}],\n        'Chichester': [{'staff': 5, 'showRoom': 5.5, 'Population1': 8, 'Population2': 10, 'alphaEnquiries': 7, 'betaEnquiries': 3.5}, {'alphaSales': 1.2, 'BetaSales': 0.45, 'profit': 1.3}],\n        'Petersfield': [{'staff': 21, 'showRoom': 12, 'Population1': 6, 'Population2': 6, 'alphaEnquiries': 15, 'betaEnquiries': 8}, {'alphaSales': 6, 'BetaSales': 0.25, 'profit': 2.9}],\n        'Petworth': [{'staff': 6, 'showRoom': 5.5, 'Population1': 2, 'Population2': 2, 'alphaEnquiries': 8, 'betaEnquiries': 5}, {'alphaSales': 1.5, 'BetaSales': 0.55, 'profit': 1.55}],\n        'Midhurst': [{'staff': 3, 'showRoom': 3.6, 'Population1': 3, 'Population2': 3, 'alphaEnquiries': 2.5, 'betaEnquiries': 1.5}, {'alphaSales': 0.8, 'BetaSales': 0.20, 'profit': 0.45}],\n        'Reading': [{'staff': 30, 'showRoom': 29, 'Population1': 120, 'Population2': 80, 'alphaEnquiries': 35, 'betaEnquiries': 20}, {'alphaSales': 7, 'BetaSales': 2.5, 'profit': 8}],\n        'Southampton': [{'staff': 25, 'showRoom': 16, 'Population1': 110, 'Population2': 80, 'alphaEnquiries': 27, 'betaEnquiries': 12}, {'alphaSales': 6.5, 'BetaSales': 3.5, 'profit': 5.4}],\n        'Bournemouth': [{'staff': 19, 'showRoom': 10, 'Population1': 90, 'Population2': 22, 'alphaEnquiries': 25, 'betaEnquiries': 13}, {'alphaSales': 5.5, 'BetaSales': 3.1, 'profit': 4.5}],\n        'Henley': [{'staff': 7, 'showRoom': 6, 'Population1': 5, 'Population2': 7, 'alphaEnquiries': 8.5, 'betaEnquiries': 4.5}, {'alphaSales': 1.2, 'BetaSales': 0.48, 'profit': 2}],\n        'Maidenhead': [{'staff': 12, 'showRoom': 8, 'Population1': 7, 'Population2': 10, 'alphaEnquiries': 12, 'betaEnquiries': 7}, {'alphaSales': 4.5, 'BetaSales': 2, 'profit': 2.3}],\n        'Fareham': [{'staff': 4, 'showRoom': 6, 'Population1': 1, 'Population2': 1, 'alphaEnquiries': 7.5, 'betaEnquiries': 3.5}, {'alphaSales': 1.1, 'BetaSales': 0.48, 'profit': 1.7}],\n        'Romsey': [{'staff': 2, 'showRoom': 2.5, 'Population1': 1, 'Population2': 1, 'alphaEnquiries': 2.5, 'betaEnquiries': 1}, {'alphaSales': 0.4, 'BetaSales': 0.1, 'profit': 0.55}],\n        'Ringwood': [{'staff': 2, 'showRoom': 3.5, 'Population1': 2, 'Population2': 2, 'alphaEnquiries': 1.9, 'betaEnquiries': 1.2}, {'alphaSales': 0.3, 'BetaSales': 0.09, 'profit': 0.4}]\n    })\n    \n    ### Create LP model\n    model = gp.Model('DEA')\n    \n    # Decision variables\n    wout = model.addVars(outattr, name=\"outputWeight\")\n    win = model.addVars(inattr, name=\"inputWeight\")\n\n    # Constraints\n    ratios = model.addConstrs( ( gp.quicksum(outputs[h][r]*wout[r] for r in outattr ) \n                                - gp.quicksum(inputs[h][i]*win[i] for i in inattr ) \n                                <= 0 for h in dmus ), name='ratios' )\n    \n    normalization = model.addConstr((gp.quicksum(inputs[target][i]*win[i] for i in inattr ) == 1 ),\n                                    name='normalization')\n    \n    # Objective function\n    \n    model.setObjective( gp.quicksum(outputs[target][r]*wout[r] for r in outattr ), GRB.MAXIMIZE)\n    \n    # Run optimization engine\n    if not verbose:\n        model.params.OutputFlag = 0\n    model.optimize()\n    \n    # Print results\n    print(f\"\\nThe efficiency of target DMU {target} is {round(model.objVal,3)}\") \n    \n    print(\"__________________________________________________________________\")\n    print(f\"The weights for the inputs are:\")\n    for i in inattr:\n        print(f\"For {i}: {round(win[i].x,3)} \") \n        \n    print(\"__________________________________________________________________\")\n    print(f\"The weights for the outputs are\")\n    for r in outattr:\n        print(f\"For {r} is: {round(wout[r].x,3)} \") \n    print(\"__________________________________________________________________\\n\\n\")  \n    \n    return model.objVal\n\ndmus = ['Winchester','Andover','Basingstoke', 'Poole', 'Woking','Newbury','Portsmouth','Alresford','Salisbury','Guildford','Alton','Weybridge', 'Dorchester', 'Bridport', 'Weymouth', 'Portland', 'Chichester', 'Petersfield', 'Petworth', 'Midhurst', 'Reading', 'Southampton', 'Bournemouth', 'Henley', 'Maidenhead', 'Fareham', 'Romsey', 'Ringwood']\n\n# Solving DEA model for each DMU\n\nperformance = {}\nfor h in dmus:    \n    performance[h] = solve_DEA(h, verbose=False)\n\n# Identifying efficient and inefficient DMUs\n\n# Sorting garages in descending efficiency number\nsorted_performance = {k: v for k, v in sorted(performance.items(), key=lambda item: item[1], reverse = True)}\n\nefficient = []\ninefficient = []\n\nfor h in sorted_performance.keys():\n    if sorted_performance[h] >= 0.9999999:\n        efficient.append(h) \n    if sorted_performance[h] < 0.9999999:\n        inefficient.append(h) \n        \nprint('____________________________________________')\nprint(f\"The efficient DMUs are:\")\nfor eff in efficient:\n    print(f\"The performance value of DMU {eff} is: {round(performance[eff],3)}\") \n    \nprint('____________________________________________')\nprint(f\"The inefficient DMUs are:\")\nfor ine in inefficient:\n    print(f\"The performance value of DMU {ine} is: {round(performance[ine],3)}\")"}]}
{"meta": {"source_path": "/Users/sunyujun03/Desktop/ReLoop/gurobi-modeling-examples/protein_folding/protein_folding.ipynb", "kind": "ipynb", "title": "Protein Folding"}, "messages": [{"role": "system", "content": "You are an optimization engineer. Write correct and runnable Python code using gurobipy (Gurobi Python API). Be concise. Output only what is requested."}, {"role": "user", "content": "    Task: Reproduce the following Gurobi modeling example in Python using gurobipy.\n\n    Scenario description (from source):\n    # Protein Folding\n\n## Objective and Prerequisites\n\nHone your modeling skills with this challenging Protein Folding problem. We’ll show you how to create a binary optimization model of the problem with the Gurobi Python API and then solve it using the Gurobi Optimizer.\n\nThis model is example 28 from the fifth edition of Model Building in Mathematical Programming by H. Paul Williams on pages 289-290 and 344-345.\n\nThis modeling example is at the advanced level, where we assume that you know Python and the Gurobi Python API and that you have advanced knowledge of building mathematical optimization models. Typically, the objective function and/or constraints of these examples are complex or require advanced features of the Gurobi Python API.\n\n**Download the Repository** <br /> \nYou can download the repository containing this and other examples by clicking [here](https://github.com/Gurobi/modeling-examples/archive/master.zip). \n\n**Gurobi License** <br /> \nIn order to run this Jupyter Notebook properly, you must have a Gurobi license. If you do not have one, you can request an [evaluation license](https://www.gurobi.com/downloads/request-an-evaluation-license/) as a *commercial user*, or download a [free license](https://www.gurobi.com/academia/academic-program-and-licenses/) as an *academic user*.\n\n---\n## Problem Description\n\nThe problem described in this Jupyter Notebook is based on a molecular biology problem that is discussed in a paper entitled “Quadratic Binary Programming Models in Computational Biology” by Forrester and Greenberg (2008). The problem pertains to a protein, which consists of a chain of amino acids. In this problem, the amino acids come in two forms: hydrophilic (waterloving) and hydrophobic (water hating). An example of such a chain is given in the following figure with the hydrophobic acids marked in bold.\n\n![chain](chain.PNG)\n\nSuch a chain naturally folds so as to bring as many hydrophobic acids as possible close together. A folding for the chain, in two dimensions, is given in the following figure, with the new matches marked by dashed lines. Our objective is to predict the optimum folding.\n\n![folding](folding.PNG)\n\nTo solve the problem posed here, we must find the optimum folding for a chain of 50 amino acids with hydrophobic acids at positions 2, 4, 5, 6, 11, 12, 17, 20, 21, 25, 27, 28, 30, 31, 33, 37, 44 and 46.\n\n---\n## Model Formulation\n\n### Sets and Indices\n\n$k \\in A =\\{1,2,...,50\\}$: Chain of aminoacids.\n\n$i,j \\in H =\\{2,4,5,6,11,12,17,20,21,25,27,28,30,31,33,37,44,46\\} \\subseteq Aminoacids $: Subset of aminoacids that are hydrophobic.\n\n### Decision variables\n\n$\\text{match}_{i,j} \\equiv x_{i,j} = 1$, iff hydrophobic acid $i$ is matched with acid $j$, for all hydrophobic acids $ i < j \\in H$. This matching does not include those matchings that are predefined by virtue of the acids being contiguous in the chain, i.e. $j > i+1$).\n\n$\\text{fold}_{k} \\equiv y_{k} = 1$, iff a fold occurs between the $i$th and $(i +1)$st acids in the chain.\n\n### Constraints\n\nFor each pair of hydrophobic acids $i$ and $j$, we can match them if: \n* they are not contiguous, that is, already matched, \n* they have an even number of acids between them in the chain,\n* and there is exactly one fold between $i$ and $j$ . \n\nThis gives rise to the following constraints.\n\n1. $y_{k} + x_{i,j} \\leq 1, \\; \\forall k \\in A, (i,j) \\in H, \\; \\text{such that} \\; i \\leq k < j, \\; \\text{and} \\; \nk \\neq (i+j-1)/2$.\n2. $x_{i,j} \\leq y_{k}, \\; \\text{where} \\; k = (i+j-1)/2 $.\n\nLet $\\text{H_fold} = \\{(i,j) \\in H: x_{i,j} \\leq y_{k}, \\; k = (i+j-1)/2  \\}$ be the set of hydrophobic acids for which there is a folding that enables the matching.\n\n### Objective function\nThe objective is to maximize the number of matchings of hydrophobic acids.\n\n$$\n\\sum_{i,j \\in \\text{H_fold}} x_{i,j}\n$$\n\n---\n## Python Implementation\n\nWe import the Gurobi Python Module.\n\n    Requirements:\n    - Use gurobipy (Model, GRB, addVar/addConstr, etc.)\n    - Make the script runnable as a standalone Python file if possible.\n    - Keep the code faithful to the example.\n"}, {"role": "assistant", "content": "# Note, the restricted license is not sufficient to run this notebook, a full license is needed\n\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# tested with Python 3.11 & Gurobi 11.0\n\n# list of aminoacids and hydrophobic acids\n\nacids = [*range(1,51)]\n\nh_phobic = [2,4,5,6,11,12,17,20,21,25,27,28,30,31,33,37,44,46]\n\n# Creating the data structures to generate the model\nlist_ij = []\n\n# Indices of hydrophobic acids that can be matched\nfor i in h_phobic:\n    for j in h_phobic:\n        if j > i + 1:\n            tp = i,j\n            list_ij.append(tp)\n            \nij = gp.tuplelist(list_ij)\n\n###\nlist_ik1j = []\n\nlist_ik2j = []\n\nfor i,j in ij:\n    for k in range(i,j):\n        if (k == (i+j-1)/2  ):\n            tp = i,j,k\n            list_ik2j.append(tp)\n        else:\n            tp = i,j,k\n            list_ik1j.append(tp)\n\n# Indices for constraints of type 2\nik2j = gp.tuplelist(list_ik2j)\n\n# Indices for constraints of type 1\nik1j = gp.tuplelist(list_ik1j)\n\n# Matchings that are enabled by a folding\nlist_ijfold = []\n\nfor i,j,k in ik2j:\n    tp = i,j\n    list_ijfold.append(tp)\n\nijfold = gp.tuplelist(list_ijfold)\n\nmodel = gp.Model('ProteinFolding')\n\n# Matching variables\nmatch = model.addVars(ij, vtype=GRB.BINARY, name=\"match\")\n\n# Folding variables\nfold = model.addVars(acids, vtype=GRB.BINARY, name=\"fold\")\n\n# Constraint 1:\n\nC1 = model.addConstrs( (fold[k] + match[i,j] <= 1 for i,j,k in ik1j ) , name='C1')\n\n# Constraint 2:\n\nC2 = model.addConstrs( ( match[i,j] <= fold[k]  for i,j,k in ik2j ) , name='C2')\n\n# Objective function\n\nmodel.setObjective(gp.quicksum(match[i,j] for i,j in ijfold) , GRB.MAXIMIZE )\n\n# Verify model formulation\n\nmodel.write('ProteinFolding.lp')\n\n# Run optimization engine\n\nmodel.optimize()\n\n# Output report\n\nprint(f\"Optimal number of hydrophobic acids matchings: {model.objVal}\")\n\nprint(\"_______________________________________\")\nprint(f\"Optimal matching of hydrophobic acids.\")\nprint(\"_______________________________________\")\n\nfor i,j,k in ik2j:\n    if (match[i,j].x > 0.5): \n        print(f\"Hydrophobic acid matching {i,j} with folding at amonacid {k}.\")"}]}
{"meta": {"source_path": "/Users/sunyujun03/Desktop/ReLoop/gurobi-modeling-examples/burrito_optimization_game/burrito_optimization_game.ipynb", "kind": "ipynb", "title": "burrito_optimization_game"}, "messages": [{"role": "system", "content": "You are an optimization engineer. Write correct and runnable Python code using gurobipy (Gurobi Python API). Be concise. Output only what is requested."}, {"role": "user", "content": "    Task: Reproduce the following Gurobi modeling example in Python using gurobipy.\n\n    Scenario description (from source):\n    ![Burrito Optimization Game](util/bog_header.png)\n<center><a target=\"_blank\" href=\"https://www.burritooptimizationgame.com/\">BurritoOptimizationGame.com</a></center>\n<center><a target=\"_blank\" href=\"https://www.gurobi.com/lp/academics/burrito-optimization-game-guide/\">Game Guide</a>  |  <a target=\"_blank\" href=\"https://www.gurobi.com/lp/academics/burrito-optimization-teaching-guide/\">Teaching Guide</a></center>\n<center>Notebook by Alison Cozad  | <a target=\"_blank\" href=\"https://www.gurobi.com/lp/academics/burrito-optimization-game-guide/#who-built-this\">Game credits</a></center>\n\nThe Burrito Optimization Game is an educational game designed to introduce students to the power of optimization. In the game, the player places burrito trucks on a city map to earn as much profit as possible. In playing the game, the player is essentially solving an optimization problem “by hand”. The game is designed to introduce players to optimization—what it is, what it’s useful for, and why it’s hard to do by hand. To play the game, you must be logged in to your Gurobi account on a desktop.\n\nIn this notebook, we will learn how to write the Burrito game optimization model for any day in Round 1 using the data downloaded from the game.\n\nThis modeling tutorial is at the introductory level, where we assume that you know Python and have a background in a discipline that uses quantitative methods.  \n\nHere are a few handy resources to have ready:\n- [Gurobi Python Documentation](https://www.gurobi.com/documentation/9.5/refman/py_python_api_overview.html)\n- [Gurobi Python Examples](https://www.gurobi.com/documentation/9.5/examples/python_examples.html)\n- [Burrito Optimization Game: Teaching Guide](https://www.gurobi.com/lp/academics/burrito-optimization-teaching-guide/)\n- [Burrito Optimization Game: Game Guide](https://www.gurobi.com/lp/academics/burrito-optimization-game-guide/)\n\n---\n\n## Problem description\n\nGuroble has just set up business in Burritoville! Guroble needs your assistance planning where to place its burrito trucks to serve hungry customers throughout the city and maximize its profit. Truck placement must be carefully planned because every truck has a cost, but its ability to earn revenue depends on how close it is to potential customers.\n\n### Your task in the game:\n![Your task in the game](util/bog_instructions.png)\n\n### Your task in this notebook: \nWrite a model to select the optimal burrito truck placement to maximize profits.  You will be solving for one day in Round 1.\n\n---\n\n## Before you dive into this model, \nIf you haven't already, we recommend playing Days 1 and 2 in Round 1 of the [BurritoOptimizationGame.com](https://www.burritooptimizationgame.com/) to learn about Burritoville and the problem we are trying to solve.  Then, ask yourself:\n- What seems easy or hard about locating burrito trucks? \n- Did you find a solution that was close to optimal?\n- Should you order a burrito now or wait until you are done with this notebook?\n- What strategy did you use? I bet you wish you had your own optimization model, eh? (Cue shameless promotion of this Jupyter Notebook).\n\n    Requirements:\n    - Use gurobipy (Model, GRB, addVar/addConstr, etc.)\n    - Make the script runnable as a standalone Python file if possible.\n    - Keep the code faithful to the example.\n"}, {"role": "assistant", "content": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Round and day specific string. Note: This model is only valid for Round 1\npath = \"https://raw.githubusercontent.com/Gurobi/modeling-examples/master/burrito_optimization_game/data/\"\n\n### CHANGE THIS TO SWITCH DAYS. ###\n# This should match the csv filenames (e.g., round1-day1, round1-day2, round1-day3...)\nround_day_str = \"round1-day1\" \n#round_day_str = \"round1-day2\" \n#round_day_str = \"round1-day3\" \n#round_day_str = \"round1-day4\"\n\nimport pandas as pd\n\n# Define the urls to pull data from\nurls={\n    'Problem data': path + round_day_str + \"_problem_data.csv\",\n    'Truck node data': path + round_day_str + \"_truck_node_data.csv\",\n    'Demand node data': path + round_day_str + \"_demand_node_data.csv\",\n    'Demand-Truck data': path + round_day_str + \"_demand_truck_data.csv\" , \n}\n\nprint(f\"Here is a summary of '{round_day_str}':\")\n\n# Read in basic problem data\nurl = urls['Problem data']\ndf = pd.read_csv(url)\nburrito_price = float(df['burrito_price'][0])\ningredient_cost = float(df['ingredient_cost'][0])\ntruck_cost = float(df['truck_cost'][0])\nprint(f\"  - The burritos cost ₲{ingredient_cost} to make and are sold for ₲{burrito_price}. Each truck costs ₲{truck_cost} to use per day.\")\n\n# Read in truck node data\nurl = urls['Truck node data']\ndf = pd.read_csv(url)\ntruck_coordinates = {row['index']:(float(row['x']),float(row['y'])) for ind,row in df.iterrows()}\ntruck_spots = truck_coordinates.keys()\nprint(f\"  - There are {len(truck_spots)} available 'truck_spots' or places where a truck can be placed around Burritoville.\")\n \n# Read in building data\nurl = urls['Demand node data']\ndf = pd.read_csv(url)\nbuildings, building_names, building_coordinates, demand = gp.multidict({\n        row['index']: [row['name'], (float(row['x']), float(row['y'])), float(row['demand'])] for ind,row in df.iterrows()\n    })\nprint(f\"  - There are in {len(buildings)} buildings with hungry customers also known as demand nodes.\")\n\n\n# Read in paired building and truck data\nurl = urls['Demand-Truck data']\ndf = pd.read_csv(url)\nbuilding_truck_spot_pairs, distance, scaled_demand = gp.multidict({\n        (row['demand_node_index'], row['truck_node_index']): [float(row['distance']), float(row['scaled_demand'])] for ind,row in df.iterrows() if float(row['scaled_demand'])>0# (building, truck_spot): distance, scaled_demand\n    })\nprint(f\"  - There are in {len(building_truck_spot_pairs)} pairs of trucks spots and buildings with hungry customers.\")\n\n# Plot the truck spots and customer demands on the Burritoville map\nimport requests\nr = requests.get('https://raw.githubusercontent.com/Gurobi/modeling-examples/master/burrito_optimization_game/util/show_map.py')\nwith open('show_map_local.py', 'w') as f:\n    f.write(r.text)\nfrom show_map_local import show_map\n\nshow_map(buildings, building_names, building_coordinates, demand, truck_coordinates)\n\n# Declare and initialize model\nmodel = gp.Model(\"Burrito Optimization Game\")\n\n# Create decision variables for the Burrito Optimization Game model\nx_placed = model.addVars(truck_spots, vtype=GRB.BINARY, name=\"x_placed\")\ny_served = model.addVars(building_truck_spot_pairs, vtype=GRB.BINARY, name=\"y_served\")\n\n# Create truck-must-exist constraints\ncons1 = model.addConstrs((y_served[b,t] <= x_placed[t] \n                          for b,t in building_truck_spot_pairs), \n                          name = \"Ensure_truck_spot_open_to_serve\")\n\n# Create only one truck per customers at building constraint\ncons2 = model.addConstrs((y_served.sum(b,'*') <= 1 for b in buildings), \n                         name=\"Ensure_one_truck_per_customers_at_building\")\n\n# Objective: maximize total profit = burrito_revenue - total_truck_cost\nburrito_revenue = (burrito_price - ingredient_cost)*y_served.prod(scaled_demand) # This is the nested summation\ntotal_truck_cost = truck_cost*x_placed.sum('*')\n\nmodel.setObjective(burrito_revenue - total_truck_cost, GRB.MAXIMIZE)\n\nmodel.write('burrito_game.lp')\n\nmodel.optimize()\n\nstatus = model.status\nif status == GRB.OPTIMAL:\n    print(f\"The final objective is \")\n    print(f\"     Burrito revenue        ₲{burrito_revenue.getValue()}\")\n    print(f\" -  Total truck cost     -  ₲{total_truck_cost.getValue()}\")\n    print(f\"-----------------------------------\")\n    print(f\"              Profit        ₲{model.objVal}\")\nelse:\n    print(f\"Model is not optimal, status = {status}\")\n\n# Plot the solution on the Burritoville Map\nplaced_trucks = [t for t in x_placed if x_placed[t].X ==1]\nshow_map(buildings, building_names, building_coordinates, demand, truck_coordinates, placed_trucks = placed_trucks)\n\n# Free Gurobi resources: Model and environment\nmodel.dispose()\ngp.disposeDefaultEnv()"}]}
{"meta": {"source_path": "/Users/sunyujun03/Desktop/ReLoop/gurobi-modeling-examples/manpower_planning/manpower_planning.ipynb", "kind": "ipynb", "title": "Manpower Planning"}, "messages": [{"role": "system", "content": "You are an optimization engineer. Write correct and runnable Python code using gurobipy (Gurobi Python API). Be concise. Output only what is requested."}, {"role": "user", "content": "    Task: Reproduce the following Gurobi modeling example in Python using gurobipy.\n\n    Scenario description (from source):\n    # Manpower Planning\n\n## Objective and Prerequisites\n\nStaffing problems – which require difficult decisions about the recruitment, training, layoffs, and scheduling of workers – are common across a broad range of manufacturing and service industries. In this example, you’ll learn how to model and solve a complex staffing problem by creating an optimal multi-period operation plan that minimizes the total number of layoffs and costs.\n\nMore information on this type of model can be found in example #5 of the fifth edition of Model Building in Mathematical Programming by H. Paul Williams on pages 256 – 257 and 303 – 304.\n\nThis modeling example is at the advanced level, where we assume that you know Python and the Gurobi Python API and that you have advanced knowledge of building mathematical optimization models. Typically, the objective function and/or constraints of these examples are complex or require advanced features of the Gurobi Python API.\n\n**Download the Repository** <br />\nYou can download the repository containing this and other examples by clicking [here](https://github.com/Gurobi/modeling-examples/archive/master.zip). \n\n---\n## Problem Description\n\nA company is changing how it runs its business, and therefore its staffing needs are expected to change.\n\nThrough the purchase of new machinery, it is expected that there will be less need for unskilled labor and more need for skilled and semi-skilled labor. In addition, a lower sales forecast ⁠— driven by an economic slowdown that is predicted to happen in the next year ⁠— is expected to further reduce labor needs across all categories.\n\nThe forecast for labor needs over the next three years is as follows:\n\n| <i></i> | Unskilled | Semi-skilled | Skilled |\n| --- | --- | --- | --- |\n| Current Strength | 2000 | 1500 | 1000 |\n| Year 1 | 1000 | 1400 | 1000 |\n| Year 2 | 500 | 2000 | 1500 |\n| Year 3 | 0 | 2500 | 2000 |\n\nThe company needs to determine the following for each of the next three years:\n\n- Recruitment\n- Retraining\n- Layoffs (redundancy)\n- Part-time vs. full-time employees\n\nIt is important to note that labor is subject to a certain level of natural attrition each year. The rate of attrition is relatively high in the first year after a new employee is hired and relatively low in subsequent years. The expected attrition rates are as follows:\n\n| <i></i> | Unskilled (%)| Semi-skilled (%) | Skilled (%) |\n| --- | --- | --- | --- |\n| $< 1$ year of service | 25 | 20 | 10 |\n| $\\geq 1$ year of service | 10 | 5 | 5 |\n\nAll of the current workers have been with the company for at least one year.\n\n### Recruitment\n\nEach year, it is possible to hire a limited number of employees in each classification from outside the company as follows:\n\n| Unskilled | Semi-skilled | Skilled |\n| --- | --- | --- |\n| 500 | 800 | 500 |\n\n### Retraining\n\nEach year, it is possible to train up to 200 unskilled workers to make them into semi-skilled workers. This training costs the company $\\$400$ per worker.\n\nIn addition, it is possible train semi-skilled workers to make them into skilled workers. However, this number can not exceed 25% of the current skilled labor force and this training costs $\\$500$ per worker.\n\nLastly, downgrading workers to a lower skill level can be done. However, 50% of the downgraded workers will leave the company, increasing the natural attrition rate described above.\n\n### Layoffs\n\nEach laid-off worker is entitled to a separation payment at the rate of $\\$200$ per unskilled worker and $\\$500$ per semi-skilled or skilled worker.\n\n### Excess Employees\n\nIt is possible to have workers in excess of the actual number needed, up to 150 workers in total in any given year, but this will result in the following additional cost per excess employee per year.\n\n| Unskilled | Semi-skilled | Skilled |\n| --- | --- | --- |\n| $\\$1500$ | $\\$2000$ | $\\$3000$ |\n\n### Part-time Workers\n\nUp to 50 employees of each skill level can be assigned to part-time work. The cost of doing so (per employee, per year) is as follows:\n\n| Unskilled | Semi-skilled | Skilled |\n| --- | --- | --- |\n| $\\$500$ | $\\$400$ | $\\$400$ |\n\n**Note:** A part-time employee is half as productive as a full-time employee.\n\nIf the company’s objective is to minimize layoffs, what plan should they adopt in order to do this?\n\nIf their objective is to minimize costs, how much could they further reduce costs?\n\nHow can they determine the annual savings possible across each job?\n\n---\n## Model Formulation\n\n### Sets and Indices\n\n$t \\in \\text{Years}=\\{1,2,3\\}$: Set of years.\n\n$s \\in \\text{Skills}=\\{s_1: \\text{unskilled},s_2: \\text{semi_skilled},s_3: \\text{skilled}\\}$: Set of skills.\n\n### Parameters\n\n$\\text{rookie_attrition} \\in [0,1] \\subset \\mathbb{R}^+$: Percentage of workers who leave within the first year of service.\n\n$\\text{veteran_attrition} \\in [0,1] \\subset \\mathbb{R}^+$: Percentage of workers who leave after the first year of service.\n\n$\\text{demoted_attrition} \\in [0,1] \\subset \\mathbb{R}^+$: Percentage of workers who leave the company after a demotion.\n\n$\\text{parttime_cap} \\in [0,1] \\subset \\mathbb{R}^+$: Productivity of part-time workers with respect to full-time workers.\n\n$\\text{max_train_unskilled} \\in \\mathbb{N}$: Maximum number of unskilled workers that can be trained on any given year.\n\n$\\text{max_train_semiskilled} \\in [0,1] \\subset \\mathbb{R}^+$: Maximum proportion of semi-skilled workers (w.r.t. skilled ones) that can be trained on any given year.\n\n$\\text{max_parttime} \\in \\mathbb{N}$: Maximum number of part-time workers of each skill at any given year.\n\n$\\text{max_overmanning} \\in \\mathbb{N}$: Maximum number of overmanned workers at any given year.\n\n$\\text{max_hiring}_s \\in \\mathbb{N}$: Maximum number of workers of skill $s$ that can be hired any given year.\n\n$\\text{training_cost}_s \\in \\mathbb{R}^+$: Cost for training a worker of skill $s$ to the next level.\n\n$\\text{layoff_cost}_s \\in \\mathbb{R}^+$: Cost for laying off a worker of skill $s$.\n\n$\\text{parttime_cost}_s \\in \\mathbb{R}^+$: Cost for assigning a worker of skill $s$ to part-time work.\n\n$\\text{overmanning_cost}_s \\in \\mathbb{R}^+$: Yearly cost for having excess manpower of skill $s$.\n\n$\\text{curr_workforce}_s \\in \\mathbb{N}$: Current manpower of skill $s$ at the beginning of the planning horizon.\n\n$\\text{demand}_{t,s} \\in \\mathbb{N}$: Required manpower of skill $s$ in year $t$.\n\n### Decision Variables\n\n$\\text{hire}_{t,s} \\in [0,\\text{max_hiring}_s] \\subset \\mathbb{R}^+$: Number of workers of skill $s$ to hire in year $t$.\n\n$\\text{part_time}_{t,s} \\in [0,\\text{max_parttime}] \\subset \\mathbb{R}^+$: Number of part-time workers of skill $s$ working in year $t$.\n\n$\\text{workforce}_{t,s} \\in \\mathbb{R}^+$: Number of workers of skill $s$ that are available in year $t$.\n\n$\\text{layoff}_{t,s} \\in \\mathbb{R}^+$: Number of workers of skill $s$ that are laid off in year $t$.\n\n$\\text{excess}_{t,s} \\in \\mathbb{R}^+$: Number of workers of skill $s$ that are overmanned in year $t$.\n\n$\\text{train}_{t,s,s'} \\in \\mathbb{R}^+$: Number of workers of skill $s$ to retrain to skill $s'$ in year $t$.\n\n### Objective Function\n\n- **Layoffs:** Minimize the total layoffs during the planning horizon.\n\n\\begin{equation}\n\\text{Minimize} \\quad Z = \\sum_{t \\in \\text{Years}}\\sum_{s \\in \\text{Skills}}{\\text{layoff}_{t,s}}\n\\end{equation}\n\n- **Cost:** Minimize the total cost (in USD) incurred by training, overmanning, part-time workers, and layoffs in the planning horizon.\n\n\\begin{equation}\n\\text{Minimize} \\quad W = \\sum_{t \\in \\text{Years}}{\\{\\text{training_cost}_{s_1}*\\text{train}_{t,s1,s2} + \\text{training_cost}_{s_2}*\\text{train}_{t,s2,s3}\\}}\n\\end{equation}\n\n\\begin{equation}\n+ \\sum_{t \\in \\text{Years}}\\sum_{s \\in \\text{Skills}}{\\{\\text{parttime_cost}*\\text{part_time}_{t,s} + \\text{layoff_cost}_s*\\text{layoff}_{t,s} + \\text{overmanning_cost}_s*\\text{excess}_{t,s}\\}}\n\\end{equation}\n\n### Constraints\n\n- **Initial Balance:** Workforce $s$ available in year $t=1$ is equal to the workforce of the previous year, recent hires, promoted and demoted workers (after accounting for attrition), minus layoffs and transferred workers.\n\n\\begin{equation}\n\\text{workforce}_{1,s} = (1-\\text{veteran_attrition}_s)*\\text{curr_workforce} + (1-\\text{rookie_attrition}_s)*\\text{hire}_{1,s} \n\\end{equation}\n\n\\begin{equation}\n+ \\sum_{s' \\in \\text{Skills} | s' < s}{\\{(1-\\text{veteran_attrition})*\\text{train}_{1,s',s} - \\text{train}_{1,s,s'}\\}} \n\\end{equation}\n\n\\begin{equation}\n+ \\sum_{s' \\in \\text{Skills} | s' > s}{\\{(1-\\text{demoted_attrition})*\\text{train}_{1,s',s} - \\text{train}_{1,s,s'}\\}} - \\text{layoff}_{1,s} \\qquad \\forall s \\in \\text{Skills}\n\\end{equation}\n\n- **Balance:** Workforce $s$ available in year $t > 1$ is equal to the workforce of the previous year, recent hires, promoted and demoted workers (after accounting for attrition), minus layoffs and transferred workers.\n\n\\begin{equation}\n\\text{workforce}_{t,s} = (1-\\text{veteran_attrition}_s)*\\text{workforce}_{t-1,s} + (1-\\text{rookie_attrition}_s)*\\text{hire}_{t,s} \n\\end{equation}\n\n\\begin{equation}\n+ \\sum_{s' \\in \\text{Skills} | s' < s}{\\{(1-\\text{veteran_attrition})*\\text{train}_{t,s',s} - \\text{train}_{t,s,s'}\\}}\n\\end{equation}\n\n\\begin{equation}\n+ \\sum_{s' \\in \\text{Skills} | s' > s}{\\{(1-\\text{demotion_attrition})*\\text{train}_{t,s',s} - \\text{train}_{t,s,s'}\\}} - \\text{layoff}_{t,s} \\quad \\forall (t > 1,s) \\in \\text{Years} \\times \\text{Skills}\n\\end{equation}\n\n- **Unskilled Training:** Unskilled workers trained in year $t$ cannot exceed the maximum allowance. Unskilled workers cannot be immediately transformed into skilled workers.\n\n\\begin{equation}\n\\text{train}_{t,s_1,s_2} \\leq 200 \\quad \\forall t \\in \\text{Years}\n\\end{equation}\n\n\\begin{equation}\n\\text{train}_{t,s_1,s_3} = 0 \\quad \\forall t \\in \\text{Years}\n\\end{equation}\n\n- **Semi-skilled Training:** Semi-skilled workers trained in year $t$ cannot exceed the maximum allowance.\n\n\\begin{equation}\n\\text{train}_{t,s_2,s_3} \\leq 0.25*\\text{available}_{t,s_3} \\quad \\forall t \\in \\text{Years}\n\\end{equation}\n\n- **Overmanning:** Excess workers in year $t$ cannot exceed the maximum allowance.\n\n\\begin{equation}\n\\sum_{s \\in \\text{Skills}}{\\text{excess}_{t,s}} \\leq \\text{max_overmanning} \\quad \\forall t \\in \\text{Years}\n\\end{equation}\n\n- **Demand:** Workforce $s$ available in year $t$ equals the required number of workers plus the excess workers and the part-time workers.\n\n\\begin{equation}\n\\text{available}_{t,s} = \\text{demand}_{t,s} + \\text{excess}_{t,s} + \\text{parttime_cap}*\\text{part_time}_{t,s} \\quad \\forall (t,s) \\in \\text{Years} \\times \\text{Skills}\n\\end{equation}\n\n---\n## Python Implementation\n\nWe import the Gurobi Python Module and other Python libraries.\n\n## Input Data\nWe define all the input data of the model.\n\n## Model Deployment\nWe create a model and the variables. For each of the three skill levels and for each year, we will create variables for the number of workers that get recruited, transferred into part-time work, are available as workers, are redundant, or are overmanned. For each pair of skill levels and each year, we have a variable for the amount of workers that get retrained to a higher/lower skill level. The number of people who are part-time and can be recruited is limited.\n\nNext, we insert the constraints. The balance constraints ensure that per skill level and per year the workers who are currently required (LaborForce) and the people who get laid off, and the people who get retrained to the current level, minus the people who get retrained from the current level to a different skill, equals the LaborForce of the last year (or the CurrentStrength in the first year) plus the recruited people. A certain amount of people leave the company each year, so this is also considered to be a factor. This constraint describes the change in the total amount of employed workers.\n\n    Requirements:\n    - Use gurobipy (Model, GRB, addVar/addConstr, etc.)\n    - Make the script runnable as a standalone Python file if possible.\n    - Keep the code faithful to the example.\n"}, {"role": "assistant", "content": "import numpy as np\nimport pandas as pd\n\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# tested with Python 3.11 & Gurobi 11.0\n\n# Parameters\n\nyears = [1, 2, 3]\nskills = ['s1', 's2', 's3']\n\ncurr_workforce = {'s1': 2000, 's2': 1500, 's3': 1000}\ndemand = {\n    (1, 's1'): 1000,\n    (1, 's2'): 1400,\n    (1, 's3'): 1000,\n    (2, 's1'): 500,\n    (2, 's2'): 2000,\n    (2, 's3'): 1500,\n    (3, 's1'): 0,\n    (3, 's2'): 2500,\n    (3, 's3'): 2000\n}\nrookie_attrition = {'s1': 0.25, 's2': 0.20, 's3': 0.10}\nveteran_attrition = {'s1': 0.10, 's2': 0.05, 's3': 0.05}\ndemoted_attrition = 0.50\nmax_hiring = {\n    (1, 's1'): 500,\n    (1, 's2'): 800,\n    (1, 's3'): 500,\n    (2, 's1'): 500,\n    (2, 's2'): 800,\n    (2, 's3'): 500,\n    (3, 's1'): 500,\n    (3, 's2'): 800,\n    (3, 's3'): 500\n}\nmax_overmanning = 150\nmax_parttime = 50\nparttime_cap = 0.50\nmax_train_unskilled = 200\nmax_train_semiskilled = 0.25\n\ntraining_cost = {'s1': 400, 's2': 500}\nlayoff_cost = {'s1': 200, 's2': 500, 's3': 500}\nparttime_cost = {'s1': 500, 's2': 400, 's3': 400}\novermanning_cost = {'s1': 1500, 's2': 2000, 's3': 3000}\n\nmanpower = gp.Model('Manpower planning')\n\nhire = manpower.addVars(years, skills, ub=max_hiring, name=\"Hire\")\npart_time = manpower.addVars(years, skills, ub=max_parttime,\n                          name=\"Part_time\")\nworkforce = manpower.addVars(years, skills, name=\"Available\")\nlayoff = manpower.addVars(years, skills, name=\"Layoff\")\nexcess = manpower.addVars(years, skills, name=\"Overmanned\")\ntrain = manpower.addVars(years, skills, skills, name=\"Train\")\n\n#1.1 & 1.2 Balance\n\nBalance = manpower.addConstrs(\n    (workforce[year, level] == (1-veteran_attrition[level])*(curr_workforce[level] if year == 1 else workforce[year-1, level])\n    + (1-rookie_attrition[level])*hire[year, level] + gp.quicksum((1- veteran_attrition[level])* train[year, level2, level]\n                                                        -train[year, level, level2] for level2 in skills if level2 < level)\n    + gp.quicksum((1- demoted_attrition)* train[year, level2, level] -train[year, level, level2] for level2 in skills if level2 > level)\n    - layoff[year, level] for year in years for level in skills), \"Balance\")\n\n#2.1 & 2.2  Unskilled training\nUnskilledTrain1 = manpower.addConstrs((train[year, 's1', 's2'] <= max_train_unskilled for year in years), \"Unskilled_training1\")\nUnskilledTrain2 = manpower.addConstrs((train[year, 's1', 's3'] == 0 for year in years), \"Unskilled_training2\")\n\n#3. Semi-skilled training\n\nSemiskilledTrain = manpower.addConstrs((train[year,'s2', 's3'] <= max_train_semiskilled * workforce[year,'s3'] for year in years), \"Semiskilled_training\")\n\n#4. Overmanning\nOvermanning = manpower.addConstrs((excess.sum(year, '*') <= max_overmanning for year in years), \"Overmanning\")\n\n#5. Demand\nDemand = manpower.addConstrs((workforce[year, level] ==\n     demand[year,level] + excess[year, level] + parttime_cap * part_time[year, level]\n                     for year in years for level in skills), \"Requirements\")\n\n#0.1 Objective Function: Minimize layoffs\nobj1 = layoff.sum()\nmanpower.setObjective(obj1, GRB.MINIMIZE)\n\nmanpower.optimize()\n\nrows = years.copy()\ncolumns = skills.copy()\nhire_plan = pd.DataFrame(columns=columns, index=rows, data=0.0)\n\nfor year, level in hire.keys():\n    if (abs(hire[year, level].x) > 1e-6):\n        hire_plan.loc[year, level] = np.round(hire[year, level].x, 1)\nhire_plan\n\nrows = years.copy()\ncolumns = ['{0} to {1}'.format(level1, level2) for level1 in skills for level2 in skills if level1 != level2]\ntrain_plan = pd.DataFrame(columns=columns, index=rows, data=0.0)\n\nfor year, level1, level2 in train.keys():\n    col = '{0} to {1}'.format(level1, level2)\n    if (abs(train[year, level1, level2].x) > 1e-6):\n        train_plan.loc[year, col] = np.round(train[year, level1, level2].x, 1)\ntrain_plan\n\nrows = years.copy()\ncolumns = skills.copy()\nlayoff_plan = pd.DataFrame(columns=columns, index=rows, data=0.0)\n\nfor year, level in layoff.keys():\n    if (abs(layoff[year, level].x) > 1e-6):\n        layoff_plan.loc[year, level] = np.round(layoff[year, level].x, 1)\nlayoff_plan\n\nrows = years.copy()\ncolumns = skills.copy()\nparttime_plan = pd.DataFrame(columns=columns, index=rows, data=0.0)\n\nfor year, level in part_time.keys():\n    if (abs(part_time[year, level].x) > 1e-6):\n        parttime_plan.loc[year, level] = np.round(part_time[year, level].x, 1)\nparttime_plan\n\nrows = years.copy()\ncolumns = skills.copy()\nexcess_plan = pd.DataFrame(columns=columns, index=rows, data=0.0)\n\nfor year, level in excess.keys():\n    if (abs(excess[year, level].x) > 1e-6):\n        excess_plan.loc[year, level] = np.round(excess[year, level].x, 1)\nexcess_plan"}]}
{"meta": {"source_path": "/Users/sunyujun03/Desktop/ReLoop/gurobi-modeling-examples/technician_routing_scheduling/technician_routing_scheduling.ipynb", "kind": "ipynb", "title": "Technician Routing and Scheduling Problem"}, "messages": [{"role": "system", "content": "You are an optimization engineer. Write correct and runnable Python code using gurobipy (Gurobi Python API). Be concise. Output only what is requested."}, {"role": "user", "content": "    Task: Reproduce the following Gurobi modeling example in Python using gurobipy.\n\n    Scenario description (from source):\n    # Technician Routing and Scheduling Problem\n\n## Objective and Prerequisites\n\nTry this modeling example to discover how mathematical optimization can help telecommunications firms automate and improve their technician assignment, scheduling, and routing decisions in order to ensure the highest levels of customer satisfaction.\n\nThis modeling example is at the intermediate level, where we assume that you know Python and are familiar with the Gurobi Python API. In addition, you have some knowledge about building mathematical optimization models. To fully understand the content of this notebook, you should be familiar with object-oriented-programming.\n\n**Download the Repository** <br /> \nYou can download the repository containing this and other examples by clicking [here](https://github.com/Gurobi/modeling-examples/archive/master.zip).\n\n## Motivation\nThe Technician Routing and Scheduling (TRS) is a common problem faced by telecommunication firms, which must be able to provide services for a large number of customers. With its limited resources, these firms must try to deliver timely, affordable and reliable services to maximize customer satisfaction. The TRS problem involves assignment, scheduling, and routing of multi-skilled technicians to serve customers with unique priorities, service time windows, processing times, skills requirements, and geographical locations. \nIn the current practice, these decisions are often being made by operators via heuristics, sometimes manually -and this method\ncan not only be time-consuming, \nbut may also deviate from optima significantly. \nUsing mathematical optimization to solve the\nTRS problem  will\nenable \ntelecom operators and dispatchers to automate and improve their assignment, scheduling, and routing decisions, while achieving high customer satisfaction.\n\n## Problem Description\nA telecom firm operates multiple service centers to serve its customers. \nEach service center has \nits technicians who are dispatched from the service center to work on their assigned jobs, and return to the center after all the jobs are completed. \nA technician has multiple skills and available working capacity that cannot be exceeded during the scheduling horizon. \nA service order/job has \na known processing time, \na customer-specified time window for starting the service, \na deadline of completing the service, \nand its skill requirements. \nDepending on the nature of the job (routine maintenance or emergency), and relationship with the customer (existing, new), the firm assesses the importance of the job and assigns a priority score to it. \nA job is assigned to at most one technician who possesses the required \nskills, \nbut the technician's available capacity during the scheduling horizon cannot be exceeded.\nTo solve the  TRS problem, telecommunications companies must be able to\nsimultaneously makes three types of decisions: (i) the assignment of jobs to a technician at all the service centers; \n(ii) the routing of each technician, i.e. the sequence/order of customers for a technician to visit; \n(iii) and the scheduling of jobs, i.e. the timing for a technician to arrive at a customer location and complete the corresponding job. \nThe firm’s goal is to minimize the total weighted lateness of all  jobs, with their priority being the weights. \n\nThe following constraints must be satisfied:\n* A technician, if utilized, departs from the service center where he/she is based and returns to the same service center after his/her assigned jobs are completed.\n* A technician’s available capacity during the scheduling horizon cannot be exceeded.\n* A job, if selected, is assigned to at most one technician who  possesses the required skills.\n* A technician must arrive at a customer location during an interval (time window) specified by the customer, and must complete a job before the deadline required by the customer. This an important constraint for guaranteeing customer satisfaction. \n\nThe above basic TRS is a variant of the multi-depot vehicle routing problem with time windows, known as the MDVRPTW in the literature [1].\n\n    Requirements:\n    - Use gurobipy (Model, GRB, addVar/addConstr, etc.)\n    - Make the script runnable as a standalone Python file if possible.\n    - Keep the code faithful to the example.\n"}, {"role": "assistant", "content": "import sys\nimport pandas as pd\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# tested with Gurobi v10.0.2\n\nclass Technician():\n    def __init__(self, name, cap, depot):\n        self.name = name\n        self.cap = cap\n        self.depot = depot\n\n    def __str__(self):\n        return f\"Technician: {self.name}\\n  Capacity: {self.cap}\\n  Depot: {self.depot}\"\n\nclass Job():\n    def __init__(self, name, priority, duration, coveredBy):\n        self.name = name\n        self.priority = priority\n        self.duration = duration\n        self.coveredBy = coveredBy\n\n    def __str__(self):\n        about = f\"Job: {self.name}\\n  Priority: {self.priority}\\n  Duration: {self.duration}\\n  Covered by: \"\n        about += \", \".join([t.name for t in self.coveredBy])\n        return about\n\nclass Customer():\n    def __init__(self, name, loc, job, tStart, tEnd, tDue):\n        self.name = name\n        self.loc = loc\n        self.job = job\n        self.tStart = tStart\n        self.tEnd = tEnd\n        self.tDue = tDue\n\n    def __str__(self):\n        coveredBy = \", \".join([t.name for t in self.job.coveredBy])\n        return f\"Customer: {self.name}\\n  Location: {self.loc}\\n  Job: {self.job.name}\\n  Priority: {self.job.priority}\\n  Duration: {self.job.duration}\\n  Covered by: {coveredBy}\\n  Start time: {self.tStart}\\n  End time: {self.tEnd}\\n  Due time: {self.tDue}\"\n\n# Read Excel workbook\nexcel_file = 'https://raw.githubusercontent.com/Gurobi/modeling-examples/master/technician_routing_scheduling/data-Sce0.xlsx'\ndf = pd.read_excel(excel_file, sheet_name='Technicians')\ndf = df.rename(columns={df.columns[0]: \"name\", df.columns[1]: \"cap\", df.columns[2]: \"depot\"})\n\ndf1 = df.drop(df.columns[3:], axis=1).drop(df.index[[0,1]])\n# Create Technician objects\ntechnicians = [Technician(*row) for row in df1.itertuples(index=False, name=None)]\n# print(df1)\n\n# Read job data\njobs=[]\nfor j in range(3, len(df.columns)):\n    coveredBy = [t for i, t in enumerate(technicians) if df.iloc[2+i,j]==1]\n    thisJob = Job(df.iloc[2:,j].name, df.iloc[0,j], df.iloc[1,j], coveredBy)\n    jobs.append(thisJob)\n\n# Read location data\ndf_locations = pd.read_excel(excel_file, sheet_name='Locations', index_col=0) #, skiprows=1, index_col=0)\n\n# Extract locations and initialize distance dictionary\nlocations = df_locations.index\ndist = {(l, l): 0 for l in locations}\n\n# Populate distance dictionary\nfor i, l1 in enumerate(locations):\n    for j, l2 in enumerate(locations):\n        if i < j:\n            dist[l1, l2] = df_locations.iloc[i, j]\n            dist[l2, l1] = dist[l1, l2]\n\n# Read customer data\ndf_customers = pd.read_excel(excel_file, sheet_name='Customers')\n\ncustomers = []\nfor i, c in enumerate(df_customers.iloc[:, 0]):\n    job_name = df_customers.iloc[i, 2]\n    \n    # Find the corresponding Job object\n    matching_job = next((job for job in jobs if job.name == job_name), None)\n    \n    if matching_job is not None:\n        # Create Customer object using corresponding Job object\n        this_customer = Customer(c, df_customers.iloc[i, 1], matching_job, *df_customers.iloc[i, 3:])\n        customers.append(this_customer)\n\ndef solve_trs0(technicians, customers, dist):\n    # Build useful data structures\n    K = [k.name for k in technicians]\n    C = [j.name for j in customers]\n    J = [j.loc for j in customers]\n    L = list(set([l[0] for l in dist.keys()]))\n    D = list(set([t.depot for t in technicians]))\n    cap = {k.name : k.cap for k in technicians}\n    loc = {j.name : j.loc for j in customers}\n    depot = {k.name : k.depot for k in technicians}\n    canCover = {j.name : [k.name for k in j.job.coveredBy] for j in customers}\n    dur = {j.name : j.job.duration for j in customers}\n    tStart = {j.name : j.tStart for j in customers}\n    tEnd = {j.name : j.tEnd for j in customers}\n    tDue = {j.name : j.tDue for j in customers}\n    priority = {j.name : j.job.priority for j in customers}\n    \n        ### Create model\n    m = gp.Model(\"trs0\")\n    \n    ### Decision variables\n    # Customer-technician assignment\n    x = m.addVars(C, K, vtype=GRB.BINARY, name=\"x\")\n    \n    # Technician assignment\n    u = m.addVars(K, vtype=GRB.BINARY, name=\"u\")\n    \n    # Edge-route assignment to technician\n    y = m.addVars(L, L, K, vtype=GRB.BINARY, name=\"y\")\n   \n    # Technician cannot leave or return to a depot that is not its base\n    for k in technicians:\n        for d in D:\n            if k.depot != d:\n                for i in L:\n                    y[i,d,k.name].ub = 0\n                    y[d,i,k.name].ub = 0\n    \n    # Start time of service\n    t = m.addVars(L, ub=600, name=\"t\")\n    \n    # Lateness of service\n    z = m.addVars(C, name=\"z\")\n    \n    # Artificial variables to correct time window upper and lower limits\n    xa = m.addVars(C, name=\"xa\")\n    xb = m.addVars(C, name=\"xb\")\n    \n    # Unfilled jobs\n    g = m.addVars(C, vtype=GRB.BINARY, name=\"g\")\n    \n        ### Constraints\n\n    # A technician must be assigned to a job, or a gap is declared (1)\n    m.addConstrs((gp.quicksum(x[j, k] for k in canCover[j]) + g[j] == 1 for j in C), name=\"assignToJob\")\n    \n    # At most one technician can be assigned to a job (2)\n    m.addConstrs((x.sum(j, '*') <= 1 for j in C), name=\"assignOne\")\n\n    # Technician capacity constraints (3)\n    capLHS = {k : gp.quicksum(dur[j]*x[j,k] for j in C) +\\\n        gp.quicksum(dist[i,j]*y[i,j,k] for i in L for j in L) for k in K}\n    m.addConstrs((capLHS[k] <= cap[k]*u[k] for k in K), name=\"techCapacity\")\n\n    # Technician tour constraints (4 and 5)\n    m.addConstrs((y.sum('*', loc[j], k) == x[j,k] for k in K for j in C),\\\n        name=\"techTour1\")\n    m.addConstrs((y.sum(loc[j], '*', k) == x[j,k] for k in K for j in C),\\\n        name=\"techTour2\")\n\n    # Same depot constraints (6 and 7)\n    m.addConstrs((gp.quicksum(y[j,depot[k],k] for j in J) == u[k] for k in K),\\\n        name=\"sameDepot1\")\n    m.addConstrs((gp.quicksum(y[depot[k],j,k] for j in J) == u[k] for k in K),\\\n        name=\"sameDepot2\")\n\n    # Temporal constraints (8) for customer locations\n    M = {(i,j) : 600 + dur[i] + dist[loc[i], loc[j]] for i in C for j in C}\n    m.addConstrs((t[loc[j]] >= t[loc[i]] + dur[i] + dist[loc[i], loc[j]]\\\n        - M[i,j]*(1 - gp.quicksum(y[loc[i],loc[j],k] for k in K))\\\n        for i in C for j in C), name=\"tempoCustomer\")\n\n    # Temporal constraints (8) for depot locations\n    M = {(i,j) : 600 + dist[i, loc[j]] for i in D for j in C}\n    m.addConstrs((t[loc[j]] >= t[i] + dist[i, loc[j]]\\\n        - M[i,j]*(1 - y.sum(i,loc[j],'*')) for i in D for j in C),\\\n        name=\"tempoDepot\")\n\n    # Time window constraints (9 and 10)\n    m.addConstrs((t[loc[j]] + xa[j] >= tStart[j] for j in C), name=\"timeWinA\")\n    m.addConstrs((t[loc[j]] - xb[j] <= tEnd[j] for j in C), name=\"timeWinB\")\n\n    # Lateness constraint (11)\n    m.addConstrs((z[j] >= t[loc[j]] + dur[j] - tDue[j] for j in C),\\\n        name=\"lateness\")\n\n    ### Objective function\n    M = 6100\n    \n    m.setObjective(z.prod(priority) + gp.quicksum( 0.01 * M * priority[j] * (xa[j] + xb[j]) for j in C) +\n                   gp.quicksum( M * priority[j] * g[j] for j in C) , GRB.MINIMIZE)\n    \n    m.write(\"TRS0.lp\")\n    m.optimize()\n\n    status = m.Status\n    if status in [GRB.INF_OR_UNBD, GRB.INFEASIBLE, GRB.UNBOUNDED]:\n        print(\"Model is either infeasible or unbounded.\")\n        sys.exit(0)\n    elif status != GRB.OPTIMAL:\n        print(\"Optimization terminated with status {}\".format(status))\n        sys.exit(0)\n        \n    ### Print results\n    # Assignments\n    print(\"\")\n    for j in customers:\n        if g[j.name].X > 0.5:\n            jobStr = \"Nobody assigned to {} ({}) in {}\".format(j.name,j.job.name,j.loc)\n        else:\n            for k in K:\n                if x[j.name,k].X > 0.5:\n                    jobStr = \"{} assigned to {} ({}) in {}. Start at t={:.2f}.\".format(k,j.name,j.job.name,j.loc,t[j.loc].X)\n                    if z[j.name].X > 1e-6:\n                        jobStr += \" {:.2f} minutes late.\".format(z[j.name].X)\n                    if xa[j.name].X > 1e-6:\n                        jobStr += \" Start time corrected by {:.2f} minutes.\".format(xa[j.name].X)\n                    if xb[j.name].X > 1e-6:\n                        jobStr += \" End time corrected by {:.2f} minutes.\".format(xb[j.name].X)\n        print(jobStr)\n\n    # Technicians\n    print(\"\")\n    for k in technicians:\n        if u[k.name].X > 0.5:\n            cur = k.depot\n            route = k.depot\n            while True:\n                for j in customers:\n                    if y[cur,j.loc,k.name].X > 0.5:\n                        route += \" -> {} (dist={}, t={:.2f}, proc={})\".format(j.loc, dist[cur,j.loc], t[j.loc].X, j.job.duration)\n                        cur = j.loc\n                for i in D:\n                    if y[cur,i,k.name].X > 0.5:\n                        route += \" -> {} (dist={})\".format(i, dist[cur,i])\n                        cur = i\n                        break\n                if cur == k.depot:\n                    break\n            print(\"{}'s route: {}\".format(k.name, route))\n        else:\n            print(\"{} is not used\".format(k.name)) \n            \n    \n    # Utilization\n    print(\"\")\n    for k in K:\n        used = capLHS[k].getValue()\n        total = cap[k]\n        util = used / cap[k] if cap[k] > 0 else 0\n        print(\"{}'s utilization is {:.2%} ({:.2f}/{:.2f})\".format(k, util,\\\n            used, cap[k]))\n    totUsed = sum(capLHS[k].getValue() for k in K)\n    totCap = sum(cap[k] for k in K)\n    totUtil = totUsed / totCap if totCap > 0 else 0\n    print(\"Total technician utilization is {:.2%} ({:.2f}/{:.2f})\".format(totUtil, totUsed, totCap))\n    \n    m.dispose()\n    gp.disposeDefaultEnv()\n\ndef printScen(scenStr):\n    sLen = len(scenStr)\n    print(\"\\n\" + \"*\"*sLen + \"\\n\" + scenStr + \"\\n\" + \"*\"*sLen + \"\\n\")\n\nif __name__ == \"__main__\":\n    # Base model\n    printScen(\"Solving base scenario model\")\n    solve_trs0(technicians, customers, dist)\n\n# Open Excel workbook\nexcel_file = 'https://raw.githubusercontent.com/Gurobi/modeling-examples/master/technician_routing_scheduling/data-Sce3.xlsx'\n\n# Read technician data\ndf = pd.read_excel(excel_file, sheet_name='Technicians')\ndf = df.rename(columns={df.columns[0]: \"name\", df.columns[1]: \"cap\", df.columns[2]: \"depot\"})\n\ndf1 = df.drop(df.columns[3:], axis=1).drop(df.index[[0,1]])\n# Create Technician objects\ntechnicians = [Technician(*row) for row in df1.itertuples(index=False, name=None)]\n\n# Read job data\njobs=[]\nfor j in range(3, len(df.columns)):\n    coveredBy = [t for i, t in enumerate(technicians) if df.iloc[2+i,j]==1]\n    thisJob = Job(df.iloc[2:,j].name, df.iloc[0,j], df.iloc[1,j], coveredBy)\n    jobs.append(thisJob)\n\n# Read location data\ndf_locations = pd.read_excel(excel_file, sheet_name='Locations', index_col=0) #, skiprows=1, index_col=0)\n\n# Extract locations and initialize distance dictionary\nlocations = df_locations.index\ndist = {(l, l): 0 for l in locations}\n\n# Populate distance dictionary\nfor i, l1 in enumerate(locations):\n    for j, l2 in enumerate(locations):\n        if i < j:\n            dist[l1, l2] = df_locations.iloc[i, j]\n            dist[l2, l1] = dist[l1, l2]\n\n# Read customer data\ndf_customers = pd.read_excel(excel_file, sheet_name='Customers')\n\ncustomers = []\nfor i, c in enumerate(df_customers.iloc[:, 0]):\n    job_name = df_customers.iloc[i, 2]\n    \n    # Find the corresponding Job object\n    matching_job = next((job for job in jobs if job.name == job_name), None)\n    \n    if matching_job is not None:\n        # Create Customer object using corresponding Job object\n        this_customer = Customer(c, df_customers.iloc[i, 1], matching_job, *df_customers.iloc[i, 3:])\n        customers.append(this_customer)\n\nif __name__ == \"__main__\":\n    # Base model\n    printScen(\"Solving scenario 1 model\")\n    solve_trs0(technicians, customers, dist)"}]}
{"meta": {"source_path": "/Users/sunyujun03/Desktop/ReLoop/gurobi-modeling-examples/traveling_salesman/tsp.ipynb", "kind": "ipynb", "title": "Traveling Salesman Problem"}, "messages": [{"role": "system", "content": "You are an optimization engineer. Write correct and runnable Python code using gurobipy (Gurobi Python API). Be concise. Output only what is requested."}, {"role": "user", "content": "    Task: Reproduce the following Gurobi modeling example in Python using gurobipy.\n\n    Scenario description (from source):\n    # Traveling Salesman Problem\n\n## Objective and Prerequisites\n\nIn this example, you’ll learn how to tackle one of the most famous combinatorial optimization problems in existence: the Traveling Salesman Problem (TSP). The goal of the TSP – to find the shortest possible route that visits each city once and returns to the original city – is simple, but solving the problem is a complex and challenging endeavor. We’ll show you how to do it!\n\nThis modeling example is at the advanced level, where we assume that you know Python and the Gurobi Python API and that you have advanced knowledge of building mathematical optimization models. Typically, the objective function and/or constraints of these examples are complex or require advanced features of the Gurobi Python API.\n\n**Download the Repository** <br />\nYou can download the repository containing this and other examples by clicking [here](https://github.com/Gurobi/modeling-examples/archive/master.zip). \n\n## Motivation\n\nThe Traveling Salesman Problem (TSP) is one of the most famous combinatorial optimization problems. This problem is very easy to explain, but very complicated to solve – even for instances with a small number of cities. More detailed information on the TSP can be found in the book The Traveling Salesman Problem: A Computational Study [1], or at the TSP home page [2]. If you are interested in the history and mathematical background of the TSP, we recommend that you watch the video by William Cook [3].\n\nThe origin of the traveling salesman problem is not very clear; it is mentioned in an 1832 manual for traveling salesman, which included example tours of 45 German cities but was not formulated as a mathematical problem. However, in the 1800s, mathematicians William Rowan Hamilton and Thomas Kirkman devised mathematical formulations of the problem.\n\nIt seems that the general form of the Traveling Salesman Problem was first studied by Karl Menger in Vienna and Harvard in the 1930s.\n\nThe problem became more and more popular in the 1950s and 1960s. In particular, George Dantzig, D. Ray Fulkerson, and Selmer M. Johnson at the RAND Corporation solved the 48-state problem by formulating it as a linear programming problem. The methods they described in their paper on this topic set the foundation for future work in combinatorial optimization, especially highlighting the importance of cutting planes.\n\nIn the early 1970s, the concept of P vs. NP problems created excitement in the theoretical computer science community. In 1972, Richard Karp demonstrated that the Hamiltonian cycle problem was NP-complete, implying that the traveling salesman problem was NP-hard.\n\nIncreasingly sophisticated codes led to rapid increases in the sizes of the traveling salesman problems solved. Dantzig, Fulkerson, and Johnson had solved a 48-city instance of the problem in 1954. Martin Grötschel more than doubled this 23 years later, solving a 120-city instance in 1977. Harlan Crowder and Manfred W. Padberg again more than doubled this in just 3 years, with a 318-city solution.\n\nIn 1987, rapid improvements were made, culminating in a 2,392-city solution by Padberg and Giovanni Rinaldi. In the following two decades, great strides were made with David L. Applegate, Robert E. Bixby, Vasek Chvátal, & William J. Cook solving a 3,308-city instance in 1992, a 7,397-city instance in 1994, a 24,978-city instance in 2004, and an 85,900-city instance in 2006 – which is the largest 2-D Euclidean TSP instance ever solved. William Cook et. al. wrote a program called Concorde TSP Solver for solving the TSP [4]. Concorde is a computer code for the symmetric TSP and some related network optimization problems. The code is written in the ANSI C programming language and it has been used to obtain the optimal solutions to the full set of 110 TSPLIB instances, the largest instance is a 109,399 node 3-D “star” instance.\n\nThe continued interest in the TSP can be explained by its success as a general engine of discovery and a steady stream of new applications. Some of the general applications of the TSP are as follows:\n* Scheduling and routing problems.\n* Genome sequencing.\n* Drilling problems.\n* Aiming telescopes and x-rays.\n* Data clustering.\n* Machine scheduling.\n\nWe use this classic combinatorial optimization problem to demonstrate how Gurobi can be used to easily and effectively solve small-sized problem instances of the TSP. However, in order to be able to solve larger instances, one needs more sophisticated techniques – such as those implemented in the Concord TSP Solver.\n\n## Problem Description\nThe TSP can be defined as follows: for a given list of cities and the distances between each pair of them, we want to find the shortest possible route that goes to each city once and returns to the origin city.\n\nThere is a class of Traveling Salesman Problems that assumes that the distance of going from city $i$ to city $j$  is the same as going form city $j$ to city $i$, this type of Traveling Salesman Problem  is also known as the symmetric Traveling Salesman Problem. In this example, we use Euclidean distances, but the TSP model formulation is valid independent of the way in which the individual distances are determined.\n\n## Solution Approach\n\nMathematical programming is a declarative approach where the modeler formulates a mathematical optimization model that captures the key aspects of a complex decision problem. The Gurobi Optimizer solves such models using state-of-the-art mathematics and computer science.\n\nA mathematical optimization model has five components, namely:\n\n* Sets and indices.\n* Parameters.\n* Decision variables.\n* Objective function(s).\n* Constraints.\n\nWe now present a MIP formulation of the TSP that identifies the shortest route that goes to all the cities once and returns to the origin city.\n\n## TSP Model Formulation\n\n### Sets and Indices\n$i, j \\in Capitals $: indices and set of US capital cities.\n\n$\\text{Pairings}= \\{(i,j) \\in Capitals \\times Capitals \\}$: Set of allowed pairings\n\n$S \\subset Capitals$: A subset of the set of US capital cities.\n\n$G = (Capitals, Pairings)$: A graph where the set $Capitals$ defines the set of nodes and the set $Pairings$ defines the set of edges. \n\n### Parameters \n\n$d_{i, j} \\in \\mathbb{R}^+$: Distance from capital city $i$ to capital city $j$, for all $(i, j) \\in Pairings$. \n\nNotice that the distance from capital city $i$ to capital city $j$ is the same as the distance from capital city $j$ to capital city $i$, i.e. $d_{i, j} = d_{j, i}$. For this reason, this TSP is also called the symmetric Traveling Salesman Problem.\n\n### Decision Variables\n$x_{i, j} \\in \\{0, 1\\}$: This variable is equal to 1, if we decide to connect city $i$ with city $j$. Otherwise, the decision variable is equal to zero.\n\n### Objective Function\n- **Shortest Route**. Minimize the total distance of a route. A route is a sequence of capital cities where the salesperson visits each city only once and returns to the starting capital city.\n\n\\begin{equation}\n\\text{Min} \\quad Z = \\sum_{(i,j) \\in \\text{Pairings}}d_{i,j} \\cdot x_{i,j}\n\\tag{0}\n\\end{equation}\n\n### Constraints \n- **Symmetry Constraints**. For each edge $(i,j)$, ensure that the city capitals $i$ and $j$ are connected, if the former is visited immediately before or after visiting the latter.\n\n\\begin{equation}\nx_{i, j} = x_{j, i} \\quad \\forall (i, j) \\in Pairings\n\\tag{1}\n\\end{equation}\n\n- **Entering and leaving a capital city**. For each capital city $i$, ensure that this city is connected to two other cities. \n\n\\begin{equation}\n\\sum_{(i,j) \\in \\text{Pairings}}x_{i,j} = 2 \\quad \\forall  i \\in Capitals\n\\tag{2}\n\\end{equation}\n\n- **Subtour elimination**. These constraints ensure that for any subset of cities $S$ of the set of $Capitals$, there is no cycle. That is, there is no route that visits all the cities in the subset and returns to the origin city.\n\n\\begin{equation}\n\\sum_{(i \\neq j) \\in S}x_{i,j} \\leq |S|-1 \\quad \\forall  S \\subset  Capitals\n\\tag{3}\n\\end{equation}\n\n- **Remark**. In general, if the number of cities of the TSP is $n$, then the possible number of routes is n\\!.\nSince there are an exponential number of constraints ($2^{n} - 2$) to eliminate cycles, we use lazy constraints to dynamically eliminate those cycles. \n\n## Python Implementation\n\nConsider a salesperson that needs to visit customers at each state capital of the continental US. The salesperson wants to identify the shortest route that goes to all the state capitals.\n\nThis modeling example requires the following libraries that are not part of the standard Python distribution:\n* **folium**: to create maps.\n* **gurobipy**: provides Gurobi algorithms to solve MIP models.\n\n    Requirements:\n    - Use gurobipy (Model, GRB, addVar/addConstr, etc.)\n    - Make the script runnable as a standalone Python file if possible.\n    - Keep the code faithful to the example.\n"}, {"role": "assistant", "content": "import json\n\n# Read capital names and coordinates from json file\ntry:\n  capitals_json = json.load(open('capitals.json'))\n# when running locally the following lines can be omitted\nexcept: \n  import urllib.request\n  url = 'https://raw.githubusercontent.com/Gurobi/modeling-examples/master/traveling_salesman/capitals.json'\n  data = urllib.request.urlopen(url).read()\n  capitals_json = json.loads(data)\n\ncapitals = []\ncoordinates = {}\nfor state in capitals_json:\n    if state not in ['AK', 'HI']:\n      capital = capitals_json[state]['capital']\n      capitals.append(capital)\n      coordinates[capital] = (float(capitals_json[state]['lat']), float(capitals_json[state]['long']))\n\nimport math\nfrom itertools import combinations\n\n# Compute pairwise distance matrix\n\ndef distance(city1, city2):\n    c1 = coordinates[city1]\n    c2 = coordinates[city2]\n    diff = (c1[0]-c2[0], c1[1]-c2[1])\n    return math.sqrt(diff[0]*diff[0]+diff[1]*diff[1])\n\ndist = {(c1, c2): distance(c1, c2) for c1, c2 in combinations(capitals, 2)}\n\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# tested with Python 3.7 & Gurobi 9.0.0\n\nm = gp.Model()\n\n# Variables: is city 'i' adjacent to city 'j' on the tour?\nvars = m.addVars(dist.keys(), obj=dist, vtype=GRB.BINARY, name='x')\n\n# Symmetric direction: use dict.update to alias variable with new key\nvars.update({(j,i):vars[i,j] for i,j in vars.keys()})\n\n# Constraints: two edges incident to each city\ncons = m.addConstrs(vars.sum(c, '*') == 2 for c in capitals)\n\n# Callback - use lazy constraints to eliminate sub-tours\n\ndef subtourelim(model, where):\n    if where == GRB.Callback.MIPSOL:\n        # make a list of edges selected in the solution\n        vals = model.cbGetSolution(model._vars)\n        selected = gp.tuplelist((i, j) for i, j in model._vars.keys()\n                             if vals[i, j] > 0.5)\n        # find the shortest cycle in the selected edge list\n        tour = subtour(selected)\n        if len(tour) < len(capitals):\n            # add subtour elimination constr. for every pair of cities in subtour\n            model.cbLazy(gp.quicksum(model._vars[i, j] for i, j in combinations(tour, 2))\n                         <= len(tour)-1)\n\n# Given a tuplelist of edges, find the shortest subtour\n\ndef subtour(edges):\n    unvisited = capitals[:]\n    cycle = capitals[:] # Dummy - guaranteed to be replaced\n    while unvisited:  # true if list is non-empty\n        thiscycle = []\n        neighbors = unvisited\n        while neighbors:\n            current = neighbors[0]\n            thiscycle.append(current)\n            unvisited.remove(current)\n            neighbors = [j for i, j in edges.select(current, '*')\n                         if j in unvisited]\n        if len(thiscycle) <= len(cycle):\n            cycle = thiscycle # New shortest subtour\n    return cycle\n\nm._vars = vars\nm.Params.lazyConstraints = 1\nm.optimize(subtourelim)\n\n# Retrieve solution\n\nvals = m.getAttr('x', vars)\nselected = gp.tuplelist((i, j) for i, j in vals.keys() if vals[i, j] > 0.5)\n\ntour = subtour(selected)\nassert len(tour) == len(capitals)\n\n# Map the solution\n\nimport folium\n\nmap = folium.Map(location=[40,-95], zoom_start = 4)\n\npoints = []\nfor city in tour:\n  points.append(coordinates[city])\npoints.append(points[0])\n\nfolium.PolyLine(points).add_to(map)\n\nmap\n\nm.dispose()\ngp.disposeDefaultEnv()"}]}
{"meta": {"source_path": "/Users/sunyujun03/Desktop/ReLoop/gurobi-modeling-examples/facility_location/facility_location.ipynb", "kind": "ipynb", "title": "Facility Location"}, "messages": [{"role": "system", "content": "You are an optimization engineer. Write correct and runnable Python code using gurobipy (Gurobi Python API). Be concise. Output only what is requested."}, {"role": "user", "content": "    Task: Reproduce the following Gurobi modeling example in Python using gurobipy.\n\n    Scenario description (from source):\n    # Facility Location\n\n## Objective and Prerequisites\n\nFacility location problems can be commonly found in many industries, including logistics and telecommunications. In this example, we’ll show you how to tackle a facility location problem that involves determining the number and location of warehouses that are needed to supply a group of supermarkets. We’ll demonstrate how to construct a mixed-integer programming (MIP) model of this problem, implement this model in the Gurobi Python API, and then use the Gurobi Optimizer to find an optimal solution.\n\nThis modeling example is at the beginner level, where we assume that you know Python and that you have some knowledge about building mathematical optimization models.\n\n**Download the Repository** <br />\nYou can download the repository containing this and other examples by clicking [here](https://github.com/Gurobi/modeling-examples/archive/master.zip). \n\n## Motivation\n\nThe study of facility location problems - also known as \"location analysis\" [1] - is a branch of operations research and computational geometry concerned with the optimal placement of facilities to minimize transportation costs while considering factors like safety (e.g. by avoiding placing hazardous materials near housing) and the location of  competitors' facilities.\n\nThe Fermat-Weber problem, formulated in the 17'th century, was one of the first facility location problems ever devised. \nThe Fermat-Weber problem can be described as follows: Given three points in a plane, find a fourth point such that the sum of its distances to the three given points is minimal. This problem can be viewed as a variation of the facility location problem, where the assumption is made that the transportation costs per distance are the same for all destinations.\n\nFacility location problems have applications in a wide variety of industries. For supply chain management and logistics, this problem  can be used to find the optimal location for stores, factories, warehouses, etc. Other applications range from public policy (e.g. positioning  police officers in a city), telecommunications (e.g. cell towers in a network), and even particle physics (e.g. separation distance between repulsive charges). Another application of the facility location problem is to determine the locations for natural gas transmission equipment. Finally, facility location problems can be applied to cluster analysis.\n\n## Problem Description\n\nA large supermarket chain in the UK needs to build warehouses for a set of supermarkets it is opening in Northern England. The locations of the supermarkets have been identified, but the locations of the warehouses have yet to be determined.\n\nSeveral good candidate locations for the warehouses have been identified, but decisions must be made regarding \nhow many warehouses to open and at which candidate locations to build them.\n\nOpening many warehouses would be advantageous as this would reduce the average distance a truck has to drive from the warehouse to the supermarket, and hence reduce the delivery cost. However, opening a warehouse has a fixed cost associated with it.\n\nIn this example, our goal is to find the optimal tradeoff between delivery costs and the costs of building new facilities.\n\n    Requirements:\n    - Use gurobipy (Model, GRB, addVar/addConstr, etc.)\n    - Make the script runnable as a standalone Python file if possible.\n    - Keep the code faithful to the example.\n"}, {"role": "assistant", "content": "from itertools import product\nfrom math import sqrt\n\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# tested with Gurobi v9.1.0 and Python 3.7.0\n\n# Parameters\ncustomers = [(0,1.5), (2.5,1.2)]\nfacilities = [(0,0), (0,1), (0,2), (1,0), (1,1), (1,2), (2,0), (2,1), (2,2)]\nsetup_cost = [3,2,3,1,3,3,4,3,2]\ncost_per_mile = 1\n\n# This function determines the Euclidean distance between a facility and customer sites.\n\ndef compute_distance(loc1, loc2):\n    dx = loc1[0] - loc2[0]\n    dy = loc1[1] - loc2[1]\n    return sqrt(dx*dx + dy*dy)\n\n# Compute key parameters of MIP model formulation\n\nnum_facilities = len(facilities)\nnum_customers = len(customers)\ncartesian_prod = list(product(range(num_customers), range(num_facilities)))\n\n# Compute shipping costs\n\nshipping_cost = {(c,f): cost_per_mile*compute_distance(customers[c], facilities[f]) for c, f in cartesian_prod}\n\n# MIP  model formulation\n\nm = gp.Model('facility_location')\n\nselect = m.addVars(num_facilities, vtype=GRB.BINARY, name='Select')\nassign = m.addVars(cartesian_prod, ub=1, vtype=GRB.CONTINUOUS, name='Assign')\n\nm.addConstrs((assign[(c,f)] <= select[f] for c,f in cartesian_prod), name='Setup2ship')\nm.addConstrs((gp.quicksum(assign[(c,f)] for f in range(num_facilities)) == 1 for c in range(num_customers)), name='Demand')\n\nm.setObjective(select.prod(setup_cost)+assign.prod(shipping_cost), GRB.MINIMIZE)\n\nm.optimize()\n\n# display optimal values of decision variables\n\nfor facility in select.keys():\n    if (abs(select[facility].x) > 1e-6):\n        print(f\"\\n Build a warehouse at location {facility + 1}.\")\n\n# Shipments from facilities to customers.\n\nfor customer, facility in assign.keys():\n    if (abs(assign[customer, facility].x) > 1e-6):\n        print(f\"\\n Supermarket {customer + 1} receives {round(100*assign[customer, facility].x, 2)} % of its demand  from Warehouse {facility + 1} .\")"}]}
{"meta": {"source_path": "/Users/sunyujun03/Desktop/ReLoop/gurobi-modeling-examples/optimization301/PoC_to_Production_Exercise/complete_poc_to_production_exercise_set.ipynb", "kind": "ipynb", "title": "Note on the Notebook"}, "messages": [{"role": "system", "content": "You are an optimization engineer. Write correct and runnable Python code using gurobipy (Gurobi Python API). Be concise. Output only what is requested."}, {"role": "user", "content": "    Task: Reproduce the following Gurobi modeling example in Python using gurobipy.\n\n    Scenario description (from source):\n    # Note on the Notebook\n\nThe examples in this notebook are inspired by real-world scenarios I've observed or experienced across different projects. They touch on several of the points discussed during the PoC to Production talk.\n\nEach example is designed to:\n- Work within the limitations of the free Gurobi restricted license, and  \n- Fit within the time constraints of our session.\n\nWhile the datasets and models here are much smaller than those used in production, the lessons, best practices, and pitfalls to avoid remain exactly the same.\n\nIn every example that follows, something is wrong.  \nYour mission, should you choose to accept it, is to identify the culprit(s) using what you've learned so far.\n\n**Happy debugging!**\n\n# Install Required Packages\n\n## Set a path to the data used\n**If you downloaded the notebook/data and are running this locally**, make sure the data is in the same directory as the notebook and run the cell below, or update it to the correct path.\n\n**If you are running this in Colab** run this cell below to set the path to read the data from the GitHub repository.\n\n    Requirements:\n    - Use gurobipy (Model, GRB, addVar/addConstr, etc.)\n    - Make the script runnable as a standalone Python file if possible.\n    - Keep the code faithful to the example.\n"}, {"role": "assistant", "content": "# %pip install plotly\n\n# Import packages\nimport math\nimport random\nimport pandas as pd\nimport gurobipy as gp\nfrom gurobipy import GRB\nimport plotly.graph_objects as go\n\n# Run this cell if you're working locally on your machine.\n# Change the path if needed.\npath = ''\n\n# Run this cell if you are using Colab.\npath = 'https://raw.githubusercontent.com/Gurobi/modeling-examples/master/optimization301/PoC_to_Production_Exercise/'\n\ndef ex1():\n    # Load the data\n    orders = pd.read_csv(path+'ex1_orders.csv')\n    vehicles = pd.read_csv(path+'ex1_vehicles.csv')\n    num_orders = len(orders)\n    num_vehicles = len(vehicles)\n    # Build the model\n    model = gp.Model('vehicle_loading')\n    # x[i,t]: 1 if order i assigned to vehicle t\n    x = model.addVars(num_orders, num_vehicles, vtype=GRB.BINARY, name='x')\n    # y[t]: 1 if vehicle t is used\n    y = model.addVars(num_vehicles, vtype=GRB.BINARY, name='y')\n\n    # Each order assigned to exactly one vehicle\n    model.addConstrs((x.sum(i, '*') == 1 for i in range(num_orders)), name='assign')\n    # vehicle capacity constraints\n    model.addConstrs(\n        (gp.quicksum(orders.loc[i, 'weight'] * x[i, t] for i in range(num_orders))\n         <= vehicles.loc[t, 'capacity'] * y[t] for t in range(num_vehicles)), name='capacity')\n\n    # Objective: minimize number of used vehicles\n    model.setObjective(y.sum(), GRB.MINIMIZE)\n    model.Params.OutputFlag = 0  # turn off the log\n    model.optimize()\n    if model.status == GRB.OPTIMAL:\n        print(f'Optimal. Best Objective: {model.ObjVal}')\n    elif model.status == GRB.INFEASIBLE:\n        print('Infeasible!')\n    else:\n        print(f'Model Status: {model.status}')\n\nex1()\n\n# Put this in the function, after reading the input data\n# Validate the data\nmax_capacity = vehicles['capacity'].max()\ninvalid_orders = orders[orders['weight'] > max_capacity]\nif not invalid_orders.empty:\n    print(f'Max vehicle capacity is: {max_capacity}.\\nInvalid orders:\\n{invalid_orders}')\n    print('\\nFix the input data first, before running the model!')\n    return\n\ndef ex2():\n    dcs_df = pd.read_csv(path+'ex2_dcs.csv')\n    cust_df = pd.read_csv(path+'ex2_customers.csv')\n    lanes_df = pd.read_csv(path+'ex2_lanes.csv')\n    # Built some objects for convenience and speed\n    dc = dcs_df['dc_id'].tolist()\n    cust = cust_df['cust_id'].tolist()\n    arcs = list(lanes_df[['dc', 'cust']].itertuples(index=False, name=None))\n    supply = dcs_df.set_index('dc_id')['supply'].to_dict()\n    demand = cust_df.set_index('cust_id')['demand'].to_dict()\n    cost = lanes_df.set_index(['dc', 'cust'])['cost'].to_dict()\n\n    # Model\n    model = gp.Model('transport')\n    # x[d,c]: flow from dc d to customer c\n    x = model.addVars(arcs, lb=0.0, vtype=GRB.CONTINUOUS, name='x')\n\n    # supply constraints\n    model.addConstrs((x.sum(d, '*') <= supply[d] for d in dc), name='supply')\n    # demand constraints\n    model.addConstrs((x.sum('*', c) >= demand[c] for c in cust), name='demand')\n    # Objective: minimize total transport cost\n    model.setObjective(gp.quicksum(cost[d, c] * x[d, c] for (d, c) in arcs), GRB.MINIMIZE)\n    model.Params.OutputFlag = 0  # turn off the log\n    model.optimize()\n    if model.Status == GRB.OPTIMAL:\n        print(f'Objective: {model.ObjVal:,.0f}')\n\nex2()\n\ndef plot_ex2():\n    dcs = pd.read_csv(path+'ex2_dcs.csv')\n    customers = pd.read_csv(path+'ex2_customers.csv')\n    fig = go.Figure()\n    # Customers\n    fig.add_trace(go.Scattermap(\n        lat=customers[\"lat\"], lon=customers[\"lon\"],\n        mode=\"markers\",\n        marker=dict(size=7),\n        customdata=customers[\"cust_id\"],\n        hovertemplate=\"Customer %{customdata}<extra></extra>\",\n        # name=\"Customers\",\n        showlegend=False))\n\n    # DCs\n    fig.add_trace(go.Scattermap(\n        lat=dcs[\"lat\"], lon=dcs[\"lon\"],\n        mode=\"markers+text\",\n        marker=dict(size=18, symbol=\"triangle-up\"),\n        text=dcs[\"dc_id\"],\n        textposition=\"top center\",\n        textfont=dict(size=14),\n        hoverinfo=\"skip\",\n        # name=\"DCs\",\n        showlegend=False))\n\n    fig.update_layout(\n        map=dict(\n            style=\"open-street-map\",\n            zoom=2.2,\n            center=dict(lat=36, lon=-100)),\n        margin=dict(l=0, r=0, t=0, b=0),\n        showlegend=False)\n    fig.show()\n\nplot_ex2()\n\ndef ex3():\n    # Using this to ensure all are working with the same data\n    n, p, seed = 200, 0.95, 42\n    random.seed(seed)\n    edges = set()\n    for i in range(n):\n        for j in range(i + 1, n):\n            if random.random() < p:\n                edges.add((i, j))\n\n    model = gp.Model('max_clique')\n    model.Params.TimeLimit = 3\n    model.Params.OutputFlag = 0\n\n    x = model.addVars(n, vtype=GRB.BINARY, name='x')\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (i, j) not in edges:  # no edge, no compatibility\n                model.addConstr(x[i] + x[j] <= 1, name=f'conflict_{i}_{j}')\n    # Find the maximum set of compatible nodes\n    model.setObjective(x.sum(), GRB.MAXIMIZE)\n    model.optimize()\n    if model.status == GRB.OPTIMAL:\n        print(f'Optimal. Best Objective: {model.ObjVal}')\n    else:\n        print('Infeasible')\n\nex3()\n\n# Example of a different process for status. Replace the end of ex3() function with this.\nif model.status == GRB.OPTIMAL:\n    print(f'Optimal. Best Objective: {model.ObjVal}')\nelif model.status == GRB.TIME_LIMIT:\n    # CAUTION: Timelimit may be reached and still no feasible solution is found.\n    # It's best to check the model for solution values that'll be populated in case of feasibility.\n    obj_val = model.ObjVal if hasattr(model, 'ObjVal') else 'Not Found'\n    print(f'Timelimit has reached. The best feasible solution objective: {obj_val}')\nelif model.status == GRB.INFEASIBLE:\n    # Better to have a mechanism to deal with this.\n    # e.g., ComputeIIS or another model that's triggered in these cases\n    print('Infeasible')\nelse:\n    print(f'Model Status for investigation: {model.status}')\n\ndef ex4():\n    model = gp.Model()\n    x = model.addVar(vtype=GRB.INTEGER, ub=1000, name=\"x\")\n    y = model.addVar(vtype=GRB.INTEGER, ub=1000, name=\"y\")\n    # max πx + ey\n    model.setObjective(math.pi * x + math.e * y, GRB.MAXIMIZE)\n    model.addConstr(math.pi * x + 1 / 3 * y <= 3141.59265)\n    model.addConstr(x + y <= 1000)\n    model.Params.OutputFlag = 0\n    model.optimize()\n    if model.Status == GRB.OPTIMAL:\n        print(f'Optimal Solution: {model.ObjVal}')\n        for v in model.getVars():\n            print(v.VarName, v.X)\n\nex4()\n\ndef ex4_solution():\n    model = gp.Model()\n    x = model.addVar(vtype=GRB.INTEGER, ub=1000, name=\"x\")\n    y = model.addVar(vtype=GRB.INTEGER, ub=1000, name=\"y\")\n    # max πx + ey\n    model.setObjective(math.pi * x + math.e * y, GRB.MAXIMIZE)\n    model.addConstr(math.pi * x + 1 / 3 * y <= 3141.59265)\n    model.addConstr(x + y <= 1000)\n    # model.Params.OutputFlag = 0  # Extra: Turn it on. Look at solution count\n    model.Params.IntFeasTol = 1e-9  # Something to play with. What happens? Why?\n    model.optimize()\n    if model.Status == GRB.OPTIMAL:\n        # This part is extra and unrelated. Just want to show you how to check the solutions of the solution pool.\n        for k in range(model.SolCount):\n            model.Params.SolutionNumber = k\n            print(f'Solution {k}: obj={model.PoolObjVal}')\n            for v in model.getVars():\n                print(v.VarName, v.Xn)\n\nex4_solution()\n\ndef ex5():\n    dcs_df = pd.read_csv(path+'ex2_dcs.csv')\n    cust_df = pd.read_csv(path+'ex2_customers.csv')\n    lanes_df = pd.read_csv(path+'ex2_lanes.csv')\n\n    # Built some objects for convenience and speed\n    dc = dcs_df['dc_id'].tolist()\n    cust = cust_df['cust_id'].tolist()\n    arcs = list(lanes_df[['dc', 'cust']].itertuples(index=False, name=None))\n    supply = dcs_df.set_index('dc_id')['supply'].to_dict()\n    dem_max = cust_df.set_index('cust_id')['demand'].to_dict()\n    dem_min = cust_df.set_index('cust_id')['min_demand'].to_dict()\n    cost = lanes_df.set_index(['dc', 'cust'])['cost'].to_dict()\n\n    # Model\n    model = gp.Model('facility_location')\n    # x[d,c]: flow from dc d to customer c\n    x = model.addVars(arcs, lb=0.0, vtype=GRB.CONTINUOUS, name='x')\n    # y[d]: 1 if dc d is open\n    y = model.addVars(dc, vtype=GRB.BINARY, name='y')\n\n    # per customer: min_demand[c] <= sum_d x[d,c] <= demand[c]\n    model.addConstrs((x.sum('*', c) >= dem_min[c] for c in cust), name='min_demand')\n    model.addConstrs((x.sum('*', c) <= dem_max[c] for c in cust), name='max_demand')\n\n    # dc capacity: sum_c x[d,c] <= supply[d] * y[d]\n    model.addConstrs((x.sum(d, '*') <= supply[d] * y[d] for d in dc), name='capacity')\n\n    # Objective: shipping + fixed cost of opening a dc\n    shipping = gp.quicksum(cost[d, c] * x[d, c] for (d, c) in arcs)\n    fixed = 10_000 * y.sum()\n    model.setObjective(shipping + fixed, GRB.MINIMIZE)\n    model.Params.OutputFlag = 0\n    model.optimize()\n    if model.Status == GRB.OPTIMAL:\n        print(f'Objective value: {model.ObjVal:.0f}')\n        print(f'Facilities opened: {sum(int(round(y[d].X)) for d in dc)}')\n        print(f'Total shipped: {sum(x[arc].X for arc in arcs):.0f}')\n\nex5()\n\ndef ex6():\n    num_facilities = 3\n    demand = 100\n    shipping_cost = 1\n    facility_cost = 5000\n    M = 1e8\n\n    model = gp.Model()\n    model.Params.Presolve = 0\n    # Quantity to ship from each facility\n    x = model.addVars(num_facilities, name=\"ship\")\n    # Whether or not we open a facility\n    y = model.addVars(num_facilities, vtype=GRB.BINARY, name=\"open_facility\")\n    # Satisfy customer demand\n    model.addConstr(x.sum() == demand)\n    # Only ship if facility is open\n    for i in range(num_facilities):\n        model.addConstr(x[i] <= M * y[i])\n    # Minimize shipping costs + facility-opening costs\n    model.setObjective(shipping_cost * x.sum() + facility_cost * y.sum(), GRB.MINIMIZE)\n    model.optimize()\n    if model.Status == GRB.OPTIMAL:\n        for v in model.getVars():\n            print(v.VarName, v.X)\n\nex6()\n\ndef ex6_solution():\n    num_facilities = 3\n    demand = 100\n    shipping_cost = 1\n    facility_cost = 5000\n    M = 1000  # smaller Big M\n\n    model = gp.Model()\n    model.Params.Presolve = 0\n    # Quantity to ship from each facility\n    x = model.addVars(num_facilities, name=\"ship\")\n    # Whether or not we open a facility\n    y = model.addVars(num_facilities, vtype=GRB.BINARY, name=\"open_facility\")\n    # Satisfy customer demand\n    model.addConstr(x.sum() == demand)\n    # Only ship if facility is open. Using indicator constraints\n    for i in range(num_facilities):\n        model.addConstr(x[i] <= M * y[i])  # use a smaller Big M\n        # model.addConstr((y[i] == 0) >> (x[i] == 0))  # or indicator\n        # model.addGenConstrIndicator(y[i], 0, x[i] == 0)  # or indicator, but this way\n    # Minimize shipping costs + facility-opening costs\n    model.setObjective(shipping_cost * x.sum() + facility_cost * y.sum(), GRB.MINIMIZE)\n    # model.Params.IntegralityFocus = 1  # you can play with the same large M value as before, but activating this parameter\n    model.optimize()\n    if model.Status == GRB.OPTIMAL:\n        for v in model.getVars():\n            print(v.VarName, v.X)\n\nex6_solution()"}]}
{"meta": {"source_path": "/Users/sunyujun03/Desktop/ReLoop/gurobi-modeling-examples/optimization301/PoC_to_Production_Exercise/poc_to_production_exercise_set.ipynb", "kind": "ipynb", "title": "Note on the Notebook"}, "messages": [{"role": "system", "content": "You are an optimization engineer. Write correct and runnable Python code using gurobipy (Gurobi Python API). Be concise. Output only what is requested."}, {"role": "user", "content": "    Task: Reproduce the following Gurobi modeling example in Python using gurobipy.\n\n    Scenario description (from source):\n    # Note on the Notebook\n\nThe examples in this notebook are inspired by real-world scenarios I've observed or experienced across different projects. They touch on several of the points discussed during the PoC to Production talk.\n\nEach example is designed to:\n- Work within the limitations of the free Gurobi restricted license, and  \n- Fit within the time constraints of our session.\n\nWhile the datasets and models here are much smaller than those used in production, the lessons, best practices, and pitfalls to avoid remain exactly the same.\n\nIn every example that follows, something is wrong.  \nYour mission, should you choose to accept it, is to identify the culprit(s) using what you've learned so far.\n\n**Happy debugging!**\n\n# Install Required Packages\n\n## Set a path to the data used\n**If you downloaded the notebook/data and are running this locally**, make sure the data is in the same directory as the notebook and run the cell below, or update it to the correct path.\n\n**If you are running this in Colab** run this cell below to set the path to read the data from the GitHub repository.\n\n    Requirements:\n    - Use gurobipy (Model, GRB, addVar/addConstr, etc.)\n    - Make the script runnable as a standalone Python file if possible.\n    - Keep the code faithful to the example.\n"}, {"role": "assistant", "content": "# %pip install plotly\n\n# Import packages\nimport math\nimport random\nimport pandas as pd\nimport gurobipy as gp\nfrom gurobipy import GRB\nimport plotly.graph_objects as go\n\n# Run this cell if you're working locally on your machine.\n# Change the path if needed.\npath = ''\n\n# Run this cell if you are using Colab.\npath = 'https://raw.githubusercontent.com/Gurobi/modeling-examples/master/optimization301/PoC_to_Production_Exercise/'\n\ndef ex1():\n    # Load the data\n    orders = pd.read_csv('ex1_orders.csv')\n    vehicles = pd.read_csv('ex1_vehicles.csv')\n    num_orders = len(orders)\n    num_vehicles = len(vehicles)\n    # Build the model\n    model = gp.Model('vehicle_loading')\n    # x[i,t]: 1 if order i assigned to vehicle t\n    x = model.addVars(num_orders, num_vehicles, vtype=GRB.BINARY, name='x')\n    # y[t]: 1 if vehicle t is used\n    y = model.addVars(num_vehicles, vtype=GRB.BINARY, name='y')\n\n    # Each order assigned to exactly one vehicle\n    model.addConstrs((x.sum(i, '*') == 1 for i in range(num_orders)), name='assign')\n    # vehicle capacity constraints\n    model.addConstrs(\n        (gp.quicksum(orders.loc[i, 'weight'] * x[i, t] for i in range(num_orders))\n         <= vehicles.loc[t, 'capacity'] * y[t] for t in range(num_vehicles)), name='capacity')\n\n    # Objective: minimize number of used vehicles\n    model.setObjective(y.sum(), GRB.MINIMIZE)\n    model.Params.OutputFlag = 0  # turn off the log\n    model.optimize()\n    if model.status == GRB.OPTIMAL:\n        print(f'Optimal. Best Objective: {model.ObjVal}')\n    elif model.status == GRB.INFEASIBLE:\n        print('Infeasible!')\n    else:\n        print(f'Model Status: {model.status}')\n\nex1()\n\ndef ex2():\n    dcs_df = pd.read_csv('ex2_dcs.csv')\n    cust_df = pd.read_csv('ex2_customers.csv')\n    lanes_df = pd.read_csv('ex2_lanes.csv')\n    # Built some objects for convenience and speed\n    dc = dcs_df['dc_id'].tolist()\n    cust = cust_df['cust_id'].tolist()\n    arcs = list(lanes_df[['dc', 'cust']].itertuples(index=False, name=None))\n    supply = dcs_df.set_index('dc_id')['supply'].to_dict()\n    demand = cust_df.set_index('cust_id')['demand'].to_dict()\n    cost = lanes_df.set_index(['dc', 'cust'])['cost'].to_dict()\n\n    # Model\n    model = gp.Model('transport')\n    # x[d,c]: flow from dc d to customer c\n    x = model.addVars(arcs, lb=0.0, vtype=GRB.CONTINUOUS, name='x')\n\n    # supply constraints\n    model.addConstrs((x.sum(d, '*') <= supply[d] for d in dc), name='supply')\n    # demand constraints\n    model.addConstrs((x.sum('*', c) >= demand[c] for c in cust), name='demand')\n    # Objective: minimize total transport cost\n    model.setObjective(gp.quicksum(cost[d, c] * x[d, c] for (d, c) in arcs), GRB.MINIMIZE)\n    model.Params.OutputFlag = 0  # turn off the log\n    model.optimize()\n    if model.Status == GRB.OPTIMAL:\n        print(f'Objective: {model.ObjVal:,.0f}')\n\nex2()\n\ndef ex3():\n    # Using this to ensure all are working with the same data\n    n, p, seed = 200, 0.95, 42\n    random.seed(seed)\n    edges = set()\n    for i in range(n):\n        for j in range(i + 1, n):\n            if random.random() < p:\n                edges.add((i, j))\n\n    model = gp.Model('max_clique')\n    model.Params.TimeLimit = 3\n    model.Params.OutputFlag = 0\n\n    x = model.addVars(n, vtype=GRB.BINARY, name='x')\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (i, j) not in edges:  # no edge, no compatibility\n                model.addConstr(x[i] + x[j] <= 1, name=f'conflict_{i}_{j}')\n    # Find the maximum set of compatible nodes\n    model.setObjective(x.sum(), GRB.MAXIMIZE)\n    model.optimize()\n    if model.status == GRB.OPTIMAL:\n        print(f'Optimal. Best Objective: {model.ObjVal}')\n    else:\n        print('Infeasible')\n\nex3()\n\ndef ex4():\n    model = gp.Model()\n    x = model.addVar(vtype=GRB.INTEGER, ub=1000, name=\"x\")\n    y = model.addVar(vtype=GRB.INTEGER, ub=1000, name=\"y\")\n    # max πx + ey\n    model.setObjective(math.pi * x + math.e * y, GRB.MAXIMIZE)\n    model.addConstr(math.pi * x + 1 / 3 * y <= 3141.59265)\n    model.addConstr(x + y <= 1000)\n    model.Params.OutputFlag = 0\n    model.optimize()\n    if model.Status == GRB.OPTIMAL:\n        print(f'Optimal Solution: {model.ObjVal}')\n        for v in model.getVars():\n            print(v.VarName, v.X)\n\nex4()\n\ndef ex5():\n    dcs_df = pd.read_csv('ex2_dcs.csv')\n    cust_df = pd.read_csv('ex2_customers.csv')\n    lanes_df = pd.read_csv('ex2_lanes.csv')\n\n    # Built some objects for convenience and speed\n    dc = dcs_df['dc_id'].tolist()\n    cust = cust_df['cust_id'].tolist()\n    arcs = list(lanes_df[['dc', 'cust']].itertuples(index=False, name=None))\n    supply = dcs_df.set_index('dc_id')['supply'].to_dict()\n    dem_max = cust_df.set_index('cust_id')['demand'].to_dict()\n    dem_min = cust_df.set_index('cust_id')['min_demand'].to_dict()\n    cost = lanes_df.set_index(['dc', 'cust'])['cost'].to_dict()\n\n    # Model\n    model = gp.Model('facility_location')\n    # x[d,c]: flow from dc d to customer c\n    x = model.addVars(arcs, lb=0.0, vtype=GRB.CONTINUOUS, name='x')\n    # y[d]: 1 if dc d is open\n    y = model.addVars(dc, vtype=GRB.BINARY, name='y')\n\n    # per customer: min_demand[c] <= sum_d x[d,c] <= demand[c]\n    model.addConstrs((x.sum('*', c) >= dem_min[c] for c in cust), name='min_demand')\n    model.addConstrs((x.sum('*', c) <= dem_max[c] for c in cust), name='max_demand')\n\n    # dc capacity: sum_c x[d,c] <= supply[d] * y[d]\n    model.addConstrs((x.sum(d, '*') <= supply[d] * y[d] for d in dc), name='capacity')\n\n    # Objective: shipping + fixed cost of opening a dc\n    shipping = gp.quicksum(cost[d, c] * x[d, c] for (d, c) in arcs)\n    fixed = 10_000 * y.sum()\n    model.setObjective(shipping + fixed, GRB.MINIMIZE)\n    model.Params.OutputFlag = 0\n    model.optimize()\n    if model.Status == GRB.OPTIMAL:\n        print(f'Objective value: {model.ObjVal:.0f}')\n        print(f'Facilities opened: {sum(int(round(y[d].X)) for d in dc)}')\n        print(f'Total shipped: {sum(x[arc].X for arc in arcs):.0f}')\n\nex5()\n\ndef ex6():\n    num_facilities = 3\n    demand = 100\n    shipping_cost = 1\n    facility_cost = 5000\n    M = 1e8\n\n    model = gp.Model()\n    model.Params.Presolve = 0\n    # Quantity to ship from each facility\n    x = model.addVars(num_facilities, name=\"ship\")\n    # Whether or not we open a facility\n    y = model.addVars(num_facilities, vtype=GRB.BINARY, name=\"open_facility\")\n    # Satisfy customer demand\n    model.addConstr(x.sum() == demand)\n    # Only ship if facility is open\n    for i in range(num_facilities):\n        model.addConstr(x[i] <= M * y[i])\n    # Minimize shipping costs + facility-opening costs\n    model.setObjective(shipping_cost * x.sum() + facility_cost * y.sum(), GRB.MINIMIZE)\n    model.optimize()\n    if model.Status == GRB.OPTIMAL:\n        for v in model.getVars():\n            print(v.VarName, v.X)\n\nex6()"}]}
{"meta": {"source_path": "/Users/sunyujun03/Desktop/ReLoop/gurobi-modeling-examples/optimization301/Modeling_Session_2/completed_modeling2.ipynb", "kind": "ipynb", "title": "Optimization Gone Wrong and How to Fix it!"}, "messages": [{"role": "system", "content": "You are an optimization engineer. Write correct and runnable Python code using gurobipy (Gurobi Python API). Be concise. Output only what is requested."}, {"role": "user", "content": "    Task: Reproduce the following Gurobi modeling example in Python using gurobipy.\n\n    Scenario description (from source):\n    # Optimization Gone Wrong and How to Fix it!\n\n## Getting to Know a Parameter with Gurobot\n\nHere is a variation of the `quadratic assignment problem (QAP)`. Below is a formulation. We really won't need it but it's here for fun.\n\n#### QAP Mathematical Formulation\n\n##### Sets and Indices\n- $i, k \\in \\{0, 1, \\ldots, n-1\\}$: Facilities\n- $j, l \\in \\{0, 1, \\ldots, n-1\\}$: Locations\n\n##### Parameters\n- $f_{ik}$: Flow between facility $i$ and facility $k$ (represented as `flow[i][k]`)\n- $d_{jl}$: Distance between location $j$ and location $l$ (represented as `dist[j][l]`)\n- $n$: Number of facilities (and locations)\n\n##### Decision Variables\n- $x_{ij} \\in \\{0, 1\\}$: Binary variable equal to 1 if facility $i$ is assigned to location $j$, 0 otherwise\n\n##### Objective Function\n\n$$\n\\min \\sum_{i=0}^{n-1} \\sum_{j=0}^{n-1} \\sum_{k=0}^{n-1} \\sum_{l=0}^{n-1} c_{ik} \\cdot f_{ik} \\cdot d_{jl} \\cdot x_{ij} \\cdot x_{kl}\n$$\n\nwhere the coefficient $c_{ik}$ is defined as:\n\n$$\nc_{ik} = \\begin{cases} \n-1 & \\text{if } (i+k) \\bmod 2 = 0 \\\\\n1 & \\text{if } (i+k) \\bmod 2 = 1\n\\end{cases}\n$$\n\n##### Constraints\n\n**Assignment constraints - Each facility to exactly one location:**\n$$\n\\sum_{j=0}^{n-1} x_{ij} = 1 \\quad \\forall i \\in \\{0, 1, \\ldots, n-1\\}\n$$\n\n**Assignment constraints - Each location receives exactly one facility:**\n$$\n\\sum_{i=0}^{n-1} x_{ij} = 1 \\quad \\forall j \\in \\{0, 1, \\ldots, n-1\\}\n$$\n\n**Binary constraints:**\n$$\nx_{ij} \\in \\{0, 1\\} \\quad \\forall i, j \\in \\{0, 1, \\ldots, n-1\\}\n$$\n\n    Requirements:\n    - Use gurobipy (Model, GRB, addVar/addConstr, etc.)\n    - Make the script runnable as a standalone Python file if possible.\n    - Keep the code faithful to the example.\n"}, {"role": "assistant", "content": "import pandas as pd\nimport gurobipy as gp\nfrom gurobipy import GRB\n\nn = 10\n\n# Distance between locations\ndist = [[abs(j - k) + 1 for k in range(n)] for j in range(n)]\n\n# Flow/weight between facilities\nflow = [[(i + k + 1) * ((i - k) ** 2 + 1) for k in range(n)] for i in range(n)]\n\n# Quadratic assignment problem\nm1 = gp.Model()\nm1.Params.Seed = 42\n\n# x[i,j] = 1 if facility i is assigned to location j\nx = m1.addVars(n, n, vtype=GRB.BINARY, name=\"x\")\n\n# Build objective function\nobj = gp.QuadExpr()\nfor i in range(n):\n    for j in range(n):\n        for k in range(n):\n            for l in range(n):\n                coeff = flow[i][k] * dist[j][l]\n                # Alternate signs\n                if (i + k) % 2 == 0:\n                    coeff = -coeff\n                obj.addTerms(coeff, x[i, j], x[k, l])\n\nm1.setObjective(obj, GRB.MINIMIZE)\n\n# Each facility is assigned to exactly one location\nfor i in range(n):\n    m1.addConstr(x.sum(i, \"*\") == 1, name=f\"assign_facility[{i}]\")\n\n# Each location is assigned exactly one facility\nfor j in range(n):\n    m1.addConstr(x.sum(\"*\", j) == 1, name=f\"assign_to_location[{j}]\")\n\n# Set parameters here after running in once. \n\n# m1.Params.ParameterName = value\nm1.optimize()\n\npath = 'https://raw.githubusercontent.com/Gurobi/modeling-examples/master/optimization101/Modeling_Session_1/'\ntransp_cost = pd.read_csv(path + 'cost.csv')\n# get production and distribution locations from data frame\nproduction = list(transp_cost['production'].unique())\ndistribution = list(transp_cost['distribution'].unique())\ntransp_cost = transp_cost.set_index(['production','distribution']).squeeze()\n\nmax_prod = pd.Series([180,200,140,80,180], index = production, name = \"max_production\")\nn_demand = pd.Series([89,95,121,101,116,181], index = distribution, name = \"demand\")\n\n# the min production is a fraction of the max\nfrac = 0.90\n# min shipment size, if it's > 0\nC = 50\n\n# gurobipy code for this above formulation\nm = gp.Model('widgets')\n\n# decision vars\nx = m.addVars(production, distribution, vtype=GRB.SEMICONT, lb = C, name = 'prod_ship')\n\n# constraints\ncan_produce = m.addConstrs((gp.quicksum(x[p,d] for d in distribution) <= max_prod[p] for p in production), name = 'can_produce')\nmust_produce = m.addConstrs((gp.quicksum(x[p,d] for d in distribution) >= frac*max_prod[p] for p in production), name = 'must_produce')\nmeet_demand = m.addConstrs((x.sum('*', d) == n_demand[d] for d in distribution), name = \"meet_demand\")\n\n#objective\nm.setObjective(gp.quicksum(transp_cost[p,d]*x[p,d] for p in production for d in distribution), GRB.MINIMIZE)\nm.optimize()\n\nif m.Status == GRB.INFEASIBLE:\n    m.computeIIS()\n    \n    # Check which constraints are in the IIS\n    for constr in m.getConstrs():\n        if constr.IISConstr:\n            print(f\"Conflicting: {constr.ConstrName}\")\n\nmax_prod = pd.Series([180,200,140,80,180], index = production, name = \"max_production\")\nn_demand = pd.Series([89,95,121,101,116,181], index = distribution, name = \"demand\")\n\n# the min production is a fraction of the max\nfrac = 0.90\n# min shipment size, if it's > 0\nC = 50\n\n# gurobipy code for this above formulation\nm = gp.Model('widgets')\n\n# decision vars\nx = m.addVars(production, distribution, vtype=GRB.SEMICONT, lb = C, name = 'prod_ship')\n\n# constraints\ncan_produce = m.addConstrs((gp.quicksum(x[p,d] for d in distribution) <= max_prod[p] for p in production), name = 'can_produce')\nmust_produce = m.addConstrs((gp.quicksum(x[p,d] for d in distribution) >= frac*max_prod[p] for p in production), name = 'must_produce')\nmeet_demand = m.addConstrs((x.sum('*', d) == n_demand[d] for d in distribution), name = \"meet_demand\")\n\n#objective\nm.setObjective(gp.quicksum(transp_cost[p,d]*x[p,d] for p in production for d in distribution), GRB.MINIMIZE)\nm.optimize()\n\n# Relax ALL constraints equally (penalty = 1.0 for each)\nm.feasRelaxS(0, False, False, True)\n#            │    │      │      └─ crelax: True = relax constraints\n#            │    │      └─ vrelax: False = don't relax variable bounds\n#            │    └─ minrelax: False = just minimize violations\n#            └─ relaxobjtype: 0=sum, 1=sum of squares, 2=count\n\nm.optimize()\n\nm.write(\"relax.lp\")\n\n# Analyze violations\nprint(\"\\nViolated constraints:\")\nfor var in m.getVars():\n    if var.VarName.startswith('Art') and var.X > 1e-6:\n        print(f\"  {var.VarName}: {var.X:.4f}\")\n\n# gurobipy code for this above formulation\nm2 = gp.Model('widgets')\n\nmax_prod2 = pd.Series([210,225,140,130,220], index = production, name = \"max_production\")\nn_demand = pd.Series([89,95,121,101,116,181], index = distribution, name = \"demand\")\n\nfrac = 0.75\n# decision vars\nx2 = m2.addVars(production, distribution, vtype=GRB.SEMICONT, lb = C, name = 'prod_ship')\ny2 = m2.addVars(production, vtype=GRB.BINARY, name = 'prod_on')\n\n# constraints\ncan_produce = m2.addConstrs((gp.quicksum(x2[p,d] for d in distribution) <= max_prod2[p] for p in production), name = 'can_produce')\nmust_produce = m2.addConstrs((gp.quicksum(x2[p,d] for d in distribution) >= frac*max_prod2[p] for p in production), name = 'must_produce')\nmeet_demand = m2.addConstrs((x2.sum('*', d) == n_demand[d] for d in distribution), name = \"meet_demand\")\nxy_link = m2.addConstrs((x2[p,d] <= max_prod2[p]*y2[p] for p in production for d in distribution), name = 'xy_link')\nonly_four = m2.addConstr((y2.sum() <= 4), name = 'only4')\n\n#objective\nm2.setObjective(gp.quicksum(transp_cost[p,d]*x2[p,d] for p in production for d in distribution), GRB.MINIMIZE)\nm2.optimize()"}]}
{"meta": {"source_path": "/Users/sunyujun03/Desktop/ReLoop/gurobi-modeling-examples/optimization301/Modeling_Session_2/modeling2.ipynb", "kind": "ipynb", "title": "Optimization Gone Wrong and How to Fix it!"}, "messages": [{"role": "system", "content": "You are an optimization engineer. Write correct and runnable Python code using gurobipy (Gurobi Python API). Be concise. Output only what is requested."}, {"role": "user", "content": "    Task: Reproduce the following Gurobi modeling example in Python using gurobipy.\n\n    Scenario description (from source):\n    # Optimization Gone Wrong and How to Fix it!\n\n## Getting to Know a Parameter with Gurobot\n\nHere is a variation of the `quadratic assignment problem (QAP)`. Below is a formulation. We really won't need it but it's here for fun.\n\n#### QAP Mathematical Formulation\n\n##### Sets and Indices\n- $i, k \\in \\{0, 1, \\ldots, n-1\\}$: Facilities\n- $j, l \\in \\{0, 1, \\ldots, n-1\\}$: Locations\n\n##### Parameters\n- $f_{ik}$: Flow between facility $i$ and facility $k$ (represented as `flow[i][k]`)\n- $d_{jl}$: Distance between location $j$ and location $l$ (represented as `dist[j][l]`)\n- $n$: Number of facilities (and locations)\n\n##### Decision Variables\n- $x_{ij} \\in \\{0, 1\\}$: Binary variable equal to 1 if facility $i$ is assigned to location $j$, 0 otherwise\n\n##### Objective Function\n\n$$\n\\min \\sum_{i=0}^{n-1} \\sum_{j=0}^{n-1} \\sum_{k=0}^{n-1} \\sum_{l=0}^{n-1} c_{ik} \\cdot f_{ik} \\cdot d_{jl} \\cdot x_{ij} \\cdot x_{kl}\n$$\n\nwhere the coefficient $c_{ik}$ is defined as:\n\n$$\nc_{ik} = \\begin{cases} \n-1 & \\text{if } (i+k) \\bmod 2 = 0 \\\\\n1 & \\text{if } (i+k) \\bmod 2 = 1\n\\end{cases}\n$$\n\n##### Constraints\n\n**Assignment constraints - Each facility to exactly one location:**\n$$\n\\sum_{j=0}^{n-1} x_{ij} = 1 \\quad \\forall i \\in \\{0, 1, \\ldots, n-1\\}\n$$\n\n**Assignment constraints - Each location receives exactly one facility:**\n$$\n\\sum_{i=0}^{n-1} x_{ij} = 1 \\quad \\forall j \\in \\{0, 1, \\ldots, n-1\\}\n$$\n\n**Binary constraints:**\n$$\nx_{ij} \\in \\{0, 1\\} \\quad \\forall i, j \\in \\{0, 1, \\ldots, n-1\\}\n$$\n\n    Requirements:\n    - Use gurobipy (Model, GRB, addVar/addConstr, etc.)\n    - Make the script runnable as a standalone Python file if possible.\n    - Keep the code faithful to the example.\n"}, {"role": "assistant", "content": "import pandas as pd\nimport gurobipy as gp\nfrom gurobipy import GRB\n\nn = 10\n\n# Distance between locations\ndist = [[abs(j - k) + 1 for k in range(n)] for j in range(n)]\n\n# Flow/weight between facilities\nflow = [[(i + k + 1) * ((i - k) ** 2 + 1) for k in range(n)] for i in range(n)]\n\n# Quadratic assignment problem\nm1 = gp.Model()\nm1.Params.Seed = 42\n\n# x[i,j] = 1 if facility i is assigned to location j\nx = m1.addVars(n, n, vtype=GRB.BINARY, name=\"x\")\n\n# Build objective function\nobj = gp.QuadExpr()\nfor i in range(n):\n    for j in range(n):\n        for k in range(n):\n            for l in range(n):\n                coeff = flow[i][k] * dist[j][l]\n                # Alternate signs\n                if (i + k) % 2 == 0:\n                    coeff = -coeff\n                obj.addTerms(coeff, x[i, j], x[k, l])\n\nm1.setObjective(obj, GRB.MINIMIZE)\n\n# Each facility is assigned to exactly one location\nfor i in range(n):\n    m1.addConstr(x.sum(i, \"*\") == 1, name=f\"assign_facility[{i}]\")\n\n# Each location is assigned exactly one facility\nfor j in range(n):\n    m1.addConstr(x.sum(\"*\", j) == 1, name=f\"assign_to_location[{j}]\")\n\n# Set parameters here after running in once. \n\n# m1.Params.ParameterName = value\nm1.optimize()\n\npath = 'https://raw.githubusercontent.com/Gurobi/modeling-examples/master/optimization101/Modeling_Session_1/'\ntransp_cost = pd.read_csv(path + 'cost.csv')\n# get production and distribution locations from data frame\nproduction = list(transp_cost['production'].unique())\ndistribution = list(transp_cost['distribution'].unique())\ntransp_cost = transp_cost.set_index(['production','distribution']).squeeze()\n\nmax_prod = pd.Series([180,200,140,80,180], index = production, name = \"max_production\")\nn_demand = pd.Series([89,95,121,101,116,181], index = distribution, name = \"demand\")\n\n# the min production is a fraction of the max\nfrac = 0.90\n# min shipment size, if it's > 0\nC = 50\n\n# gurobipy code for this above formulation\nm = gp.Model('widgets')\n\n# decision vars\nx = m.addVars(production, distribution, vtype=GRB.SEMICONT, lb = C, name = 'prod_ship')\n\n# constraints\ncan_produce = m.addConstrs((gp.quicksum(x[p,d] for d in distribution) <= max_prod[p] for p in production), name = 'can_produce')\nmust_produce = m.addConstrs((gp.quicksum(x[p,d] for d in distribution) >= frac*max_prod[p] for p in production), name = 'must_produce')\nmeet_demand = m.addConstrs((x.sum('*', d) == n_demand[d] for d in distribution), name = \"meet_demand\")\n\n#objective\nm.setObjective(gp.quicksum(transp_cost[p,d]*x[p,d] for p in production for d in distribution), GRB.MINIMIZE)\nm.optimize()\n\nif m.Status == GRB.INFEASIBLE:\n    m.computeIIS()\n    \n    # Check which constraints are in the IIS\n    for constr in m.getConstrs():\n        if constr.IISConstr:\n            print(f\"Conflicting: {constr.ConstrName}\")\n\nmax_prod = pd.Series([180,200,140,80,180], index = production, name = \"max_production\")\nn_demand = pd.Series([89,95,121,101,116,181], index = distribution, name = \"demand\")\n\n# the min production is a fraction of the max\nfrac = 0.90\n# min shipment size, if it's > 0\nC = 50\n\n# gurobipy code for this above formulation\nm = gp.Model('widgets')\n\n# decision vars\nx = m.addVars(production, distribution, vtype=GRB.SEMICONT, lb = C, name = 'prod_ship')\n\n# constraints\ncan_produce = m.addConstrs((gp.quicksum(x[p,d] for d in distribution) <= max_prod[p] for p in production), name = 'can_produce')\nmust_produce = m.addConstrs((gp.quicksum(x[p,d] for d in distribution) >= frac*max_prod[p] for p in production), name = 'must_produce')\nmeet_demand = m.addConstrs((x.sum('*', d) == n_demand[d] for d in distribution), name = \"meet_demand\")\n\n#objective\nm.setObjective(gp.quicksum(transp_cost[p,d]*x[p,d] for p in production for d in distribution), GRB.MINIMIZE)\nm.optimize()\n\n# Relax ALL constraints equally (penalty = 1.0 for each)\nm.feasRelaxS(0, False, False, True)\n#            │    │      │      └─ crelax: True = relax constraints\n#            │    │      └─ vrelax: False = don't relax variable bounds\n#            │    └─ minrelax: False = just minimize violations\n#            └─ relaxobjtype: 0=sum, 1=sum of squares, 2=count\n\nm.optimize()\n\nm.write(\"relax.lp\")\n\n# Analyze violations\nprint(\"\\nViolated constraints:\")\nfor var in m.getVars():\n    if var.VarName.startswith(  ????  ) and var.X > 1e-6:\n        print(f\"  {var.VarName}: {var.X:.4f}\")\n\n# gurobipy code for this above formulation\nm2 = gp.Model('widgets')\n\nmax_prod2 = pd.Series([210,225,140,130,220], index = production, name = \"max_production\")\nn_demand = pd.Series([89,95,121,101,116,181], index = distribution, name = \"demand\")\n\nfrac = 0.75\n# decision vars\nx2 = m2.addVars(production, distribution, vtype=GRB.SEMICONT, lb = C, name = 'prod_ship')\ny2 = m2.addVars(production, vtype=GRB.BINARY, name = 'prod_on')\n\n# constraints\ncan_produce = m2.addConstrs((gp.quicksum(x2[p,d] for d in distribution) <= max_prod2[p] for p in production), name = 'can_produce')\nmust_produce = m2.addConstrs((gp.quicksum(x2[p,d] for d in distribution) >= frac*max_prod2[p] for p in production), name = 'must_produce')\nmeet_demand = m2.addConstrs((x2.sum('*', d) == n_demand[d] for d in distribution), name = \"meet_demand\")\nxy_link = m2.addConstrs((x2[p,d] <= max_prod2[p]*y2[p] for p in production for d in distribution), name = 'xy_link')\nonly_four = m2.addConstr((y2.sum() <= 4), name = 'only4')\n\n#objective\nm2.setObjective(gp.quicksum(transp_cost[p,d]*x2[p,d] for p in production for d in distribution), GRB.MINIMIZE)\nm2.optimize()"}]}
{"meta": {"source_path": "/Users/sunyujun03/Desktop/ReLoop/gurobi-modeling-examples/optimization301/Modeling_Session_1/completed_modeling1.ipynb", "kind": "ipynb", "title": "Modeling Session 1"}, "messages": [{"role": "system", "content": "You are an optimization engineer. Write correct and runnable Python code using gurobipy (Gurobi Python API). Be concise. Output only what is requested."}, {"role": "user", "content": "    Task: Reproduce the following Gurobi modeling example in Python using gurobipy.\n\n    Scenario description (from source):\n    # Modeling Session 1\nThis set of exercises are meant to cover many of the topics from Day 1, with callbacks from Opti 101, 201, 202 along the way. You can work along in this notebook, but if you really just want to see the solutions, those can also be found in the GitHub repo.\n\n## Building Trust in Optimization\n\n### Solution pools\n\nIn this section, we'll explore solution pools to build trust in a discrete model by\nsurfacing *multiple, near‑optimal* operating plans. We'll use the same storage + solar\ndispatch context from earlier (charging/discharging a battery, buying from the grid, meeting\ndemand), but we’ll ask Gurobi to return a *set* of high‑quality alternatives.\n\nGoal: Collect the top‑k solutions within a small optimality gap and compare them on\nkey features (objective, total grid energy, number of charge/discharge switches).\n\nNote that some of this (the problem, and the approaches) should seem familiar...\n\n    Requirements:\n    - Use gurobipy (Model, GRB, addVar/addConstr, etc.)\n    - Make the script runnable as a standalone Python file if possible.\n    - Keep the code faithful to the example.\n"}, {"role": "assistant", "content": "import pandas as pd\nimport numpy as np\nimport gurobipy as gp\nfrom gurobipy import GRB\n\nimport pandas as pd\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# Tiny instance (kept small so we can enumerate several pool solutions quickly)\nT = range(12)                        # time periods\nprice = [20,18,16,15,16,18,25,40,45,35,28,22]  # grid price €/MWh\ndemand = [5,5,5,5,6,6,7,7,7,6,6,5]  # MWh demand each period\n\neta_in, eta_out = 0.95, 0.95        # round-trip efficiency\ncap = 10.0                          # MWh battery capacity\npmax = 4.0                          # MW charge/discharge limit\ns0 = 2.0                            # initial state of charge\n\nm = gp.Model(\"storage_pool\")\n\n# Decision variables\nch = m.addVars(T, name=\"charge\", lb=0, ub=pmax)\ndis = m.addVars(T, name=\"discharge\", lb=0, ub=pmax)\ngrid = m.addVars(T, name=\"grid\", lb=0)\nsoc = m.addVars(T, name=\"soc\", lb=0, ub=cap)\n# on/off switching to discourage rapid toggling (makes model MIP)\ny_ch = m.addVars(T, vtype=GRB.BINARY, name=\"y_ch\")\ny_dis = m.addVars(T, vtype=GRB.BINARY, name=\"y_dis\")\n\n# Logic: can’t charge and discharge simultaneously\nm.addConstrs((y_ch[t] + y_dis[t] <= 1 for t in T), name=\"no_simul\")\nm.addConstrs((ch[t] <= pmax * y_ch[t] for t in T), name=\"charge_gate\")\nm.addConstrs((dis[t] <= pmax * y_dis[t] for t in T), name=\"discharge_gate\")\n\n# Energy balance vs demand\nm.addConstrs((grid[t] + dis[t]*eta_out >= demand[t] + ch[t] for t in T), name=\"balance\")\n\n# State of charge dynamics\nfor t in T:\n    if t == 0:\n        m.addConstr(soc[t] == s0 + ch[t]*eta_in - dis[t]/eta_out, name=f\"soc_{t}\")\n    else:\n        m.addConstr(soc[t] == soc[t-1] + ch[t]*eta_in - dis[t]/eta_out, name=f\"soc_{t}\")\n\n# Mild cycling preference: penalize on/off changes to diversify plans\nswitches = gp.quicksum((y_ch[t] + y_dis[t]) for t in T)\n\n# Cost: energy purchased from grid\ncost = gp.quicksum(price[t]*grid[t] for t in T)\n\n# Multi-criteria via a single objective (lexico done elsewhere; here we pool around cost)\nm.setObjective(cost + 1e-3 * switches, GRB.MINIMIZE)\n\n# Ask for a pool of near‑optimal solutions\nm.setParam(GRB.Param.PoolSearchMode, 2)  # systematic search for k‑best\nm.setParam(GRB.Param.PoolSolutions, 500)  # keep up to 500\nm.setParam(GRB.Param.PoolGap, 0.02)      # within 2% of best found\nm.optimize()\n\n# Collect solutions\nrows = []\nfor i in range(m.SolCount):\n    m.setParam(GRB.Param.SolutionNumber, i)\n    obj = m.PoolObjVal\n    total_grid = sum(grid[t].Xn for t in T)\n    total_switch = sum(y_ch[t].Xn + y_dis[t].Xn for t in T)\n    rows.append({\"obj\": obj, \"grid_MWh\": total_grid, \"switch_count\": total_switch})\n\nsols = pd.DataFrame(rows).sort_values(\"obj\").reset_index(drop=True)\n\nbest_obj = m.ObjVal\nsols[\"rel_diff_to_best_pct\"] = ((sols[\"obj\"] - best_obj) / abs(best_obj)* 100).round(6).astype(str) + \"%\"\nsols_unique = sols.drop_duplicates().reset_index(drop=True)\nsols_unique\n\nimport pandas as pd\nimport gurobipy as gp\nfrom gurobipy import GRB\n\nT = range(12)\nbase_price = [20,18,16,15,16,18,25,40,45,35,28,22]\nbase_demand = [5,5,5,5,6,6,7,7,7,6,6,5]\n\nscenarios = {\n    \"Base\": (base_price, base_demand),\n    \"HighPricePeak\": ([p*1.2 if 7<=t<=9 else p for t,p in enumerate(base_price)], base_demand),\n    \"EveningHeavyDemand\": (base_price, [d*1.2 if t>=7 else d for t,d in enumerate(base_demand)]),\n}\n\neta_in, eta_out = 0.95, 0.95\ncap, pmax, s0 = 10.0, 4.0, 2.0\n\ndef solve(price, demand):\n    m = gp.Model(\"storage_scen\")\n    ch = m.addVars(T, name=\"charge\", lb=0, ub=pmax)\n    dis = m.addVars(T, name=\"discharge\", lb=0, ub=pmax)\n    grid = m.addVars(T, name=\"grid\", lb=0)\n    soc = m.addVars(T, name=\"soc\", lb=0, ub=cap)\n\n    # LP version to keep focus on param changes\n    m.addConstrs((grid[t] + dis[t]*eta_out >= demand[t] + ch[t] for t in T), name=\"balance\")\n    for t in T:\n        if t == 0:\n            m.addConstr(soc[t] == s0 + ch[t]*eta_in - dis[t]/eta_out)\n        else:\n            m.addConstr(soc[t] == soc[t-1] + ch[t]*eta_in - dis[t]/eta_out)\n\n    cost = gp.quicksum(price[t]*grid[t] for t in T)\n    m.setObjective(cost, GRB.MINIMIZE)\n    m.setParam(\"OutputFlag\", 0)\n    m.optimize()\n\n    return float(cost.getValue()), float(soc[max(T)].X)\n\nrows = []\nfor name, (p, d) in scenarios.items():\n    total_cost, final_soc = solve(p, d)\n    rows.append({\"scenario\": name, \"total_cost\": round(total_cost,2), \"final_soc\": round(final_soc,2)})\n\npd.DataFrame(rows).sort_values(\"total_cost\")\n\nimport pandas as pd\nimport gurobipy as gp\nfrom gurobipy import GRB\n\nT = range(12)\nprice = [20,18,16,15,16,18,25,40,45,35,28,22]\ndemand = [5,5,5,5,6,6,7,7,7,6,6,5]\n\neta_in, eta_out = 0.95, 0.95\ncap, pmax, s0 = 10.0, 4.0, 2.0\n\n# Build LP (no binaries)\nm = gp.Model(\"storage_duals\")\nch = m.addVars(T, name=\"charge\", lb=0, ub=pmax)\ndis = m.addVars(T, name=\"discharge\", lb=0, ub=pmax)\ngrid = m.addVars(T, name=\"grid\", lb=0)\nsoc = m.addVars(T, name=\"soc\", lb=0, ub=cap)\n\nbalance = m.addConstrs((grid[t] + dis[t]*eta_out >= demand[t] + ch[t] for t in T), name=\"balance\")\nfor t in T:\n    if t == 0:\n        m.addConstr(soc[t] == s0 + ch[t]*eta_in - dis[t]/eta_out, name=f\"soc_{t}\")\n    else:\n        m.addConstr(soc[t] == soc[t-1] + ch[t]*eta_in - dis[t]/eta_out, name=f\"soc_{t}\")\n\ncost = gp.quicksum(price[t]*grid[t] for t in T)\nm.setObjective(cost, GRB.MINIMIZE)\nm.setParam(\"OutputFlag\", 0)\nm.optimize()\n\n# Read duals (Pi) and slacks\nrows = []\nfor t in T:\n    con = balance[t]\n    rows.append({\n        \"t\": t,\n        \"pi\": con.Pi,\n        \"slack\": con.Slack,\n    })\n\npi_df = pd.DataFrame(rows).sort_values(\"pi\", ascending=False)\nprint(\"Top periods by shadow price (higher pi => relaxing balance helps more):\")\ndisplay(pi_df.head(6))\n\n# Sensitivity check: bump demand at period with largest pi by +0.1 and compare objective change\nt_star = int(pi_df.iloc[0][\"t\"])\nbump = 0.1\n\ndef solve_with_demand(d):\n    m2 = gp.Model(\"storage_duals_copy\")\n    ch2 = m2.addVars(T, name=\"charge\", lb=0, ub=pmax)\n    dis2 = m2.addVars(T, name=\"discharge\", lb=0, ub=pmax)\n    grid2 = m2.addVars(T, name=\"grid\", lb=0)\n    soc2 = m2.addVars(T, name=\"soc\", lb=0, ub=cap)\n    bal2 = m2.addConstrs((grid2[t] + dis2[t]*eta_out >= d[t] + ch2[t] for t in T))\n    for t in T:\n        if t == 0:\n            m2.addConstr(soc2[t] == s0 + ch2[t]*eta_in - dis2[t]/eta_out)\n        else:\n            m2.addConstr(soc2[t] == soc2[t-1] + ch2[t]*eta_in - dis2[t]/eta_out)\n    cost2 = gp.quicksum(price[t]*grid2[t] for t in T)\n    m2.setObjective(cost2, GRB.MINIMIZE)\n    m2.setParam(\"OutputFlag\", 0)\n    m2.optimize()\n    return float(cost2.getValue())\n\nbase_obj = float(cost.getValue())\nd2 = demand.copy()\nd2[t_star] += bump\nnew_obj = solve_with_demand(d2)\n\napprox_change = pi_df.iloc[0][\"pi\"] * bump\nactual_change = new_obj - base_obj\n\nsummary = pd.DataFrame({\n    \"t*\":[t_star],\n    \"pi\":[pi_df.iloc[0][\"pi\"]],\n    \"bump\":[bump],\n    \"approx_obj_change (pi*bump)\":[approx_change],\n    \"actual_obj_change\":[actual_change],\n})\ndisplay(summary)\n \n# FYI explanation printout, commas only\nprint(\n    f\"\\nFYI,\\n\"\n    f\"- Period {t_star} had the highest shadow price (pi = {pi_df.iloc[0]['pi']:.1f}), meaning extra demand there is most expensive.\\n\"\n    f\"- The bump of {bump} MWh is small enough that the linear, pi-based prediction is valid.\\n\"\n    f\"- Predicted vs actual change ({approx_change:.2f} vs {actual_change:.2f}) are nearly identical, so we are within the linear sensitivity range.\\n\"\n    f\"- Slack = 0 confirms this constraint was binding.\\n\"\n    f\"- In plain terms, adding 0.1 MWh at hour {t_star} costs about €{approx_change:.1f}, exactly as the model’s dual value predicted.\"\n)\n\n# Install the optimods package\nimport numpy as np\n\nfrom gurobi_optimods.datasets import load_portfolio\nfrom gurobi_optimods.portfolio import MeanVariancePortfolio\n\nnp.set_printoptions(legacy='1.21')\n\ndata = load_portfolio()\ncov_matrix = data.cov()\nmu = data.mean()\n\n# Show the expected returns for our potential 'assets'\nmu\n\n# Show the covariance matrix\ncov_matrix\n\n# We can define this risk-aversion coefficient\ngamma = 20\n# Max positions K\nK = 3\n\n# Fill in the above info for expected returns and the covariance, respectively\nmvp = MeanVariancePortfolio(mu, cov_matrix)\n\n# Put in gamma, max positions. If you want to see the logs, set verbose = True\nmp = mvp.efficient_portfolio(gamma, max_positions=K, verbose = False)\n\nprint(f\"The portfolio's expected return is {round(mp.ret,5)}\")\n\n# The portfolio's allocation:\nmp.x\n\n#### Now model it yourself\ngamma = 20\nl = 0.01\n# Create an empty optimization model\nm = gp.Model()\n\n# Add variables: x[i] denotes the proportion invested in stock i\n# 0 <= x[i] <= 1\nx = m.addMVar(len(mu), lb=0, ub=1, name=\"x\")\nb = m.addMVar(len(mu), vtype=gp.GRB.BINARY, name=\"b\")\n\n# Budget constraint: all investments sum up to 1\nm.addConstr(x.sum() == 1, name=\"Budget_Constraint\")\n\n# Link the continuous x to the binary b\n# If x > 0 then b = 1 (also remember the bounds of x)\nm.addConstr(x <= b, name=\"Indicator\")\n\n# Minimal position; see formula (2) above\nm.addConstr(x >= l * b, name=\"Minimal_Position\")\n# Cardinality constraint: at most K positions\ncardinality_constr = m.addConstr(b.sum() <= 3, \"Cardinality\")\n\n# Define objective function: Maximize expected utility\nm.setObjective(\n    mu.to_numpy() @ x - gamma / 2 * (x @ cov_matrix.to_numpy() @ x), gp.GRB.MAXIMIZE\n)\nm.optimize()\n\ns2 = pd.Series(x.X, index= mp.x.index)\ns1 = pd.Series(mp.x)\ndf = pd.concat([s2,s1], axis=1, ignore_index=True)\ndf.columns = ['OptiMod','Our Model']\ndf\n\ndata = load_portfolio()\ncov_matrix = data.cov()\nmu = data.mean()\n\n# Values for the model parameters:\nV = 0.0025  # Maximal admissible variance (sigma^2)\nl = 0.001  # Minimal position size\nc = 0.0001  # Fixed transaction costs\nf = 0.001 * np.ones(mu.shape)  # Variable transaction fees\n\n# Create an empty optimization model\nm = gp.Model()\n\n# Add variables: x[i] denotes the proportion invested in stock i\nx = m.addMVar(len(mu), lb=0, ub=1, name=\"x\")\n# Add variables: b[i]=1 if stock i is held, and b[i]=0 otherwise\nb = m.addMVar(len(mu), vtype=gp.GRB.BINARY, name=\"b\")\n# Upper bound on variance\nm.addConstr(x @ cov_matrix.to_numpy() @ x <= V, name=\"Variance\")\n# Force x to 0 if not traded; see formula (1) above\nm.addConstr(x <= b, name=\"Indicator\")\n# Minimal position; see formula (2) above\nm.addConstr(x >= l * b, name=\"Minimal_Position\")\n# Budget constraint: all investments, costs, and fees sum up to 1\nbudget_constr = m.addConstr(\n    x.sum() + c*b.sum() + f @ x == 1, name=\"Budget_Constraint\"\n)\n# Define objective: Maximize expected return\nm.setObjective(mu.to_numpy() @ x, gp.GRB.MAXIMIZE)\n\nm.optimize()\n\npd.Series(x.X)\n\nimport gurobipy as gp\nfrom gurobipy import GRB\nimport pandas as pd\nimport time\n\nmps_file = 'markshare_4_0.mps'\n\ndef solve_with_mipfocus(model_file = mps_file, mipfocus_value = 0, output_flag = 1, time_limit=60):\n    \"\"\"\n    Solve a model with a specific MIPFocus value and return performance metrics.\n    \n    Parameters:\n    -----------\n    model_file : str\n        Path to the .mps file\n    mipfocus_value : int\n        MIPFocus parameter value (0, 1, 2, or 3)\n    time_limit : float\n        Time limit in seconds\n    \n    Returns:\n    --------\n    dict : Dictionary containing performance metrics\n    \"\"\"\n    # Create environment and model\n    # This will make the name of a '*.log' file\n    log_file = f'mipfocus{mipfocus_value}.log'\n    env = gp.Env(params={\"LogFile\": log_file, \n                         \"OutputFlag\": output_flag, \n                         \"LogToConsole\": 0})  \n    model = gp.read(model_file, env=env)\n    \n    # Set parameters\n    model.setParam('MIPFocus', mipfocus_value)\n    model.setParam('TimeLimit', time_limit)\n    \n    print(f\"\\n{'='*80}\")\n    print(f\"Solving with MIPFocus = {mipfocus_value}\")\n    print(f\"{'='*80}\\n\")\n    \n    # Solve the model\n    model.optimize()\n    \n    # Collect metrics\n    metrics = {\n        'MIPFocus': mipfocus_value,\n        'Status': model.Status,\n        'StatusName': model.getAttr(GRB.Attr.Status),\n        'Runtime': model.Runtime,\n        'NodeCount': model.NodeCount,\n        'IterCount': model.IterCount,\n    }\n    \n    # Add solution-specific metrics if available\n    if model.SolCount > 0:\n        metrics['ObjVal'] = model.ObjVal\n        metrics['ObjBound'] = model.ObjBound\n        metrics['MIPGap'] = model.MIPGap\n        metrics['SolCount'] = model.SolCount\n    else:\n        metrics['ObjVal'] = None\n        metrics['ObjBound'] = model.ObjBound if hasattr(model, 'ObjBound') else None\n        metrics['MIPGap'] = None\n        metrics['SolCount'] = 0\n\n    \n    # Clean up\n    model.dispose()\n    env.dispose()\n    \n    return metrics\n\n# Solve with MIPFocus = 0\nresults_0 = solve_with_mipfocus(mipfocus_value=0)\n\nfor key, value in results_0.items():\n    if key != 'StatusName':\n        print(f\"{key:20s}: {value}\")\n\n# Solve with MIPFocus = 1\nresults_1 = solve_with_mipfocus(mipfocus_value=1)\n\nfor key, value in results_1.items():\n    if key != 'StatusName':\n        print(f\"{key:20s}: {value}\")\n\n# Solve with MIPFocus = 2\nresults_2 = solve_with_mipfocus(mipfocus_value=2)\n\nfor key, value in results_2.items():\n    if key != 'StatusName':\n        print(f\"{key:20s}: {value}\")\n\n# Solve with MIPFocus = 3\nresults_3 = solve_with_mipfocus(mipfocus_value=3)\n\nfor key, value in results_3.items():\n    if key != 'StatusName':\n        print(f\"{key:20s}: {value}\")\n\n# Create a comparison dataframe\ncomparison_df = pd.DataFrame([results_0, results_1, results_2, results_3])\ncomparison_df = comparison_df.drop('StatusName', axis=1)\ncomparison_df\n\nn = 10\n\n# Distance between locations\ndist = [[abs(j - k) + 1 for k in range(n)] for j in range(n)]\n\n# Flow/weight between facilities\nflow = [[(i + k + 1) * ((i - k) ** 2 + 1) for k in range(n)] for i in range(n)]\n\n# Quadratic assignment problem\nm1 = gp.Model()\n\n# x[i,j] = 1 if facility i is assigned to location j\nx = m1.addVars(n, n, vtype=GRB.BINARY, name=\"x\")\n\n# Build objective function\nobj = gp.QuadExpr()\nfor i in range(n):\n    for j in range(n):\n        for k in range(n):\n            for l in range(n):\n                coeff = flow[i][k] * dist[j][l]\n                # Alternate signs\n                if (i + k) % 2 == 0:\n                    coeff = -coeff\n                obj.addTerms(coeff, x[i, j], x[k, l])\n\nm1.setObjective(obj, GRB.MINIMIZE)\n\n# Each facility is assigned to exactly one location\nfor i in range(n):\n    m1.addConstr(x.sum(i, \"*\") == 1, name=f\"assign_facility[{i}]\")\n\n# Each location is assigned exactly one facility\nfor j in range(n):\n    m1.addConstr(x.sum(\"*\", j) == 1, name=f\"assign_to_location[{j}]\")\n\n# Set parameters here\n# m.Params.ParameterName = value\nm1.optimize()\n\nn = 9\n\n# Quadratic assignment problem\nm2 = gp.Model()\n# Distance between locations\ndist = [[abs(j - k) + 1 for k in range(n)] for j in range(n)]\n\n# Flow/weight between facilities\nflow = [[(i + k + 1) * ((i - k) ** 2 + 1) for k in range(n)] for i in range(n)]\n\n# x[i,j] = 1 if facility i is assigned to location j\nx = m2.addVars(n, n, vtype=GRB.BINARY, name=\"x\")\n\n# Build objective function\nobj = gp.QuadExpr()\nfor i in range(n):\n    for j in range(n):\n        for k in range(n):\n            for l in range(n):\n                coeff = flow[i][k] * dist[j][l]\n                # Alternate signs\n                if (i + k) % 2 == 0:\n                    coeff = -coeff\n                obj.addTerms(coeff, x[i, j], x[k, l])\n\nm2.setObjective(obj, GRB.MINIMIZE)\n\n# Each facility is assigned to exactly one location\nfor i in range(n):\n    m2.addConstr(x.sum(i, \"*\") == 1, name=f\"assign_facility[{i}]\")\n\n# Each location is assigned exactly one facility\nfor j in range(n):\n    m2.addConstr(x.sum(\"*\", j) == 1, name=f\"assign_to_location[{j}]\")\n\n# Set parameters here\nm2.Params.PreQLinearize = 2\n\nm2.optimize()"}]}
{"meta": {"source_path": "/Users/sunyujun03/Desktop/ReLoop/gurobi-modeling-examples/optimization301/Modeling_Session_1/modeling1.ipynb", "kind": "ipynb", "title": "Modeling Session 1"}, "messages": [{"role": "system", "content": "You are an optimization engineer. Write correct and runnable Python code using gurobipy (Gurobi Python API). Be concise. Output only what is requested."}, {"role": "user", "content": "    Task: Reproduce the following Gurobi modeling example in Python using gurobipy.\n\n    Scenario description (from source):\n    # Modeling Session 1\nThis set of exercises are meant to cover many of the topics from Day 1, with callbacks from Opti 101, 201, 202 along the way. You can work along in this notebook, but if you really just want to see the solutions, those can also be found in the GitHub repo.\n\n## Building Trust in Optimization\n\n### Solution pools\n\nIn this section, we'll explore solution pools to build trust in a discrete model by\nsurfacing *multiple, near‑optimal* operating plans. We'll use the same storage + solar\ndispatch context from earlier (charging/discharging a battery, buying from the grid, meeting\ndemand), but we’ll ask Gurobi to return a *set* of high‑quality alternatives.\n\nGoal: Collect the top‑k solutions within a small optimality gap and compare them on\nkey features (objective, total grid energy, number of charge/discharge switches).\n\nNote that some of this (the problem, and the approaches) should seem familiar...\n\n    Requirements:\n    - Use gurobipy (Model, GRB, addVar/addConstr, etc.)\n    - Make the script runnable as a standalone Python file if possible.\n    - Keep the code faithful to the example.\n"}, {"role": "assistant", "content": "import pandas as pd\nimport numpy as np\nimport gurobipy as gp\nfrom gurobipy import GRB\n\nimport pandas as pd\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# Tiny instance (kept small so we can enumerate several pool solutions quickly)\nT = range(12)                        # time periods\nprice = [20,18,16,15,16,18,25,40,45,35,28,22]  # grid price €/MWh\ndemand = [5,5,5,5,6,6,7,7,7,6,6,5]  # MWh demand each period\n\neta_in, eta_out = 0.95, 0.95        # round-trip efficiency\ncap = 10.0                          # MWh battery capacity\npmax = 4.0                          # MW charge/discharge limit\ns0 = 2.0                            # initial state of charge\n\nm = gp.Model(\"storage_pool\")\n\n# Decision variables\nch = m.addVars(T, name=\"charge\", lb=0, ub=pmax)\ndis = m.addVars(T, name=\"discharge\", lb=0, ub=pmax)\ngrid = m.addVars(T, name=\"grid\", lb=0)\nsoc = m.addVars(T, name=\"soc\", lb=0, ub=cap)\n# on/off switching to discourage rapid toggling (makes model MIP)\ny_ch = m.addVars(T, vtype=GRB.BINARY, name=\"y_ch\")\ny_dis = m.addVars(T, vtype=GRB.BINARY, name=\"y_dis\")\n\n# Logic: can’t charge and discharge simultaneously\nm.addConstrs((          ?????           ), name=\"no_simul\")\nm.addConstrs((          ?????           ), name=\"charge_gate\")\nm.addConstrs((          ?????           ), name=\"discharge_gate\")\n\n# Energy balance vs demand\nm.addConstrs((          ?????           ), name=\"balance\")\n\n# State of charge dynamics\nfor t in T:\n    if t == 0:\n        m.addConstr(soc[t] == s0 + ch[t]*eta_in - dis[t]/eta_out, name=f\"soc_{t}\")\n    else:\n        m.addConstr(          ?????           , name=f\"soc_{t}\")\n\n# Mild cycling preference: penalize on/off changes to diversify plans\nswitches = gp.quicksum((          ?????           ) for t in T)\n\n# Cost: energy purchased from grid\ncost = gp.quicksum(          ?????           )\n\n# Multi-criteria via a single objective (lexico done elsewhere; here we pool around cost)\nm.setObjective(cost + 1e-3 * switches, GRB.MINIMIZE)\n\n# Ask for a pool of near‑optimal solutions\nm.setParam(GRB.Param.PoolSearchMode, ?????)  # systematic search for k‑best\nm.setParam(GRB.Param.PoolSolutions, ?????)  # keep up to 500\nm.setParam(GRB.Param.PoolGap, 0.?????)      # within 2% of best found\nm.optimize()\n\n# Collect solutions\nrows = []\nfor i in range(m.SolCount):\n    m.setParam(GRB.Param.SolutionNumber, i)\n    obj = m.PoolObjVal\n    total_grid = sum(grid[t].Xn for t in T)\n    total_switch = sum(y_ch[t].Xn + y_dis[t].Xn for t in T)\n    rows.append({\"obj\": obj, \"grid_MWh\": total_grid, \"switch_count\": total_switch})\n\nsols = pd.DataFrame(rows).sort_values(\"obj\").reset_index(drop=True)\n\nbest_obj = m.ObjVal\nsols[\"rel_diff_to_best_pct\"] = ((sols[\"obj\"] - best_obj) / abs(best_obj)* 100).round(6).astype(str) + \"%\"\nsols_unique = sols.drop_duplicates().reset_index(drop=True)\nsols_unique\n\nimport pandas as pd\nimport gurobipy as gp\nfrom gurobipy import GRB\n\nT = range(12)\nbase_price = [20,18,16,15,16,18,25,40,45,35,28,22]\nbase_demand = [5,5,5,5,6,6,7,7,7,6,6,5]\n\nscenarios = {\n    \"Base\": (base_price, base_demand),\n    \"HighPricePeak\": ([p*1.2 if 7<=t<=9 else p for t,p in enumerate(base_price)], base_demand),\n    \"EveningHeavyDemand\": (base_price, [d*1.2 if t>=7 else d for t,d in enumerate(base_demand)]),\n}\n\neta_in, eta_out = 0.95, 0.95\ncap, pmax, s0 = 10.0, 4.0, 2.0\n\ndef solve(price, demand):\n    m = gp.Model(\"storage_scen\")\n    ch = m.addVars(T, name=\"charge\", lb=0, ub=pmax)\n    dis = m.addVars(T, name=\"discharge\", lb=0, ub=pmax)\n    grid = m.addVars(T, name=\"grid\", lb=0)\n    soc = m.addVars(T, name=\"soc\", lb=0, ub=cap)\n\n    # LP version to keep focus on param changes\n    m.addConstrs((grid[t] + dis[t]*eta_out >= demand[t] + ch[t] for t in T), name=\"balance\")\n    for t in T:\n        if t == 0:\n            m.addConstr(soc[t] == s0 + ch[t]*eta_in - dis[t]/eta_out)\n        else:\n            m.addConstr(soc[t] == soc[t-1] + ch[t]*eta_in - dis[t]/eta_out)\n\n    cost = gp.quicksum(price[t]*grid[t] for t in T)\n    m.setObjective(cost, GRB.MINIMIZE)\n    m.setParam(\"OutputFlag\", 0)\n    m.optimize()\n\n    return float(cost.getValue()), float(soc[max(T)].X)\n\nrows = []\nfor name, (p, d) in scenarios.items():\n    total_cost, final_soc = solve(p, d)\n    rows.append({\"scenario\": name, \"total_cost\": round(total_cost,2), \"final_soc\": round(final_soc,2)})\n\npd.DataFrame(rows).sort_values(\"total_cost\")\n\nimport pandas as pd\nimport gurobipy as gp\nfrom gurobipy import GRB\n\nT = range(12)\nprice = [20,18,16,15,16,18,25,40,45,35,28,22]\ndemand = [5,5,5,5,6,6,7,7,7,6,6,5]\n\neta_in, eta_out = 0.95, 0.95\ncap, pmax, s0 = 10.0, 4.0, 2.0\n\n# Build LP (no binaries)\nm = gp.Model(\"storage_duals\")\nch = m.addVars(T, name=\"charge\", lb=0, ub=pmax)\ndis = m.addVars(T, name=\"discharge\", lb=0, ub=pmax)\ngrid = m.addVars(T, name=\"grid\", lb=0)\nsoc = m.addVars(T, name=\"soc\", lb=0, ub=cap)\n\nbalance = m.addConstrs((grid[t] + dis[t]*eta_out >= demand[t] + ch[t] for t in T), name=\"balance\")\nfor t in T:\n    if t == 0:\n        m.addConstr(soc[t] == s0 + ch[t]*eta_in - dis[t]/eta_out, name=f\"soc_{t}\")\n    else:\n        m.addConstr(soc[t] == soc[t-1] + ch[t]*eta_in - dis[t]/eta_out, name=f\"soc_{t}\")\n\ncost = gp.quicksum(price[t]*grid[t] for t in T)\nm.setObjective(cost, GRB.MINIMIZE)\nm.setParam(\"OutputFlag\", 0)\nm.optimize()\n\n# Read duals (Pi) and slacks\nrows = []\nfor t in T:\n    con = balance[t]\n    rows.append({\n        \"t\": t,\n        \"pi\": con.Pi,\n        \"slack\": con.Slack,\n    })\n\npi_df = pd.DataFrame(rows).sort_values(\"pi\", ascending=False)\nprint(\"Top periods by shadow price (higher pi => relaxing balance helps more):\")\ndisplay(pi_df.head(6))\n\n# Sensitivity check: bump demand at period with largest pi by +0.1 and compare objective change\nt_star = int(pi_df.iloc[0][\"t\"])\nbump = 0.1\n\ndef solve_with_demand(d):\n    m2 = gp.Model(\"storage_duals_copy\")\n    ch2 = m2.addVars(T, name=\"charge\", lb=0, ub=pmax)\n    dis2 = m2.addVars(T, name=\"discharge\", lb=0, ub=pmax)\n    grid2 = m2.addVars(T, name=\"grid\", lb=0)\n    soc2 = m2.addVars(T, name=\"soc\", lb=0, ub=cap)\n    bal2 = m2.addConstrs((grid2[t] + dis2[t]*eta_out >= d[t] + ch2[t] for t in T))\n    for t in T:\n        if t == 0:\n            m2.addConstr(soc2[t] == s0 + ch2[t]*eta_in - dis2[t]/eta_out)\n        else:\n            m2.addConstr(soc2[t] == soc2[t-1] + ch2[t]*eta_in - dis2[t]/eta_out)\n    cost2 = gp.quicksum(price[t]*grid2[t] for t in T)\n    m2.setObjective(cost2, GRB.MINIMIZE)\n    m2.setParam(\"OutputFlag\", 0)\n    m2.optimize()\n    return float(cost2.getValue())\n\nbase_obj = float(cost.getValue())\nd2 = demand.copy()\nd2[t_star] += bump\nnew_obj = solve_with_demand(d2)\n\napprox_change = pi_df.iloc[0][\"pi\"] * bump\nactual_change = new_obj - base_obj\n\nsummary = pd.DataFrame({\n    \"t*\":[t_star],\n    \"pi\":[pi_df.iloc[0][\"pi\"]],\n    \"bump\":[bump],\n    \"approx_obj_change (pi*bump)\":[approx_change],\n    \"actual_obj_change\":[actual_change],\n})\ndisplay(summary)\n \n# FYI explanation printout, commas only\nprint(\n    f\"\\nFYI,\\n\"\n    f\"- Period {t_star} had the highest shadow price (pi = {pi_df.iloc[0]['pi']:.1f}), meaning extra demand there is most expensive.\\n\"\n    f\"- The bump of {bump} MWh is small enough that the linear, pi-based prediction is valid.\\n\"\n    f\"- Predicted vs actual change ({approx_change:.2f} vs {actual_change:.2f}) are nearly identical, so we are within the linear sensitivity range.\\n\"\n    f\"- Slack = 0 confirms this constraint was binding.\\n\"\n    f\"- In plain terms, adding 0.1 MWh at hour {t_star} costs about €{approx_change:.1f}, exactly as the model’s dual value predicted.\"\n)\n\n# Install the optimods package\nimport numpy as np\n\nfrom gurobi_optimods.datasets import load_portfolio\nfrom gurobi_optimods.portfolio import MeanVariancePortfolio\n\nnp.set_printoptions(legacy='1.25')\n\ndata = load_portfolio()\ncov_matrix = data.cov()\nmu = data.mean()\n\n# Show the expected returns for our potential 'assets'\nmu\n\n# Show the covariance matrix\ncov_matrix\n\n# We can define this risk-aversion coefficient\ngamma = 20\n# Max positions K\nK = 3\n\n# Fill in the above info for expected returns and the covariance, respectively\nmvp = MeanVariancePortfolio(????, ????)\n\n# Put in gamma, max positions. If you want to see the logs, set verbose = True\nmp = mvp.efficient_portfolio(????, max_positions=????, verbose = False)\n\nprint(f\"The portfolio's expected return is {round(mp.ret,5)}\")\n\n# The portfolio's allocation:\nmp.x\n\n#### Now model it yourself\ngamma = 20\nl = 0.01\n# Create an empty optimization model\nm = gp.Model()\n\n# Add variables: x[i] denotes the proportion invested in stock i\n# 0 <= x[i] <= 1\nx = m.addMVar(len(???), lb=0, ub=1, name=\"x\")\nb = m.addMVar(len(???), vtype=gp.GRB.BINARY, name=\"b\")\n\n# Budget constraint: all investments sum up to 1\nm.addConstr(????, name=\"Budget_Constraint\")\n\n# Link the continuous x to the binary b\n# If x > 0 then b = 1 (also remember the bounds of x)\nm.addConstr(????, name=\"Indicator\")\n\n# Minimal position; see formula (2) above\nm.addConstr(????, name=\"Minimal_Position\")\n# Cardinality constraint: at most K positions\ncardinality_constr = m.addConstr(????, \"Cardinality\")\n\n# Define objective function: Maximize expected utility\nm.setObjective(\n    mu.to_numpy()    ????     cov_matrix.to_numpy()   ????   , gp.GRB.MAXIMIZE\n)\nm.optimize()\n\ns2 = pd.Series(x.X, index= mp.x.index)\ns1 = pd.Series(mp.x)\ndf = pd.concat([s2,s1], axis=1, ignore_index=True)\ndf.columns = ['OptiMod','Our Model']\ndf\n\ndata = load_portfolio()\ncov_matrix = data.cov()\nmu = data.mean()\n\n# Values for the model parameters:\nV = 0.0025  # Maximal admissible variance (sigma^2)\nl = 0.001  # Minimal position size\nc = 0.0001  # Fixed transaction costs\nf = 0.001 * np.ones(mu.shape)  # Variable transaction fees\n\n# Create an empty optimization model\nm = gp.Model()\n\n# Add variables: x[i] denotes the proportion invested in stock i\nx = m.addMVar(len(mu), lb=0, ub=1, name=\"x\")\n# Add variables: b[i]=1 if stock i is held, and b[i]=0 otherwise\nb = m.addMVar(len(mu), vtype=gp.GRB.BINARY, name=\"b\")\n# Upper bound on variance\nm.addConstr(     ????       , name=\"Variance\")\n# Force x to 0 if not traded; see formula (1) above\nm.addConstr(x <= b, name=\"Indicator\")\n# Minimal position; see formula (2) above\nm.addConstr(x >= l * b, name=\"Minimal_Position\")\n# Budget constraint: all investments, costs, and fees sum up to 1\nbudget_constr = m.addConstr(\n         ????           , name=\"Budget_Constraint\"\n)\n# Define objective: Maximize expected return\nm.setObjective(mu.to_numpy() ????  , gp.GRB.MAXIMIZE)\n\nm.optimize()\n\npd.Series(x.X)\n\nimport gurobipy as gp\nfrom gurobipy import GRB\nimport pandas as pd\nimport time\n\nmps_file = 'markshare_4_0.mps'\n\ndef solve_with_mipfocus(model_file = mps_file, mipfocus_value = 0, output_flag = 1, time_limit=60):\n    \"\"\"\n    Solve a model with a specific MIPFocus value and return performance metrics.\n    \n    Parameters:\n    -----------\n    model_file : str\n        Path to the .mps file\n    mipfocus_value : int\n        MIPFocus parameter value (0, 1, 2, or 3)\n    time_limit : float\n        Time limit in seconds\n    \n    Returns:\n    --------\n    dict : Dictionary containing performance metrics\n    \"\"\"\n    # Create environment and model\n    # This will make the name of a '*.log' file\n    log_file = f'mipfocus{mipfocus_value}.log'\n    env = gp.Env(params={\"LogFile\": log_file, \n                         \"OutputFlag\": output_flag, \n                         \"LogToConsole\": 0})  \n    model = gp.read(model_file, env=env)\n    \n    # Set parameters\n    model.setParam('MIPFocus', mipfocus_value)\n    model.setParam('TimeLimit', time_limit)\n    \n    print(f\"\\n{'='*80}\")\n    print(f\"Solving with MIPFocus = {mipfocus_value}\")\n    print(f\"{'='*80}\\n\")\n    \n    # Solve the model\n    model.optimize()\n    \n    # Collect metrics\n    metrics = {\n        'MIPFocus': mipfocus_value,\n        'Status': model.Status,\n        'StatusName': model.getAttr(GRB.Attr.Status),\n        'Runtime': model.Runtime,\n        'NodeCount': model.NodeCount,\n        'IterCount': model.IterCount,\n    }\n    \n    # Add solution-specific metrics if available\n    if model.SolCount > 0:\n        metrics['ObjVal'] = model.ObjVal\n        metrics['ObjBound'] = model.ObjBound\n        metrics['MIPGap'] = model.MIPGap\n        metrics['SolCount'] = model.SolCount\n    else:\n        metrics['ObjVal'] = None\n        metrics['ObjBound'] = model.ObjBound if hasattr(model, 'ObjBound') else None\n        metrics['MIPGap'] = None\n        metrics['SolCount'] = 0\n\n    \n    # Clean up\n    model.dispose()\n    env.dispose()\n    \n    return metrics\n\n# Solve with MIPFocus = 0\nresults_0 = solve_with_mipfocus(mipfocus_value=0)\n\nfor key, value in results_0.items():\n    if key != 'StatusName':\n        print(f\"{key:20s}: {value}\")\n\n# Solve with MIPFocus = 1\nresults_1 = solve_with_mipfocus(mipfocus_value=1)\n\nfor key, value in results_1.items():\n    if key != 'StatusName':\n        print(f\"{key:20s}: {value}\")\n\n# Solve with MIPFocus = 2\nresults_2 = solve_with_mipfocus(mipfocus_value=2)\n\nfor key, value in results_2.items():\n    if key != 'StatusName':\n        print(f\"{key:20s}: {value}\")\n\n# Solve with MIPFocus = 3\nresults_3 = solve_with_mipfocus(mipfocus_value=3)\n\nfor key, value in results_3.items():\n    if key != 'StatusName':\n        print(f\"{key:20s}: {value}\")\n\n# Create a comparison dataframe\ncomparison_df = pd.DataFrame([results_0, results_1, results_2, results_3])\ncomparison_df = comparison_df.drop('StatusName', axis=1)\ncomparison_df\n\nn = 9\n\n# Distance between locations\ndist = [[abs(j - k) + 1 for k in range(n)] for j in range(n)]\n\n# Flow/weight between facilities\nflow = [[(i + k + 1) * ((i - k) ** 2 + 1) for k in range(n)] for i in range(n)]\n\n# Quadratic assignment problem\nm1 = gp.Model()\n\n# x[i,j] = 1 if facility i is assigned to location j\nx = m1.addVars(n, n, vtype=GRB.BINARY, name=\"x\")\n\n# Build objective function\nobj = gp.QuadExpr()\nfor i in range(n):\n    for j in range(n):\n        for k in range(n):\n            for l in range(n):\n                coeff = flow[i][k] * dist[j][l]\n                # Alternate signs\n                if (i + k) % 2 == 0:\n                    coeff = -coeff\n                obj.addTerms(coeff, x[i, j], x[k, l])\n\nm1.setObjective(obj, GRB.MINIMIZE)\n\n# Each facility is assigned to exactly one location\nfor i in range(n):\n    m1.addConstr(x.sum(i, \"*\") == 1, name=f\"assign_facility[{i}]\")\n\n# Each location is assigned exactly one facility\nfor j in range(n):\n    m1.addConstr(x.sum(\"*\", j) == 1, name=f\"assign_to_location[{j}]\")\n\n# Set parameters here\n# m.Params.ParameterName = value\nm1.optimize()\n\nn = 9\n\n# Quadratic assignment problem\nm2 = gp.Model()\n# Distance between locations\ndist = [[abs(j - k) + 1 for k in range(n)] for j in range(n)]\n\n# Flow/weight between facilities\nflow = [[(i + k + 1) * ((i - k) ** 2 + 1) for k in range(n)] for i in range(n)]\n\n# x[i,j] = 1 if facility i is assigned to location j\nx = m2.addVars(n, n, vtype=GRB.BINARY, name=\"x\")\n\n# Build objective function\nobj = gp.QuadExpr()\nfor i in range(n):\n    for j in range(n):\n        for k in range(n):\n            for l in range(n):\n                coeff = flow[i][k] * dist[j][l]\n                # Alternate signs\n                if (i + k) % 2 == 0:\n                    coeff = -coeff\n                obj.addTerms(coeff, x[i, j], x[k, l])\n\nm2.setObjective(obj, GRB.MINIMIZE)\n\n# Each facility is assigned to exactly one location\nfor i in range(n):\n    m2.addConstr(x.sum(i, \"*\") == 1, name=f\"assign_facility[{i}]\")\n\n# Each location is assigned exactly one facility\nfor j in range(n):\n    m2.addConstr(x.sum(\"*\", j) == 1, name=f\"assign_to_location[{j}]\")\n\n# Set parameters here\nm2.Params.PreQLinearize = 2\n\nm2.optimize()"}]}
{"meta": {"source_path": "/Users/sunyujun03/Desktop/ReLoop/gurobi-modeling-examples/pooling/std_pooling.ipynb", "kind": "ipynb", "title": "Standard Pooling Problem"}, "messages": [{"role": "system", "content": "You are an optimization engineer. Write correct and runnable Python code using gurobipy (Gurobi Python API). Be concise. Output only what is requested."}, {"role": "user", "content": "    Task: Reproduce the following Gurobi modeling example in Python using gurobipy.\n\n    Scenario description (from source):\n    # Standard Pooling Problem\n\n## Objective and Prerequisites\n\nCompanies across numerous industries – including petrochemical refining, wastewater treatment, and mining – use mathematical optimization to solve the pooling problem. In this example, we’ll guide you through the process of building a mixed-integer quadratically-constrained programming (MIQCP) model of a pooling problem using the Gurobi Python API and show you how to generate an optimal solution to the problem with the Gurobi Optimizer.\n\nThis modeling example is at the advanced level, where we assume that you know Python and the Gurobi Python API and that you have advanced knowledge of building mathematical optimization models. Typically, the objective function and/or constraints of these examples are complex or require advanced features of the Gurobi Python API.\n\n**Download the Repository** <br /> \nYou can download the repository containing this and other examples by clicking [here](https://github.com/Gurobi/modeling-examples/archive/master.zip). \n\n---\n## Motivation\n\nThe pooling problem is a challenging problem in the petrochemical refining, wastewater treatment and mining industries. This problem can be regarded as a generalization of the minimum-cost flow problem and the blending problem. It is indeed important because of the significant savings it can generate, so it comes at no surprise that it has been studied extensively since Haverly pointed out the non-linear structure of this problem in 1978 [5].\n\n---\n## Problem Description\n\nThe Minimum-Cost Flow Problem (MCFP) seeks to find the cheapest way of sending a certain amount of flow from a set of source nodes to a set of target nodes, possibily via transshipment nodes⁠, in a directed capacitated network. The Blending Problem is a type of MCFP with only source and target nodes, where raw materials with different attribute qualities are blended together to create end products in such a way that their attribute qualities are within tolerances.\n\nThe Pooling Problem combines features of both problems, as flow streams from different sources are mixed at intermediate pools and blended again at the target nodes. The non-linearity is in fact the direct result of considering pools, as the quality of a given attribute at a pool —defined as the weighted average of the qualities of the incoming streams— is an unknown quantity and thus needs to be captured by a decision variable. We refer to this problem as the Standard Pooling Problem when the network can be represented by a tripartite graph, i.e. three disjoint sets of nodes such that no nodes within the same set are adjacent. In a nutshell, it can be stated as follows: Given a list of source nodes with raw materials containing known attribute qualities, what is the cheapest way of mixing these materials at intermediate pools so as to meet the demand and tolerances at multiple target nodes? (Gupte et al., 2017) [4]. Several different formulations for the Standard Pooling Problem and its extensions exist in the literature, which can be classified into two main categories: one that consists of flow and quality variables, and the other that uses flow proportions instead of quality variables. Both categories will be considered in this notebook.\n\n---\n## Problem Instance\n\nAs an illustrative example, we will solve the second Pooling Problem posed by Rehfeldt and Tisljar in 1997 and cited by Audet et al. in 2004:\n\n![Graph](rehfeldt_tisljar2_graph.png)\n\n![Table](rehfeldt_tisljar2_table.png)\n\nTo that end, let's declare the required data structures to represent this problem instance:\n\n---\n## Solution Approach\n\nMathematical programming is a declarative approach where the modeler formulates a mathematical optimization model that captures the key aspects of a complex decision problem. The Gurobi Optimizer solves such models using state-of-the-art mathematics and computer science.\n\nA mathematical optimization model has five components, namely:\n\n- Sets and indices.\n- Parameters.\n- Decision variables.\n- Objective function(s).\n- Constraints.\n\nA quadratic constraint that involves only products of disjoint pairs of variables is often called a bilinear constraint, and a model that contains bilinear constraints is often called a Bilinear Program. Bilinear constraints are a special case of non-convex quadratic constraints. This type of problems is typically solved using spatial Branch and Bound (sB&B). This algorithm explores the entire search space, so it provides a globally valid lower bound on the optimal objective value and —given enough time— it will find a globally optimal solution (subject to tolerances). The interested reader is referred to [references](#references) [3], [6] and [7].\n\nWe now present two alternative Bilinear Programs for the Standard Pooling Problem:\n\n### P-formulation (Concentration)\n\n#### Sets and Indices\n\n$G=(V,E)$: Directed graph.\n\n$i,j \\in V$: Set of nodes.\n\n$(i,j) \\in E \\subset  V \\times V$: Set of edges.\n\n$N(i)^+ = \\{j \\in V \\mid (i,j) \\in E \\}$: Set of successor nodes receiving outflow from node $i$.\n\n$N(j)^- = \\{i \\in V \\mid (i,j) \\in E \\}$: Set of predecessor nodes sending inflow to node $i$.\n\n$k \\in \\text{Attrs}$: Set of attributes.\n\n$s \\in \\text{Sources} \\subset V$: Set of source nodes, i.e. $N(s)^-= \\emptyset$.\n\n$t \\in \\text{Targets} \\subset V$: Set of target nodes, i.e. $N(t)^+= \\emptyset$.\n\n$p \\in \\text{Pools} = V \\setminus (\\text{Sources} \\cup \\text{Targets})$: Set of pools.\n\n#### Parameters\n\n$\\text{Cost}_s \\in \\mathbb{R}^+$: Cost of acquiring one unit of raw material at source node $s$.\n\n$\\text{Supply}_s \\in \\mathbb{R}^+$: Maximum number of units of raw material available at source node $s$.\n\n$\\text{Content}_{s,k} \\in \\mathbb{R}^+$: Content of attribute $k$ in raw material at source node $s$.\n\n$\\text{Price}_t \\in \\mathbb{R}^+$: Price for selling one unit of final blend at target node $t$.\n\n$\\text{Demand}_t \\in \\mathbb{R}^+$: Minimum number of units required of final blend at target node $t$.\n\n$\\text{Min_tol}_{t,k} \\in \\mathbb{R}^+$: Minimum tolerance for attribute $k$ in final blend at target node $t$.\n\n$\\text{Max_tol}_{t,k} \\in \\mathbb{R}^+$: Maximum tolerance for attribute $k$ in final blend at target node $t$.\n\n$\\text{Cap}_p \\in \\mathbb{R}^+$: Maximum Capacity to store intermediate blend at pool $p$.\n\n$\\text{UB}_{i,j}\\in \\mathbb{R}^+$: Maximum flow from node $i$ to node $j$.\n\n#### Decision Variables\n\n$\\text{flow}_{i,j} \\in [0, \\text{UB}_{i,j}]$: Flow from node $i$ to node $j$.\n\n$\\text{quality}_{p,k} \\in \\mathbb{R}^+$: Concentration of attribute $k$ at pool $p$.\n\n#### Objective Function\n\n- **Profit**: Maximize total profits.\n\n\\begin{equation}\n\\text{Max} \\quad Z = \\sum_{t \\in \\text{Targets}}{\\sum_{i \\in N(t)^-}{\\text{Price}_t \\cdot \\text{flow}_{i,t}}} - \\sum_{s \\in \\text{Sources}}{\\sum_{j \\in N(s)^+}{\\text{Cost}_s \\cdot \\text{flow}_{s,j}}}\n\\tag{0}\n\\end{equation}\n\n#### Constraints\n\n- **Flow conservation**: Total inflow of pool $p$ must be equal to its total outflow (nothing is stored in them).\n\n\\begin{equation}\n\\sum_{t \\in N(p)^+}{\\text{flow}_{p,t}} - \\sum_{s \\in N(p)^-}{\\text{flow}_{s,p}} = 0 \\quad \\forall p \\in \\text{Pools}\n\\tag{1}\n\\end{equation}\n\n- **Source capacity**: Total outflow of source $s$ cannot exceed its capacity.\n\n\\begin{equation}\n\\sum_{j \\in N(s)^+}{\\text{flow}_{s,j}} \\leq \\text{Supply}_s \\quad \\forall s \\in \\text{Sources}\n\\tag{2}\n\\end{equation}\n\n- **Pool capacity**: Total outflow of pool $p$ cannot exceed its capacity.\n\n\\begin{equation}\n\\sum_{t \\in N(p)^+}{\\text{flow}_{p,t}} \\leq \\text{Cap}_p \\quad \\forall p \\in \\text{Pools}\n\\tag{3}\n\\end{equation}\n\n- **Target demand**: Total inflow of target $t$ must at least meet its minimum demand.\n\n\\begin{equation}\n\\sum_{i \\in N(t)^-}{\\text{flow}_{i,t}} \\geq \\text{Demand}_t \\quad \\forall t \\in \\text{Targets}\n\\tag{4}\n\\end{equation}\n\n- **Pool concentration**: Concentration of attribute $k$ at pool $p$ is expressed as the weighted average (linear blending) of the concentrations associated to the incoming flows (notice the bilinear terms on the right-hand side).\n\n\\begin{equation}\n\\sum_{s \\in N(p)^-}{\\text{Content}_{s,k} \\cdot \\text{flow}_{s,p}} = \\text{quality}_{p,k} \\cdot \\sum_{t \\in N(p)^+}{\\text{flow}_{p,t}} \\quad \\forall (p,k) \\in \\text{Pools} \\times \\text{Attrs}\n\\tag{5}\n\\end{equation}\n\n- **Target tolerances**: Concentration of attribute $k$ at target $t$ is also the result of linear blending, and must be within tolerances (notice the bilinear terms on the second expression of the left-hand side).\n\n\\begin{equation}\n\\sum_{s \\in N(t)^- \\cap \\text{Sources}}{\\text{Content}_{s,k} \\cdot \\text{flow}_{s,t}}+ \\sum_{p \\in N(t)^- \\cap \\text{Pools}}{\\text{quality}_{p,k} \\cdot \\text{flow}_{p,t}} \\geq \\text{Min_tol}_{t,k} \\cdot \\sum_{i \\in N(t)^-}{\\text{flow}_{i,t}} \\quad \\forall (t,k) \\in \\text{Targets} \\times \\text{Attrs}\n\\tag{6.1}\n\\end{equation}\n\n\\begin{equation}\n\\sum_{s \\in N(t)^- \\cap \\text{Sources}}{\\text{Content}_{s,k} \\cdot \\text{flow}_{s,t}}+ \\sum_{p \\in N(t)^- \\cap \\text{Pools}}{\\text{quality}_{p,k} \\cdot \\text{flow}_{p,t}} \\leq \\text{Max_tol}_{t,k} \\cdot \\sum_{i \\in N(t)^-}{\\text{flow}_{i,t}} \\quad \\forall (t,k) \\in \\text{Targets} \\times \\text{Attrs}\n\\tag{6.2}\n\\end{equation}\n\nThe number of bilinear terms in this formulation is proportional to the number of attributes. An alternative formulation relies on decision variables that represent fractions of flow instead of concentrations, so that the bilinear terms are no longer associated to the number of attributes. Two types of decision variables may be used:\n\n- fraction of total inflow at pool $p$, coming from source $s$.\n- fraction of total outflow at pool $p$, going to terminal $t$.\n\nA model based on the first option is now presented:\n\n### Q-formulation (Proportion)\n\n#### Decision Variables\n\n$\\text{flow}_{i,j} \\in [0, \\text{UB}_{i,j}]$: Flow from node $i$ to node $j$.\n\n$\\text{prop}_{s,p} \\in \\mathbb{R}^+$: fraction of total inflow at pool $p$, coming from source $s$.\n\n**Note:** The $\\text{flow}$ variables from sources to pools are replaced by the $\\text{prop}$ variables.\n\n#### Objective Function\n\n- **Profit**: Maximize total profits (notice the bilinear terms on the second expression).\n\n\\begin{equation}\n\\text{Max} \\quad Z = \\sum_{t \\in \\text{Targets}}{\\sum_{i \\in N(t)^-}{\\text{Price}_t \\cdot \\text{flow}_{i,t}}} - \\sum_{s \\in \\text{Sources}}{\\text{cost}_s \\cdot \\left( \\sum_{t \\in N(s)^+ \\cap \\text{Targets}}{\\text{flow}_{s,t}} + \\sum_{p \\in N(s)^+ \\cap \\text{Pools}}{\\text{prop}_{s,p} \\cdot \\sum_{t \\in N(p)^+}{\\text{flow}_{p,t}}} \\right) }\n\\tag{0}\n\\end{equation}\n\n#### Constraints\n\n- **Source capacity**: Total outflow of source $s$ cannot exceed its capacity (notice the bilinear terms on the first expression of the left-hand side).\n\n\\begin{equation}\n\\sum_{p \\in N(s)^+ \\cap \\text{Pools}}{\\text{prop}_{s,p} \\cdot \\sum_{t \\in N(p)^+}{\\text{flow}_{p,t}}} + \\sum_{t \\in N(s)^+ \\cap \\text{Targets}}{\\text{flow}_{s,t}} \\leq \\text{Supply}_s \\quad \\forall s \\in \\text{Sources}\n\\tag{1}\n\\end{equation}\n\n- **Pool capacity**: Total outflow of pool $p$ cannot exceed its capacity.\n\n\\begin{equation}\n\\sum_{t \\in N(p)^+}{\\text{flow}_{p,t}} \\leq \\text{Cap}_p \\quad \\forall p \\in \\text{Pools}\n\\tag{2}\n\\end{equation}\n\n- **Target demand**: Total inflow of target $t$ must at least meet its minimum demand.\n\n\\begin{equation}\n\\sum_{i \\in N(t)^-}{\\text{flow}_{i,t}} \\geq \\text{Demand}_t \\quad \\forall t \\in \\text{Targets}\n\\tag{3}\n\\end{equation}\n\n- **Pool inflow**: The sum of the contributions of all incoming sources to pool $p$ must equal one.\n\n\\begin{equation}\n\\sum_{s \\in N(p)^-}{\\text{prop}_{s,p}} = 1 \\quad \\forall p \\in \\text{Pools}\n\\tag{4}\n\\end{equation}\n\n- **Target tolerances**: Concentration of attribute $k$ at target $t$ is also the result of linear blending, and must be within tolerances (notice the bilinear terms on the second expression of the left-hand side).\n\n\\begin{equation}\n\\sum_{s \\in N(t)^- \\cap \\text{Sources}}{\\text{Content}_{s,k} \\cdot \\text{flow}_{s,t}} + \\sum_{p \\in N(t)^- \\cap \\text{Pools}}{\\text{flow}_{p,t} \\cdot \\sum_{s \\in N(p)^-}{\\text{content}_{s,k} \\cdot \\text{prop}_{s,p}}}\n\\geq \\text{Min_tol}_{t,k} \\cdot \\sum_{i \\in N(t)^-}{\\text{flow}_{i,t}} \\\\\n\\forall (t,k) \\in \\text{Targets} \\times \\text{Attrs}\n\\tag{5.1}\n\\end{equation}\n\n\\begin{equation}\n\\sum_{s \\in N(t)^- \\cap \\text{Sources}}{\\text{Content}_{s,k} \\cdot \\text{flow}_{s,t}} + \\sum_{p \\in N(t)^- \\cap \\text{Pools}}{\\text{flow}_{p,t} \\cdot \\sum_{s \\in N(p)^-}{\\text{content}_{s,k} \\cdot \\text{prop}_{s,p}}}\n\\leq \\text{Max_tol}_{t,k} \\cdot \\sum_{i \\in N(t)^-}{\\text{flow}_{i,t}} \\\\\n\\forall (t,k) \\in \\text{Targets} \\times \\text{Attrs}\n\\tag{5.2}\n\\end{equation}\n\nOne drawback is that if some of the source-to-pool edges have flow capacity, we need to define additional constraints instead of just specifying upper bounds on the associated decision variables. Such constraints can be defined with bilinear terms as follows:\n\n- **Flow limit**: Flow from source $s$ to pool $p$ cannot exceed the installed capacity (notice the bilinear terms on the left-hand side). In the P-formulation, declaring this is as easy as setting the upper bound of the associated $\\text{flow}$ variable. However, this variable no longer exists in the Q-formulation so we need to model the capacity as a constraint.  \n\n\\begin{equation}\n\\text{prop}_{s,p} \\cdot \\sum_{t \\in N(p)^+}{\\text{flow}_{p,t}} \\leq \\text{UB}_{s,p} \\quad \\forall (i,j) \\in E \\cap \\left( \\text{Sources} \\times \\text{Pools} \\right) \\mid \\text{UB}_{i,j} < \\infty\n\\tag{6}\n\\end{equation}\n\n---\n## Python Implementation\n\nSolving Bilinear Programs with Gurobi is as easy as configuring the global parameter `nonConvex`. When setting this parameter to a value of 2, non-convex quadratic problems are solved by means of translating them into bilinear form and applying sB&B. We will first deploy the P-formulation model, and then compare it with the Q-formulation model:\n\n### P-formulation (Concentration)\n\nThe P-formulation for this instance has:\n\n- 24 decision variables.\n- 10 linear constraints.\n- 20 bilinear constraints.\n- a linear objective function.\n\nAs can be seen, we observe a gap of 103.23% after reaching the time limit of five minutes (at this point, the incumbent solution induces a total profit of 411,530.70 USD). In fact, even after 20 minutes the solver does not make much progress in closing the gap.\n\n### Q-Formulation (proportion)\n\nLet's now see how the q-formulation model performs:\n\nThe Q-formulation for this instance has:\n\n- 16 decision variables.\n- 7 linear constraints.\n- 15 bilinear constraints.\n- a bilinear objective function.\n\nNotice it has fewer decision variables and also fewer bilinear constraints. Now Gurobi was able to find the optimal solution of 439,182.59 USD in less than one second.\n\n---\n## Analysis\n\nLet's see the optimal flows found:\n\n### Flow from Sources to Targets\nThe following table determines the flows from source nodes to target nodes. For example, from source node s2 to target node t1 there is a flow of 966.7$\\times 10^{2}$ bbl.\n\n    Requirements:\n    - Use gurobipy (Model, GRB, addVar/addConstr, etc.)\n    - Make the script runnable as a standalone Python file if possible.\n    - Keep the code faithful to the example.\n"}, {"role": "assistant", "content": "import numpy as np\nimport pandas as pd\nfrom itertools import product\n\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# tested with Gurobi v9.1.0 and Python 3.7.0\n\nattrs = {'den', 'bnz', 'roz', 'moz'}\n\nsources, cost, supply, content = gp.multidict({\n    \"s1\": [49.2, 6097.56, {'den': 0.82, 'bnz':3, 'roz':99.2,'moz':90.5}],\n    \"s2\": [62.0, 16129, {'den': 0.62, 'bnz':0, 'roz':87.9,'moz':83.5}],\n    \"s3\": [300.0, 500, {'den': 0.75, 'bnz':0, 'roz':114,'moz':98.7}]\n})\n\ntargets, price, demand, min_tol, max_tol = gp.multidict({\n    \"t1\": [190, 500, {'den': 0.74, 'roz':95,'moz':85}, {'den': 0.79}],\n    \"t2\": [230, 500, {'den': 0.74, 'roz':96,'moz':88}, {'den': 0.79, 'bnz':0.9}],\n    \"t3\": [150, 500, {'den': 0.74, 'roz':91}, {'den': 0.79}]\n})\n\npools, cap = gp.multidict({\n    \"p1\": 1250,\n    \"p2\": 1750\n})\n\n# The function `product` deploys the Cartesian product of elements in sets A and B\ns2p = set(product(sources, pools))\np2t = set(product(pools, targets))\ns2t = {(\"s1\", \"t2\"),\n       (\"s2\", \"t1\"),\n       (\"s2\", \"t3\"),\n       (\"s3\", \"t1\")}\n\np_pooling = gp.Model(\"Pooling\")\n\n# Set global parameters\np_pooling.params.nonConvex = 2\np_pooling.params.timelimit = 5*60 # time limit of 5 minutes\n\n# Declare decision variables\n\n# flow\nik = p_pooling.addVars(s2t, name=\"Source2Target\")\nij = p_pooling.addVars(s2p, name=\"Source2Pool\")\njk = p_pooling.addVars(p2t, name=\"Pool2Target\")\nik[\"s1\",\"t2\"].ub = 750\nik[\"s3\",\"t1\"].ub = 750\n# quality\nprop = p_pooling.addVars(pools, attrs, name=\"Proportion\")\n\n# Deploy constraint sets\n\n# 1. Flow conservation\np_pooling.addConstrs((ij.sum('*',j) == jk.sum(j,'*') for j in pools),\n                     name=\"Flow_conservation\")\n# 2. Source capacity\np_pooling.addConstrs((ij.sum(i,'*') + ik.sum(i,'*') <= supply[i] for i in sources),\n                     name=\"Source_capacity\")\n# 3. Pool capacity\np_pooling.addConstrs((jk.sum(j,'*') <= cap[j] for j in pools),\n                     name=\"Pool_capacity\")\n# 4. Target demand\np_pooling.addConstrs((ik.sum('*',k) + jk.sum('*',k) >= demand[k] for k in targets),\n                     name=\"Target_demand\")\n# 5. Pool concentration\np_pooling.addConstrs((gp.quicksum(content[i][attr]*ij[i,j]\n                               for i in sources if (i,j) in s2p)\n                      == prop[j,attr]*jk.sum(j,'*') for j in pools for attr in attrs),\n                     name=\"Pool_concentration\")\n# 6.1 Target (min) tolerances\np_pooling.addConstrs((gp.quicksum(content[i][attr]*ik[i,k]\n                               for i in sources if (i,k) in s2t)\n                      + gp.quicksum(prop[j,attr]*jk[j,k]\n                                 for j in pools if (j,k) in p2t)\n                      >= min_tol[k][attr]*(ik.sum('*',k) + jk.sum('*',k))\n                      for k in targets for attr in min_tol[k].keys()),\n                     name=\"Target_min_tolerances\")\n# 6.2 Target (max) tolerances\np_pooling.addConstrs((gp.quicksum(content[i][attr]*ik[i,k]\n                               for i in sources if (i,k) in s2t)\n                      + gp.quicksum(prop[j,attr]*jk[j,k]\n                                 for j in pools if (j,k) in p2t)\n                      <= max_tol[k][attr]*(ik.sum('*',k) + jk.sum('*',k))\n                      for k in targets for attr in max_tol[k].keys()),\n                     name=\"Target_max_tolerances\")\n\n# Deploy Objective Function\n\n# 0. Total profit\nobj = gp.quicksum(price[k]*(ik.sum('*',k) + jk.sum('*',k))\n               for k in targets) \\\n- gp.quicksum(cost[i]*(ij.sum(i,'*') + ik.sum(i,'*'))\n           for i in sources)\np_pooling.setObjective(obj, GRB.MAXIMIZE)\n\n# Find the optimal solution\np_pooling.optimize()\n\nq_pooling = gp.Model(\"Pooling\")\n\n# Set global parameters\nq_pooling.params.nonConvex = 2\nq_pooling.params.timelimit = 5*60\n\n# Declare decision variables\n\n# flow\nik = q_pooling.addVars(s2t, name=\"Source2Target\")\njk = q_pooling.addVars(p2t, name=\"Pool2Target\")\nik[\"s1\",\"t2\"].ub = 750\nik[\"s3\",\"t1\"].ub = 750\n# proportion\np_ij = q_pooling.addVars(s2p, ub=1.0, name=\"Prop_Source2Pool\")\n\n# Deploy constraint sets\n\n# 1. Source capacity\nq_pooling.addConstrs((gp.quicksum(p_ij[i,j]*jk.sum(j,'*')\n                               for j in pools if (i,j) in s2p)\n                      + ik.sum(i,'*') <= supply[i] for i in sources),\n                     name=\"Source_capacity\")\n# 2. Pool capacity\nq_pooling.addConstrs((jk.sum(j,'*') <= cap[j] for j in pools),\n                     name=\"Pool_capacity\")\n# 3. Target demand\nq_pooling.addConstrs((ik.sum('*',k) + jk.sum('*',k) >= demand[k] for k in targets),\n                     name=\"Target_demand\")\n# 4. Pool inflow\nq_pooling.addConstrs((p_ij.sum('*',j) == 1 for j in pools),\n                     name=\"Pool_inflow\")\n# 5.1 Target (min) tolerances\nq_pooling.addConstrs((gp.quicksum(content[i][attr]*ik[i,k]\n                               for i in sources if (i,k) in s2t)\n                      + gp.quicksum(content[i][attr]*p_ij[i,j]*jk[j,k]\n                                 for (i,j) in s2p if (j,k) in p2t)\n                      >= min_tol[k][attr]*(ik.sum('*',k) + jk.sum('*',k))\n                      for k in targets for attr in min_tol[k].keys()),\n                     name=\"Target_min_tolerances\")\n# 5.2 Target (max) tolerances\nq_pooling.addConstrs((gp.quicksum(content[i][attr]*ik[i,k]\n                               for i in sources if (i,k) in s2t)\n                      + gp.quicksum(content[i][attr]*p_ij[i,j]*jk[j,k]\n                                 for (i,j) in s2p if (j,k) in p2t)\n                      <= max_tol[k][attr]*(ik.sum('*',k) + jk.sum('*',k))\n                      for k in targets for attr in max_tol[k].keys()),\n                     name=\"Target_max_tolerances\")\n\n# Deploy Objective Function\n\n# 0. Total profit\nobj = gp.quicksum(price[k]*(ik.sum('*',k) + jk.sum('*',k))\n               for k in targets) \\\n- gp.quicksum(cost[i]*(gp.quicksum(p_ij[i,j]*jk.sum(j,'*')\n                             for j in pools if (i,j) in s2p)\n                    + ik.sum(i,'*'))\n           for i in sources)\nq_pooling.setObjective(obj, GRB.MAXIMIZE)\n\n# Find the optimal solution\nq_pooling.optimize()\n\nrows = sources.copy()\ncolumns = targets.copy()\ns2t_plan = pd.DataFrame(columns=columns, index=rows, data=0.0)\n\nfor source, target in ik.keys():\n    if (abs(ik[source, target].x) > 1e-6):\n        s2t_plan.loc[source, target] = np.round(ik[source, target].x, 1)\ns2t_plan\n\nrows = pools.copy()\ncolumns = targets.copy()\np2t_plan = pd.DataFrame(columns=columns, index=rows, data=0.0)\n\nfor pool, target in jk.keys():\n    if (abs(jk[pool, target].x) > 1e-6):\n        p2t_plan.loc[pool, target] = np.round(jk[pool, target].x, 1)\np2t_plan\n\nrows = sources.copy()\ncolumns = pools.copy()\ns2p_plan = pd.DataFrame(columns=columns, index=rows, data=0.0)\n\nfor source, pool in p_ij.keys():\n    if (abs(p_ij[source, pool].x) > 1e-6):\n        flow = p_ij[source, pool].x * p2t_plan.loc[pool,:].sum()\n        s2p_plan.loc[source, pool] = np.round(flow, 1)\ns2p_plan"}]}
{"meta": {"source_path": "/Users/sunyujun03/Desktop/ReLoop/gurobi-modeling-examples/constraint_optimization/constraint_optimization.ipynb", "kind": "ipynb", "title": "Constraint Optimization"}, "messages": [{"role": "system", "content": "You are an optimization engineer. Write correct and runnable Python code using gurobipy (Gurobi Python API). Be concise. Output only what is requested."}, {"role": "user", "content": "    Task: Reproduce the following Gurobi modeling example in Python using gurobipy.\n\n    Scenario description (from source):\n    # Constraint Optimization\n\n## Objective and Prerequisites\n\nIf you are looking to improve your modeling skills, then try this tricky constraint optimization problem. We’ll show you how to model this problem as a linear programming problem using the Gurobi Python API and solve it using the Gurobi Optimizer.\n\nThis model is example 18 from the fifth edition of Model Building in Mathematical Programming by H. Paul Williams on pages 273 and 328-330.\n\nThis modeling example is at the advanced level, where we assume that you know Python and the Gurobi Python API and that you have advanced knowledge of building mathematical optimization models. Typically, the objective function and/or constraints of these examples are complex or require advanced features of the Gurobi Python API.\n\n**Download the Repository** <br /> \nYou can download the repository containing this and other examples by clicking [here](https://github.com/Gurobi/modeling-examples/archive/master.zip). \n\n---\n## Problem Description\n\nIn an integer programming model, the following constraint occurs:\n\n$$\n9x_{1} + 13x_{2} -14x_{3} + 17x_{4} + 13x_{5} - 19x_{6} + 23x_{7} + 21x_{8} \\leq 37\n$$\n\nAll the decision variables in the constraint are binary, and the objective is to find another constraint involving the same binary variables that is logically equivalent to the original constraint, but that has the smallest possible absolute value of the right-hand side (RHS).\n\nIt is well established in the theory of  integer programming that the ability to efficiently solve an  integer programming problem depends on how \"close\" the linear programming relaxation is to the convex hull of all the integer solutions of the \ninteger programming problem. A linear programming relaxation is \"tight\" when this formulation is \"close\" to the convex hull of all the integer solutions. We say that an equivalent constraint with respect to an original constraint is \"tighter\" whenever the equivalent constraint has the same integer solutions as the original one, but has removed some fractional feasible solutions of the original one. These ideas are illustrated in the following figure.\n\n![OptimizedConstraint](OptimizedConstraint.PNG)\n\nThe original constraint in the figure is determined by the line AB and the \"tighter\" equivalent constraint is defined by the line CD. Notice that the equivalent constraint has the same set of integer solutions and has removed fractional feasible solutions of the original constraint.\n\n---\n## Model Formulation\n\nA procedure for simplifying a single 0–1 constraint has been described by Bradley et al. (1974). We adopt their procedure of using a linear programming model. It is convenient to consider the constraint in a standard form with positive coefficients in descending order of magnitude. This can be achieved by the transformation:\n\n$$\ny_{1} = x_{7}, y_{2} = x_{8}, y_{3} = 1 - x_{6}, y_{4} = x_{4},\n$$\n\n$$\ny_{5} = 1 - x_{3}, y_{6} = x_{5}, y_{7} = x_{2}, y_{8} = x_{1}.\n$$\n\nThe resulting equivalent constraint is\n\n$$\n23y_{1} + 21y_{2} + 19y_{3} + 17y_{4} + 14y_{5} + 13y_{6} + 13y_{7} + 9y_{8} \\leq 70.\n$$\n\nAll inequalities of the form $\\sum_{i=1}^{8} b_{i}*y_{i} \\leq b_{0} $ equivalent to the constraint to be optimized are characterized by a set of inequalities of a linear programming model defined in terms of the decision variables $b_{i}$. Observe that the variables $b_{i}$ are the coefficients of the transformed constraint.\n\nIn order to capture the total logical import of the original constraint, we search for subsets of the indices known as *roofs* and *ceilings*. Ceilings are ‘maximal’ subsets of the indices of the variables for which the sum of the corresponding coefficients does not exceed the right-hand side coefficient. Such a subset is maximal in the sense that no subset properly containing it, or to the left in the implied lexicographical ordering, can also be a ceiling. For example, the subset {1, 2, 4, 8} is a ceiling, $23 +21 + 17 + 9 \\leq 70$, but any subset properly containing it (e.g. {1, 2, 4, 7, 8}) or to the ‘left’ of it (e.g. {1, 2, 4, 7}) is not a ceiling. Roofs are ‘minimal’ subsets of the indices for which the sum of the corresponding coefficients exceeds the right-hand side coefficient. Such a subset is ‘minimal’ in the same sense as a subset is ‘maximal’. For example {2, 3, 4, 5} is a roof, \n$21 +19+ 17 + 14 > 70 $ ,\nbut any subset properly contained in it (e.g. {3, 4, 5}) or to the ‘right’ of it (e.g.\n{2, 3, 4, 6}) is not a roof. See the details about how these constraints are derived in Bradley et al. (1974).\n\nTherefore, all inequalities of the form $\\sum_{i=1}^{8} b_{i}*y_{i} \\leq b_{0} $ equivalent to the constraint to be optimized are characterized by the following constraints.\n\n**Ceiling constraints**: <br />\n\n$$\n\\{1,2,3 \\}: b_{1} + b_{2} + b_{3} \\leq b_{0}\n$$\n\n$$\n\\{1,2,4,8 \\}: b_{1} + b_{2} + b_{4} + b_{8}  \\leq b_{0}\n$$\n\n$$\n\\{1,2,6,7 \\}: b_{1} + b_{2} + b_{6} + b_{7}  \\leq b_{0}\n$$\n\n$$\n\\{1,3,5,6 \\}: b_{1} + b_{3} + b_{5} + b_{6}  \\leq b_{0}\n$$\n\n$$\n\\{2,3,4,6 \\}: b_{2} + b_{3} + b_{4} + b_{6}  \\leq b_{0}\n$$\n\n$$\n\\{2,5,6,7,8 \\}: b_{2} + b_{5} + b_{6} + b_{7} + b_{8} \\leq b_{0}\n$$\n\n**Roof constraints**: <br />\n\n$$\n\\{1,2,3,8 \\}: b_{1} + b_{2} + b_{3} + b_{8} \\geq b_{0} + 1\n$$\n\n$$\n\\{1,2,5,7 \\}: b_{1} + b_{2} + b_{5} + b_{7}  \\geq b_{0} + 1\n$$\n\n$$\n\\{1,3,4,7 \\}: b_{1} + b_{3} + b_{4} + b_{7} \\geq b_{0} + 1\n$$\n\n$$\n\\{1,5,6,7,8 \\}: b_{1} + b_{5} + b_{6} + b_{7} + b_{8} \\geq b_{0} + 1\n$$\n\n$$\n\\{2,3,4,5 \\}: b_{2} + b_{3} + b_{4} + b_{5} \\geq b_{0} + 1\n$$\n\n$$\n\\{3,4,6,7,8 \\}: b_{3} + b_{4} + b_{6} + b_{7} + b_{8} \\geq b_{0} + 1\n$$\n\n$$\n\\text{Decreasing value:} \\quad b_{i} \\geq b_{i+1} \\quad \\forall i=1..7\n$$\n\n$$\n\\text{Non-negativity:} \\quad b_{i} \\geq 0 \\quad \\forall i=0,1..7\n$$\n\nThe objective is to minimize the RHS of the original constraint.\n$$\n\\text{Objective function:} \\quad \\text{Min} \\;\\; (b_{0} - b_{3} - b_{5} )\n$$\n\n---\n## Python Implementation\n\nWe import the Gurobi Python Module.\n\n    Requirements:\n    - Use gurobipy (Model, GRB, addVar/addConstr, etc.)\n    - Make the script runnable as a standalone Python file if possible.\n    - Keep the code faithful to the example.\n"}, {"role": "assistant", "content": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# tested with Python 3.11 & Gurobi 11.0\n\n# list of indices of variables b[i]\n\nindices = [*range(9)]\n\nmodel = gp.Model('ConstraintOptimization')\n\n# Variables b[i]\nb = model.addVars(indices, name=\"b\")\n\n# Constraint {1, 2, 3}:\n\nC123 = model.addConstr( b[1] + b[2] + b[3] <= b[0] , name='C123')\n\n# Constraint {1, 2, 4, 8}}:\n\nC1248 = model.addConstr( b[1] + b[2] + b[4] + b[8] <= b[0] , name='C1248')\n\n# Constraint {1, 2, 6, 7}:\n\nC1267 = model.addConstr( b[1] + b[2] + b[6] + b[7] <= b[0] , name='C1267')\n\n# Constraint {1, 3, 5, 6}:\n\nC1356 = model.addConstr( b[1] + b[3] + b[5] + b[6] <= b[0] , name='C1356')\n\n# Constraint {2, 3, 4, 6}:\n\nC2346 = model.addConstr( b[2] + b[3] + b[4] + b[6] <= b[0] , name='C2346')\n\n# Constraint {2, 5, 6, 7, 8}:\n\nC25678 = model.addConstr( b[2] + b[5] + b[6] + b[7] + b[8] <= b[0] , name='C25678')\n\n# Constraint {1, 2, 3, 8}:\n\nR1238 = model.addConstr( b[1] + b[2] + b[3] + b[8] >= b[0] + 1 , name='R1238')\n\n# Constraint {1, 2, 5, 7}:\n\nR1257 = model.addConstr( b[1] + b[2] + b[5] + b[7] >= b[0] + 1 , name='R1257')\n\n# Constraint {1, 3, 4, 7}:\n\nR1347 = model.addConstr( b[1] + b[3] + b[4] + b[7] >= b[0] + 1 , name='R1347')\n\n# Constraint {1, 5, 6, 7, 8}:\n\nR15678 = model.addConstr( b[1] + b[5] + b[6] + b[7] + b[8] >= b[0] + 1 , name='R15678')\n\n# Constraint {2, 3, 4, 5}:\n\nR2345 = model.addConstr( b[2] + b[3] + b[4] + b[5] >= b[0] + 1 , name='R2345')\n\n# Constraint {3, 4, 6, 7, 8}:\n\nR34678 = model.addConstr( b[3] + b[4] + b[6] + b[7] + b[8] >= b[0] + 1 , name='R34678')\n\n# Decreasing value of coefficients\n\nDV1_2 = model.addConstr( b[1] >= b[2] , name='DV1_2')\nDV2_3 = model.addConstr( b[2] >= b[3] , name='DV2_3')\nDV3_4 = model.addConstr( b[3] >= b[4] , name='DV3_4')\nDV4_5 = model.addConstr( b[4] >= b[5] , name='DV4_5')\nDV5_6 = model.addConstr( b[5] >= b[6] , name='DV5_6')\nDV6_7 = model.addConstr( b[6] >= b[7] , name='DV6_7')\nDV7_8 = model.addConstr( b[7] >= b[8] , name='DV7_8')\n\n# Objective function\n\nmodel.setObjective(b[0] -b[3] -b[5] )\n\n# Verify model formulation\n\nmodel.write('OptimizeConstraint.lp')\n\n# Run optimization engine\n\nmodel.optimize()\n\n# Output report\n\n\n# Optimized values of the coefficients resepect to the original variables x.\n\na = {}\n\na[0] = b[0].x - b[3].x - b[5].x\na[1] = b[8].x\na[2] = b[7].x\na[3] = -b[5].x\na[4] = b[4].x\na[5] = b[6].x\na[6] = -b[3].x\na[7] = b[1].x\na[8] = b[2].x\n\nprint(\"________________________________________\")\nprint(f\"The equivalent optimized constraint is:\")\n\n\noptimized_constraint = {}\nfor i in indices:\n    if i==0:\n        optimized_constraint[i]=f\"{a[i]}\"\n    else:\n        optimized_constraint[i]= f\"{a[i]}x[{i}]\"\n        #print(optimized_constraint)\n            \nprint(f\"\\n{optimized_constraint[1]} + {optimized_constraint[2]} + {optimized_constraint[3]} + {optimized_constraint[4]} + {optimized_constraint[5]} + {optimized_constraint[6]}  + {optimized_constraint[7]} + {optimized_constraint[8]} <= {optimized_constraint[0]}\")"}]}
{"meta": {"source_path": "/Users/sunyujun03/Desktop/ReLoop/gurobi-modeling-examples/railway_dispatching/railway_dispatching.ipynb", "kind": "ipynb", "title": "Railway dispatching"}, "messages": [{"role": "system", "content": "You are an optimization engineer. Write correct and runnable Python code using gurobipy (Gurobi Python API). Be concise. Output only what is requested."}, {"role": "user", "content": "    Task: Reproduce the following Gurobi modeling example in Python using gurobipy.\n\n    Scenario description (from source):\n    # Railway dispatching\nPublic transport is an industry with many use cases that benefit from mathematical optimization. Examples include long-term planning (which services to operate at what frequency, timetabling of services), mid-term (assigning rolling stock and crew to train trips) and short-term (rescheduling, dispatching). In this notebook we consider the railway dispatching problem. We are given a set of trains with their current position and desired route. The challenge is to decide on the sequence of movements, so each train reaches its endpoint as soon as possible while respecting capacity limitations at the tracks and intermediate stations.\n\n## Load required packages\nIf you have a Gurobi license and installed the software already, you can skip the installation of `gurobipy`, but always make sure you have the [latest version](https://www.gurobi.com/downloads/gurobi-software) available.\n\n## Retrieving the data\nWe will be loading our scenarios from CSV files. These can be found in the `data` folder; each scenario consists of various CSV files within a subfolder. The files contain the following data:\n- `stations.csv` contains the railway stations. Each has a `capacity` (number of trains that can be at the station concurrently) and `duration` (time required for a stop at the station). Stations also have a `y` coordinate for visualizing the schedule later.\n- `tracks.csv` contains the railway tracks that connect pairs of stations. Each has a `capacity` and `duration` as above, as well as a `start` and `end` station. We assume tracks can be traversed in both directions, so the order of `start` and `end` is not relevant.\n- `routes.csv` contains predefined routes through the network. Each route is a list of resources (stations and tracks).\n- `trains.csv` contains the trains that require scheduling for traversing the network. Each train follows a `route`, but may `start` at any point in the route.\n\nWe will do a bit of processing, to make it easier to use our data.\n\n    Requirements:\n    - Use gurobipy (Model, GRB, addVar/addConstr, etc.)\n    - Make the script runnable as a standalone Python file if possible.\n    - Keep the code faithful to the example.\n"}, {"role": "assistant", "content": "import itertools as it\nimport math\nimport pandas as pd\nimport plotly.express as px\nimport datetime as dt\nfrom os import path\nimport gurobipy as gp\nfrom gurobipy import GRB\n\ndataset = 'linear'\nfolder = f'data/{dataset}'\ndf_stations = pd.read_csv(path.join(folder, 'stations.csv')).set_index('id')\ndf_tracks = pd.read_csv(path.join(folder, 'tracks.csv')).set_index('id')\ndf_routes = pd.read_csv(path.join(folder, 'routes.csv')).set_index('id')\ndf_trains = pd.read_csv(path.join(folder, 'trains.csv')).set_index('id')\n\n# For each route, parse the station/track string\nroutes = df_routes['resources'].map(lambda route: [int(res) for res in route.split('-')]).to_dict()\n\n# For each train, find the corresponding route and apply the starting position\ntrains = df_trains.apply(lambda row: list(it.dropwhile(lambda resource: resource!=row.start, routes[row.route])), axis=1).to_dict()\n\n# For each resource, find the duration and capacity\nduration = pd.concat([df_tracks['duration'], df_stations['duration']]).to_dict()\ncapacity = pd.concat([df_tracks['capacity'], df_stations['capacity']]).to_dict()\n\n# Find Y coordinates for the stations\nstation_y = df_stations['y'].to_dict()\n\n# For each track, find the pair of stations on both sides of the track\ntrack_stations = df_tracks.apply(lambda track: (track.start, track.end), axis=1)\n\n# Find the set of resources with their types (S=station, T=track)\nresource_type = { key: 'S' for key in df_stations.index } | { key: 'T' for key in df_tracks.index }\nresources = resource_type.keys()\n\npd.DataFrame({'type': resource_type, 'duration': duration, 'capacity': capacity, 'y': station_y, 'endpoints': track_stations})\n\ndef get_next_resource(train, resource):\n    route = trains[train]\n    index = route.index(resource)\n    return route[index + 1] if index < len(route)-1 else None\n\nmodel = gp.Model()\nevents = gp.tuplelist([(train, resource) for train, route in trains.items() for resource in route])\nt = model.addVars(events, name='t')\ntf = model.addVars(trains.keys(), name='tf')\n\n# Helper function to retrieve 't' or 'tf', depending on if resource=None\ndef tvar(train, resource):\n    return t[train, resource] if resource is not None else tf[train]\n\n# Precedence constraints\nfor train, route in trains.items():\n    for train_i in range(len(route)-1):\n        # We assume that trains are present in the network from the start, so must\n        # have their first event equal to 0.\n        if train_i==0:\n            model.addConstr(t[train, route[train_i+1]] - t[train, route[train_i]] >= duration[route[train_i]])\n        else:\n            model.addConstr(t[train, route[train_i+1]] - t[train, route[train_i]] >= duration[route[train_i]])            \n    model.addConstr(tf[train] - t[train, route[len(route)-1]] == duration[route[len(route)-1]])\n\n# Starting position\nfor train in trains:\n    resource = trains[train][0]\n    t[train, resource].UB=0\n\nM = sum(duration) * len(trains)\n\ndef create_disjunct_constraints(resource, train_i, resource_u, train_j, resource_v, M):\n    t_ir = tvar(train_i, resource)\n    t_iu = tvar(train_i, resource_u)\n    t_jr = tvar(train_j, resource)\n    t_jv = tvar(train_j, resource_v)\n\n    # A before B\n    y_ab = model.addVar(vtype=GRB.BINARY, name=f'y[{resource},{train_i},{train_j}]')\n    model.addConstr(t_jr - t_iu >= -M *(1-y_ab), name=f'y[{resource},{train_i},{train_j}]')\n\n    # B before A\n    y_ba = model.addVar(vtype=GRB.BINARY, name=f'y[{resource},{train_j},{train_i}]')\n    model.addConstr(t_ir - t_jv >= -M *(1-y_ba), name=f'y[{resource},{train_j},{train_i}]')\n\n    # A and B meet\n    x = model.addVar(vtype=GRB.BINARY, name=f'x[{resource},{train_i},{train_j}]')\n    model.addConstr(t_jv - t_ir >= -M *(1-x), name=f'x1[{resource},{train_i},{train_j}]')\n    model.addConstr(t_iu - t_jr >= -M *(1-x), name=f'x2[{resource},{train_i},{train_j}]')\n\n    # Have exactly one of three situations\n    model.addConstr(y_ab + y_ba + x == 1, name=f'xy[{resource},{train_i},{train_j}]')\n    return x\n\n# Conflicts\nfor resource in resources:\n    # Find trains that visit\n    resource_events = events.select('*', resource)\n    resource_trains = [t for (t,r) in resource_events]\n    trains_with_next = []\n\n    # For each train, find the consecutive event\n    for train in resource_trains:\n        next_resource = get_next_resource(train, resource)\n        trains_with_next.append((train, next_resource))\n\n    # List of X variables to use for hotspot constraint later\n    xlist = {}\n\n    # Consider pairs of trains\n    pairs = it.combinations(trains_with_next, 2)\n    for pair in pairs:\n        ((train_i, resource_u), (train_j, resource_v)) = pair\n        xlist[train_i,train_j] = create_disjunct_constraints(resource, train_i, resource_u, train_j, resource_v, M)\n\n    # Add hotspot constraints\n    if len(resource_trains) <= capacity[resource]:\n        continue\n    elif(capacity[resource] > 1):\n        subsets = it.combinations(resource_trains, capacity[resource]+1)\n        rhs = math.comb(capacity[resource]+1, 2) - 1\n        for subset in subsets:\n            pairs = it.combinations(subset, 2)\n            xsel = [xlist[ta,tb] for (ta,tb) in pairs]\n            suffix = ','.join(list(subset))\n            model.addConstr(gp.quicksum(xsel) <= rhs, f'h[{resource},{suffix}]')            \n    else:\n        for x in xlist.values():\n            x.UB = 0\n\n#model.addConstr(tf['F'] <= tf['E'])\n\ndef delay(train):\n    min_duration = sum(duration[resource] for resource in trains[train])\n    return tf[train] - min_duration\n    \nmodel.setObjective(gp.quicksum(delay(train) for train in trains))\nmodel.ModelSense = GRB.MINIMIZE\n\nmodel.optimize()\n\nintervals = {\n    (train, resource): (tvar(train, resource).X, tvar(train, get_next_resource(train, resource)).X, get_next_resource(train, resource) )\n    for (train, resource) in events\n}\nmodel.dispose()\n\ndf_intervals = pd.DataFrame.from_dict(intervals, orient='index').rename(columns={0:'start',1:'end',2:'next'}).reset_index()\ndf_intervals['train'], df_intervals['resource'] = zip(*df_intervals['index'])\ndf_intervals.drop(columns='index', inplace=True)\ndf_intervals.pivot_table(values='start', columns='resource', index='train', fill_value='')\n\n# For each train, compute Y coodinates per event\ntrain_coordinates = { }\nfor train, route in trains.items():\n    current_resource = None\n    for resource in route:\n        if resource_type[resource] == 'S':\n            train_coordinates[train, resource] = (station_y[resource], station_y[resource])\n        else:\n            endpoints = track_stations[resource]\n            if current_resource != None:\n                first = current_resource\n                second = endpoints[0] if endpoints[1] == current_resource else endpoints[1]                \n            else:\n                second = route[1]\n                first = endpoints[0] if endpoints[1] == second else endpoints[1]\n            train_coordinates[train, resource] = (station_y[first], station_y[second])\n        current_resource = resource\n\ndf_diagram = it.chain(*[[{ 'train':train, 'y': train_coordinates[train, resource][0], 'x': start }, { 'train':train, 'y': train_coordinates[train, resource][1], 'x':end }] for (train, resource), (start, end, next) in intervals.items()])\nfig = px.line(df_diagram, x='x', y='y', color='train', width=600, height=400)\nfig.update_traces(line={'width': 4}, opacity=.7)\nfor station, y_ab in station_y.items():    \n    fig.add_hline(y=y_ab, annotation_text=station, line_dash=\"dot\", line_width=1, line_color='gray')\nfig.show()\n\nt = dt.datetime.combine(dt.date.today(), dt.time())\ndf_timeline =  pd.DataFrame.from_records([{ 'train':train, 'resource':resource, 'start':t+dt.timedelta(minutes=start), 'end':t+dt.timedelta(minutes=end) } for (train, resource), (start, end, next) in intervals.items()])\nfig = px.timeline(df_timeline, x_start='start', x_end='end', y='resource', color='train', height=400, opacity=0.5)\nfig.update_yaxes(type='category', showticklabels=True, categoryorder='array', categoryarray=sorted(int(x) for x in resources))\nfig.show()"}]}
{"meta": {"source_path": "/Users/sunyujun03/Desktop/ReLoop/gurobi-modeling-examples/food_program/food_supply.ipynb", "kind": "ipynb", "title": "Tackling world hunger using mathematical optimization"}, "messages": [{"role": "system", "content": "You are an optimization engineer. Write correct and runnable Python code using gurobipy (Gurobi Python API). Be concise. Output only what is requested."}, {"role": "user", "content": "    Task: Reproduce the following Gurobi modeling example in Python using gurobipy.\n\n    Scenario description (from source):\n    # Tackling world hunger using mathematical optimization\n\nThe United Nations World Food Program (WFP) supplies food assistance to around 100 million people in 80 countries each year.\nTransporting food in a global transportation network is a challenging undertaking.\nIn this notebook, we will build an optimization model to set up a food supply chain based on real data from WFP. \nThe optimization model is motivated by the case studies in Syria by [Peters et al. (2021)](https://pubsonline.informs.org/doi/epdf/10.1287/ijoo.2019.0047), [Peters et al. (2022)](https://pubsonline.informs.org/doi/abs/10.1287/inte.2021.1097) and the [Zero Hunger Lab](https://www.tilburguniversity.edu/research/institutes-and-research-groups/zero-hunger-lab).\n\nThe idea is to transport food from cities identified as \"suppliers\" to beneficiary cities in Syria.\nThe quantity of food arriving at beneficiary cities must be sufficient enough to satisfy basic nutritional needs of the people there.\nOn the other hand, the procurement and transportation of food comes at a cost, and therefore must be done efficiently.\nIn this notebook, we will learn how to set up an optimization problem to achieve a cost-efficient food supply chain.\n\n<!-- ![alt text](image/figure_syria.png) -->\n\n<!-- |<img src=\"image/figure_syria.png\" width=\"1000\" align=\"center\">| \n|:--:|\n| <b>Image Credits: [Peters et al. (2016). The Nutritious Supply Chain: Optimizing Humanitarian Food Aid. NFORMS Journal on Optimization.](https://pubsonline.informs.org/doi/10.1287/ijoo.2019.0047) </b>|  -->\n\n<!-- **Goal**:  -->\n\n## Prepare the inputs\n\nWe need three types of data files. First, we will construct a transportation network that consists of supplier cities, transit hubs and beneficiary camps. Second, we will obtain information on the nutritional composition of different food types and the nutritional needs of an average person. Third, we will load information on the costs of procuring different food types from the supplier cities using historical data on procurement costs.\n\nThe following packages are needed to process and visualize the data.\n\n    Requirements:\n    - Use gurobipy (Model, GRB, addVar/addConstr, etc.)\n    - Make the script runnable as a standalone Python file if possible.\n    - Keep the code faithful to the example.\n"}, {"role": "assistant", "content": "from PIL import Image\nimport requests\nfrom io import BytesIO\n \nprint('Food supply chain in Syria:')  \nimg = Image.open(BytesIO(requests.get('https://github.com/Gurobi/modeling-examples/blob/master/food_program/figure_syria.png?raw=true').content))\nimg \n# Image('figure_syria.png')\n\nimport pandas as pd\nimport numpy as np\nimport networkx as nx\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport datetime\n\nnode_types = pd.read_csv('https://raw.githubusercontent.com/Gurobi/modeling-examples/master/food_program/data/node_types.csv',)\n# node_types = pd.read_csv('data/node_types.csv',)\n\nprint(len(node_types))\nN = set(node_types['Name'])\nN_S = set(s[:-2] for s in N if s[-2:] == ' S') # suppliers\nN_TS = set(s[:-3] for s in N if s[-2:] == 'TS') # transit hubs \nN_B = set(s[:-2] for s in N if s[-1] == 'D') # beneficiary camps\nN = N_S.union(N_TS,N_B)  # set of all cities\nprint(\"There are %i cities in total. %i are suppliers and %i are beneficiary camps. %i cities serve as both.\"%(len(N),len(N_S),len(N_B),len(N_S.intersection(N_B))))\ndemand = {i: node_types.set_index('Name').stack().to_dict()[i+' D','Demand'] for i in N_B}\nprint(\"Number of people in each beneficiary camp:\")\n\nbar = sns.barplot(x=list(demand.keys()), y=[demand[k] for k in demand])\nbar.set_xticklabels(bar.get_xticklabels(), rotation=40);\nbar.set(xlabel='Benefitiary camp', ylabel='Number of beneficiaries');\nplt.show()\n\nedge_costs = pd.read_csv('https://raw.githubusercontent.com/Gurobi/modeling-examples/master/food_program/data/edge_costs.csv')\n# edge_costs = pd.read_csv('data/edge_costs.csv')\nt = edge_costs.set_index(['A','B']).tCost.to_dict() # travel cost for each link\nedges = list(t.keys())  # directed edges \n\nG = nx.DiGraph() # create an empty directed graph\nG.add_edges_from(edges) # add edges to the graph; this step automatically creates the nodes as well\nplt.figure(figsize=(20,14))\ncolor_map = ['green' if (i in N_S and i not in N_B) else 'red' if (i in N_B and i not in N_S) else 'blue' if (i in N_B and i in N_S) else 'lightblue' for i in G.nodes()]\n\nnx.draw(G, pos = nx.kamada_kawai_layout(G),node_color=color_map, node_size=900, linewidths=.25, width=1, font_size=25, font_weight='bold', with_labels=True, arrowsize=50, verticalalignment='top', horizontalalignment='right')\nnx.draw_networkx_edge_labels(G, pos = nx.kamada_kawai_layout(G), edge_labels = t,  font_size=20)\nprint(\"Green node: Only a supplier, Red node: Only a beneficiary, Blue node: Both a supplier and a beneficiary. \\nThe transportation cost for each edge is also shown.\")\nplt.show()\n\nnutrient_requirements = pd.read_csv('https://raw.githubusercontent.com/Gurobi/modeling-examples/master/food_program/data/nutrient_requirements.csv', index_col=False) \n# nutrient_requirements = pd.read_csv('data/nutrient_requirements.csv', index_col=False) \nU = nutrient_requirements.columns.values.tolist() # Set of all nutrients\nU.remove('Type') \nm = {u: nutrient_requirements.to_dict()[u][0] for u in U}  # dicionary containing minimum nutritional requirement per person\npd.DataFrame(m, index=[0])\n\nfood_nutrition = pd.read_csv('https://raw.githubusercontent.com/Gurobi/modeling-examples/master/food_program/data/food_nutrition.csv', index_col=False) \n# food_nutrition = pd.read_csv('data/food_nutrition.csv', index_col=False) \nF = set(food_nutrition['Food']) # Set of all food types\nv = food_nutrition.set_index('Food').stack().to_dict() # dicionary containing nutrional content in each food type\ndf_nutrition = pd.Series(v).reset_index() # creating a new dataframe to display the data\ndf_nutrition.columns = ['Food', 'Nutrient', 'Amount'] \ndf_nutrition.pivot_table(index=['Food'], columns='Nutrient', values='Amount', fill_value=0).reset_index().rename_axis(None, axis=1).head(5)\n\ndf_food_costs = pd.read_csv('https://raw.githubusercontent.com/Gurobi/modeling-examples/master/food_program/data/food_costs.csv') \n# df_food_costs = pd.read_csv('data/food_costs.csv') \np = df_food_costs.set_index(['supplier','food'])['Mean'].to_dict()\n\ninternational_food_price = pd.read_csv('https://raw.githubusercontent.com/Gurobi/modeling-examples/master/food_program/data/food_internationalprice.csv').set_index('Food')['InternationalPrice'].to_dict() \n# international_food_price = pd.read_csv('data/food_internationalprice.csv').set_index('Food')['InternationalPrice'].to_dict() \n \np.update({(i,f): international_food_price[f] for f in F for i in N_S if (i,f) not in p})\npd.Series(p).unstack()\n\nimport gurobipy as gp\nfrom gurobipy import GRB\nmodel = gp.Model(\"foodsupply\")\n\nr = model.addVars(F, N_B, name=\"r\") # amount of each food type per person in each beneficiary location\n\nP = {(f,i): 10000000 for f in F for i in N_S} # we set a large upper limit on the amount of food purchased\ns = model.addVars(F, N_S, name=\"s\", lb=0, ub=P) # amount of each food type purchased from each supply location \n\nx = model.addVars(F, edges, name=\"x\") # amount of each food type flowing in each edge \n\nprint(\"This model has\",len(x)+len(r)+len(s),\"decision variables in total.\")\n\nmodel.update()\n\nobjective = gp.quicksum(s[f,i]*p[i,f] for f in F for i in N_S) # procurement cost\nobjective += gp.quicksum(x[f,i,j]*t[i,j] for f in F for (i,j) in edges)   # transport cost\nmodel.setObjective(objective,sense=GRB.MINIMIZE)\n\n# model.setObjective(s.prod(ProcCost)+x.prod(t),sense=GRB.MINIMIZE)\n\nM = {u: 2*m[u] for u in m} # we assume that the upper limit for each nutrient value is twice the lower limit\n \nmodel.addConstrs((gp.quicksum(v[f,u]*r[f,j] for f in F) == [m[u], M[u]]) for u in U for j in N_B)\nmodel.update()\n\ndelta_minus = {i: set(G.predecessors(i)) for i in N}  # preceding neighbors of each city\ndelta_plus = {i: set(G.successors(i)) for i in N}  # forward neighbors of each city\n\nprint(\"Damascus can receive food from\",delta_minus['Damascus'],\"\\nDamascus send food to\",delta_plus['Damascus'])\n\nfor f in F:\n    for i in N:\n        if i in N_B and i not in N_S:\n            model.addConstr((gp.quicksum(x[f,j,i] for j in delta_minus[i])-gp.quicksum(x[f,i,j] for j in delta_plus[i]) == demand[i]*r[f,i]))\n        if i in N_S and i not in N_B:\n            model.addConstr((gp.quicksum(x[f,j,i] for j in delta_minus[i])-gp.quicksum(x[f,i,j] for j in delta_plus[i]) == -s[f,i]))\n        if i in N_S and i in N_B:\n            model.addConstr((gp.quicksum(x[f,j,i] for j in delta_minus[i])-gp.quicksum(x[f,i,j] for j in delta_plus[i]) == demand[i]*r[f,i]-s[f,i]))\nmodel.update()\n# D+ = []\n\nmodel.optimize()\n\nprint(\"$\",round(model.ObjVal/10**6,2),\"million\")\n\nfor f in F: \n    flow_f = {(i,j): x[f,i,j].X for (i,j) in edges if x[f,i,j].X > 0} # retrieve the optimal variables values \n    \n    # plot the flow networks for each food type\n    if flow_f != {}:\n        graph = G.edge_subgraph(flow_f.keys()) \n        print(\"Optimal flow of\",f,\":\")  \n        nx.draw(graph, pos = nx.kamada_kawai_layout(G),node_size=100, width=1, linewidths=.25, font_size=14, font_weight='bold', with_labels=True,arrowsize=15, verticalalignment='bottom')\n        plt.show()\n\ndf_beneficiary = pd.DataFrame([[j,f,r[f,j].X] for j in N_B for f in F if r[f,j].X > 0],columns=['Beneficiary city', 'Food','Quantity per person'])\n\nfor i in N_B:\n    df = df_beneficiary[df_beneficiary['Beneficiary city']==i].set_index('Food')\n    print(\"Each of the %i beneficiaries in %s receives:\"%(demand[i],i))\n    plot = df.plot.pie(y='Quantity per person', figsize=(5, 5),legend=None) \n    plt.show()\n\ndf_supply = pd.DataFrame([[i,f,round(s[f,i].X,2),p[i,f]] for i in N_S for f in F if s[f,i].X > 0],columns=['Supply city', 'Food','Quantity supplied','Procurement cost'])            \n\nfor i in N_S:\n    df = df_supply[df_supply['Supply city']==i].set_index('Food')\n    if len(df)>0:\n        print(\"Supplier city %s supplies:\"%(i))\n        plot = df.plot.pie(y='Quantity supplied', figsize=(5, 5),legend=None) \n        plt.show()\n\nmodel.dispose()\ngp.disposeDefaultEnv()"}]}
{"meta": {"source_path": "/Users/sunyujun03/Desktop/ReLoop/gurobi-modeling-examples/car_rental/car_rental_2.ipynb", "kind": "ipynb", "title": "Car Rental 2"}, "messages": [{"role": "system", "content": "You are an optimization engineer. Write correct and runnable Python code using gurobipy (Gurobi Python API). Be concise. Output only what is requested."}, {"role": "user", "content": "    Task: Reproduce the following Gurobi modeling example in Python using gurobipy.\n\n    Scenario description (from source):\n    # Car Rental 2\n\n## Objective and Prerequisites\n\nIn this example, which is an extension of Vehicle Rental Optimization I, you’ll see how mathematical optimization can be used to figure out in which locations a car rental company should expand repair capacity. We’ll guide you through the process of creating a mixed integer linear programming model of this problem using the Gurobi Python API and then show you how you can find an optimal solution with the Gurobi Optimizer.\n\nThis model is example 26 from the fifth edition of Model Building in Mathematical Programming by H. Paul Williams on pages 287 and 342-343.\n\nThis example is at the intermediate level, where we assume that you know Python and the Gurobi Python API and that you have some knowledge of building mathematical optimization models.\n\n**Download the Repository** <br /> \nYou can download the repository containing this and other examples by clicking [here](https://github.com/Gurobi/modeling-examples/archive/master.zip). \n\n---\n## Problem Description\n\nA small car rental company\n(which rents only one type of car) \nhas depots in Glasgow, Manchester, Birmingham and Plymouth. There is an estimated demand for each day of the week except Sunday (when the company is closed). These estimates are given in the following table. It is not necessary to meet all demand.\n\n![weeklyDemand](weeklyDemand.PNG)\n\nCars can be rented for one, two or three days and returned to either the\ndepot from which they were rented or another depot at the start of the next morning. For\nexample, a 2-day rental on Thursday means that the car has to be returned on\nSaturday morning; a 3-day rental on Friday means that the car has to be returned\non Tuesday morning. A 1-day rental on Saturday means that the car has to be\nreturned on Monday morning, and a 2-day rental on Tuesday morning.\n\nThe rental period is independent of the origin and destination. From historical\ndata, the company knows the distribution of rental periods: 55% of cars are rented\nfor one day, 20% for two days and 25% for three days. The current estimates\nof percentages of cars rented from each depot and returned to a given depot\n(independent of the day) are given in the following table.\n\n![FromToPct](FromToPct.PNG)\n\nThe company's marginal cost\nof renting out a car (‘wear and tear’, administration, etc.) is estimated as follows:\n\n| Days rented | Marginal cost |\n| --- | --- |\n| 1-day | $\\$ 20$ |\n| 2-day | $\\$ 25$ |\n| 3-day | $\\$ 30$ |\n\nThe ‘opportunity cost’ (interest on capital, storage, servicing, etc.) of owning\na car is $\\$ 15$ per week.\n\nIt is possible to transfer undamaged cars from one depot to another depot,\nirrespective of distance. Cars cannot be rented out during the day in which they\nare transferred. The costs in USD, per car, of transfer are given in the following table.\n\n![FromToCst](FromToCst.PNG)\n\nTen percent of cars returned by customers are damaged. When this happens,\nthe customer is charged an excess of $\\$ 100$  (irrespective of the amount of damage\nthat the company completely covers by its insurance). In addition, the car has\nto be transferred to a repair depot, where it will be repaired the following day.\nThe cost of transferring a damaged car is the same as transferring an undamaged\none (except when the repair depot is the current depot, \nin which case the cost would be $\\$0$). \nThe transfer of a damaged car takes a day, unless it is already at a repair depot.\nHaving arrived at a repair depot, all types of repair (or replacement) take a day.\nOnly two of the depots have repair capacity. The (cars/day) capacity at each repair depot is as follows:\n\n| Repair depot | Capacity |\n| --- | --- |\n| Manchester | 12 |\n| Birmingham | 20 |\n\nHaving been repaired, the car is available for rent at the depot the next day\nor may be transferred to another depot (taking a day). Thus, a car that is returned\ndamaged on a Wednesday morning is transferred to a repair depot (if not the\ncurrent depot) on Wednesday, repaired on Thursday and is available for rent\nat the repair depot on Friday morning.\nThe rental price depends on the number of days for which the car is rented\nand whether it is returned to the same depot or not. The prices (in USD) are given in the following table.\n\n![RentalPrice](RentalPrice.PNG)\n\nWe assume the following at the beginning of each day:\n1. Customers return cars that are due that day.\n2. Damaged cars are sent to the repair depot.\n3. Cars that were transferred from other depots arrive.\n4. Transfers are sent out.\n5. Cars are rented out.\n6. If it is a repair depot, then the repaired cars are available for rental.\n\nThe car rental company wants to determine in which locations it should expand  repair capacity. The weekly fixed costs, given below, include interest payments on the necessary\nloans for expansion. The options are as follows:\n\n1. Expand repair capacity at Birmingham by 5 cars per day at a fixed cost\nper week of $\\$18,000$.\n2. Further expand repair capacity at Birmingham by 5 cars per day at a fixed\ncost per week of $\\$8,000$.\n3. Expand repair capacity at Manchester by 5 cars per day at a fixed cost per\nweek of $\\$20,000$.\n4. Further expand repair capacity at Manchester by 5 cars per day at a fixed\ncost per week of $\\$5,000$.\n5. Create repair capacity at Plymouth of 5 cars per day at a fixed cost per\nweek of $\\$19,000$.\n\nIf any of these options is chosen, it must be carried out in its entirety; that\nis, there can be no partial expansion. Also, a further expansion at a depot can be\ncarried out only if the first expansion is also carried out -so, for example, option\n(2) at Birmingham cannot be chosen unless option (1) is also chosen. If option (2)\nis chosen, thereby also choosing option (1), these count as two options. Similar\nstipulations apply regarding the expansions at Manchester. At most three of the\noptions can be carried out.\n\nThe goal is to determine in which locations to expand  repair capacity, the numbers of cars the car rental company should own, and where they should  be located at the start of each week day in order to maximize weekly profit. The company wants a ‘steady state’ solution in which the same expected number of cars will be located at the same depot on the same day of subsequent weeks.\n\n---\n## Model Formulation\n\n$d,d2 \\in \\text{Depots}=\\{\\text{Glasgow}, \\text{Manchester}, \\text{Birmingham},  \\text{Plymouth}\\}$\n\n$\\text{NRD}=\\{\\text{Glasgow}\\}$: Depots without repair capacity.\n\n$\\text{RD}=\\{\\text{Manchester}, \\text{Birmingham}, \\text{Plymouth}\\}$: Depots with repair capacity.\n\n$t \\in \\text{Days}=\\{\\text{Monday},\\text{Tuesday},\\text{Wednesday},\\text{Thursday},\\text{Friday},\\text{Saturday}\\}$\n\n$r \\in \\text{RentDays}=\\{1,2,3\\}$: Number of days rented.\n\n### Parameters\n\n$\\text{demand}_{d,t} \\in \\mathbb{R}^+$: Estimated rental demand at depot $d$ on day $t$.\n\n$\\text{pctDepot}_{d,d2} \\in \\mathbb{R}^+$: Proportion of cars rented at depot $d$ to be returned to depot $d2$.\n\n$\\text{cstTransfer}_{d,d2} \\in \\mathbb{R}^+$: Transfer cost of a car from depot $d$ to depot $d2$.\n\n$\\text{pctRent}_{r} \\in \\mathbb{R}^+$: Proportion of cars rented for $r$ days.\n\n$\\text{capRepair}_{d} \\in \\mathbb{R}^+$: Repair capacity of depot $d$.\n\n$\\text{cstSameDepot}_{r} \\in \\mathbb{R}^+$: Rental cost for $r$ days with return to same depot.\n\n$\\text{cstOtherDepot}_{r} \\in \\mathbb{R}^+$: Rental cost for $r$ days with return to other depot.\n\n$\\text{marginalCost}_{r} \\in \\mathbb{R}^+$: Marginal cost to company of  $r$ days rental of a car.\n\n$\\text{pctUndamaged } \\in [0,1]$: Percent of cars returned by customers that are undamaged.\n\n$\\text{pctDamaged  } \\in [0,1]$: Percent of cars returned by customers that are damaged.\n\n$\\text{cstOwn} \\in \\mathbb{R}^+$: Cost of owning a car.\n\n$\\text{damagedFee} = 10$: Damaged car fee. Ten percent of the cars are damaged and the fee for a damaged car is $\\$100$.\n\n$\\text{cstExpCapB1} \\in \\mathbb{R}^+$: Fixed cost per week of expanding capacity at Birmingham.\n\n$\\text{cstExpCapB2} \\in \\mathbb{R}^+$: Fixed cost per week of further expanding capacity at Birmingham.\n\n$\\text{cstExpCapM1} \\in \\mathbb{R}^+$: Fixed cost per week of expanding capacity at Manchester.\n\n$\\text{cstExpCapM2} \\in \\mathbb{R}^+$: Fixed cost per week of further expanding capacity at Manchester.\n\n$\\text{cstExpCapP} \\in \\mathbb{R}^+$: Fixed cost per week of expanding capacity at Plymouth.\n\n### Decision Variables\n\n$\\text{xOwned} \\in \\mathbb{R}^+$: Total number of cars owned.\n\n$\\text{xUndamaged}_{d,t} \\in \\mathbb{R}^+$: Number of undamaged cars available at depot $d$ at the beginning of day $t$.\n\n$\\text{xDamaged}_{d,t} \\in \\mathbb{R}^+$: Number of damaged cars available at depot $d$ at the beginning of day $t$.\n\n$\\text{xRented}_{d,t} \\in \\mathbb{R}^+$: number of cars rented  out from depot $d$ at the beginning of day $t$.\n\n$\\text{xUDleft}_{d,t} \\in \\mathbb{R}^+$: Number of undamaged cars available at depot $d$ at the beginning of day $t$.\n\n$\\text{xDleft}_{d,t} \\in \\mathbb{R}^+$: Number of damaged cars left in depo $d$ at the end of day  $t$.\n\n$\\text{xUDtransfer}_{d,d2,t} \\in \\mathbb{R}^+$: Number of undamaged cars  at depot $d$ at the beginning of day $t$, to be transferred to depot $d2$. \n\n$\\text{xDtransfer}_{d,d2,t} \\in \\mathbb{R}^+$: Number of damaged cars at depot $d$ at the beginning of day $t$, to be transferred to depot $d2$. \n\n$\\text{xRepaired}_{d,t} \\in \\mathbb{R}^+$: Number of damaged cars to be repaired at depot $d$ during day $t$.\n\n$\\text{yExpandCapB1} \\in \\{0,1 \\}$: This binary variable is equal to 1, if the Birmingham repair capacity is expanded by 5 cars per day.\n\n$\\text{yExpandCapB2} \\in \\{0,1 \\}$: This binary variable is equal to 1, if the Birmingham repair capacity is expanded by a further 5 cars per day.\n\n$\\text{yExpandCapM1} \\in \\{0,1 \\}$: This binary variable is equal to 1, if the Manchester repair capacity is expanded by 5 cars per day.\n\n$\\text{yExpandCapM2} \\in \\{0,1 \\}$: This binary variable is equal to 1, if the Manchester repair capacity is expanded by a further 5 cars per day.\n\n$\\text{yExpandCapP} \\in \\{0,1 \\}$: This binary variable is equal to 1, if the Plymouth repair capacity is expanded by 5 cars per day.\n\n### Objective function\nThe objective is to maximize profit.\n\n\\begin{equation}\n\\sum_{d \\in \\text{Depots}}\n\\sum_{t \\in \\text{Days}}\n\\sum_{r \\in \\text{RentDays}} \n\\text{pctDepot}_{d,d}*\\text{pctRent}_{r}*(\\text{cstSameDepot}_{r} - \\text{marginalCost}_{r} + \\text{damagedFee})*\\text{xRented}_{d,t}\n\\end{equation}\n\n\\begin{equation}\n+ \\sum_{d \\in \\text{Depots}} \\sum_{d2 \\in \\text{Depots}}\n\\sum_{t \\in \\text{Days}}\n\\sum_{r \\in \\text{RentDays}} \n\\text{pctDepot}_{d,d2}*\\text{pctRent}_{r}*(\\text{cstOtherDepot}_{r} - \\text{marginalCost}_{r} + \\text{damagedFee})*\\text{xRented}_{d,t}\n\\end{equation}\n\n\\begin{equation}\n- \\sum_{d \\in \\text{Depots}} \\sum_{d2 \\in \\text{Depots}}\n\\sum_{t \\in \\text{Days}} \\text{cstTransfer}_{d,d2}*(\\text{xUDtransfer}_{d,d2,t} + \\text{xDtransfer}_{d,d2,t} )\n- \\text{cstOwn}*\\text{xOwned}\n\\end{equation}\n\n\\begin{equation}\n-(\\text{cstExpCapB1}*\\text{yExpandCapB1} + \\text{cstExpCapB2}*\\text{yExpandCapB2} + \\text{cstExpCapM1}*\\text{yExpandCapM1} \n\\end{equation}\n\n\\begin{equation}\n+ \\text{cstExpCapM2}*\\text{yExpandCapM2} + \\text{cstExpCapP}*\\text{yExpandCapP} )\n\\end{equation}\n\n### Constraints\n\n**Undamaged cars at a non-repair depot** <br />\nNumber of undamaged cars available at a non-repair depot $d$ at the beginning of day $t$.\n\n\\begin{equation}\n\\sum_{d2 \\in \\text{Depots}} \n\\sum_{r \\in \\text{RentDays}} \\text{pctUndamaged}*\\text{pctDepot}_{d2,d}*\\text{pctRent}_{r}*\\text{xRented}_{d2,(t-r)mod(6)}\n\\end{equation}\n\n\\begin{equation}\n+ \\sum_{d2 \\in \\text{Depots}} \\text{xUDtransfer}_{d2,d,(t-1)mod(6)} + \\text{xUDleft}_{d,(t-1)mod(6)} = \\text{xUndamaged}_{d,t} \n\\quad \\forall d \\in NRD, t \\in Days\n\\end{equation}\n\nDemand of undamaged cars at the non-repair depot $d$ during day $t$.\n\n\\begin{equation}\n\\text{xUndamaged}_{d,t} = \\text{xRented}_{d,t} + \n\\sum_{d2 \\in \\text{Depots}} \\text{xUDtransfer}_{d,d2,t} + \\text{xUDleft}_{d,t}\n\\quad \\forall d \\in NRD, t \\in Days\n\\end{equation}\n\n**Undamaged cars at a repair depot** <br />\nNumber of undamaged cars available at a repair depot $d$ at the beginning of day $t$.\n\n\\begin{equation}\n\\sum_{d2 \\in \\text{Depots}} \n\\sum_{r \\in \\text{RentDays}} \\text{pctUndamaged}*\\text{pctDepot}_{d2,d}*\\text{pctRent}_{r}*\\text{xRented}_{d2,(t-r)mod(6)}\n\\end{equation}\n\n\\begin{equation}\n+ \\sum_{d2 \\in \\text{Depots}} \\text{xUDtransfer}_{d2,d,(t-1)mod(6)} \n+ \\text{xRepaired}_{d,(t-1)mod(6)}  + \\text{xUDleft}_{d,(t-1)mod(6)} = \\text{xUndamaged}_{d,t} \n\\quad \\forall d \\in NRD, t \\in Days\n\\end{equation}\n\nDemand of undamaged cars at the repair depot $d$ during day $t$.\n\n\\begin{equation}\n\\text{xUndamaged}_{d,t} = \\text{xRented}_{d,t} + \n\\sum_{d2 \\in \\text{Depots}} \\text{xUDtransfer}_{d,d2,t} + \\text{xUDleft}_{d,t}\n\\quad \\forall d \\in NRD, t \\in Days\n\\end{equation}\n\n**Damaged cars at a non-repair depot** <br />\nNumber of damaged cars available at a non-repair depot $d$ at the beginning of day $t$.\n\n\\begin{equation}\n\\sum_{d2 \\in \\text{Depots}} \n\\sum_{r \\in \\text{RentDays}} \\text{pctDamaged}*\\text{pctDepot}_{d2,d}*\\text{pctRent}_{r}*\\text{xRented}_{d2,(t-r)mod(6)}\n\\end{equation}\n\n\\begin{equation}\n+ \\text{xDleft}_{d,(t-1)mod(6)} = \\text{xDamaged}_{d,t} \\quad \\forall d \\in NRD, t \\in Days\n\\end{equation}\n\nDemand of undamaged cars at the non-repair depot $d$ during day $t$.\n\n\\begin{equation}\n\\text{xDamaged}_{d,t} = \n\\sum_{d2 \\in \\text{Depots} \\cap RD} \\text{xDtransfer}_{d,d2,t} + \\text{xDleft}_{d,t}\n\\quad \\forall d \\in NRD, t \\in Days\n\\end{equation}\n\n**Damaged cars at a repair depot** <br />\nNumber of damaged cars available at a repair depot $d$ at the beginning of day $t$.\n\n\\begin{equation}\n\\sum_{d2 \\in \\text{Depots}} \n\\sum_{r \\in \\text{RentDays}} \\text{pctDamaged}*\\text{pctDepot}_{d2,d}*\\text{pctRent}_{r}*\\text{xRented}_{d2,(t-r)mod(6)}\n\\end{equation}\n\n\\begin{equation}\n+ \\sum_{d2 \\in \\text{Depots}} \\text{xDtransfer}_{d2,d,(t-1)mod(6)} \n+ \\text{xDleft}_{d,(t-1)mod(6)} = \\text{xdamaged}_{d,t} \n\\quad \\forall d \\in RD, t \\in Days\n\\end{equation}\n\nDemand of undamaged cars at the non-repair depot $d$ during day $t$.\n\n\\begin{equation}\n\\text{xDamaged}_{d,t} = \\text{xRepaired}_{d,t} +\n\\sum_{d2 \\in \\text{Depots} \\cap RD} \\text{xDtransfer}_{d,d2,t} + \\text{xDleft}_{d,t}\n\\quad \\forall d \\in RD, t \\in Days\n\\end{equation}\n\n**Repair Capacity** <br />\nRepair capacity of depot $d$ for each day $t$, including expansion capacity options. \n\n\\begin{equation}\n\\text{xRepaired}_{Birmingham,t} \\leq \\text{capRepair}_{Birmingham}\n+ 5*\\text{yExpandCapB1} + 5*\\text{yExpandCapB2}\n\\quad \\forall t \\in Days\n\\end{equation}\n\n\\begin{equation}\n\\text{xRepaired}_{Manchester,t} \\leq \\text{capRepair}_{Manchester}\n+ 5*\\text{yExpandCapM1} + 5*\\text{yExpandCapM2}\n\\quad \\forall t \\in Days\n\\end{equation}\n\n\\begin{equation}\n\\text{xRepaired}_{Plymouth,t} \\leq \\text{capRepair}_{Plymouth}\n+ 5*\\text{yExpandCapP}\n\\quad \\forall t \\in Days\n\\end{equation}\n\n**Depot Demand** <br />\nDemand at depot $d$ for each day $t$. \n\n\\begin{equation}\n\\text{xRented}_{d,t} \\leq \\text{demand}_{d,t}\n\\quad \\forall d \\in Depots, t \\in Days\n\\end{equation}\n\n**Number of cars** <br />\nTotal number of cars owned equals number of cars rented out from all depots on Monday for 3 days, plus those on Tuesday for 2 or 3 days, plus all damaged and undamaged cars in depots at the beginning of Wednesday. \nRationale: Let’s choose a day (Wednesday), count the cars undamaged and damaged that were returned to the depots and that are available on Wednesday morning. Let’s count the cars that have been rented and have not been returned: Cars rented on Monday for 3 days, and cars rented on Tuesday for 2 or 3 days.\n\n\\begin{equation}\n\\sum_{d \\in \\text{Depots}} (0.25*\\text{xRented}_{d,0} + 0.45*\\text{xRented}_{d,1} + \\text{xUndamaged}_{d,2}  + \\text{xdamaged}_{d,2} ) = \\text{xOwned}\n\\end{equation}\n\n**Capacity expansion constraints** <br />\nAdditional expansion at a depot can be carried out only if the first expansion is also carried out.\n\n\\begin{equation}\n\\text{yExpandCapB1} \\geq \\text{yExpandCapB2}\n\\end{equation}\n\n\\begin{equation}\n\\text{yExpandCapM1} \\geq \\text{yExpandCapM2}\n\\end{equation}\n\n**Maximum number of expansions** <br />\nAt most three of the options can be carried out.\n\n\\begin{equation}\n\\text{yExpandCapB1} + \\text{yExpandCapB2} +\n\\text{yExpandCapM1} + \n\\end{equation}\n\n\\begin{equation}\n\\text{yExpandCapM2} +\n\\text{yExpandCapP} \\leq 3\n\\end{equation}\n\n---\n## Python Implementation\n\nWe import the Gurobi Python Module and other Python libraries.\n\n    Requirements:\n    - Use gurobipy (Model, GRB, addVar/addConstr, etc.)\n    - Make the script runnable as a standalone Python file if possible.\n    - Keep the code faithful to the example.\n"}, {"role": "assistant", "content": "import pandas as pd\nfrom itertools import product\n\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# tested with Python 3.11 & Gurobi 11.0\n\n# list of depots and working days of a week\n\ndepots = ['Glasgow','Manchester','Birmingham','Plymouth']\nNRD = ['Glasgow'] # Non-repair depot\nRD =['Manchester','Birmingham','Plymouth'] # Repair depot\n\ndays = [0,1,2,3,4,5] # Monday = 0, Tuesday = 1, ...  Saturday = 5\nrentDays = [1,2,3]\n\nd2w, demand = gp.multidict({\n    ('Glasgow',0): 100,\n    ('Glasgow',1): 150,\n    ('Glasgow',2): 135,\n    ('Glasgow',3): 83,\n    ('Glasgow',4): 120,\n    ('Glasgow',5): 230,\n    ('Manchester',0): 250,\n    ('Manchester',1): 143,\n    ('Manchester',2): 80,\n    ('Manchester',3): 225,\n    ('Manchester',4): 210,\n    ('Manchester',5): 98,\n    ('Birmingham',0): 95,\n    ('Birmingham',1): 195,\n    ('Birmingham',2): 242,\n    ('Birmingham',3): 111,\n    ('Birmingham',4): 70,\n    ('Birmingham',5): 124,\n    ('Plymouth',0): 160,\n    ('Plymouth',1): 99,\n    ('Plymouth',2): 55,\n    ('Plymouth',3): 96,\n    ('Plymouth',4): 115,\n    ('Plymouth',5): 80\n})\n\n#repairCap\ndepots, capacity = gp.multidict({\n    ('Glasgow'): 0,\n    ('Manchester'): 12,\n    ('Birmingham'): 20,\n    ('Plymouth'): 0\n})\n\n# Create a dictionary to capture \n# pctRent: percentage of cars rented for r days \n# cstMarginal: marginal cost for renting a car for r days\n# prcSameD: price of renting a car r days and returning to same depot\n# prcOtherD: price of renting a car r days and returning to another depot\nrentDays, pctRent, costMarginal, priceSameD, priceOtherD = gp.multidict({\n    (1): [0.55,20,50,70],\n    (2): [0.20,25,70,100],\n    (3): [0.25,30,120,150]\n})\n\n# Cost of owing a car per week.\ncstOwn = 15\n\n# damaged car fee\ndamagedFee = 10\n\n# Create a dictionary to capture the proportion of cars rented at depot d to be returned to depot d2 \nd2d, pctFromToD = gp.multidict({\n    ('Glasgow','Glasgow'): 0.6,\n    ('Glasgow','Manchester'): 0.2,\n    ('Glasgow','Birmingham'): 0.1,\n    ('Glasgow','Plymouth'): 0.1,\n    ('Manchester','Glasgow'): 0.15,\n    ('Manchester','Manchester'): 0.55,\n    ('Manchester','Birmingham'): 0.25,\n    ('Manchester','Plymouth'): 0.05,\n    ('Birmingham','Glasgow'): 0.15,\n    ('Birmingham','Manchester'): 0.2,\n    ('Birmingham','Birmingham'): 0.54,\n    ('Birmingham','Plymouth'): 0.11,\n    ('Plymouth','Glasgow'): 0.08,\n    ('Plymouth','Manchester'): 0.12,\n    ('Plymouth','Birmingham'): 0.27,\n    ('Plymouth','Plymouth'): 0.53\n})\n\n# Create a dictionary to capture the transfer costs  of cars\nd2d, cstFromToD = gp.multidict({\n    ('Glasgow','Glasgow'): 0.001,\n    ('Glasgow','Manchester'): 20,\n    ('Glasgow','Birmingham'): 30,\n    ('Glasgow','Plymouth'): 50,\n    ('Manchester','Glasgow'): 20,\n    ('Manchester','Manchester'): 0.001,\n    ('Manchester','Birmingham'): 15,\n    ('Manchester','Plymouth'): 35,\n    ('Birmingham','Glasgow'): 30,\n    ('Birmingham','Manchester'): 15,\n    ('Birmingham','Birmingham'): 0.001,\n    ('Birmingham','Plymouth'): 25,\n    ('Plymouth','Glasgow'): 50,\n    ('Plymouth','Manchester'): 35,\n    ('Plymouth','Birmingham'): 25,\n    ('Plymouth','Plymouth'): 0.001\n})\n\n# Proportion of undamaged and damaged cars returned\npctUndamaged = 0.9\npctDamaged = 0.1\n\n# Expansion of capacity binary costs\ncstExpCapB1 = 18000\ncstExpCapB2 = 8000\ncstExpCapM1 = 20000\ncstExpCapM2 = 5000\ncstExpCapP = 19000\n\n# Build a list of tuples (depot, depot2) such that d != d2\nlist_d2notd = []\n\nfor d,d2 in d2d:\n    if (d != d2):\n        tp = d,d2\n        list_d2notd.append(tp)\n\nd2notd = gp.tuplelist(list_d2notd)\n\n# Build a list of tuples (depot, depot2, day)\nlist_dd2t = []\n\nfor d,d2 in d2notd:\n    for t in days:\n        tp = d,d2,t \n        list_dd2t.append(tp)\n                    \ndd2t = gp.tuplelist(list_dd2t)\n\n# Build a list of tuples (depot, rent_day)\nlist_dr = []\n\nfor d in depots:\n    for r in rentDays:\n        tp = d,r\n        list_dr.append(tp)\n        \ndr = gp.tuplelist(list_dr) \n\n# Build a list of tuples (depot, day, rent_days )\nlist_dtr = []\n\nfor d in depots:\n    for t in days:\n            for r in rentDays:\n                tp = d,t,r\n                list_dtr.append(tp)\n                \ndtr = gp.tuplelist(list_dtr) \n\n# Build a list of tuples (depot, depot2, day, rent_days)\nlist_dd2tr = []\n\nfor d,d2 in d2notd:\n    for t in days:\n        for r in rentDays:\n            tp = d,d2,t,r\n            list_dd2tr.append(tp)\n                    \n                    \ndd2tr = gp.tuplelist(list_dd2tr)\n\nmodel = gp.Model('RentalCar1')\n\n# Number of cars owned\nn = model.addVar(name=\"cars\")\n\n# Number of undamaged cars\nnu = model.addVars(d2w, name=\"UDcars\")\n\n# Number of damaged cars\nnd = model.addVars(d2w, name=\"Dcars\")\n\n# Number of cars hired (rented) cannot exceed their demand\ntr = model.addVars(d2w, ub=demand, name=\"Hcars\")\n#for d,t in d2w:\n    #tr[d,t].lb = 1\n\n# End inventory of undamaged cars\neu = model.addVars(d2w, name=\"EUDcars\")\n\n# End inventory of damaged cars\ned = model.addVars(d2w, name=\"EDcars\")\n\n# Number of undamaged cars transferred\ntu = model.addVars(dd2t, name=\"TUDcars\")\n\n# Number of damaged cars transferred\ntd = model.addVars(dd2t, name=\"TDcars\")\n\n# Number of damaged cars repaired\nrp = model.addVars(d2w, name=\"RPcars\")\n\n# Number of damaged cars repaired cannot exceed depot capacity\nfor d,t in d2w:\n    if d == 'Glasgow':\n        rp[d,t].ub = capacity[d] #repair capacity of Glasgow is zero\n        \n# Expansion of capacity binary variables\nzB1 = model.addVar(vtype=GRB.BINARY, name='expCapB1') # Expansion at Birmingham\n\nzB2 = model.addVar(vtype=GRB.BINARY, name='expCapB2') # Extra expansion at Birmingham\n\nzM1 = model.addVar(vtype=GRB.BINARY, name='expCapM1') # Expansion at Manchester\n\nzM2 = model.addVar(vtype=GRB.BINARY, name='expCapM2') # Extra expansion at Manchester\n\nzP = model.addVar(vtype=GRB.BINARY, name='expCapP') # Expansion at Plymouth\n\n# Undamaged cars into a non-repair depot constraints (left hand side of balance equation -availability)\n\nUDcarsNRD_L = model.addConstrs((gp.quicksum(pctUndamaged*pctFromToD[d2,d]*pctRent[r]*tr[d2,(t-r)%6 ] for d2,r in dr ) \n                              + gp.quicksum(tu.select('*',d,(t-1)%6)  ) \n                              + eu[d,(t-1)%6 ] == nu[d,t] for d in NRD for t in days ), \n                             name=\"UDcarsNRD_L\")\n\n# Undamaged cars out of a non-repair depot constraints (right hand side of balance equation -requirements)\n\nUDcarsNRD_R = model.addConstrs((tr[d,t] \n                                + gp.quicksum(tu.select(d,'*',t )) \n                                + eu[d,t] == nu[d,t] for d in NRD for t in days ), name='UDcarsNRD_R' )\n\n# Undamaged cars into a repair depot constraints (left hand side of balance equation -availability)\n\nUDcarsRD_L = model.addConstrs((gp.quicksum(pctUndamaged*pctFromToD[d2,d]*pctRent[r]*tr[d2,(t-r)%6 ] for d2,r in dr ) \n                              + gp.quicksum(tu.select('*',d,(t-1)%6)  ) + rp[d, (t-1)%6 ]\n                              + eu[d,(t-1)%6 ] == nu[d,t] for d in RD for t in days ), \n                             name=\"UDcarsRD_L\")\n\n# Undamaged cars out of a repair depot constraints (right hand side of balance equation -requirements)\n\nUDcarsRD_R = model.addConstrs((tr[d,t] \n                                + gp.quicksum(tu.select(d,'*',t ) ) \n                                + eu[d,t] == nu[d,t] for d in RD for t in days ), name='UDcarsRD_R' )\n\n# Damaged cars into a non-repair depot constraints (left hand side of balance equation -availability)\n\nDcarsNRD_L = model.addConstrs((gp.quicksum(pctDamaged*pctFromToD[d2,d]*pctRent[r]*tr[d2,(t-r)%6 ] for d2,r in dr ) \n                              + ed[d,(t-1)%6 ] == nd[d,t] for d in NRD for t in days ), \n                             name=\"DcarsNRD_L\")\n\n# Damaged cars out of a non-repair depot constraints (right hand side of balance equation -requirements)\n\nDcarsNRD_R = model.addConstrs(( gp.quicksum(td[d,d2,t] for d2 in RD ) \n                                + ed[d,t] == nd[d,t] for d in NRD for t in days ), name='DcarsNRD_R' )\n\n# Damaged cars into a repair depot constraints (left hand side of balance equation -availability)\n\nDcarsRD_L = model.addConstrs((gp.quicksum(pctDamaged*pctFromToD[d2,d]*pctRent[r]*tr[d2,(t-r)%6 ] for d2,r in dr )\n                              + gp.quicksum(td[d2,d,(t-1)%6 ] for d2, dd in d2notd if (dd == d)) \n                              + ed[d,(t-1)%6 ] == nd[d,t] for d in RD for t in days ), \n                             name=\"DcarsRD_L\")\n\n# Damaged cars out of a repair depot constraints (right hand side of balance equation -requirements)\n\nDcarsND_R = model.addConstrs((rp[d,t] + gp.quicksum(td[d,d2,t ] for d2 in NRD ) \n                                + ed[d,t] == nd[d,t] for d in RD for t in days ), name='DcarsND_R' )\n\n# Total number of cars owned constraint\n# Note: 25% of cars are rented for 3 days, and 20% + 25% = 45% of the cars are rented for 2-days or 3-days\n\ncarsConstr = model.addConstr((gp.quicksum(0.25*tr[d,0] + 0.45*tr[d,1] + nu[d,2] + nd[d,2] for d in depots ) \n                              == n ),name='carsConstr')\n\n# Depot capacity constraints\n\nRepairCapB = model.addConstrs((rp['Birmingham',t] <= capacity['Birmingham'] \n                               + 5*(zB1 + zB2) for t in days ), name='RepairCapB')\n\nRepairCapM = model.addConstrs((rp['Manchester',t] <= capacity['Manchester'] \n                               + 5*(zM1 + zM2) for t in days ), name='RepairCapM')\n\nRepairCapP = model.addConstrs((rp['Plymouth',t] <= capacity['Plymouth'] \n                               + 5*zP for t in days ), name='RepairCapP')\n\n# Additional expansion constraints\n\nexpandB1B2 = model.addConstr((zB1 >= zB2 ), name='expandB1B2')\n\nexpandM1M2 = model.addConstr((zM1 >= zM2 ), name='expandM1M2')\n\n# At most three expansions are possible\n\natMost3 = model.addConstr((zB1 + zB2 + zM1 + zM2 + zP <= 3), name='atMost3')\n\n# Maximize profit objective function.\n\nmodel.setObjective((\n    gp.quicksum(pctFromToD[d,d]*pctRent[r]*(priceSameD[r] - costMarginal[r] + damagedFee)*tr[d,t] for d,t,r in dtr )\n    + gp.quicksum(pctFromToD[d,d2]*pctRent[r]*(priceOtherD[r]-costMarginal[r]+damagedFee)*tr[d,t] for d,d2,t,r in dd2tr)\n    - gp.quicksum(cstFromToD[d,d2]*tu[d,d2,t] for d,d2,t in dd2t) \n    - gp.quicksum(cstFromToD[d,d2]*td[d,d2,t] for d,d2,t in dd2t) \n    -(cstExpCapB1*zB1 + cstExpCapB2*zB2 + cstExpCapM1*zM1 + cstExpCapM2*zM2 + cstExpCapP*zP) - cstOwn*n ), GRB.MAXIMIZE)\n\n# Verify model formulation\n\nmodel.write('CarRental2.lp')\n\n# Run optimization engine\n\nmodel.optimize()\n\n# Output report\n\n# Total number of cars owned\nprint(f\"The optimal number of cars to be owned is: {round(n.x)}\")\n\n# Optimal profit\nprint(f\"The optimal profit is: {'${:,.2f}'.format(round(model.objVal,2))}\")\n\n# Repair capacity expansion plan\n\nif zB1.x > 0.5:\n    print(f\"The depot at Birmingham expanded its capacity to 5 more cars per day\")\n    if zB2.x > 0.5:\n        print(f\"The depot at Birmingham further expanded 5 more cars per day of additional capacity\")\n\nif zM1.x > 0.5:\n    print(f\"The depot at Manchester expanded its capacity to 5 more cars per day\")\n    if zM2.x > 0.5:\n        print(f\"The depot at Manchester further expanded 5 more cars per day of additional capacity\")\n\nif zP.x > 0.5:\n    print(f\"The depot at Plymouth expanded its capacity to 5 more cars per day\")\n\n# Create a list to translate the number label of each day to the actual name of the day\ndayname = ['Monday','Tuesday','Wednesday','Thursday','Friday','Saturday']\n\n# Number of undamaged cars in depot at the beginning of each day.\nprint(\"\\n\\n_________________________________________________________________________________\")\nprint(f\"Estimated number of undamaged cars in depot at the beginning of each day: \")\nprint(\"_________________________________________________________________________________\")\n\nundamaged_cars = pd.DataFrame(\n    {\n        \"Day\": [dayname[t] for t in days],\n        \"Glasgow\": [round(nu['Glasgow',t].x) for t in days],\n        \"Manchester\": [round(nu['Manchester',t].x) for t in days],\n        \"Birmingham\": [round(nu['Birmingham',t].x) for t in days],\n        \"Plymouth\": [round(nu['Plymouth',t].x) for t in days],\n    }\n)\nundamaged_cars.index=[''] * len(undamaged_cars)\nundamaged_cars\n\n# Number of Damaged cars in depot at the beginning of each day.\nprint(\"_________________________________________________________________________________\")\nprint(f\"Estimated number of damaged cars in depot at the beginning of each day: \")\nprint(\"_________________________________________________________________________________\")\n\ndamaged_cars = pd.DataFrame(\n    {\n        \"Day\": [dayname[t] for t in days],\n        \"Glasgow\": [round(nd['Glasgow',t].x) for t in days],\n        \"Manchester\": [round(nd['Manchester',t].x) for t in days],\n        \"Birmingham\": [round(nd['Birmingham',t].x) for t in days],\n        \"Plymouth\": [round(nd['Plymouth',t].x) for t in days],\n    }\n)\ndamaged_cars.index=[''] * len(damaged_cars)\ndamaged_cars\n\n# Undamaged car rented out from each depot and day.\nprint(\"_________________________________________________________________________________\")\nprint(f\"Estimated number of undamaged cars rented out from each depot and day: \")\nprint(\"_________________________________________________________________________________\")\n\nrentedOut = {}\n\nfor d in depots:\n    for t in days:\n        count = 0\n        for d2 in depots:\n            for r in rentDays:\n                #print(f\"Depot {d}, day {t}: cars rented out {tr[d,t].x}\")\n                count += pctUndamaged*pctFromToD[d,d2]*pctRent[r]*tr[d,t].x\n        rentedOut[d,t] = round(count)\n    \n\n#print(rentedOut)\n\nrentout_cars = pd.DataFrame(\n    {\n        \"Day\": [dayname[t] for t in days],\n        \"Glasgow\": [round(rentedOut['Glasgow',t]) for t in days],\n        \"Manchester\": [round(rentedOut['Manchester',t]) for t in days],\n        \"Birmingham\": [round(rentedOut['Birmingham',t]) for t in days],\n        \"Plymouth\": [round(rentedOut['Plymouth',t]) for t in days],\n    }\n)\nrentout_cars.index=[''] * len(rentout_cars)\nrentout_cars"}]}
{"meta": {"source_path": "/Users/sunyujun03/Desktop/ReLoop/gurobi-modeling-examples/car_rental/car_rental_1.ipynb", "kind": "ipynb", "title": "Car Rental 1"}, "messages": [{"role": "system", "content": "You are an optimization engineer. Write correct and runnable Python code using gurobipy (Gurobi Python API). Be concise. Output only what is requested."}, {"role": "user", "content": "    Task: Reproduce the following Gurobi modeling example in Python using gurobipy.\n\n    Scenario description (from source):\n    # Car Rental 1\n\n## Objective and Prerequisites\n\nBoost your modeling skills with this example, which will teach you how you can use mathematical optimization to figure out how many cars a car rental company should own and where they should be located every day to maximize weekly profits.\n\nThis model is example 25 from the fifth edition of Model Building in Mathematical Programming by H. Paul Williams on pages 284-286 and 340-342.\n\nThis example is at the intermediate level, where we assume that you know Python and the Gurobi Python API and that you have some knowledge of building mathematical optimization models.\n\n**Download the Repository** <br /> \nYou can download the repository containing this and other examples by clicking [here](https://github.com/Gurobi/modeling-examples/archive/master.zip). \n\n---\n## Problem Description\n\nA small car rental company (which rents only one type of car) has depots in Glasgow, Manchester, Birmingham and Plymouth. There is an estimated demand for each day of the week except Sunday (when the company is closed). These estimates are given in the following table. It is not necessary to meet all demand.\n\n![weeklyDemand](weeklyDemand.PNG)\n\nCars can be rented for one, two or three days and returned to either the\ndepot from which they were rented or another depot at the start of the next morning. For\nexample, a 2-day rental on Thursday means that the car has to be returned on\nSaturday morning; a 3-day rental on Friday means that the car has to be returned\non Tuesday morning. A 1-day rental on Saturday means that the car has to be\nreturned on Monday morning, and a 2-day rental on Tuesday morning.\n\nThe rental period is independent of the origin and destination. From historical\ndata, the company knows the distribution of rental periods: 55% of cars are hired\nfor one day, 20% for two days, and 25% for three days. The current estimates\nof percentages of cars rented from each depot and returned to a given depot\n(independent of the day) are given in the following table.\n\n![FromToPct](FromToPct.PNG)\n\nThe company's marginal cost of renting out a car (‘wear and tear’, administration, etc.) is estimated as follows:\n\n| Days rented | Marginal cost |\n| --- | --- |\n| 1-day | $\\$ 20$ |\n| 2-day | $\\$ 25$ |\n| 3-day | $\\$ 30$ |\n\nThe ‘opportunity cost’ (interest on capital, storage, servicing, etc.) of owning\na car is $\\$ 15$ per week.\n\nIt is possible to transfer undamaged cars from one depot to another depot,\nirrespective of distance. Cars cannot be rented out during the day in which they\nare transferred. The costs in USD, per car, of transfer are given in the following table.\n\n![FromToCst](FromToCst.PNG)\n\nTen percent of cars returned by customers are damaged. When this happens,\nthe customer is charged an excess of $\\$ 100$  (irrespective of the amount of damage\nthat the company completely covers by its insurance). In addition, the car has\nto be transferred to a repair depot, where it will be repaired the following day.\nThe cost of transferring a damaged car is the same as transferring an undamaged\none (except when the repair depot is the current depot, \nin which case the cost would be $\\$0$). The transfer of a damaged car takes a day, unless it is already at a repair depot.\nHaving arrived at a repair depot, all types of repair (or replacement) take a day.\nOnly two of the depots have repair capacity. The (cars/day) capacity at each repair depot is as follows:\n\n| Repair depot | Capacity |\n| --- | --- |\n| Manchester | 12 |\n| Birmingham | 20 |\n\nHaving been repaired, the car is available for rent at the depot the next day\nor may be transferred to another depot (taking a day). Thus, a car that is returned\ndamaged on a Wednesday morning is transferred to a repair depot (if not the\ncurrent depot) on Wednesday, repaired on Thursday, and is available for rent\nat the repair depot on Friday morning.\nThe rental price depends on the number of days for which the car is rented\nand whether it is returned to the same depot or not. The prices (in USD) are given in the following table.\n\n![RentalPrice](RentalPrice.PNG)\n\nWe assume the following at the beginning of each day:\n1. Customers return cars that are due that day.\n2. Damaged cars are sent to the repair depot.\n3. Cars that were transferred from other depots arrive.\n4. Transfers are sent out.\n5. Cars are rented out.\n6. If it is a repair depot, then the repaired cars are available for rental.\n\nThe goal is to determine the numbers of cars the car rental company should own and where should they be located at the start of each week day in order to maximize weekly profit. The company wants a ‘steady state’ solution\nin which the same expected number of cars will be located at the same depot on\nthe same day of subsequent weeks.\n\n---\n## Model Formulation\n\n$d,d2 \\in \\text{Depots}=\\{\\text{Glasgow}, \\text{Manchester}, \\text{Birmingham},  \\text{Plymouth}\\}$\n\n$\\text{NRD}=\\{\\text{Glasgow}, \\text{Plymouth}\\}$: Depots without repair capacity.\n\n$\\text{RD}=\\{\\text{Manchester}, \\text{Birmingham}\\}$: Depots with repair capacity.\n\n$t \\in \\text{Days}=\\{\\text{Monday},\\text{Tuesday},\\text{Wednesday},\\text{Thursday},\\text{Friday},\\text{Saturday}\\}$\n\n$r \\in \\text{RentDays}=\\{1,2,3\\}$: Number of days rented.\n\n### Parameters\n\n$\\text{demand}_{d,t} \\in \\mathbb{R}^+$: Estimated rental demand at depot $d$ on day $t$.\n\n$\\text{pctDepot}_{d,d2} \\in \\mathbb{R}^+$: Proportion of cars rented at depot $d$ to be returned to depot $d2$.\n\n$\\text{cstTransfer}_{d,d2} \\in \\mathbb{R}^+$: Transfer cost of a car from depot $d$ to depot $d2$.\n\n$\\text{pctRent}_{r} \\in \\mathbb{R}^+$: Proportion of cars rented for $r$ days.\n\n$\\text{capRepair}_{d} \\in \\mathbb{R}^+$: Repair capacity of depot $d$.\n\n$\\text{cstSameDepot}_{r} \\in \\mathbb{R}^+$: Rental cost for $r$ days with return to same depot.\n\n$\\text{cstOtherDepot}_{r} \\in \\mathbb{R}^+$: Rental cost for $r$ days with return to other depot.\n\n$\\text{marginalCost}_{r} \\in \\mathbb{R}^+$: Marginal cost to company of  $r$ days rental of a car.\n\n$\\text{pctUndamaged } \\in [0,1]$: Percent of cars returned by customers that are undamaged.\n\n$\\text{pctDamaged  } \\in [0,1]$: Percent of cars returned by customers that are damaged.\n\n$\\text{cstOwn} \\in \\mathbb{R}^+$: Cost of owning a car.\n\n$\\text{damagedFee} = 10$: Damaged car fee. Ten percent of the cars are damaged and the fee for a damaged car is $\\$100$.\n\n### Decision Variables\n\n$\\text{xOwned} \\in \\mathbb{R}^+$: Total number of cars owned.\n\n$\\text{xUndamaged}_{d,t} \\in \\mathbb{R}^+$: Number of undamaged cars available at depot $d$ at the beginning of day $t$.\n\n$\\text{xDamaged}_{d,t} \\in \\mathbb{R}^+$: Number of damaged cars available at depot $d$ at the beginning of day $t$.\n\n$\\text{xRented}_{d,t} \\in \\mathbb{R}^+$: number of cars rented  out from depot $d$ at the beginning of day $t$.\n\n$\\text{xUDleft}_{d,t} \\in \\mathbb{R}^+$: Number of undamaged cars available at depot $d$ at the beginning of day $t$.\n\n$\\text{xDleft}_{d,t} \\in \\mathbb{R}^+$: Number of damaged cars left in depo $d$ at the end of day  $t$.\n\n$\\text{xUDtransfer}_{d,d2,t} \\in \\mathbb{R}^+$: Number of undamaged cars  at depot $d$ at the beginning of day $t$, to be transferred to depot $d2$. \n\n$\\text{xDtransfer}_{d,d2,t} \\in \\mathbb{R}^+$: Number of damaged cars at depot $d$ at the beginning of day $t$, to be transferred to depot $d2$. \n\n$\\text{xRepaired}_{d,t} \\in \\mathbb{R}^+$: Number of damaged cars to be repaired at depot $d$ during day $t$.\n\n### Objective function\nThe objective is to maximize profit.\n\n\\begin{equation}\n\\sum_{d \\in \\text{Depots}}\n\\sum_{t \\in \\text{Days}}\n\\sum_{r \\in \\text{RentDays}} \n\\text{pctDepot}_{d,d}*\\text{pctRent}_{r}*(\\text{cstSameDepot}_{r} - \\text{marginalCost}_{r} + \\text{damagedFee})*\\text{xRented}_{d,t}\n\\end{equation}\n\n\\begin{equation}\n+ \\sum_{d \\in \\text{Depots}} \\sum_{d2 \\in \\text{Depots}}\n\\sum_{t \\in \\text{Days}}\n\\sum_{r \\in \\text{RentDays}} \n\\text{pctDepot}_{d,d2}*\\text{pctRent}_{r}*(\\text{cstOtherDepot}_{r} - \\text{marginalCost}_{r} + \\text{damagedFee})*\\text{xRented}_{d,t}\n\\end{equation}\n\n\\begin{equation}\n- \\sum_{d \\in \\text{Depots}} \\sum_{d2 \\in \\text{Depots}}\n\\sum_{t \\in \\text{Days}} \\text{cstTransfer}_{d,d2}*(\\text{xUDtransfer}_{d,d2,t} + \\text{xDtransfer}_{d,d2,t} )\n- \\text{cstOwn}*\\text{xOwned}\n\\end{equation}\n\n### Constraints\n\n**Undamaged cars at a non-repair depot** <br />\nNumber of undamaged cars available at a non-repair depot $d$ at the beginning of day $t$.\n\n\\begin{equation}\n\\sum_{d2 \\in \\text{Depots}} \n\\sum_{r \\in \\text{RentDays}} \\text{pctUndamaged}*\\text{pctDepot}_{d2,d}*\\text{pctRent}_{r}*\\text{xRented}_{d2,(t-r)mod(6)}\n\\end{equation}\n\n\\begin{equation}\n+ \\sum_{d2 \\in \\text{Depots}} \\text{xUDtransfer}_{d2,d,(t-1)mod(6)} + \\text{xUDleft}_{d,(t-1)mod(6)} = \\text{xUndamaged}_{d,t} \n\\quad \\forall d \\in NRD, t \\in Days\n\\end{equation}\n\nDemand of undamaged cars at the non-repair depot $d$ during day $t$.\n\n\\begin{equation}\n\\text{xUndamaged}_{d,t} = \\text{xRented}_{d,t} + \n\\sum_{d2 \\in \\text{Depots}} \\text{xUDtransfer}_{d,d2,t} + \\text{xUDleft}_{d,t}\n\\quad \\forall d \\in NRD, t \\in Days\n\\end{equation}\n\n**Undamaged cars at a repair depot** <br />\nNumber of undamaged cars available at a repair depot $d$ at the beginning of day $t$.\n\n\\begin{equation}\n\\sum_{d2 \\in \\text{Depots}} \n\\sum_{r \\in \\text{RentDays}} \\text{pctUndamaged}*\\text{pctDepot}_{d2,d}*\\text{pctRent}_{r}*\\text{xRented}_{d2,(t-r)mod(6)}\n\\end{equation}\n\n\\begin{equation}\n+ \\sum_{d2 \\in \\text{Depots}} \\text{xUDtransfer}_{d2,d,(t-1)mod(6)} \n+ \\text{xRepaired}_{d,(t-1)mod(6)}  + \\text{xUDleft}_{d,(t-1)mod(6)} = \\text{xUndamaged}_{d,t} \n\\quad \\forall d \\in NRD, t \\in Days\n\\end{equation}\n\nDemand of undamaged cars at the repair depot $d$ during day $t$.\n\n\\begin{equation}\n\\text{xUndamaged}_{d,t} = \\text{xRented}_{d,t} + \n\\sum_{d2 \\in \\text{Depots}} \\text{xUDtransfer}_{d,d2,t} + \\text{xUDleft}_{d,t}\n\\quad \\forall d \\in NRD, t \\in Days\n\\end{equation}\n\n**Damaged cars at a non-repair depot** <br />\nNumber of damaged cars available at a non-repair depot $d$ at the beginning of day $t$.\n\n\\begin{equation}\n\\sum_{d2 \\in \\text{Depots}} \n\\sum_{r \\in \\text{RentDays}} \\text{pctDamaged}*\\text{pctDepot}_{d2,d}*\\text{pctRent}_{r}*\\text{xRented}_{d2,(t-r)mod(6)}\n\\end{equation}\n\n\\begin{equation}\n+ \\text{xDleft}_{d,(t-1)mod(6)} = \\text{xDamaged}_{d,t} \\quad \\forall d \\in NRD, t \\in Days\n\\end{equation}\n\nDemand of undamaged cars at the non-repair depot $d$ during day $t$.\n\n\\begin{equation}\n\\text{xDamaged}_{d,t} = \n\\sum_{d2 \\in \\text{Depots} \\cap RD} \\text{xDtransfer}_{d,d2,t} + \\text{xDleft}_{d,t}\n\\quad \\forall d \\in NRD, t \\in Days\n\\end{equation}\n\n**Damaged cars at a repair depot** <br />\nNumber of damaged cars available at a repair depot $d$ at the beginning of day $t$.\n\n\\begin{equation}\n\\sum_{d2 \\in \\text{Depots}} \n\\sum_{r \\in \\text{RentDays}} \\text{pctDamaged}*\\text{pctDepot}_{d2,d}*\\text{pctRent}_{r}*\\text{xRented}_{d2,(t-r)mod(6)}\n\\end{equation}\n\n\\begin{equation}\n+ \\sum_{d2 \\in \\text{Depots}} \\text{xDtransfer}_{d2,d,(t-1)mod(6)} \n+ \\text{xDleft}_{d,(t-1)mod(6)} = \\text{xdamaged}_{d,t} \n\\quad \\forall d \\in RD, t \\in Days\n\\end{equation}\n\nDemand of undamaged cars at the non-repair depot $d$ during day $t$.\n\n\\begin{equation}\n\\text{xDamaged}_{d,t} = \\text{xRepaired}_{d,t} +\n\\sum_{d2 \\in \\text{Depots} \\cap RD} \\text{xDtransfer}_{d,d2,t} + \\text{xDleft}_{d,t}\n\\quad \\forall d \\in RD, t \\in Days\n\\end{equation}\n\n**Depot Capacity** <br />\nRepair capacity of depot $d$ for each day $t$. \n\n\\begin{equation}\n\\text{xRepaired}_{d,t} \\leq \\text{capRepair}_{d}\n\\quad \\forall d \\in Depots, t \\in Days\n\\end{equation}\n\n**Depot Demand** <br />\nDemand at depot $d$ for each day $t$. \n\n\\begin{equation}\n\\text{xRented}_{d,t} \\leq \\text{demand}_{d,t}\n\\quad \\forall d \\in Depots, t \\in Days\n\\end{equation}\n\n**Number of cars** <br />\nTotal number of cars owned equals number of cars rented out from all depots on Monday for 3 days, plus those on Tuesday for 2 or 3 days, plus all damaged and undamaged cars in depots at the beginning of Wednesday. \nRationale: Let’s pick a day (Wednesday), count the cars undamaged and damaged that were returned to the depots and that are available on Wednesday morning. Let’s count the cars that have been rented and have not been returned: Cars rented on Monday for 3 days, and cars rented on Tuesday for 2 or 3 days.\n\n\\begin{equation}\n\\sum_{d \\in \\text{Depots}} (0.25*\\text{xRented}_{d,0} + 0.45*\\text{xRented}_{d,1} + \\text{xUndamaged}_{d,2}  + \\text{xdamaged}_{d,2} ) = \\text{xOwned}\n\\end{equation}\n\n---\n## Python Implementation\n\nWe import the Gurobi Python Module and other Python libraries.\n\n    Requirements:\n    - Use gurobipy (Model, GRB, addVar/addConstr, etc.)\n    - Make the script runnable as a standalone Python file if possible.\n    - Keep the code faithful to the example.\n"}, {"role": "assistant", "content": "import pandas as pd\nfrom itertools import product\n\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# tested with Python 3.11 & Gurobi 11.0\n\n# list of depots and working days of a week\n\ndepots = ['Glasgow','Manchester','Birmingham','Plymouth']\nNRD = ['Glasgow','Plymouth'] # Non-repair depot\nRD =['Manchester','Birmingham'] # Repair depot\n\ndays = [0,1,2,3,4,5] # Monday = 0, Tuesday = 1, ...  Saturday = 5\nrentDays = [1,2,3]\n\nd2w, demand = gp.multidict({\n    ('Glasgow',0): 100,\n    ('Glasgow',1): 150,\n    ('Glasgow',2): 135,\n    ('Glasgow',3): 83,\n    ('Glasgow',4): 120,\n    ('Glasgow',5): 230,\n    ('Manchester',0): 250,\n    ('Manchester',1): 143,\n    ('Manchester',2): 80,\n    ('Manchester',3): 225,\n    ('Manchester',4): 210,\n    ('Manchester',5): 98,\n    ('Birmingham',0): 95,\n    ('Birmingham',1): 195,\n    ('Birmingham',2): 242,\n    ('Birmingham',3): 111,\n    ('Birmingham',4): 70,\n    ('Birmingham',5): 124,\n    ('Plymouth',0): 160,\n    ('Plymouth',1): 99,\n    ('Plymouth',2): 55,\n    ('Plymouth',3): 96,\n    ('Plymouth',4): 115,\n    ('Plymouth',5): 80\n})\n\n#repairCap\ndepots, capacity = gp.multidict({\n    ('Glasgow'): 0,\n    ('Manchester'): 12,\n    ('Birmingham'): 20,\n    ('Plymouth'): 0\n})\n\n# Create a dictionary to capture \n# pctRent: percentage of cars rented for r days \n# cstMarginal: marginal cost for renting a car for r days\n# prcSameD: price of renting a car r days and returning to same depot\n# prcOtherD: price of renting a car r days and returning to another depot\nrentDays, pctRent, costMarginal, priceSameD, priceOtherD = gp.multidict({\n    (1): [0.55,20,50,70],\n    (2): [0.20,25,70,100],\n    (3): [0.25,30,120,150]\n})\n\n# Cost of owing a car per week.\ncstOwn = 15\n\n# Proportional damaged car fee\ndamagedFee = 10\n\n# Create a dictionary to capture the proportion of cars rented at depot d to be returned to depot d2 \nd2d, pctFromToD = gp.multidict({\n    ('Glasgow','Glasgow'): 0.6,\n    ('Glasgow','Manchester'): 0.2,\n    ('Glasgow','Birmingham'): 0.1,\n    ('Glasgow','Plymouth'): 0.1,\n    ('Manchester','Glasgow'): 0.15,\n    ('Manchester','Manchester'): 0.55,\n    ('Manchester','Birmingham'): 0.25,\n    ('Manchester','Plymouth'): 0.05,\n    ('Birmingham','Glasgow'): 0.15,\n    ('Birmingham','Manchester'): 0.2,\n    ('Birmingham','Birmingham'): 0.54,\n    ('Birmingham','Plymouth'): 0.11,\n    ('Plymouth','Glasgow'): 0.08,\n    ('Plymouth','Manchester'): 0.12,\n    ('Plymouth','Birmingham'): 0.27,\n    ('Plymouth','Plymouth'): 0.53\n})\n\n# Create a dictionary to capture the transfer costs  of cars\nd2d, cstFromToD = gp.multidict({\n    ('Glasgow','Glasgow'): 0.001,\n    ('Glasgow','Manchester'): 20,\n    ('Glasgow','Birmingham'): 30,\n    ('Glasgow','Plymouth'): 50,\n    ('Manchester','Glasgow'): 20,\n    ('Manchester','Manchester'): 0.001,\n    ('Manchester','Birmingham'): 15,\n    ('Manchester','Plymouth'): 35,\n    ('Birmingham','Glasgow'): 30,\n    ('Birmingham','Manchester'): 15,\n    ('Birmingham','Birmingham'): 0.001,\n    ('Birmingham','Plymouth'): 25,\n    ('Plymouth','Glasgow'): 50,\n    ('Plymouth','Manchester'): 35,\n    ('Plymouth','Birmingham'): 25,\n    ('Plymouth','Plymouth'): 0.001\n})\n\n# Proportion of undamaged and damaged cars returned\npctUndamaged = 0.9\npctDamaged = 0.1\n\n# Build a list of tuples (depot, depot2) such that d != d2\nlist_d2notd = []\n\nfor d,d2 in d2d:\n    if (d != d2):\n        tp = d,d2\n        list_d2notd.append(tp)\n\nd2notd = gp.tuplelist(list_d2notd)\n\n# Build a list of tuples (depot, depot2, day)\nlist_dd2t = []\n\nfor d,d2 in d2notd:\n    for t in days:\n        tp = d,d2,t \n        list_dd2t.append(tp)\n                    \ndd2t = gp.tuplelist(list_dd2t)\n\n# Build a list of tuples (depot, rent_day)\nlist_dr = []\n\nfor d in depots:\n    for r in rentDays:\n        tp = d,r\n        list_dr.append(tp)\n        \ndr = gp.tuplelist(list_dr) \n\n# Build a list of tuples (depot, day, rent_days )\nlist_dtr = []\n\nfor d in depots:\n    for t in days:\n            for r in rentDays:\n                tp = d,t,r\n                list_dtr.append(tp)\n                \ndtr = gp.tuplelist(list_dtr) \n\n# Build a list of tuples (depot, depot2, day, rent_days)\nlist_dd2tr = []\n\nfor d,d2 in d2notd:\n    for t in days:\n        for r in rentDays:\n            tp = d,d2,t,r\n            list_dd2tr.append(tp)\n                    \n                    \ndd2tr = gp.tuplelist(list_dd2tr)\n\nmodel = gp.Model('RentalCar1')\n\n# Number of cars owned\nn = model.addVar(name=\"cars\")\n\n# Number of undamaged cars\nnu = model.addVars(d2w, name=\"UDcars\")\n\n# Number of damaged cars\nnd = model.addVars(d2w, name=\"Dcars\")\n\n# Number of cars hired (rented) cannot exceed their demand\ntr = model.addVars(d2w, ub=demand, name=\"Hcars\")\n#for d,t in d2w:\n    #tr[d,t].lb = 1\n\n# End inventory of undamaged cars\neu = model.addVars(d2w, name=\"EUDcars\")\n\n# End inventory of damaged cars\ned = model.addVars(d2w, name=\"EDcars\")\n\n# Number of undamaged cars transferred\ntu = model.addVars(dd2t, name=\"TUDcars\")\n\n# Number of damaged cars transferred\ntd = model.addVars(dd2t, name=\"TDcars\")\n\n# Number of damaged cars repaired\nrp = model.addVars(d2w, name=\"RPcars\")\n\n# Number of damaged cars repaired cannot exceed depot capacity\nfor d,t in d2w:\n    rp[d,t].ub = capacity[d] #repair capacity\n\n# Undamaged cars into a non-repair depot constraints (left hand side of balance equation -availability)\n\nUDcarsNRD_L = model.addConstrs((gp.quicksum(pctUndamaged*pctFromToD[d2,d]*pctRent[r]*tr[d2,(t-r)%6 ] for d2,r in dr ) \n                              + gp.quicksum(tu.select('*',d,(t-1)%6)  ) \n                              + eu[d,(t-1)%6 ] == nu[d,t] for d in NRD for t in days ), \n                             name=\"UDcarsNRD_L\")\n\n# Undamaged cars out of a non-repair depot constraints (right hand side of balance equation -requirements)\n\nUDcarsNRD_R = model.addConstrs((tr[d,t] \n                                + gp.quicksum(tu.select(d,'*',t )) \n                                + eu[d,t] == nu[d,t] for d in NRD for t in days ), name='UDcarsNRD_R' )\n\n# Undamaged cars into a repair depot constraints (left hand side of balance equation -availability)\n\nUDcarsRD_L = model.addConstrs((gp.quicksum(pctUndamaged*pctFromToD[d2,d]*pctRent[r]*tr[d2,(t-r)%6 ] for d2,r in dr ) \n                              + gp.quicksum(tu.select('*',d,(t-1)%6)  ) + rp[d, (t-1)%6 ]\n                              + eu[d,(t-1)%6 ] == nu[d,t] for d in RD for t in days ), \n                             name=\"UDcarsRD_L\")\n\n# Undamaged cars out of a repair depot constraints (right hand side of balance equation -requirements)\n\nUDcarsRD_R = model.addConstrs((tr[d,t] \n                                + gp.quicksum(tu.select(d,'*',t ) ) \n                                + eu[d,t] == nu[d,t] for d in RD for t in days ), name='UDcarsRD_R' )\n\n# Damaged cars into a non-repair depot constraints (left hand side of balance equation -availability)\n\nDcarsNRD_L = model.addConstrs((gp.quicksum(pctDamaged*pctFromToD[d2,d]*pctRent[r]*tr[d2,(t-r)%6 ] for d2,r in dr ) \n                              + ed[d,(t-1)%6 ] == nd[d,t] for d in NRD for t in days ), \n                             name=\"DcarsNRD_L\")\n\n# Damaged cars out of a non-repair depot constraints (right hand side of balance equation -requirements)\n\nDcarsNRD_R = model.addConstrs(( gp.quicksum(td[d,d2,t] for d2 in RD ) \n                                + ed[d,t] == nd[d,t] for d in NRD for t in days ), name='DcarsNRD_R' )\n\n# Damaged cars into a repair depot constraints (left hand side of balance equation -availability)\n\nDcarsRD_L = model.addConstrs((gp.quicksum(pctDamaged*pctFromToD[d2,d]*pctRent[r]*tr[d2,(t-r)%6 ] for d2,r in dr )\n                              + gp.quicksum(td[d2,d,(t-1)%6 ] for d2, dd in d2notd if (dd == d)) \n                              + ed[d,(t-1)%6 ] == nd[d,t] for d in RD for t in days ), \n                             name=\"DcarsRD_L\")\n\n# Damaged cars out of a repair depot constraints (right hand side of balance equation -requirements)\n\nDcarsND_R = model.addConstrs((rp[d,t] + gp.quicksum(td[d,d2,t ] for d2 in NRD ) \n                                + ed[d,t] == nd[d,t] for d in RD for t in days ), name='DcarsND_R' )\n\n# Total number of cars owned constraint\n# Note: 25% of cars are rented for 3 days, and 20% + 25% = 45% of the cars are rented for 2-days or 3-days\n\ncarsConstr = model.addConstr((gp.quicksum(0.25*tr[d,0] + 0.45*tr[d,1] + nu[d,2] + nd[d,2] for d in depots ) \n                              == n ),name='carsConstr')\n\n# Maximize profit objective function\n\nmodel.setObjective((\n    gp.quicksum(pctFromToD[d,d]*pctRent[r]*(priceSameD[r] - costMarginal[r] + damagedFee)*tr[d,t] for d,t,r in dtr )\n    + gp.quicksum(pctFromToD[d,d2]*pctRent[r]*(priceOtherD[r]-costMarginal[r]+damagedFee)*tr[d,t] for d,d2,t,r in dd2tr)\n    - gp.quicksum(cstFromToD[d,d2]*tu[d,d2,t] for d,d2,t in dd2t) \n    - gp.quicksum(cstFromToD[d,d2]*td[d,d2,t] for d,d2,t in dd2t) - cstOwn*n ), GRB.MAXIMIZE)\n\n# Verify model formulation\n\nmodel.write('CarRental1.lp')\n\n# Run optimization engine\n\nmodel.optimize()\n\n# Output report\n\n# Total number of cars owned\nprint(f\"The optimal number of cars to be owned is: {round(n.x)}.\")\n\n# Optimal profit\nprint(f\"The optimal profit is: {'${:,.2f}'.format(round(model.objVal,2))}.\")\n\n# Create a list to translate the number label of each day to the actual name of the day\ndayname = ['Monday','Tuesday','Wednesday','Thursday','Friday','Saturday']\n\n# Number of undamaged cars in depot at the beginning of each day.\nprint(\"\\n\\n_________________________________________________________________________________\")\nprint(f\"Estimated number of undamaged cars in depot at the beginning of each day: \")\nprint(\"_________________________________________________________________________________\")\n\nundamaged_cars = pd.DataFrame(\n    {\n        \"Day\": [dayname[t] for t in days],\n        \"Glasgow\": [round(nu['Glasgow',t].x) for t in days],\n        \"Manchester\": [round(nu['Manchester',t].x) for t in days],\n        \"Birmingham\": [round(nu['Birmingham',t].x) for t in days],\n        \"Plymouth\": [round(nu['Plymouth',t].x) for t in days],\n    }\n)\nundamaged_cars.index=[''] * len(undamaged_cars)\nundamaged_cars\n\n# Number of Damaged cars in depot at the beginning of each day.\nprint(\"_________________________________________________________________________________\")\nprint(f\"Estimated number of damaged cars in depot at the beginning of each day: \")\nprint(\"_________________________________________________________________________________\")\n\ndamaged_cars = pd.DataFrame(\n    {\n        \"Day\": [dayname[t] for t in days],\n        \"Glasgow\": [round(nd['Glasgow',t].x) for t in days],\n        \"Manchester\": [round(nd['Manchester',t].x) for t in days],\n        \"Birmingham\": [round(nd['Birmingham',t].x) for t in days],\n        \"Plymouth\": [round(nd['Plymouth',t].x) for t in days],\n    }\n)\ndamaged_cars.index=[''] * len(damaged_cars)\ndamaged_cars\n\n# Undamaged car rented out from each depot and day.\nprint(\"_________________________________________________________________________________\")\nprint(f\"Estimated number of undamaged cars rented out from each depot and day: \")\nprint(\"_________________________________________________________________________________\")\n\nrentedOut = {}\n\nfor d in depots:\n    for t in days:\n        count = 0\n        for d2 in depots:\n            for r in rentDays:\n                #print(f\"Depot {d}, day {t}: cars rented out {tr[d,t].x}\")\n                count += pctUndamaged*pctFromToD[d,d2]*pctRent[r]*tr[d,t].x\n        rentedOut[d,t] = round(count)\n    \n\n#print(rentedOut)\n\nrentout_cars = pd.DataFrame(\n    {\n        \"Day\": [dayname[t] for t in days],\n        \"Glasgow\": [round(rentedOut['Glasgow',t]) for t in days],\n        \"Manchester\": [round(rentedOut['Manchester',t]) for t in days],\n        \"Birmingham\": [round(rentedOut['Birmingham',t]) for t in days],\n        \"Plymouth\": [round(rentedOut['Plymouth',t]) for t in days],\n    }\n)\nrentout_cars.index=[''] * len(rentout_cars)\nrentout_cars"}]}
{"meta": {"source_path": "/Users/sunyujun03/Desktop/ReLoop/gurobi-modeling-examples/optimization202/ESUPS_case_study/opti202_disaster_prepositioning.ipynb", "kind": "ipynb", "title": "opti202_disaster_prepositioning"}, "messages": [{"role": "system", "content": "You are an optimization engineer. Write correct and runnable Python code using gurobipy (Gurobi Python API). Be concise. Output only what is requested."}, {"role": "user", "content": "    Task: Reproduce the following Gurobi modeling example in Python using gurobipy.\n\n    Scenario description (from source):\n    ## Disaster Pre-positioning with Mathematical Optimization\n\nIn this notebook, we will take you through the end-to-end process of how ESUPS transformed from a simple idea into a global initiative that is reshaping disaster response logistics. We will delve into the crucial role that optimization plays in this transformation, demonstrating how ESUPS utilizes advanced algorithms to optimize the allocation and movement of disaster relief supplies.\n\n## 1. The Setup\n\nOur first step in the journey is reading and cleaning the data. We won't focus too much on this step because the really interesting stuff happens once we have the data loaded. However, we will showcase how the data needs to be formatted for Gurobi. If this is your first pass of the case study, feel free to skip over this section and return to it later when you want a more in-depth overview of formatting the data.\n\nBefore we begin, I wanted to make a quick note about a line of code you'll see repeated throughout the notebook: %%script false --no-raise-error\n\n- **NOTE:** This is just cell magic (if you're unfamiliar, think of it as using the cmd line) telling the notebook not to run this cell. We'll use it in various places to demonstrate ideas or code snippets that are not meant to produce an output.\n\n### 1.1 The Environment\n\n    Requirements:\n    - Use gurobipy (Model, GRB, addVar/addConstr, etc.)\n    - Make the script runnable as a standalone Python file if possible.\n    - Keep the code faithful to the example.\n"}, {"role": "assistant", "content": "from IPython.display import Image\nImage(filename='images/ESUPS-Logo.png', width=600)\n\nimport pandas as pd\nimport numpy as np\nimport math \n\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n#now hidden code\nfrom setup_imports import *\n\n#Set Up Our Data\nCOUNTRY = \"madagascar\"\n\nwarnings.filterwarnings('ignore') # type: ignore\nreader = CsvProblemReader() # type: ignore\ndataset = reader.read(DATA_DIR / COUNTRY) # type: ignore\n\n#The class is as follows\n@dataclass(frozen=True)\nclass Dataset:\n    depots: list[Depot]\n    disasters: list[Disaster]\n    disaster_locations: list[DisasterLocation]\n    probabilities: dict[Disaster, float]\n    items: list[Item]\n    transport_modes: list[TransportMode]\n    inventory: dict[Tuple[Depot, Item], int]\n    inventory_scenarios: dict[str, dict[Tuple[Depot, Item], int]]\n    distance: DistanceMatrix\n    people_affected: dict[Tuple[DisasterImpact, Item], float]\n    persons_per_item_general: dict[Tuple[DisasterImpact, Item], float]\n    persons_per_item_monthly: dict[Tuple[DisasterImpact, Item], float]\n    disaster_affected_totals: dict[str, int]\n\n    _zero_demand_threshold = 1e6\n\n@dataclass(frozen=True)\nclass Item:\n    id: str = field(hash=True)\n    weight: float = field(repr=False)  # Metric tons\n    volume: float = field(repr=False)  # Cubic metres\n\ndef graph_locations():\n    warehouses = [['warehouses',\n                   depot.latitude,\n                   depot.longitude] \n                   for depot in dataset.depots]\n\n    disasters = [['disasters',\n                  disaster_locations.latitude,\n                  disaster_locations.longitude] \n                  for disaster_locations in dataset.disaster_locations]\n\n    dfw = pd.DataFrame(warehouses)\n    dfw.columns = ['Type', 'Lat', 'Long']\n\n    dfd = pd.DataFrame(disasters) # type: ignore\n    dfd.columns = ['Type', 'Lat', 'Long']\n\n    df_combined = pd.concat([dfw[['Lat', 'Long', 'Type']], dfd[['Lat', 'Long', 'Type']]], ignore_index=True)\n\n    fig = px.scatter_mapbox(df_combined, \n                            lat=\"Lat\", \n                            lon=\"Long\", \n                            color=\"Type\",\n                            color_discrete_sequence=px.colors.qualitative.Safe,\n                            zoom=4.5)\n    \n    # Use a minimalist map style to reduce clutter\n    fig.update_layout(mapbox_style=\"open-street-map\")\n\n    # Optionally center the map around the mean latitude and longitude of your points\n    mean_lat = df_combined['Lat'].mean()\n    mean_long = df_combined['Long'].mean()\n    fig.update_layout(mapbox_center={\"lat\": mean_lat, \"lon\": mean_long})\n    fig.update_layout(margin={\"r\": 0, \"t\": 0, \"l\": 0, \"b\": 0})\n\n    fig.show()\n\ngraph_locations()\n\nimport plotly.graph_objects as go\n\n# Sample Data\ndef make_barchart():\n    items = {}\n    for x in dataset.inventory:\n        if x[1].id in items:\n            items[x[1].id] += dataset.inventory[x]\n        else:\n            items[x[1].id] = dataset.inventory[x]\n\n    items = dict(sorted(items.items(), key=lambda item: item[1], reverse=True))\n\n    # Extract keys and values from the dictionary\n    categories = list(items.keys())\n    values = list(items.values())\n\n    # Normalize the values for color scale\n    normalized_values = np.array(values) / max(values)\n\n    # Define a color scale (e.g., 'Viridis', 'Cividis', 'Plasma', etc.)\n    colorscale = 'Cividis'\n\n    def format_number(num):\n        if num >= 1_000_000:\n            return f'{num/1_000_000:.1f}M'  # Format as millions\n        elif num >= 1_000:\n            return f'{num/1_000:.0f}k'  # Format as thousands\n        else:\n            return str(num)  # Show the number as is if below 1,000\n\n    # Create formatted text for display\n    formatted_text = [format_number(v) for v in values]  # Use the custom formatting function\n\n    # Create a bar chart with a color continuum\n    fig = go.Figure(\n        data=[\n            go.Bar(\n                x=categories,\n                y=values,\n                marker=dict(\n                    color=normalized_values,  # Use normalized values for the color scale\n                    colorscale=colorscale,  # Apply the chosen color scale\n                    showscale=False  # Hide the color scale bar\n                    \n                ),\n                texttemplate='%{text}',  # Explicitly set text template\n                text=formatted_text,  # Display formatted text with 'k' and 'M' suffixes\n                hovertemplate='<b>%{x}</b><br>Quantity: %{y}<extra></extra>',  # Show exact hover info\n                textposition='auto',  # Automatically position the text\n            )\n        ]\n    )\n\n    # Update layout\n    fig.update_layout(\n        title={\n            'text': \"Distribution of Supplies for Disaster Relief\",\n            'y': 0.95,\n            'x': 0.5,\n            'xanchor': 'center',\n            'yanchor': 'top'\n        },\n        xaxis_title=\"Supplies\",\n        yaxis_title=\"Quantity\",\n        yaxis_type=\"log\",  # Logarithmic scale for better visualization\n        xaxis=dict(tickangle=-45),  # Rotate x-axis labels for better readability\n        plot_bgcolor='white',  # Set background color to white for better contrast\n        xaxis_tickfont_size=10,  # Font size for x-axis labels\n        yaxis_tickfont_size=10,  # Font size for y-axis labels\n        margin=dict(l=40, r=40, t=80, b=100),  # Adjust margins\n    )\n\n    # Add annotations to highlight key insights\n    fig.add_annotation(\n        x=categories[0],  # Example: Highlighting the highest value category\n        y=values[0],\n        text=\"Highest Quantity\",\n        showarrow=True,\n        arrowhead=2,\n        ax=-40,\n        ay=-40\n    )\n\n    # Show the plot\n    fig.show()\n\nmake_barchart()\n\ndef graph_supplies():\n  supplies=[[x[0].latitude,\n             x[0].longitude,\n             dataset.inventory[x]]\n             for x in dataset.inventory if x[1].id=='Buckets']\n \n  df=pd.DataFrame(supplies)\n  df.columns = ['Lat', 'Long', 'Buckets']\n\n  fig = px.scatter_mapbox(df, \n                        lat=\"Lat\", \n                        lon=\"Long\", \n                        size=\"Buckets\",\n                        #size_max=10,  # Maximum size of the marker\n                        #size_min=5,\n                        color_discrete_sequence=px.colors.qualitative.Safe,\n                        zoom=4.5,  # Adjust zoom level as needed\n                        )\n\n  # Optionally center the map around the mean latitude and longitude of your points\n  # Use a minimalist map style to reduce clutter\n  fig.update_layout(mapbox_style=\"carto-positron\")\n\n  mean_lat = df['Lat'].mean()\n  mean_long = df['Long'].mean()\n  fig.update_layout(mapbox_center={\"lat\": mean_lat, \"lon\": mean_long})\n  fig.update_layout(margin={\"r\":0,\"t\":0,\"l\":0,\"b\":0})\n\n  fig.show()\ngraph_supplies()\n\ndef graph_impacts():\n    \n    # Example values for l and h\n    l = -0.1\n    h = 0.1\n\n    # Sample data preparation\n    disasters = [[disasters.type.id,\n                disaster_locations.latitude,\n                disaster_locations.longitude,\n                dataset.disaster_affected_totals[key]] \n                for disasters, disaster_locations, key in zip(dataset.disasters, dataset.disaster_locations, dataset.disaster_affected_totals)]\n\n    df = pd.DataFrame(disasters)\n    df.columns = ['Type', 'Lat', 'Long', 'People Impacted']\n\n    fig = px.scatter_mapbox(df, \n                            lat=\"Lat\", \n                            lon=\"Long\", \n                            color=\"Type\", \n                            size=\"People Impacted\",\n                            #size_max=10,  # Maximum size of the marker\n                            #size_min=5,\n                            zoom=4.5,  # Adjust zoom level as needed\n                            color_discrete_sequence=px.colors.qualitative.Safe,\n                            )\n\n    # Optionally center the map around the mean latitude and longitude of your points\n    # Use a minimalist map style to reduce clutter\n    fig.update_layout(mapbox_style=\"carto-positron\")\n\n    mean_lat = df['Lat'].mean()\n    mean_long = df['Long'].mean()\n    fig.update_layout(mapbox_center={\"lat\": mean_lat, \"lon\": mean_long})\n    fig.update_layout(margin={\"r\":0,\"t\":0,\"l\":0,\"b\":0})\n\n    fig.show()\n\ngraph_impacts()\n\ndef graph_overlap():\n  supplies=[['supplies',\n             x[0].latitude,\n             x[0].longitude,\n             dataset.inventory[x]*2.5] #this is people per bucket\n             for x in dataset.inventory if x[1].id=='Buckets']\n \n  supplies=pd.DataFrame(supplies)\n  supplies.columns = ['Type','Lat', 'Long', 'Scale']\n\n\n  # Sample data preparation\n  disasters = [['disasters',\n                disaster_locations.latitude,\n                disaster_locations.longitude,\n                dataset.disaster_affected_totals[key]] \n                for disasters, disaster_locations, key in zip(dataset.disasters, dataset.disaster_locations, dataset.disaster_affected_totals)]\n\n  disasters = pd.DataFrame(disasters)\n  \n  \n  disasters.columns = ['Type', 'Lat', 'Long', 'Scale']\n\n  df_combined = pd.concat([supplies[['Type','Lat', 'Long', 'Scale']],\n                           disasters[['Type','Lat', 'Long', 'Scale']]],\n                           ignore_index=True)\n\n\n\n\n  fig = px.scatter_mapbox(df_combined, \n                        lat=\"Lat\", \n                        lon=\"Long\", \n                        size=\"Scale\",\n                        color='Type',\n                        size_max=40,  # Maximum size of the marker\n                        #size_min=5,\n                        zoom=4.5,  # Adjust zoom level as needed\n                        color_discrete_sequence=px.colors.qualitative.Safe,\n                        )\n\n  # Optionally center the map around the mean latitude and longitude of your points\n  # Use a minimalist map style to reduce clutter\n  fig.update_layout(mapbox_style=\"carto-positron\")\n\n  mean_lat = df_combined['Lat'].mean()\n  mean_long = df_combined['Long'].mean()\n  fig.update_layout(mapbox_center={\"lat\": mean_lat, \"lon\": mean_long})\n  fig.update_layout(margin={\"r\":0,\"t\":0,\"l\":0,\"b\":0})\n\n  fig.show()\n\ngraph_overlap()\n\nImage(filename='images/Old_Stockholm.png', width=1200)\n\nImage(filename='images/Disaster_Dashboard.png',width=1200)\n\n#prep distance matrix\ndf_distance, relevant_warehouses, BucketsNeeded = get_distance_matrix(dataset) # type: ignore\nt = df_distance.drivingTime_hrs\nn = len(relevant_warehouses)\n\n# Create model\nmodel = gp.Model(\"simple_Allocation\") \n\n# Add decision variables\ny=model.addVars(n, name=\"Warehouse_Allocation\")\n\n#Add constraint to meet demand\nmodel.addConstr(gp.quicksum(y[i] for i in range(n))==BucketsNeeded,name='Meet_Demand')\n\n# Add in warehouse_constraints\nfor i, supplies in enumerate(relevant_warehouses):\n    model.addConstr(y[i] <= supplies[2], name=f\"warehouse_endowment_{i}\")\n\n# Note we don't have a constraint for y >= 0 since it's assumed in the variable definition\n# Add objective\nobjective = gp.quicksum(t[i] * y[i] for i in range(n))\nmodel.setObjective(objective, GRB.MINIMIZE)\n\n# Fire up the solver!\nmodel.optimize()\n\n#Show Solution\nb=[]\nfor v, total, dis in zip(model.getVars(),relevant_warehouses,list(df_distance['drivingTime_hrs'])):\n    if v.VarName[0:20]== 'Warehouse_Allocation':\n        #print('%s %g | total= %g | distance=%g' % (v.VarName, v.X,total[2],dis))\n        b.append([v.VarName, v.X,total[2],dis])\nb=pd.DataFrame(b)\nb.columns=['Var','amount','possible','distance']\nb.sort_values('distance')\n\ndemand, probs = get_probs(dataset)\n\nn = len(relevant_warehouses)\nm = len(demand)\na = []\n\nmodel = gp.Model(\"all_disaster_allocation\") \n\n# Create an array of driving times based on the df_distance DataFrame\nt = df_distance.drivingTime_hrs\nc = pd.DataFrame(t)\n\n# Amount to take per Warehouse\ny = model.addVars(m, n, name=\"Warehouse_Allocation\")\n\n# Add constraints to meet demand for each disaster scenario (k)\nfor k in range(m):\n    # Demand constraints\n    model.addConstr(gp.quicksum(y[k, i] for i in range(n)) == demand[k], name=f\"Meet_Demand_K:{k}\")\n    \n    # Warehouse constraints\n    for i, supplies in enumerate(relevant_warehouses):\n        model.addConstr(y[k, i] <= supplies[2], name=f\"warehouse_endowment_K:{k}_I:{i}\")\n\n# Objective function to minimize the weighted driving time using T as a parameter\nobjective = gp.quicksum(\n    probs[k] * gp.quicksum(t[i] * y[k, i] for i in range(n))\n    for k in range(m)\n)\n\n# Optimize model\nmodel.setObjective(objective, GRB.MINIMIZE)\nmodel.optimize()\n\n# Store results in the list 'a'\nfor v in model.getVars():\n    a.append([v.VarName, v.X])\n\npd.DataFrame(a).iloc[:15]\n\nmodel = gp.Model(\"full_allocation\")\n\nn = len(relevant_warehouses)\nm = len(demand)\n\n# Create an array of driving times based on the df_distance DataFrame\nt = df_distance.drivingTime_hrs\n\n# Amount to take per Warehouse\ny = model.addVars(m, n, name=\"Single_Warehouse_Allocation\")\n\n# National Allocation\nX = model.addVars(n, name=\"National_Allocation\")\n\n# Total national endowment constraint\nmodel.addConstr(gp.quicksum(X[i] for i in range(n)) == 40811, name=\"Total_National_Endowment\")\n\nfor k in range(m):\n    model.addConstr(y[k, i] <= X[i])\n\n# Demand and warehouse constraints for each scenario\nfor k in range(m):\n    model.addConstr(gp.quicksum(y[k, i] for i in range(n)) == demand[k], name=f\"Meet_Demand_K:{k}\")\n    for i, supplies in enumerate(relevant_warehouses):\n        model.addConstr(y[k, i] <= supplies[2], name=f\"warehouse_endowment_K:{k}_I:{i}\")\n\n# Objective function to minimize the weighted driving time using T as a parameter\nobjective = gp.quicksum(\n    probs[k] * gp.quicksum(t[i] * y[k, i] for i in range(n))\n    for k in range(m)\n)\n\n# Optimize model\nmodel.setObjective(objective, GRB.MINIMIZE)\nmodel.optimize()\n\ny_values = []\nfor i in range(m):\n    for j in range(n):\n        y_values.append([y[(i,j)].VarName, y[(i,j)].X])\ny_values = pd.DataFrame(y_values, columns=['VarName', 'X'])\ny_values[y_values.X > 0]\n\n#Write your code here"}]}
{"meta": {"source_path": "/Users/sunyujun03/Desktop/ReLoop/gurobi-modeling-examples/optimization202/Modeling_Session_2/completed_exercise_set2.ipynb", "kind": "ipynb", "title": "Back to the widget production problem"}, "messages": [{"role": "system", "content": "You are an optimization engineer. Write correct and runnable Python code using gurobipy (Gurobi Python API). Be concise. Output only what is requested."}, {"role": "user", "content": "    Task: Reproduce the following Gurobi modeling example in Python using gurobipy.\n\n    Scenario description (from source):\n    # Back to the widget production problem\nLet's go back to the Opti 101/201 classic: Widget production and distribution. Use the code below as the base model for this problem.\n\n$$\n\\begin{align*} \n{\\rm minimize} \\space &\\sum_{p,d}c_{p,d}x_{p,d}, \\forall p \\in P, d \\in D\\\\ \n\\sum_{p}&x_{p,d} \\ge n_d, \\forall d \\in D \\\\ \n\\sum_{d}&x_{p,d} \\le m_p, \\forall p \\in P \\\\ \n\\sum_{d}&x_{p,d} \\ge a*m_p, \\forall p \\in P\\\\ \n&x_{p,d} \\in \\{0\\} \\cup [30, u_p]\n\\end{align*}\n$$\n\n<div class=\"alert alert-warning\">\n    <strong>Note!</strong>\n    <p>Make sure to run the next two code cells to get a baseline for the original problem.</p>\n</div>\n\nCode for the 'gurobipy' model:\n\n    Requirements:\n    - Use gurobipy (Model, GRB, addVar/addConstr, etc.)\n    - Make the script runnable as a standalone Python file if possible.\n    - Keep the code faithful to the example.\n"}, {"role": "assistant", "content": "import pandas as pd\nimport numpy as np\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# read in transportation cost data\npath = 'https://raw.githubusercontent.com/Gurobi/modeling-examples/master/optimization101/Modeling_Session_1/'\ntransp_cost = pd.read_csv(path + 'cost.csv')\n\n# get production and distribution locations from data frame\nproduction = list(transp_cost['production'].unique())\ndistribution = list(transp_cost['distribution'].unique())\ntransp_cost = transp_cost.set_index(['production','distribution']).squeeze()\n\nmax_prod = pd.Series([180,200,140,80,180], index = production, name = \"max_production\")\nn_demand = pd.Series([89,95,121,101,116,181], index = distribution, name = \"demand\")\n\n# min overall production requirement, and min shipment amount from p to d\nfrac = 0.75\nC = 30\n\nm = gp.Model('widgets')\nm.setParam('OutputFlag',0)\nm.setParam('PoolSearchMode',2)   \nm.setParam('PoolSolutions',2)   \n\n# decision vars\nx = m.addVars(production, distribution, vtype=GRB.SEMICONT, lb = C, name = 'prod_ship')\n\n# constraints\ncan_produce = m.addConstrs((gp.quicksum(x[p,d] for d in distribution) <= max_prod[p] for p in production), name = 'can_produce')\nmust_produce = m.addConstrs((gp.quicksum(x[p,d] for d in distribution) >= frac*max_prod[p] for p in production), name = 'must_produce')\nmeet_demand = m.addConstrs((x.sum('*', d) >= n_demand[d] for d in distribution), 'meet_demand')\n\n# objective\ntotal_cost = gp.quicksum(transp_cost[p,d]*x[p,d] for p in production for d in distribution)\nm.setObjective(total_cost, GRB.MINIMIZE)\n\n# optimize and extract and show solution\nm.optimize()\n\nx_values = pd.Series(m.getAttr('X', x), name = \"shipment\", index = transp_cost.index)\nsol = pd.concat([transp_cost, x_values], axis=1)\n\nm_ObjVal = m.ObjVal\nprint(f\"This model has a total cost of {round(m_ObjVal,2)}\")\nsol[sol.shipment > 0]\n\nm_pwl = gp.Model('widgets')\nm_pwl.setParam('OutputFlag', 0)\n\nx_pwl = m_pwl.addVars(production, distribution, vtype=GRB.SEMICONT, lb = 30, name = 'prod_ship')\npwl_cost = m_pwl.addVars(production, distribution, name = 'pwl_cost')\n\n# constraints\ncan_produce = m_pwl.addConstrs((gp.quicksum(x_pwl[p,d] for d in distribution) <= max_prod[p] for p in production), name = 'can_produce')\nmust_produce = m_pwl.addConstrs((gp.quicksum(x_pwl[p,d] for d in distribution) >= frac*max_prod[p] for p in production), name = 'must_produce')\nmeet_demand = m_pwl.addConstrs((x_pwl.sum('*', d) >= n_demand[d] for d in distribution), name = 'demand')\n\n# create empty series for analysis \nbulk_costs = pd.Series(index=transp_cost.keys(), name='bulk_costs')\nbase_costs = pd.Series(index=transp_cost.keys(), name='base_costs')\n\n# Create piecewise cost functions\nfor p in production:\n    for d in distribution:\n        max_produce = max_prod[p]\n        frac_produce = 0.5*max_produce\n        \n        # Adjusted costs\n        base_cost = transp_cost[p,d] + 0.5\n        bulk_cost = round(0.6*base_cost, 2) # 25% increase for the first half\n\n        base_costs[p,d] = base_cost\n        bulk_costs[p,d] = bulk_cost\n\n        # Define the piecewise-linear function points\n        pwl_points_x = [\n            0, frac_produce, max_produce\n        ]\n\n        pwl_points_y = [\n            0, base_cost * frac_produce, base_cost * frac_produce + bulk_cost * (max_produce - frac_produce)\n        ]\n\n        m_pwl.addGenConstrPWL(x_pwl[p, d], pwl_cost[p, d], pwl_points_x, pwl_points_y, name=f\"pwl_{p}_{d}\")\n\n# Objective: minimize the total cost\nm_pwl.setObjective(gp.quicksum(pwl_cost[p, d] for p, d in transp_cost.keys()), GRB.MINIMIZE)\n\n# Optimize\nm_pwl.optimize()\n\nx_values_pwl = pd.Series(m_pwl.getAttr('X', x_pwl), name = \"shipment_pwl\", index = transp_cost.index)\nsol_pwl = pd.concat([transp_cost, base_costs, bulk_costs, x_values_pwl], axis=1)\n\nprint(f\"This model has a total cost of {round(m_pwl.ObjVal,2)}\")\nsol_pwl[sol_pwl.shipment_pwl > 0]\n\nsol_comp = pd.concat([sol, sol_pwl.drop('cost', axis=1)], axis=1)\nsol_comp[(sol_comp.shipment > 0) | (sol_comp.shipment_pwl > 0)]\n\nm_pwl2 = gp.Model('widgets')\n#m_pwl2.setParam('OutputFlag',0)\n\n# decision vars\nx_pwl2 = m_pwl2.addVars(production, distribution, vtype=GRB.SEMICONT, lb = C, name = 'prod_ship')\n\n# constraints\ncan_produce = m_pwl2.addConstrs((gp.quicksum(x_pwl2[p,d] for d in distribution) <= max_prod[p] for p in production), name = 'can_produce')\nmust_produce = m_pwl2.addConstrs((gp.quicksum(x_pwl2[p,d] for d in distribution) >= frac*max_prod[p] for p in production), name = 'must_produce')\nmeet_demand = m_pwl2.addConstrs(x_pwl2.sum('*', d) >= n_demand[d] for d in distribution)\n\n# Total production for each facility\nbase_prod_cost = pd.Series([1,1.2,.8,.8,.9], index = production, name = \"max_production\")\n\n# Add new variables and/or constraints\nq = m_pwl2.addVars(production, name='q')\npwl_prod = m_pwl2.addVars(production, name='pwl_prod')\nm_pwl2.addConstrs((q[p] == gp.quicksum(x_pwl2[p, d] for d in distribution) for p in production), name='total_production')\n\nfor p in production:\n    m_pwl2.addGenConstrPWL(\n        q[p],\n        pwl_prod[p],\n        [0, 0.25 * max_prod[p], max_prod[p]],\n        [0, base_prod_cost[p]*max_prod[p], base_prod_cost[p]*max_prod[p] + 1.25*base_prod_cost[p]* (max_prod[p] - 0.25*max_prod[p])],\n        name=f'pwl_cost_{p}'\n    )\n\n# objective\ntotal_transp_cost = gp.quicksum(transp_cost[p,d]*x_pwl2[p,d] for p in production for d in distribution)\nm_pwl2.setObjective(total_transp_cost + pwl_prod.sum(), GRB.MINIMIZE)\n\n# optimize and extract and show solution\nm_pwl2.optimize()\n\nx_values_prod = pd.Series(m_pwl2.getAttr('X', x_pwl2), name = \"shipment\", index = transp_cost.index)\nsol_prod = pd.concat([transp_cost, x_values_prod], axis=1)\nprint(f\"This model has a total cost of {round(m_pwl2.ObjVal,2)}\")\nsol_prod[sol_prod.shipment > 0].drop('cost',axis=1)\n\nm.Params.SolutionNumber = 1\nm_ObjVal2 = m.PoolObjVal\nprint(f\"This model has a total cost of {round(m_ObjVal2,2)}. The original cost was {round(m_ObjVal,2)}\")\nx_values2 = pd.Series(m.getAttr('Xn', x), name = \"shipment2\", index = transp_cost.index)\nsol2 = pd.concat([transp_cost, x_values2], axis=1)\nsol_sim_comp = pd.concat([sol, sol2.drop('cost', axis = 1)], axis=1)\nsol_sim_comp[(sol_sim_comp.shipment > 0) | (sol_sim_comp.shipment2 > 0)]\n\nnp.random.seed(2579)\n\n# Number of samples to generate\nn_samples = 1000\n\n# Current cost between Cleveland and Indianapolis\nmean_cost = 2.3\nstd_sev = 0.2\n# Generate random costs using normal distribution\nnormal_costs = np.random.normal(loc=mean_cost, scale=std_sev, size=n_samples)\n\n# Extract the shipment amount from Cleveland to Indianapolis for each solution\nshipment_amount = sol_sim_comp.loc[('Cleveland', 'Indianapolis'), 'shipment']\nshipment_amount2 = sol_sim_comp.loc[('Cleveland', 'Indianapolis'), 'shipment2']\n\n# Find the total costs for all other shipments for each of the two solution since we are assuming they are fixed\nobj1 = sum(sol_sim_comp.cost * sol_sim_comp.shipment) - shipment_amount*sol_sim_comp.loc[('Cleveland', 'Indianapolis'), 'cost']\nobj2 = sum(sol_sim_comp.cost * sol_sim_comp.shipment2) - shipment_amount2*sol_sim_comp.loc[('Cleveland', 'Indianapolis'), 'cost']\n\n# Create a DataFrame to hold total costs including the new simulated costs \ntotal_costs_df = pd.DataFrame({\n    'Total_Cost_Sol1': obj1 + normal_costs * shipment_amount,\n    'Total_Cost_Sol2': obj2 + normal_costs * shipment_amount2\n})\n\n# Determine the common range for both datasets\nmin_cost = min(total_costs_df['Total_Cost_Sol1'].min(), total_costs_df['Total_Cost_Sol2'].min())\nmax_cost = max(total_costs_df['Total_Cost_Sol1'].max(), total_costs_df['Total_Cost_Sol2'].max())\n\n### This is code to create a visualization of each solution's variability\n# Define bin width and create bins\nbinwidth = (max_cost - min_cost) / 30  # Adjust the divisor for desired number of bins\nbins = np.arange(min_cost, max_cost + binwidth, binwidth)\n\n# Plot the overlaid histograms with the same binwidth and range\nplt.figure(figsize=(10, 6))\n\n# Histogram for total cost using normal distribution costs\nsns.histplot(total_costs_df['Total_Cost_Sol1'], bins=bins, color='blue', label='Optimal Solution',\n             alpha=0.5, kde=False, stat='frequency')\n\n# Histogram for total cost using triangular distribution costs\nsns.histplot(total_costs_df['Total_Cost_Sol2'], bins=bins, color='orange', label='Second Best Solution',\n             alpha=0.5, kde=False, stat='frequency')\n\n# Add vertical lines at the means\nplt.axvline(total_costs_df['Total_Cost_Sol1'].mean(), color='blue', linestyle='dashed', linewidth=2)\nplt.axvline(total_costs_df['Total_Cost_Sol2'].mean(), color='orange', linestyle='dashed', linewidth=2)\n\nplt.title('Overlaid Histograms')\nplt.xlabel('Cle-Ind Cost')\nplt.ylabel('Frequency')\nplt.figtext(0.5, 0.01, 'Dashed lines show respective means', ha='center', fontsize=10)\nplt.legend()\nplt.show()\n\nfrom scipy.stats import poisson\n\nq95 = poisson.ppf(0.95, 100)\nq95\n\nmeet_demand['Nashville'].RHS = q95\nm.update()\nm.optimize()\n\nx_values_Nash = pd.Series(m.getAttr('X', x), name = 'shipment_Nash', index = transp_cost.index)\n\nm_Nash_ObjVal = m.ObjVal\nprint(f\"This model has a total cost of {round(m_Nash_ObjVal,2)}. The original model has a cost of {round(m_ObjVal,2)}\")\nsol_Nash = pd.concat([transp_cost, x_values_Nash], axis=1)\nsol_Nash_comp = pd.concat([sol, sol_Nash.drop('cost', axis = 1)], axis=1)\nsol_Nash_comp[(sol_Nash_comp.shipment > 0) | (sol_Nash_comp.shipment_Nash > 0)]\n\n# Define sectors\nsectors = [\n    'Tech',\n    'TradRetailUtil',\n    'Renewable',\n    'FossilFuel',\n    'Auto',\n    'GenHealth',\n    'TradHealth'\n]\n\n# Define scenarios\nscenarios = [1, 2, 3]\n\n# Expected returns (%) for each sector under each scenario\nestimated_returns = {\n    ('Tech', 1): 12,\n    ('Tech', 2): 1,\n    ('Tech', 3): 3,\n    ('TradRetailUtil', 1): 3,\n    ('TradRetailUtil', 2): 4,\n    ('TradRetailUtil', 3): 3,\n    ('Renewable', 1): 5,\n    ('Renewable', 2): 15,\n    ('Renewable', 3): 4,\n    ('FossilFuel', 1): 3,\n    ('FossilFuel', 2): -5,\n    ('FossilFuel', 3): 4,\n    ('Auto', 1): 4,\n    ('Auto', 2): 2,\n    ('Auto', 3): 4,\n    ('GenHealth', 1): 1,\n    ('GenHealth', 2): 4,\n    ('GenHealth', 3): 10,\n    ('TradHealth', 1): 3,\n    ('TradHealth', 2): 2,\n    ('TradHealth', 3): -3\n}\n\n# Create a new model\nm_scen = gp.Model(\"PortfolioOptimization\")\nm_scen.setParam('OutputFlag', 0)\n\n# Decision variables: Investment fractions in each sector\nx = m_scen.addVars(sectors, name=\"Investment\", lb=0, ub=1)\n\n# Auxiliary variable: Minimum portfolio return\nz = m_scen.addVar(name=\"MinReturn\")\n\n# Add investment allocation constraint\nm_scen.addConstr(x.sum() == 1, name=\"TotalInvestment\")\n\n# Add portfolio return constraints for each scenario\nportfolio_return = m_scen.addConstrs((gp.quicksum(estimated_returns[(i, s)] * x[i] for i in sectors) >= z for s in scenarios), name = 'ReturnConstraint_Scenario')\n\n# Set objective: Maximize the minimum portfolio return\nm_scen.setObjective(z, GRB.MAXIMIZE)\n\n# Optimize the model\nm_scen.optimize()\n\nprint(f\"Optimal objective value: {round(m_scen.ObjVal,2)}\")\n\n# Get the results\ninvestment_allocation = pd.Series({i: round(x[i].X,3) for i in sectors}, name='Investment Allocation')\ninvestment_allocation.to_frame()\n\n# Add new variables and/or constraints\ny = m_scen.addVars(sectors, vtype=GRB.BINARY,name='decision')\n\nl = 0.1\nm_scen.addConstrs((x[i] <= y[i] for i in sectors), name='xy_link1')\nm_scen.addConstrs((x[i] >= l*y[i] for i in sectors), name='xy_link2')\nm_scen.addConstr(y.sum() >= 4)\n# Optimize the model\nm_scen.optimize()\n\n# Get the results\ninvestment_allocation = pd.Series({i: round(x[i].X,3) for i in sectors}, name='Investment Allocation')\ninvestment_allocation.to_frame()"}]}
{"meta": {"source_path": "/Users/sunyujun03/Desktop/ReLoop/gurobi-modeling-examples/optimization202/Modeling_Session_2/exercise_set2.ipynb", "kind": "ipynb", "title": "Back to the widget production problem"}, "messages": [{"role": "system", "content": "You are an optimization engineer. Write correct and runnable Python code using gurobipy (Gurobi Python API). Be concise. Output only what is requested."}, {"role": "user", "content": "    Task: Reproduce the following Gurobi modeling example in Python using gurobipy.\n\n    Scenario description (from source):\n    # Back to the widget production problem\nLet's go back to the Opti 101/201 classic: Widget production and distribution. Use the code below as the base model for this problem.\n\n$$\n\\begin{align*} \n{\\rm minimize} \\space &\\sum_{p,d}c_{p,d}x_{p,d}, \\forall p \\in P, d \\in D\\\\ \n\\sum_{p}&x_{p,d} \\ge n_d, \\forall d \\in D \\\\ \n\\sum_{d}&x_{p,d} \\le m_p, \\forall p \\in P \\\\ \n\\sum_{d}&x_{p,d} \\ge a*m_p, \\forall p \\in P\\\\ \n&x_{p,d} \\in \\{0\\} \\cup [30, u_p]\n\\end{align*}\n$$\n\n<div class=\"alert alert-warning\">\n    <strong>Note!</strong>\n    <p>Make sure to run the next two code cells to get a baseline for the original problem.</p>\n</div>\n\nCode for the 'gurobipy' model:\n\n    Requirements:\n    - Use gurobipy (Model, GRB, addVar/addConstr, etc.)\n    - Make the script runnable as a standalone Python file if possible.\n    - Keep the code faithful to the example.\n"}, {"role": "assistant", "content": "import pandas as pd\nimport numpy as np\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# read in transportation cost data\npath = 'https://raw.githubusercontent.com/Gurobi/modeling-examples/master/optimization101/Modeling_Session_1/'\ntransp_cost = pd.read_csv(path + 'cost.csv')\n\n# get production and distribution locations from data frame\nproduction = list(transp_cost['production'].unique())\ndistribution = list(transp_cost['distribution'].unique())\ntransp_cost = transp_cost.set_index(['production','distribution']).squeeze()\n\nmax_prod = pd.Series([180,200,140,80,180], index = production, name = \"max_production\")\nn_demand = pd.Series([89,95,121,101,116,181], index = distribution, name = \"demand\")\n\n# min overall production requirement, and min shipment amount from p to d\nfrac = 0.75\nC = 30\n\nm = gp.Model('widgets')\nm.setParam('OutputFlag',0)\nm.setParam('PoolSearchMode',2)   \nm.setParam('PoolSolutions',2)   \n\n# decision vars\nx = m.addVars(production, distribution, vtype=GRB.SEMICONT, lb = C, name = 'prod_ship')\n\n# constraints\ncan_produce = m.addConstrs((gp.quicksum(x[p,d] for d in distribution) <= max_prod[p] for p in production), name = 'can_produce')\nmust_produce = m.addConstrs((gp.quicksum(x[p,d] for d in distribution) >= frac*max_prod[p] for p in production), name = 'must_produce')\nmeet_demand = m.addConstrs((x.sum('*', d) >= n_demand[d] for d in distribution), 'meet_demand')\n\n# objective\ntotal_cost = gp.quicksum(transp_cost[p,d]*x[p,d] for p in production for d in distribution)\nm.setObjective(total_cost, GRB.MINIMIZE)\n\n# optimize and extract and show solution\nm.optimize()\n\nx_values = pd.Series(m.getAttr('X', x), name = \"shipment\", index = transp_cost.index)\nsol = pd.concat([transp_cost, x_values], axis=1)\n\nm_ObjVal = m.ObjVal\nprint(f\"This model has a total cost of {round(m_ObjVal,2)}\")\nsol[sol.shipment > 0]\n\nm_pwl = gp.Model('widgets')\nm_pwl.setParam('OutputFlag', 0)\n\nx_pwl = m_pwl.addVars(production, distribution, vtype=GRB.SEMICONT, lb = 30, name = 'prod_ship')\npwl_cost = m_pwl.addVars(production, distribution, name = 'pwl_cost')\n\n# constraints\ncan_produce = m_pwl.addConstrs((gp.quicksum(x_pwl[p,d] for d in distribution) <= max_prod[p] for p in production), name = 'can_produce')\nmust_produce = m_pwl.addConstrs((gp.quicksum(x_pwl[p,d] for d in distribution) >= frac*max_prod[p] for p in production), name = 'must_produce')\nmeet_demand = m_pwl.addConstrs((x_pwl.sum('*', d) >= n_demand[d] for d in distribution), name = 'demand')\n\n# create empty series for analysis \nbulk_costs = pd.Series(index=transp_cost.keys(), name='bulk_costs')\nbase_costs = pd.Series(index=transp_cost.keys(), name='base_costs')\n\n# Create piecewise cost functions\nfor p in production:\n    for d in distribution:\n        max_produce = ???\n        frac_produce = ???\n        \n        # Adjusted costs\n        base_cost = ???\n        bulk_cost = round(???, 2) # 25% increase for the first half\n\n        base_costs[p,d] = base_cost\n        bulk_costs[p,d] = bulk_cost\n\n        # Define the piecewise-linear function points\n        pwl_points_x = [\n            0, ???, ???\n        ]\n\n        pwl_points_y = [\n            0, ???, ???\n        ]\n\n        m_pwl.addGenConstrPWL(???, ???, ???, ???, name=f\"pwl_{p}_{d}\")\n\n# Objective: minimize the total cost\nm_pwl.setObjective(gp.quicksum(pwl_cost[p, d] for p, d in transp_cost.keys()), GRB.MINIMIZE)\n\n# Optimize\nm_pwl.optimize()\n\nx_values_pwl = pd.Series(m_pwl.getAttr('X', x_pwl), name = \"shipment_pwl\", index = transp_cost.index)\nsol_pwl = pd.concat([transp_cost, base_costs, bulk_costs, x_values_pwl], axis=1)\n\nprint(f\"This model has a total cost of {round(m_pwl.ObjVal,2)}\")\nsol_pwl[sol_pwl.shipment_pwl > 0]\n\nsol_comp = pd.concat([sol, sol_pwl.drop('cost', axis=1)], axis=1)\nsol_comp[(sol_comp.shipment > 0) | (sol_comp.shipment_pwl > 0)]\n\nm_pwl2 = gp.Model('widgets')\n#m_pwl2.setParam('OutputFlag',0)\n\n# decision vars\nx_pwl2 = m_pwl2.addVars(production, distribution, vtype=GRB.SEMICONT, lb = C, name = 'prod_ship')\n\n# constraints\ncan_produce = m_pwl2.addConstrs((gp.quicksum(x_pwl2[p,d] for d in distribution) <= max_prod[p] for p in production), name = 'can_produce')\nmust_produce = m_pwl2.addConstrs((gp.quicksum(x_pwl2[p,d] for d in distribution) >= frac*max_prod[p] for p in production), name = 'must_produce')\nmeet_demand = m_pwl2.addConstrs(x_pwl2.sum('*', d) >= n_demand[d] for d in distribution)\n\n# Total production for each facility\nbase_prod_cost = pd.Series([1,1.2,.8,.8,.9], index = production, name = \"max_production\")\n\n# Add new variables and/or constraints\nq = m_pwl2.addVars(production, name='q')\npwl_prod = m_pwl2.addVars(production, name='pwl_prod')\nm_pwl2.addConstrs((q[p] == gp.quicksum(x_pwl2[p, d] for d in distribution) for p in production), name='total_production')\n\nfor p in production:\n    m_pwl2.addGenConstrPWL(\n        ???,\n        ???,\n        ???,\n        ???,\n        name=f'pwl_cost_{p}'\n    )\n\n# objective\ntotal_transp_cost = gp.quicksum(??? for p in production for d in distribution)\nm_pwl2.setObjective(total_transp_cost + ???, GRB.MINIMIZE)\n\n# optimize and extract and show solution\nm_pwl2.optimize()\n\nx_values_prod = pd.Series(m_pwl2.getAttr('X', x_pwl2), name = \"shipment\", index = transp_cost.index)\nsol_prod = pd.concat([transp_cost, x_values_prod], axis=1)\nprint(f\"This model has a total cost of {round(m_pwl2.ObjVal,2)}\")\nsol_prod[sol_prod.shipment > 0].drop('cost',axis=1)\n\nm.Params.SolutionNumber = 1\nm_ObjVal2 = m.PoolObjVal\nprint(f\"This model has a total cost of {round(m_ObjVal2,2)}. The original cost was {round(m_ObjVal,2)}\")\nx_values2 = pd.Series(m.getAttr('Xn', x), name = \"shipment2\", index = transp_cost.index)\nsol2 = pd.concat([transp_cost, x_values2], axis=1)\nsol_sim_comp = pd.concat([sol, sol2.drop('cost', axis = 1)], axis=1)\nsol_sim_comp[(sol_sim_comp.shipment > 0) | (sol_sim_comp.shipment2 > 0)]\n\nnp.random.seed(2579)\n\n# Number of samples to generate\nn_samples = 1000\n\n# Current cost between Cleveland and Indianapolis\nmean_cost = 2.3\nstd_sev = 0.2\n# Generate random costs using normal distribution\nnormal_costs = np.random.normal(loc=???, scale=???, size=???)\n\n# Extract the shipment amount from Cleveland to Indianapolis for each solution\nshipment_amount = sol_sim_comp.loc[('Cleveland', 'Indianapolis'), 'shipment']\nshipment_amount2 = sol_sim_comp.loc[('Cleveland', 'Indianapolis'), 'shipment2']\n\n# Find the total costs for all other shipments for each of the two solution since we are assuming they are fixed\nobj1 = sum(sol_sim_comp.cost * sol_sim_comp.shipment) - shipment_amount*sol_sim_comp.loc[('Cleveland', 'Indianapolis'), 'cost']\nobj2 = sum(sol_sim_comp.cost * sol_sim_comp.shipment2) - shipment_amount2*sol_sim_comp.loc[('Cleveland', 'Indianapolis'), 'cost']\n\n# Create a DataFrame to hold total costs including the new simulated costs \ntotal_costs_df = pd.DataFrame({\n    'Total_Cost_Sol1': ???\n    'Total_Cost_Sol2': ???\n})\n\n# Determine the common range for both datasets\nmin_cost = min(total_costs_df['Total_Cost_Sol1'].min(), total_costs_df['Total_Cost_Sol2'].min())\nmax_cost = max(total_costs_df['Total_Cost_Sol1'].max(), total_costs_df['Total_Cost_Sol2'].max())\n\n### This is code to create a visualization of each solution's variability\n# Define bin width and create bins\nbinwidth = (max_cost - min_cost) / 30  # Adjust the divisor for desired number of bins\nbins = np.arange(min_cost, max_cost + binwidth, binwidth)\n\n# Plot the overlaid histograms with the same binwidth and range\nplt.figure(figsize=(10, 6))\n\n# Histogram for total cost using normal distribution costs\nsns.histplot(total_costs_df['Total_Cost_Sol1'], bins=bins, color='blue', label='Optimal Solution',\n             alpha=0.5, kde=False, stat='frequency')\n\n# Histogram for total cost using triangular distribution costs\nsns.histplot(total_costs_df['Total_Cost_Sol2'], bins=bins, color='orange', label='Second Best Solution',\n             alpha=0.5, kde=False, stat='frequency')\n\n# Add vertical lines at the means\nplt.axvline(total_costs_df['Total_Cost_Sol1'].mean(), color='blue', linestyle='dashed', linewidth=2)\nplt.axvline(total_costs_df['Total_Cost_Sol2'].mean(), color='orange', linestyle='dashed', linewidth=2)\n\nplt.title('Overlaid Histograms')\nplt.xlabel('Cle-Ind Cost')\nplt.ylabel('Frequency')\nplt.figtext(0.5, 0.01, 'Dashed lines show respective means', ha='center', fontsize=10)\nplt.legend()\nplt.show()\n\nfrom scipy.stats import poisson\n\nq95 = poisson.ppf(???, ???)\nq95\n\nmeet_demand['Nashville'].RHS = ???\nm.update()\nm.optimize()\n\nx_values_Nash = pd.Series(m.getAttr('X', x), name = 'shipment_Nash', index = transp_cost.index)\n\nm_Nash_ObjVal = m.ObjVal\nprint(f\"This model has a total cost of {round(m_Nash_ObjVal,2)}. The original model has a cost of {round(m_ObjVal,2)}\")\nsol_Nash = pd.concat([transp_cost, x_values_Nash], axis=1)\nsol_Nash_comp = pd.concat([sol, sol_Nash.drop('cost', axis = 1)], axis=1)\nsol_Nash_comp[(sol_Nash_comp.shipment > 0) | (sol_Nash_comp.shipment_Nash > 0)]\n\n# Define sectors\nsectors = [\n    'Tech',\n    'TradRetailUtil',\n    'Renewable',\n    'FossilFuel',\n    'Auto',\n    'GenHealth',\n    'TradHealth'\n]\n\n# Define scenarios\nscenarios = [1, 2, 3]\n\n# Expected returns (%) for each sector under each scenario\nestimated_returns = {\n    ('Tech', 1): 12,\n    ('Tech', 2): 1,\n    ('Tech', 3): 3,\n    ('TradRetailUtil', 1): 3,\n    ('TradRetailUtil', 2): 4,\n    ('TradRetailUtil', 3): 3,\n    ('Renewable', 1): 5,\n    ('Renewable', 2): 15,\n    ('Renewable', 3): 4,\n    ('FossilFuel', 1): 3,\n    ('FossilFuel', 2): -5,\n    ('FossilFuel', 3): 4,\n    ('Auto', 1): 4,\n    ('Auto', 2): 2,\n    ('Auto', 3): 4,\n    ('GenHealth', 1): 1,\n    ('GenHealth', 2): 4,\n    ('GenHealth', 3): 10,\n    ('TradHealth', 1): 3,\n    ('TradHealth', 2): 2,\n    ('TradHealth', 3): -3\n}\n\n# Create a new model\n???\n\n# Decision variables: Investment fractions in each sector\n???\n\n# Auxiliary variable: Minimum portfolio return\n???\n\n# Add investment allocation constraint\n???\n\n# Add portfolio return constraints for each scenario\n???\n\n# Set objective: Maximize the minimum portfolio return\n???\n\n# Optimize the model\n???\n\nprint(f\"Optimal objective value: {round(???,2)}\")\n\n# Get the results\n???\n\n# Add new variables and/or constraints\n\n\n# Optimize the model\n\n\n# Get the results"}]}
{"meta": {"source_path": "/Users/sunyujun03/Desktop/ReLoop/gurobi-modeling-examples/optimization202/Modeling_Session_1/exercise_set1.ipynb", "kind": "ipynb", "title": "Exercise Set 1"}, "messages": [{"role": "system", "content": "You are an optimization engineer. Write correct and runnable Python code using gurobipy (Gurobi Python API). Be concise. Output only what is requested."}, {"role": "user", "content": "    Task: Reproduce the following Gurobi modeling example in Python using gurobipy.\n\n    Scenario description (from source):\n    # Exercise Set 1\n\n## Multiple Choice / True-False\n\n**Q1.** When dealing with numerical instability, which of the following is NOT a recommended approach?\n\n> a. Using well-scaled and precise data\n\n> b. Ensuring matrix coefficients are within 6 orders of magnitude\n\n> c. Increasing the Big M value as much as possible\n\n> d. Setting the NumericFocus parameter to prioritize stability\n\n**Q2.** Which of the following statements about MIP Gap is accurate?\n\n> a. A lower MIP Gap always leads to significant solution improvements\n\n> b. A higher MIP Gap can still yield a solution close to optimal, depending on the problem\n\n> c. Setting MIP Gap to zero is ideal for all real-world applications\n\n> d. MIP Gap only affects runtime but not solution quality\n\n**Q3.** Which of the following is a potential benefit of using the Big M method in an optimization model?\n\n> a. It helps establish conditional constraints based on binary variables\n\n> b. It eliminates the need for slack variables\n\n> c. It reduces the numerical range required for coefficients\n\n> d. It ensures the model is solved to exact optimality\n\n**Q4.** An optimization model can sometimes be infeasible in exact arithmetic but feasible within the solver’s tolerances.\n\n> True\n\n> False\n\n**Q5.** For which of the following application areas is non-linear optimization used in practice?\n\n> a. Finance\n\n> b. Utilities\n\n> c. Engineering\n\n> d. All of the above\n\n**Q6.** Which type of optimization problem could have local optimal solutions that are not globally optimal?\n\n> a. Linear programs\n\n> b. Convex Quadratic Programs\n\n> c. Non-convex Quadratic Programs\n\n> d. None of the above\n\n**Q7.** Which of the following constraints defines a convex feasible region?\n\n> a. $y \\geq x^2$\n\n> b. $y \\leq x^2$\n\n> c. $y = x^2$\n\n> d. $y \\neq x^2$\n\n## Simple modeling / coding\n\n**Q8.** Show these constraints are either compatible (find a feasible solution) or incompatible (prove a contradiction) algebraically:\n> Part 1. \n\n\\begin{align*}\nx + y + z &\\ge 3   \\quad &(1)    \\\\\n2x + 3y - z &\\le 4   \\quad &(2)  \\\\\nx, y, z &\\ge 0\n\\end{align*}\n\n> Part 2. \n\n\\begin{align*}\nx_1 + x_2 + x_3 &= 6 \\quad &(1)      \\\\\n3x_1 + 2x_2 + x_3 &\\ge 20  \\quad &(2)\\\\\nx_1, x_2, x_3, &\\ge 0\n\\end{align*}\n\n**Q9.** Translate the following into constraints using binary variables for deciding to invest in three stocks. Then determine if they are compatible as above. \n\n- I will invest in exactly two of the three stocks.\n- If I invest in stock A, then I will invest in stock B.\n- If I invest in stock B, then I will invest in stock C.\n\n## Back to the widget production problem\nUse the code below as the base model for this problem.\n\n    Requirements:\n    - Use gurobipy (Model, GRB, addVar/addConstr, etc.)\n    - Make the script runnable as a standalone Python file if possible.\n    - Keep the code faithful to the example.\n"}, {"role": "assistant", "content": "# Install any packages\n\n# Import packages\nimport pandas as pd\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# read in transportation cost data\npath = 'https://raw.githubusercontent.com/Gurobi/modeling-examples/master/optimization101/Modeling_Session_1/'\ntransp_cost = pd.read_csv(path + 'cost.csv')\n\n# get production and distribution locations from data frame\nproduction = list(transp_cost['production'].unique())\ndistribution = list(transp_cost['distribution'].unique())\ntransp_cost = transp_cost.set_index(['production','distribution']).squeeze()\n\nmax_prod = pd.Series([180,200,140,80,180], index = production, name = \"max_production\")\nn_demand = pd.Series([89,95,121,101,116,181], index = distribution, name = \"demand\")\n# the min production is a fraction of the max\nfrac = 0.75\nC = 30\n\n# gurobipy code for model\nm = gp.Model('widgets')\nm.setParam('OutputFlag',0)\n\n# decision variables - reminder that we ended on x being a semi-continuous variable type\nx = m.addVars(production, distribution, vtype=GRB.SEMICONT, lb = C, name = 'prod_ship')\n\n# constraints\ncan_produce = m.addConstrs((gp.quicksum(x[p,d] for d in distribution) <= max_prod[p] for p in production), name = 'can_produce')\nmust_produce = m.addConstrs((gp.quicksum(x[p,d] for d in distribution) >= frac*max_prod[p] for p in production), name = 'must_produce')\nmeet_demand = m.addConstrs(x.sum('*', d) >= n_demand[d] for d in distribution)\n\n#objective\nm.setObjective(gp.quicksum(transp_cost[p,d]*x[p,d] for p in production for d in distribution), GRB.MINIMIZE)\n\nm.optimize()\n\nx_values = pd.Series(m.getAttr('X', x), name = \"shipment\", index = transp_cost.index)\nsol = pd.concat([transp_cost, x_values], axis=1)\n\nprint(f\"The original model had a total cost of {round(m.ObjVal,2)}\")\nsol[sol.shipment > 0]\n\n# Your code goes here\n\n# Your code goes here\n\n# Your code goes here\ns = \nNL2 = m.addConstr(    ???       )\n\n# First, remove the complicated form of the constraint\nm.remove(NL2)\n# Your code goes here"}]}
{"meta": {"source_path": "/Users/sunyujun03/Desktop/ReLoop/gurobi-modeling-examples/optimization202/Modeling_Session_1/completed_exercise_set1.ipynb", "kind": "ipynb", "title": "Exercise Set 1"}, "messages": [{"role": "system", "content": "You are an optimization engineer. Write correct and runnable Python code using gurobipy (Gurobi Python API). Be concise. Output only what is requested."}, {"role": "user", "content": "    Task: Reproduce the following Gurobi modeling example in Python using gurobipy.\n\n    Scenario description (from source):\n    # Exercise Set 1\n\n## Multiple Choice / True-False\n\nCorrect answers are `marked like this`.\n\n**Q1.** When dealing with numerical instability, which of the following is NOT a recommended approach?\n\n> a. Using well-scaled and precise data\n\n> b. Ensuring matrix coefficients are within 6 orders of magnitude\n\n> c. `Increasing the Big M value as much as possible`\n\n> d. Setting the NumericFocus parameter to prioritize stability\n\n**Q2.** Which of the following statements about MIP Gap is accurate?\n\n> a. A lower MIP Gap always leads to significant solution improvements\n\n> b. `A higher MIP Gap can still yield a solution close to optimal, depending on the problem`\n\n> c. Setting MIP Gap to zero is ideal for all real-world applications\n\n> d. MIP Gap only affects runtime but not solution quality\n\n**Q3.** Which of the following is a potential benefit of using the Big M method in an optimization model?\n\n> a. `It helps establish conditional constraints based on binary variables`\n\n> b. It eliminates the need for slack variables\n\n> c. It reduces the numerical range required for coefficients\n\n> d. It ensures the model is solved to exact optimality\n\n**Q4.** An optimization model can sometimes be infeasible in exact arithmetic but feasible within the solver’s tolerances.\n\n> `True` \n\n> False\n\n**Q5.** For which of the following application areas is non-linear optimization used in practice?\n\n> a. Finance\n\n> b. Utilities\n\n> c. Engineering\n\n> d. `All of the above`\n\n**Q6.** Which type of optimization problem could have local optimal solutions that are not globally optimal?\n\n> a. Linear programs\n\n> b. Convex Quadratic Programs\n\n> c. `Non-convex Quadratic Programs`\n\n> d. None of the above\n\n**Q7.** Which of the following constraints defines a convex feasible region?\n\n> a. `Correct:` $y \\geq x^2$\n\n> b. $y \\leq x^2$\n\n> c. $y = x^2$\n\n> d. $y \\neq x^2$\n\n## Simple modeling / coding\n\n**Q8.** Show these constraints are either compatible (find a feasible solution) or incompatible (prove a contradiction) algebraically:\n> **Q8a.** \n\n\\begin{align*}\nx + y + z &\\ge 3   \\quad &(1)    \\\\\n2x + 3y - z &\\le 4   \\quad &(2)  \\\\\nx, y, z &\\ge 0\n\\end{align*}\n\n`Solution:`\nAn example solution is to select $x = y = z = 1$.\n\n> **Q8b.** \n\n\\begin{align*}\nx_1 + x_2 + x_3 &= 6 \\quad &(1)      \\\\\n3x_1 + 2x_2 + x_3 &\\ge 20  \\quad &(2)\\\\\nx_1, x_2, x_3, &\\ge 0\n\\end{align*}\n\n`Solution:`\n\nOne way to derive a contradiction:\nMultiply $(1)$ by 3, which gives $3x_1 + 3x_2 + 3x_3 = 18$. \n\nSince $x_1, x_2, x_3$ are all nonnegative,\n\\begin{align*}\n3x_1 + 3x_2 + 3x_3 \\ge 3x_1 + 2x_2 + x_3 \\ge 20\n\\end{align*}\n\nThis reduces to:\n\n\\begin{align*}\n18 \\ge 3x_1 + &2x_2 + x_3 \\ge 20 \\\\\n18 &\\ge 20\n\\end{align*}\n\nWhich is a contradiction. \n\n**Q9.** Translate the following into constraints using binary variables for deciding to invest in three stocks. Then determine if they are compatible as above. \n\n- I will invest in exactly two of the three stocks.\n- If I invest in stock A, then I will invest in stock B.\n- If I invest in stock B, then I will invest in stock C.\n\n`Solution:`\nLet $y_A, y_B, y_C \\in \\{0,1\\}$ be the three stocks.\n\\begin{align*}\n\\sum_{i \\in \\{A,B,C\\}} y_i &= 2 \\\\\ny_A &\\le y_B \\\\\ny_B &\\le y_C \\\\\n\\end{align*}\n$y_A = 0, y_B = 1, y_C = 1$ satisfies the constraints. \n\n## Back to the widget production problem\nUse the code below as the base model for this problem.\n\n    Requirements:\n    - Use gurobipy (Model, GRB, addVar/addConstr, etc.)\n    - Make the script runnable as a standalone Python file if possible.\n    - Keep the code faithful to the example.\n"}, {"role": "assistant", "content": "# Import packages\nimport pandas as pd\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# read in transportation cost data\npath = 'https://raw.githubusercontent.com/Gurobi/modeling-examples/master/optimization101/Modeling_Session_1/'\ntransp_cost = pd.read_csv(path + 'cost.csv')\n\n# get production and distribution locations from data frame\nproduction = list(transp_cost['production'].unique())\ndistribution = list(transp_cost['distribution'].unique())\ntransp_cost = transp_cost.set_index(['production','distribution']).squeeze()\n\nmax_prod = pd.Series([180,200,140,80,180], index = production, name = \"max_production\")\nn_demand = pd.Series([89,95,121,101,116,181], index = distribution, name = \"demand\")\n\n# the min production is a fraction of the max\nfrac = 0.75\nC = 30\n\n# gurobipy code for model\nm = gp.Model('widgets')\nm.setParam('OutputFlag',0)\n\n# decision variables - reminder that we ended on x being a semi-continuous variable type\nx = m.addVars(production, distribution, vtype=GRB.SEMICONT, lb = C, name = 'prod_ship')\n\n# constraints\ncan_produce = m.addConstrs((gp.quicksum(x[p,d] for d in distribution) <= max_prod[p] for p in production), name = 'can_produce')\nmust_produce = m.addConstrs((gp.quicksum(x[p,d] for d in distribution) >= frac*max_prod[p] for p in production), name = 'must_produce')\nmeet_demand = m.addConstrs(x.sum('*', d) >= n_demand[d] for d in distribution)\n\n#objective\nm.setObjective(gp.quicksum(transp_cost[p,d]*x[p,d] for p in production for d in distribution), GRB.MINIMIZE)\n\nm.optimize()\n\nx_values = pd.Series(m.getAttr('X', x), name = \"shipment\", index = transp_cost.index)\nsol = pd.concat([transp_cost, x_values], axis=1)\n\nprint(f\"The original model had a total cost of {round(m.ObjVal,2)}\")\nsol[sol.shipment > 0]\n\n# One solution\nm.setObjective(gp.quicksum(transp_cost[p,d]*x[p,d] for p in production for d in distribution) + 0.01 * gp.quicksum(x.sum(p, '*') * x.sum(p, '*') for p in production), GRB.MINIMIZE)\nm.optimize()\nprint(f\"The updated model had a total cost of {round(m.ObjVal,2)}\")\n\n# Another solution\n# Introduces auxiliary variables representing total production for each facility\n# produced = m.addVars(production, name='total_produced')\n# m.addConstrs((produced[p] == x.sum(p, '*') for p in production), name='set_produced')\n# m.setObjective(gp.quicksum(transp_cost[p,d]*x[p,d] for p in production for d in distribution) + 0.01 * gp.quicksum(produced[p] * produced[p] for p in production), GRB.MINIMIZE)\n\n# One solution\nprod_cost = m.addVar(name='prod_cost')\nm.addConstr(prod_cost == gp.quicksum(transp_cost[p,d] * gp.nlfunc.log(1 + x[p, d]) for p in production for d in distribution), name='set_prod_cost')\nm.setObjective(prod_cost, GRB.MINIMIZE)\nm.optimize()\nprint(f\"The updated model had a total cost of {round(m.ObjVal,2)}\")\n\n# One solution\ns = m.addVar(name=\"s\")\nNL2 = m.addConstr(s == gp.nlfunc.log(4 * x['Baltimore', 'Indianapolis'] / x.sum('Baltimore', '*')), name='strange_company_rule')\nm.optimize()\nprint(f\"The updated model had a total cost of {round(m.ObjVal,2)}\")\n\n# One solution\n# First, remove the complicated form of the constraint\nm.remove(NL2)\n\n# Meaning of the constraint: at least 25% of Baltimore's total production must be sent to Indianapolis\nm.addConstr(x['Baltimore', 'Indianapolis'] >= 0.25 * x.sum('Baltimore', '*'), name='strange_company_rule_linearized')\nm.optimize()\nx_values = pd.Series(m.getAttr('X', x), name = \"shipment\", index = transp_cost.index)\nsol = pd.concat([transp_cost, x_values], axis=1)\n\nprint(f\"The updated model had a total cost of {round(m.ObjVal,2)}\")\nsol[sol.shipment > 0]"}]}
{"meta": {"source_path": "/Users/sunyujun03/Desktop/ReLoop/gurobi-modeling-examples/optimization202/Modeling_Session_1/nonlinear_regression_exercise.ipynb", "kind": "ipynb", "title": "Nonlinear regression: Estimating reaction parameters"}, "messages": [{"role": "system", "content": "You are an optimization engineer. Write correct and runnable Python code using gurobipy (Gurobi Python API). Be concise. Output only what is requested."}, {"role": "user", "content": "    Task: Reproduce the following Gurobi modeling example in Python using gurobipy.\n\n    Scenario description (from source):\n    # Nonlinear regression: Estimating reaction parameters\n\n## Motivation\n\n### What and why\nReady to dive into nonlinear regression? In nonlinear regression models, the relationship between the regression parameters and the outcome variable is nonlinear.  Here are a couple of regression models where the regression parameters $a$, $b$, and $c$ have a nonlinear relationship with the dependent variable $y$:\n\n$$y(x) = a\\cdot x^b+c$$\n$$y(x) = \\dfrac{a\\cdot x}{b+x}$$\n$$y(x) = \\dfrac{a}{1+b^{x-c}}$$\n\nNonlinear regression is essential in fields with complex relationships, providing flexibility for more accurate modeling. Notable applications include:\n\n- **Biology and Medicine**: Understanding growth rates and enzyme kinetics.\n- **Economics**: Analyzing complex demand and price curves.\n- **Environmental Science**: Uncovering relationships between crop yields and soil conditions.\n- **Physics and Engineering**: Understanding radioactive decay or modeling properties of materials.\n\nThese applications benefit from nonlinear regression's ability to deliver more accurate models and retain known model form for predictions and insights, especially in situations where linear regression approaches may fall short.\n\n### The nonlinear regression problem\nThe goal of nonlinear regression is to find the parameters that minimize the model error, typically measured by the squared error between the model’s predictions,  $y(x_i; \\text{regression parameters})$ and the actual data points $y_i$. In optimization terms, this process involves:\n- **Decision variables**: The regression parameters (e.g., $a$ and $b$ in our example below) that define the model.\n- **Data**: The \"variables\" from the regression model (e.g., y(x) and x) become data points $y_i$ and $x_i$ for all data points $i$.\n- **Objective**: Commonly, we minimize the sum of the squared error between the model predictions $y_{\\rm model}(x_i; a, b)$ and observed values $y_i$.  Sometimes, absolute error is used as an alternative.\n- **Constraints**: Often, nonlinear regression has no natural constraints, though bounds can be set on parameters as needed. In this exercise we will, we define $y_{\\rm model}(x)$ to establish our objective.\n\nHere’s the general form for least squares regression:\n\\begin{align*}\n{\\rm minimize}_{a,b} & \\quad \\displaystyle \\sum_{\\text{data points }i}   \\left(y_\\text{model}(x_i; a,b) - y_i\\right)^2\n\\end{align*}\n\nAnd, if we use our second example model from above $y(x) = \\dfrac{a\\cdot x}{b+x}$, this would be \n\\begin{align*}\n{\\rm minimize}_{a,b} & \\quad \\displaystyle \\sum_{\\text{data points }i}   \\left(\\dfrac{a\\cdot x_i}{b+x_i} - y_i\\right)^2\n\\end{align*}\n\nIn many application such problems are solved using a reduced gradient method that cannot guarantee global optimality. In nonlinear regression, it is possible to have multiple local optima because they are typically nonconvex.\n\n    Requirements:\n    - Use gurobipy (Model, GRB, addVar/addConstr, etc.)\n    - Make the script runnable as a standalone Python file if possible.\n    - Keep the code faithful to the example.\n"}, {"role": "assistant", "content": "import gurobipy as gp\nfrom gurobipy import GRB\n\nimport pandas as pd\nimport plotly.express as px\nimport plotly.graph_objects as go\nimport plotly.io as pio\nimport numpy as np\n\n# Data\npath = 'https://raw.githubusercontent.com/Gurobi/modeling-examples/master/optimization202/Modeling_Session_1/'\ndf = pd.read_excel(path + 'MMdata.xlsx') \n\n# Use the gurobipy multidict structure to unpack the data in our data frame\n# Data is from https://cran.r-project.org/web/packages/renz/vignettes/dirMM.html\npoints, xtrain, ytrain = gp.multidict({\n        row['index']: [float(row['x']), float(row['y'])] for ind,row in df.iterrows()\n    }) \n\n# Show the data:\nprint(\"Here are the x values:\")\nprint(xtrain)\n\nprint(\"\\nHere are the y values:\")\nprint(ytrain)\n\n# Create a figure\nfig = go.Figure()\nxtrain_arr = np.array(list(xtrain.values()))\nytrain_arr = np.array(list(ytrain.values()))\n\n# Add the first line\nfig.add_trace(go.Scatter(x=xtrain_arr, y=ytrain_arr, mode='markers', name='Training data'))\n\n# Update layout \nfig.update_layout(title='Nonlinear regression example: Reaction Speed vs Concentration',\n                  xaxis_title='x',\n                  yaxis_title='y',\n                  template='simple_white')\n# Show the figure\nfig.show()\n\n# Declare and initialize model\nmodel = gp.Model(\"Nonlinear regression\")\n\n# Create decision variables \n# Vmax = model.addVar(...) #complete the code\n# Km = model.addVar(...)\n\n# Create additional variables to define the model\nymax = max(ytrain.values()) # Used in a thoughtful upper bound on ymodel\n# (your code goes here)\n\n# Check your work by printing out the variables\nmodel.update()\nprint(\"The model variables are: \")\nfor v in model.getVars():\n    print(f\" - {v.varname} with lower bound of {v.lb} and upper bound of {v.ub}\")\n\n# Write out your constraint to define ymodel[i] for each data point in points\n# (your code goes here)\n\n# Write the objective\n# (your code goes here)\n\nmodel.write('nonlinear_regression.lp')\n\nmodel.optimize()\n\nstatus = model.status\nif status == GRB.OPTIMAL:\n    print(f\"An optimal solution was found with objective {model.objVal}\")\n    model.printAttr('X')\nelse:\n    print(f\"Model is not optimal, status = {status}\")\n\n# Create a figure\ndef ylist_MM(xlist, Vmax, Km):\n    return [Vmax*x/(Km + x) for x in xlist]\ndef mean_squared_error(xlist, ylist, Vmax, Km):\n    y = ylist_MM(xlist, Vmax, Km)\n    return np.sum((y-ylist)**2)/len(xlist)\n\n# Create a figure\nfig = go.Figure()\nxtrain_arr = np.array(list(xtrain.values()))\nytrain_arr = np.array(list(ytrain.values()))\nxplot = np.linspace(min(xtrain_arr), max(xtrain_arr), 100)\n\n# Add the first line\nfig.add_trace(go.Scatter(x=xtrain_arr, y=ytrain_arr, mode='markers', name='Training data'))\n\n# Add the second line\nlabel = \"dir-MM (R-method)\"\nthis_Vmax = 181.18\nthis_Km = 3.115\nMSE = mean_squared_error(xtrain_arr, ytrain_arr, this_Vmax, this_Km)\nfig.add_trace(go.Scatter(x=xplot, y=ylist_MM(xplot,this_Vmax, this_Km), mode='lines', name=f\"{label}: Vmax={round(this_Vmax,1)}, Km={round(this_Km,1)} (MSE={round(MSE,1)})\"))\n\n# Add the second line\nlabel = \"Gurobi\"\nMSE = mean_squared_error(xtrain_arr, ytrain_arr, Vmax.X, Km.X)\nfig.add_trace(go.Scatter(x=xplot, y=ylist_MM(xplot,Vmax.X, Km.X), mode='lines', name=f\"{label}: Vmax={round(Vmax.X,1)}, Km={round(Km.X,1)} (MSE={round(MSE,1)})\"))\n\n\n# Update layout (optional)\nfig.update_layout(title='Nonlinear regression example: Reaction Speed vs Concentration',\n                  xaxis_title='x',\n                  yaxis_title='y',)\nfig.update_layout(template='simple_white')\n# Show the figure\nfig.show()\n\n# Free Gurobi resources: Model and environment\nmodel.dispose()\ngp.disposeDefaultEnv()"}]}
{"meta": {"source_path": "/Users/sunyujun03/Desktop/ReLoop/gurobi-modeling-examples/optimization202/Modeling_Session_1/completed_nonlinear_regression_exercise.ipynb", "kind": "ipynb", "title": "Nonlinear regression: Estimating reaction parameters"}, "messages": [{"role": "system", "content": "You are an optimization engineer. Write correct and runnable Python code using gurobipy (Gurobi Python API). Be concise. Output only what is requested."}, {"role": "user", "content": "    Task: Reproduce the following Gurobi modeling example in Python using gurobipy.\n\n    Scenario description (from source):\n    # Nonlinear regression: Estimating reaction parameters\n\n## Motivation\n\n### What and why\nReady to dive into nonlinear regression? In nonlinear regression models, the relationship between the regression parameters and the outcome variable is nonlinear.  Here are a couple of regression models where the regression parameters $a$, $b$, and $c$ have a nonlinear relationship with the dependent variable $y$:\n\n$$y(x) = a\\cdot x^b+c$$\n$$y(x) = \\dfrac{a\\cdot x}{b+x}$$\n$$y(x) = \\dfrac{a}{1+b^{x-c}}$$\n\nNonlinear regression is essential in fields with complex relationships, providing flexibility for more accurate modeling. Notable applications include:\n\n- **Biology and Medicine**: Understanding growth rates and enzyme kinetics.\n- **Economics**: Analyzing complex demand and price curves.\n- **Environmental Science**: Uncovering relationships between crop yields and soil conditions.\n- **Physics and Engineering**: Understanding radioactive decay or modeling properties of materials.\n\nThese applications benefit from nonlinear regression's ability to deliver more accurate models and retain known model form for predictions and insights, especially in situations where linear regression approaches may fall short.\n\n### The nonlinear regression problem\nThe goal of nonlinear regression is to find the parameters that minimize the model error, typically measured by the squared error between the model’s predictions,  $y(x_i; \\text{regression parameters})$ and the actual data points $y_i$. In optimization terms, this process involves:\n- **Decision variables**: The regression parameters (e.g., $a$ and $b$ in our example below) that define the model.\n- **Data**: The \"variables\" from the regression model (e.g., y(x) and x) become data points $y_i$ and $x_i$ for all data points $i$.\n- **Objective**: Commonly, we minimize the sum of the squared error between the model predictions $y_{\\rm model}(x_i; a, b)$ and observed values $y_i$.  Sometimes, absolute error is used as an alternative.\n- **Constraints**: Often, nonlinear regression has no natural constraints, though bounds can be set on parameters as needed. In this exercise we will, we define $y_{\\rm model}(x)$ to establish our objective.\n\nHere’s the general form for least squares regression:\n\\begin{align*}\n{\\rm minimize}_{a,b} & \\quad \\displaystyle \\sum_{\\text{data points }i}   \\left(y_\\text{model}(x_i; a,b) - y_i\\right)^2\n\\end{align*}\n\nAnd, if we use our second example model from above $y(x) = \\dfrac{a\\cdot x}{b+x}$, this would be \n\\begin{align*}\n{\\rm minimize}_{a,b} & \\quad \\displaystyle \\sum_{\\text{data points }i}   \\left(\\dfrac{a\\cdot x_i}{b+x_i} - y_i\\right)^2\n\\end{align*}\n\nIn many application such problems are solved using a reduced gradient method that cannot guarantee global optimality. In nonlinear regression, it is possible to have multiple local optima because they are typically nonconvex.\n\n    Requirements:\n    - Use gurobipy (Model, GRB, addVar/addConstr, etc.)\n    - Make the script runnable as a standalone Python file if possible.\n    - Keep the code faithful to the example.\n"}, {"role": "assistant", "content": "import gurobipy as gp\nfrom gurobipy import GRB\n\nimport pandas as pd\nimport plotly.express as px\nimport plotly.graph_objects as go\nimport plotly.io as pio\nimport numpy as np\n\n# Data\npath = 'https://raw.githubusercontent.com/Gurobi/modeling-examples/master/optimization202/Modeling_Session_1/'\ndf = pd.read_excel(path + 'MMdata.xlsx') \n\n# Use the gurobipy multidict structure to unpack the data in our data frame\n# Data is from https://cran.r-project.org/web/packages/renz/vignettes/dirMM.html\npoints, xtrain, ytrain = gp.multidict({\n        row['index']: [float(row['x']), float(row['y'])] for ind,row in df.iterrows()\n    }) \n\n# Show the data:\nprint(\"Here are the x values:\")\nprint(xtrain)\n\nprint(\"\\nHere are the y values:\")\nprint(ytrain)\n\n# Create a figure\nfig = go.Figure()\nxtrain_arr = np.array(list(xtrain.values()))\nytrain_arr = np.array(list(ytrain.values()))\n\n# Add the first line\nfig.add_trace(go.Scatter(x=xtrain_arr, y=ytrain_arr, mode='markers', name='Training data'))\n\n# Update layout \nfig.update_layout(title='Nonlinear regression example: Reaction Speed vs Concentration',\n                  xaxis_title='x',\n                  yaxis_title='y',\n                  template='simple_white')\n# Show the figure\nfig.show()\n\n# Declare and initialize model\nmodel = gp.Model(\"Nonlinear regression\")\n\n# Create decision variables \nVmax = model.addVar(name='Vmax', ub=1000)\nKm = model.addVar(name='Km', ub=1000)\n\n# Create additional variables to define the model\nymax = max(ytrain.values()) # Used in a thoughtful upper bound on ymodel\nymodel = model.addVars(points, lb=-2*ymax, ub=2*ymax, name=\"ymodel\")\n\n# Check your work by printing out the variables\nmodel.update()\nprint(\"The model variables are: \")\nfor v in model.getVars():\n    print(f\" - {v.varname} with lower bound of {v.lb} and upper bound of {v.ub}\")\n\n# Write out your constraint to define ymodel[i] for each data poitn in points\nconstrs = model.addConstrs((ymodel[i]*(Km + xtrain[i])   == Vmax*xtrain[i] for i in points), name=\"Define_ymodel\")\n\n# Write the objective\nmodel.setObjective(sum((ymodel[i] - ytrain[i])**2 for i in points), sense=GRB.MINIMIZE)\n\nmodel.write('nonlinear_regression.lp')\n\nmodel.optimize()\n\nstatus = model.status\nif status == GRB.OPTIMAL:\n    print(f\"An optimal solution was found with objective {model.objVal}\")\n    model.printAttr('X')\nelse:\n    print(f\"Model is not optimal, status = {status}\")\n\n# Create a figure\ndef ylist_MM(xlist, Vmax, Km):\n    return [Vmax*x/(Km + x) for x in xlist]\ndef mean_squared_error(xlist, ylist, Vmax, Km):\n    y = ylist_MM(xlist, Vmax, Km)\n    return np.sum((y-ylist)**2)/len(xlist)\n\n# Create a figure\nfig = go.Figure()\nxtrain_arr = np.array(list(xtrain.values()))\nytrain_arr = np.array(list(ytrain.values()))\nxplot = np.linspace(min(xtrain_arr), max(xtrain_arr), 100)\n\n# Add the first line\nfig.add_trace(go.Scatter(x=xtrain_arr, y=ytrain_arr, mode='markers', name='Training data'))\n\n# Add the second line\nlabel = \"dir-MM (R-method)\"\nthis_Vmax = 181.18\nthis_Km = 3.115\nMSE = mean_squared_error(xtrain_arr, ytrain_arr, this_Vmax, this_Km)\nfig.add_trace(go.Scatter(x=xplot, y=ylist_MM(xplot,this_Vmax, this_Km), mode='lines', name=f\"{label}: Vmax={round(this_Vmax,1)}, Km={round(this_Km,1)} (MSE={round(MSE,1)})\"))\n\n# Add the second line\nlabel = \"Gurobi\"\nMSE = mean_squared_error(xtrain_arr, ytrain_arr, Vmax.X, Km.X)\nfig.add_trace(go.Scatter(x=xplot, y=ylist_MM(xplot,Vmax.X, Km.X), mode='lines', name=f\"{label}: Vmax={round(Vmax.X,1)}, Km={round(Km.X,1)} (MSE={round(MSE,1)})\"))\n\n\n# Update layout (optional)\nfig.update_layout(title='Nonlinear regression example: Reaction Speed vs Concentration',\n                  xaxis_title='x',\n                  yaxis_title='y',)\nfig.update_layout(template='simple_white')\n# Show the figure\nfig.show()\n\n# Free Gurobi resources: Model and environment\nmodel.dispose()\ngp.disposeDefaultEnv()"}]}
{"meta": {"source_path": "/Users/sunyujun03/Desktop/ReLoop/gurobi-modeling-examples/optimization202/next_level_modeling/modeling-with-genAI.ipynb", "kind": "ipynb", "title": "modeling-with-genAI"}, "messages": [{"role": "system", "content": "You are an optimization engineer. Write correct and runnable Python code using gurobipy (Gurobi Python API). Be concise. Output only what is requested."}, {"role": "user", "content": "    Task: Reproduce the following Gurobi modeling example in Python using gurobipy.\n\n    Scenario description (from source):\n    ### Links\n\n#### Gurobi AI Modeling Documentation\nhttps://gurobi-optimization-gurobi-ai-modeling.readthedocs-hosted.com/en/latest/\n\n#### Gurobi AI Modeling GPT\nhttps://chatgpt.com/g/g-g69cy3XAp-gurobi-ai-modeling-assistant\n\nThis will work best if you have a *Plus* account, but should generate formulations and code without it. \n\n#### Source Data\nhttps://www.kaggle.com/datasets/pedroisrael/mix-marketing-analysis?select=Bathrooms_random_data2.csv\n\n### Prompt Template\n\nProblem description:\n<describe the problem on a high level, making sure you also introduce the context. Normally, 3-5 sentences is sufficient for this.>\n\nObjective: <Maximize/Minimize> <objective>\n\nConstraints:\n- <constraint name 1>: <describe constraint>\n- <constraint name 2>: <describe constraint>\n- <constraint name 3>: <describe constraint>\n- etc.\n\nData:\n<data in csv format, including headers> or \\<upload your files and name the filename here>\n\n### Regression Data\n\n### How I'd Model the Problem:\nAdding in an assumption that there are no free ads\n\n    Requirements:\n    - Use gurobipy (Model, GRB, addVar/addConstr, etc.)\n    - Make the script runnable as a standalone Python file if possible.\n    - Keep the code faithful to the example.\n"}, {"role": "assistant", "content": "import pandas as pd\npath = 'https://raw.githubusercontent.com/yurchisin/ODSC2024/refs/heads/main/data_files/'\nlm_coeff = pd.read_csv(path + 'lm_coeff.csv', index_col=['productcategory','mediatype','platform'])\nlm_coeff\n\n### Paste any code you want to test out\n# %pip install gurobipy\n\nimport gurobipy as gp\nfrom gurobipy import GRB\n\nm = gp.Model(\"mmo\")\n\nno_free_ads = 10 # assume there is a positive min spend, calculate this how ever you want\nB = 373896 # average total weekly spend, use that as budget\n\nspend = m.addVars(lm_coeff.index, vtype=GRB.SEMICONT, lb = (lm_coeff.min_spend+no_free_ads), ub = (lm_coeff.max_spend+no_free_ads), name = 'spend')\nimpressions = m.addVars(lm_coeff.index, name = 'impressions')\n\nlm_eqs = m.addConstrs((impressions[i,j,k] == lm_coeff.slope[i,j,k]*spend[i,j,k] for [i, j, k] in lm_coeff.index), name='lm_eqs')\ntotal_budget = m.addConstr(spend.sum() <= B, name = 'total_budget')\n\nm.setObjective(impressions.sum(), sense = GRB.MAXIMIZE)\n\nm.optimize()\n\nspend_values = pd.Series(m.getAttr('X', spend), name = \"dollars\", index = lm_coeff.index)\nspend_values[spend_values > 0]"}]}
{"meta": {"source_path": "/Users/sunyujun03/Desktop/ReLoop/gurobi-modeling-examples/decentralization_planning/decentralization_planning.ipynb", "kind": "ipynb", "title": "Decentralization Planning"}, "messages": [{"role": "system", "content": "You are an optimization engineer. Write correct and runnable Python code using gurobipy (Gurobi Python API). Be concise. Output only what is requested."}, {"role": "user", "content": "    Task: Reproduce the following Gurobi modeling example in Python using gurobipy.\n\n    Scenario description (from source):\n    # Decentralization Planning\n\n## Objective and Prerequisites\n\nReady for a mathematical optimization modeling challenge? Put your skills to the test with this example, where you’ll learn how to model and solve a decentralization planning problem. You’ll have to figure out – given a set of departments of a company, and potential cities where these departments can be located – the “best” location for each department in order to maximize gross margins.\n\nThis model is example 10 from the fifth edition of Model Building in Mathematical Programming by H. Paul Williams on pages 265 and 317-319.\n\nThis modeling example is at the advanced level, where we assume that you know Python and the Gurobi Python API and that you have advanced knowledge of building mathematical optimization models. Typically, the objective function and/or constraints of these examples are complex or require advanced features of the Gurobi Python API.\n\n**Download the Repository** <br /> \nYou can download the repository containing this and other examples by clicking [here](https://github.com/Gurobi/modeling-examples/archive/master.zip). \n\n## Problem Description\n\nA large company wants to move some of its departments out of London. Doing so will result in reduced costs in some areas\n(such as cheaper housing, government incentives, easier recruitment, etc.), and increased costs in other areas (such as communication between departments). The cost implications for all possible locations of each department have been calculated.\nThe goal is to determine where to locate each department in order to maximize the total difference between the reduced costs  from relocating and the increased communication costs between departments.\n\nThe company comprises five departments (A, B, C, D and E). The possible cities for relocation are Bristol and Brighton, or a department may be kept in London. None of these cities (including London) may be the location for more than three of the departments.\n\n## Model Formulation\n\n### Sets and Indices\n\n$d,d2 \\in \\text{Departments}=\\{A,B,C,D,E\\}$\n\n$c,c2 \\in \\text{Cities}=\\{\\text{Bristol}, \\text{Brighton}, \\text{London}\\}$\n\n### Parameters\n\n$\\text{benefit}_{d,c} \\in \\mathbb{R}^+$: Benefit -in thousands of dollars per year, derived from relocating department $d$  to city $c$.\n\n$\\text{communicationCost}_{d,c,d2,c2} \\in \\mathbb{R}^+$: Communication cost -in thousands of dollars per year, derived from relocating department $d$  to city $c$ and relocating department $d2$  to city $c2$.\n\nWe define the set $dcd2c2 = \\{(d,c,d2,c2) \\in \\text{Departments} \\times \\text{Cities} \\times \\text{Departments} \\times \\text{Cities}: \\text{communicationCost}_{d,c,d2,c2} > 0  \\}$\n\n### Decision Variables\n\n$\\text{locate}_{d,c} \\in \\{0,1 \\}$: This binary variable is equal 1, if department $d$  is located at city $c$, and 0 otherwise.\n\n$y_{d,c,d2,c2} = \\text{locate}_{d,c}*\\text{locate}_{d2,c2} \\in \\{0,1 \\}$: This auxiliary binary variable is equal 1, if department $d$ is located at city $c$ and department $d2$ is located at city $c2$, and 0 otherwise. \n\n### Constraints\n\n**Department location**: Each department must be located in only one city.\n\n\\begin{equation}\n\\sum_{c \\in \\text{Cities}} \\text{locate}_{d,c} = 1 \\quad \\forall d \\in \\text{Departments}\n\\end{equation}\n\n**Departments limit**: No city may be the location for more than three departments.\n\n\\begin{equation}\n\\sum_{d \\in \\text{Departments}} \\text{locate}_{d,c} \\leq 3 \\quad \\forall c \\in \\text{Cities}\n\\end{equation}\n\n**Logical Constraints**: \n\n- If $y_{d,c,d2,c2} = 1$ then $\\text{locate}_{d,c} = 1$ and $\\text{locate}_{d2,c2} = 1$.\n\n\\begin{equation}\ny_{d,c,d2,c2} \\leq \\text{locate}_{d,c} \\quad \\forall (d,c,d2,c2) \\in dcd2c2\n\\end{equation}\n\n\\begin{equation}\ny_{d,c,d2,c2} \\leq \\text{locate}_{d2,c2} \\quad \\forall (d,c,d2,c2) \\in dcd2c2\n\\end{equation}\n\n-  If $\\text{locate}_{d,c} = 1$ and $\\text{locate}_{d2,c2} = 1 $ then $y_{d,c,d2,c2} = 1$.\n\n\\begin{equation}\n\\text{locate}_{d,c} + \\text{locate}_{d2,c2} - y_{d,c,d2,c2} \\leq 1 \\quad  \\forall (d,c,d2,c2) \\in dcd2c2\n\\end{equation}\n\n### Objective Function\n\n**Gross margin**: Maximize the gross margin of relocation.\n\n\\begin{equation}\n\\text{Maximize} \\quad Z = \\sum_{d \\in \\text{Departments}} \\sum_{c \\in \\text{Cities}} \\text{benefit}_{d,c}*\\text{locate}_{d,c} -\n\\sum_{d,c,d2,c2 \\in dcd2c2} \\text{communicationCost}_{d,c,d2,c2}*y_{d,c,d2,c2}\n\\end{equation}\n\nThis linear integer programming formulation of the decentralization problem is in fact a linearization of a quadratic assignment formulation of this problem. With Gurobi 9.0, you can directly solve  the quadratic assignment formulation of the decentralization problem without the auxiliary variables and the logical constraints.\n\n### Objective Function\n\n**Gross margin**: Maximize the gross margin of relocation.\n\n\\begin{equation}\n\\text{Maximize} \\quad Z = \\sum_{d \\in \\text{Departments}} \\sum_{c \\in \\text{Cities}} \\text{benefit}_{d,c}*\\text{locate}_{d,c} -\n\\sum_{d,c,d2,c2 \\in dcd2c2} \\text{communicationCost}_{d,c,d2,c2}*\\text{locate}_{d,c}*\\text{locate}_{d2,c2}\n\\end{equation}\n\n### Constraints\n\n**Department location**: Each department must be located in only one city.\n\n\\begin{equation}\n\\sum_{c \\in \\text{Cities}} \\text{locate}_{d,c} = 1 \\quad \\forall d \\in \\text{Departments}\n\\end{equation}\n\n**Departments limit**: No city may be the location for more than three departments.\n\n\\begin{equation}\n\\sum_{d \\in \\text{Departments}} \\text{locate}_{d,c} \\leq 3 \\quad \\forall c \\in \\text{Cities}\n\\end{equation}\n\n## Python Implementation\n\nWe import the Gurobi Python Module and other Python libraries.\n\n    Requirements:\n    - Use gurobipy (Model, GRB, addVar/addConstr, etc.)\n    - Make the script runnable as a standalone Python file if possible.\n    - Keep the code faithful to the example.\n"}, {"role": "assistant", "content": "import pandas as pd\n\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# tested with Python 3.11 & Gurobi 11.0\n\n# Lists of deparments and cities\n\nDeparments = ['A','B','C','D','E']\nCities = ['Bristol', 'Brighton', 'London']\n\n# Create a dictionary to capture benefits -in thousands of dollars from relocation.\n\nd2c, benefit = gp.multidict({\n    ('A', 'Bristol'): 10,\n    ('A', 'Brighton'): 10,\n    ('A', 'London'): 0,\n    ('B', 'Bristol'): 15,\n    ('B', 'Brighton'): 20,\n    ('B', 'London'): 0,\n    ('C', 'Bristol'): 10,\n    ('C', 'Brighton'): 15,\n    ('C', 'London'): 0,\n    ('D', 'Bristol'): 20,\n    ('D', 'Brighton'): 15,\n    ('D', 'London'): 0,\n    ('E', 'Bristol'): 5,\n    ('E', 'Brighton'): 15,\n    ('E', 'London'): 0\n})\n\n# Create a dictionary to capture the communication costs -in thousands of dollars from relocation.\n\ndcd2c2, communicationCost = gp.multidict({\n    ('A','London','C','Bristol'): 13,\n    ('A','London','C','Brighton'): 9,\n    ('A','London','C','London'): 10,\n    ('A','London','D','Bristol'): 19.5,\n    ('A','London','D','Brighton'): 13.5,\n    ('A','London','D','London'): 15,\n    ('B','London','C','Bristol'): 18.2,\n    ('B','London','C','Brighton'): 12.6,\n    ('B','London','C','London'): 14,\n    ('B','London','D','Bristol'): 15.6,\n    ('B','London','D','Brighton'): 10.8,\n    ('B','London','D','London'): 12,\n    ('C','London','E','Bristol'): 26,\n    ('C','London','E','Brighton'): 18,\n    ('C','London','E','London'): 20,\n    ('D','London','E','Bristol'): 9.1,\n    ('D','London','E','Brighton'): 6.3,\n    ('D','London','E','London'): 7,\n    ('A','Bristol','C','Bristol'): 5,\n    ('A','Bristol','C','Brighton'): 14,\n    ('A','Bristol','C','London'): 13,\n    ('A','Bristol','D','Bristol'): 7.5,\n    ('A','Bristol','D','Brighton'): 21,\n    ('A','Bristol','D','London'): 19.5,\n    ('B','Bristol','C','Bristol'): 7,\n    ('B','Bristol','C','Brighton'): 19.6,\n    ('B','Bristol','C','London'): 18.2,\n    ('B','Bristol','D','Bristol'): 6,\n    ('B','Bristol','D','Brighton'): 16.8,\n    ('B','Bristol','D','London'): 15.6,\n    ('C','Bristol','E','Bristol'): 10,\n    ('C','Bristol','E','Brighton'): 28,\n    ('C','Bristol','E','London'): 26,\n    ('D','Bristol','E','Bristol'): 3.5,\n    ('D','Bristol','E','Brighton'): 9.8, \n    ('D','Bristol','E','London'): 9.1,\n    ('A','Brighton','C','Bristol'): 14,\n    ('A','Brighton','C','Brighton'): 5,\n    ('A','Brighton','C','London'): 9,\n    ('A','Brighton','D','Bristol'): 21,\n    ('A','Brighton','D','Brighton'): 7.5,\n    ('A','Brighton','D','London'): 13.5,\n    ('B','Brighton','C','Bristol'): 19.6,\n    ('B','Brighton','C','Brighton'): 7,\n    ('B','Brighton','C','London'): 12.6,\n    ('B','Brighton','D','Bristol'): 16.8,\n    ('B','Brighton','D','Brighton'): 6,\n    ('B','Brighton','D','London'): 10.8,\n    ('C','Brighton','E','Bristol'): 28,\n    ('C','Brighton','E','Brighton'): 10,\n    ('C','Brighton','E','London'): 18,\n    ('D','Brighton','E','Bristol'): 9.8,\n    ('D','Brighton','E','Brighton'): 3.5,\n    ('D','Brighton','E','London'): 6.3\n})\n\nmodel = gp.Model('decentralization')\n\n# Set global parameters \nmodel.params.nonConvex = 2\n\n# locate deparment d at city c\nlocate = model.addVars(d2c, vtype=GRB.BINARY, name=\"locate\")\n\n# Department location constraint\n\ndepartment_location = model.addConstrs((gp.quicksum(locate[d,c] for c in Cities) == 1 for d in Deparments), \n                                    name='department_location')\n\n# Limit on number of departments\n\ndepartments_limit = model.addConstrs((gp.quicksum(locate[d,c] for d in Deparments) <= 3 for c in Cities), \n                                    name='departments_limit')\n\nmodel.setObjective((gp.quicksum(benefit[d,c]*locate[d,c] for d,c in d2c) \n                    - gp.quicksum(communicationCost[d,c,d2,c2]*locate[d,c]*locate[d2,c2] for d,c,d2,c2 in dcd2c2) ),\n                   GRB.MAXIMIZE)\n\n# Verify model formulation\n\nmodel.write('decentralizationQA.lp')\n\n# Run optimization engine\n\nmodel.optimize()\n\nrelocation_plan = pd.DataFrame(\n    {key for key, var in locate.items() if var.x > 0.5},\n    columns = [\"Department\", \"City\"],\n)\nrelocation_plan.index=['']*len(relocation_plan)\nrelocation_plan.sort_values([\"Department\", \"City\"])\n\nprint(\"\\n\\n_________________________________________________________________________________\")\nprint(f\"Financial report\")\nprint(\"_________________________________________________________________________________\")\ntotal_benefit = 0\nfor c in Cities:\n    for d in Deparments:\n        if(locate[d,c].x > 0.5):\n            total_benefit += 1000*benefit[d,c]\n\ndollars_benefit = '${:,.2f}'.format(total_benefit)\nprint(f\"The yearly total benefit is {dollars_benefit} dollars\")\n\ntotal_communication_cost = 0\nfor d,c,d2,c2 in dcd2c2:\n    if(locate[d,c].x*locate[d2,c2].x > 0.5):\n        total_communication_cost += 1000*communicationCost[d,c,d2,c2]\n\ndollars_communication_cost = '${:,.2f}'.format(total_communication_cost)\nprint(f\"The yearly total communication cost is {dollars_communication_cost} dollars\")\n\ntotal_gross_margin = total_benefit - total_communication_cost\ndollars_gross_margin = '${:,.2f}'.format(total_gross_margin)\nprint(f\"The yearly total gross margin is {dollars_gross_margin} dollars\")"}]}
{"meta": {"source_path": "/Users/sunyujun03/Desktop/ReLoop/gurobi-modeling-examples/workforce/workforce_scheduling.ipynb", "kind": "ipynb", "title": "Workforce Scheduling Problem"}, "messages": [{"role": "system", "content": "You are an optimization engineer. Write correct and runnable Python code using gurobipy (Gurobi Python API). Be concise. Output only what is requested."}, {"role": "user", "content": "    Task: Reproduce the following Gurobi modeling example in Python using gurobipy.\n\n    Scenario description (from source):\n    # Workforce Scheduling Problem\n\n## Objective and Prerequisites\n\nIn this example, you’ll learn how to solve a critical, central problem in the services industry: workforce scheduling. We’ll demonstrate how you can use mathematical optimization to generate an optimal workforce schedule that meets your business requirements, maximizes employee fairness and satisfaction, and minimizes the number of temporary workers your company needs to hire.\n\nThis modeling example is at the advanced level, where we assume that you know Python and the Gurobi Python API and that you have advanced knowledge of building mathematical optimization models. Typically, the objective function and/or constraints of these examples are complex or require advanced features of the Gurobi Python API.\n\n**Download the Repository** <br />\nYou can download the repository containing this and other examples by clicking [here](https://github.com/Gurobi/modeling-examples/archive/master.zip). \n\n## Motivation\nPeople are the most important asset for companies in the services industry as well as their largest source of costs.\nWorkforce allocation and personnel scheduling deal with the arrangement of work schedules  and the assignment of personnel shifts in order to cover the demand for resources that vary over time.\n\nThese problems are very important for companies in the services industries who rely on workforce resources such as:\n- Telephone operators\n- Hospital nurses\n- Policemen\n- Transportation personnel (plane crews, bus drivers, etc.)\n- Hospitality personnel\n- Restaurant personnel\n\n## Problem Description\n\nConsider a service business, like a restaurant, that develops its workforce plans for the next two weeks (considering a 7-day week). The service requires only one set of skills. There are a number of employed workers with the same set of skills and with identical productivity that are available to work on some of the days during the two-week planning horizon. There is only one shift per workday. Each shift may have different resource (worker) requirements on each workday. The service business may hire extra (temp) workers from an agency to satisfy shift requirements. The service business wants to minimize the number of extra workers that it needs to hire, and as a secondary objective, it wants to balance the workload of employed workers to ensure fairness.\n\n## Model Formulation\nMathematical programming is a declarative approach where the modeler formulates a mathematical optimization problem that captures the key features of a complex decision problem. The Gurobi Optimizer solves the mathematical optimization problem using state-of-the-art mathematics and computer science.\n\nA mathematical optimization model has five components:\n- Sets.\n- Parameters.\n- Decision variables.\n- Constraints.\n- Objective function(s).\n\n### Sets and Indices\n\n$s \\in \\text{shifts}$: Index and set of shifts.\n\n$w \\in workers$: Index and set of employed workers.\n\n$availability= \\{(w,s): w \\in workers \\; \\text{is available for} \\; s \\in \\text{shifts} \\}$: This set determines that the employed worker  $w$ is available to work on shift $s$.\n\n### Parameters\n\n$\\text{shiftRequirements}(s) \\in \\mathbb{N}$: This parameter represents the number of workers required at each shift \n$s \\in \\text{shifts}$.\n\n$pay(w) \\in \\mathbb{R^{+}}$: This parameter is the salary per day of each worker $w \\in workers$. \n\n$relTol$: This relative tolerance parameter  makes it possible to deviate from the optimal objective function value of the primary objective, when solving the model for the secondary objective. (See explanation below of the multi-objective optimization process).\n\n### Computed Parameters\nThese parameters are derived from the input parameters and/or from the optimization process.\n\n$Opt(totSlack)$: This parameter is the minimum value of extra workers required to fill demand. \n\n### Decision Variables\n\n$x(w,s) \\in \\{0,1\\}$: This variable equals 1 if worker $w \\in workers$ is assigned to shift $s \\in \\text{shifts}$, \nand 0 otherwise.\nThis decision variable is defined over the $availability$ set.\n\n$Slack(s) \\geq 0$: This variable is the number of extra workers required to satisfy the requirements of shift $s$.\n\n### Auxiliary Variables\nAuxiliary variables are derived from the values of the decision variables.\n\n$totSlack$: This variable counts the total number of extra workers required to satisfy the demand for shift workers.\n\n$\\text{totShifts}(w)$: This variable counts the total number of shifts worked by each worker $w \\in workers$.\n\n$\\text{minShift}$: This variable determines the minimum number of shifts allocated to workers. \n\n$\\text{maxShift}$: This variable  determines the maximum number of shifts allocated to workers.\n\n## Optimization Process\n\nIn this modeling example, we tackle a multi-objective model where the primary objective is to minimize the number of extra workers required to satisfy shift requirements, and the secondary objective is to minimize the maximum difference in the number of shifts worked between any pair of workers. This secondary objective balances the workload allocated to workers.\n\nThe hierarchical multi-objective optimization approach will first solve the following model with the primary objective.\n\n### Objective Function\n\n- **Primary objective:** The objective function is to minimize the number of extra workers allocated. \n\n\\begin{equation}\n\\text{Min} \\quad totSlack\n\\tag{0}\n\\end{equation}\n\n### Constraints\n\n- **Shift requirements:**  All shifts requirements most be satisfied.\n\n\\begin{equation}\n\\sum_{w \\: \\in \\: workers} x(w,s)  +  Slack(s) = \\text{shiftRequirements}(s) \\quad \\forall \\; s \\in \\text{shifts}\n\\tag{1}\n\\end{equation}\n\n- **Temps:** Compute the total number of extra workers required.\n\n\\begin{equation}\n\\sum_{s \\: \\in \\: \\text{shifts}} Slack(s) =  totSlack \n\\tag{2}\n\\end{equation}\n\n- **Shifts:**  Compute the total number of shifts for each worker.\n\n\\begin{equation}\n\\sum_{s \\: \\in \\: \\text{shifts}} x(w,s)  = \\text{totShifts}(w) \\quad \\forall \\; w \\in workers\n\\tag{3}\n\\end{equation}\n\n- **Binary and non-negativity constraints:**\n\n$$\nx(w,s) \\in \\{0, 1 \\}  \\quad \\forall \\; (w,s) \\in availability\n$$\n\n$$\nSlack(s) \\geq 0 \\quad  \\forall \\; s \\in \\text{shifts}\n$$\n\n$$\n\\text{totShifts}(w) \\geq 0 \\quad \\forall \\; w \\in workers\n$$\n\n$$\ntotSlack  \\geq 0\n$$\n\nThe parameter $Opt(totSlack)$ is set to be equal to the minimum number of extra workers required to satisfy demand. That is, $Opt(totSlack) = totSlack^{*} $, where $totSlack^{*} $ is the optimal value of the variable $totSlack$.\n\nFor a given relative tolerance of primary objective $relTol$, we now solve the following model where we minimize the secondary objective.\n\n### Objective Function\n\n- **Secondary objective:** The objective function is to minimize the difference between the maximum number of shifts allocated to a worker, and the minimum number of shifts allocated to a worker. \n\n\\begin{equation}\n\\text{Min} \\quad ( \\text{maxShift} -  \\text{minShift} )\n\\tag{4}\n\\end{equation}\n\n### Constraints\n\n- **Shift requirements:**  All shifts requirements most be satisfied.\n\n\\begin{equation}\n\\sum_{w \\: \\in \\: workers} x(w,s)  +  Slack(s) = \\text{shiftRequirements}(s) \\quad \\forall \\; s \\in \\text{shifts}\n\\tag{1}\n\\end{equation}\n\n- **Relative tolerance:**  Ensure that the total number of extra workers (totSlack) minimized by the primary objective is satisfied up to a tolerance percentage.\n\n\\begin{equation}\n\\sum_{s \\: \\in \\: shifts} Slack(s) \\leq (1+relTol)*Opt(totSlack)\n\\tag{5}\n\\end{equation}\n\n- **Shifts:**  Compute the total number of shifts for each worker.\n\n\\begin{equation}\n\\sum_{s \\: \\in \\: \\text{shifts}} x(w,s)  = \\text{totShifts}(w) \\quad \\forall \\; w \\in workers\n\\tag{3}\n\\end{equation}\n\n- **Minimum shifts:**  Compute the minimum number of shifts allocated to an employed worker.\n\n\\begin{equation}\n\\text{minShift} = \\text{Min} \\{\\text{totShifts}(w): \\ w \\; in \\; workers \\}  \n\\tag{6}\n\\end{equation}\n\n- **Maximum shifts:**  Compute the maximum number of shifts allocated to an employed worker.\n\n\\begin{equation}\n\\text{maxShift} = \\text{Max} \\{\\text{totShifts}(w): \\ w \\; in \\; workers \\}\n\\tag{7}\n\\end{equation}\n\n- **Binary and non-negativity constraints:**\n\n$$\nx(w,s) \\in \\{0, 1 \\}  \\quad \\forall \\; (w,s) \\in availability\n$$\n\n$$\nSlack(s) \\geq 0 \\quad  \\forall \\; s \\in \\text{shifts}\n$$\n\n$$\n\\text{totShifts}(w) \\geq 0 \\quad   \\forall \\; w \\in workers\n$$\n\n$$\n\\text{maxShift},  \\text{minShift}   \\geq 0\n$$\n\nThis optimization process is done automatically by the Gurobi Python API when using the following method: \n\n\"Model.setObjectiveN()\"\n\n## Python Implementation\n\nWe now import the Gurobi Python Module. Then, we initialize the data structures with the given data.\n\n## Input Data\n\nWe define all the input data of the model.\n\n### Parameter\n\n$\\text{shiftRequirements}(s) \\in \\mathbb{N}$: This parameter represents the number of workers required at each shift \n$s \\in \\text{shifts}$.\n\n    Requirements:\n    - Use gurobipy (Model, GRB, addVar/addConstr, etc.)\n    - Make the script runnable as a standalone Python file if possible.\n    - Keep the code faithful to the example.\n"}, {"role": "assistant", "content": "# This command imports the Gurobi functions and classes.\n\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n\nimport pandas as pd\nfrom pylab import *\nimport matplotlib\nimport matplotlib.pyplot as plt\n\n# Number of workers required for each shift.\nshifts, shiftRequirements = gp.multidict({\n  \"Mon1\":  3,\n  \"Tue2\":  2,\n  \"Wed3\":  4,\n  \"Thu4\":  4,\n  \"Fri5\":  5,\n  \"Sat6\":  6,\n  \"Sun7\":  5,\n  \"Mon8\":  2,\n  \"Tue9\":  2,\n  \"Wed10\": 3,\n  \"Thu11\": 4,\n  \"Fri12\": 6,\n  \"Sat13\": 7,\n  \"Sun14\": 5 })\n\n# Amount each worker is paid to work one shift.\nworkers, pay = gp.multidict({\n  \"Amy\":   10,\n  \"Bob\":   12,\n  \"Cathy\": 10,\n  \"Dan\":   8,\n  \"Ed\":    8,\n  \"Fred\":  9,\n  \"Gu\":    11 })\n\n# Worker availability: defines on which day each employed worker is available.\n\navailability = gp.tuplelist([\n('Amy', 'Tue2'), ('Amy', 'Wed3'), ('Amy', 'Fri5'), ('Amy', 'Sun7'),\n('Amy', 'Tue9'), ('Amy', 'Wed10'), ('Amy', 'Thu11'), ('Amy', 'Fri12'),\n('Amy', 'Sat13'), ('Amy', 'Sun14'), ('Bob', 'Mon1'), ('Bob', 'Tue2'),\n('Bob', 'Fri5'), ('Bob', 'Sat6'), ('Bob', 'Mon8'), ('Bob', 'Thu11'),\n('Bob', 'Sat13'), ('Cathy', 'Wed3'), ('Cathy', 'Thu4'), ('Cathy', 'Fri5'),\n('Cathy', 'Sun7'), ('Cathy', 'Mon8'), ('Cathy', 'Tue9'), ('Cathy', 'Wed10'),\n('Cathy', 'Thu11'), ('Cathy', 'Fri12'), ('Cathy', 'Sat13'),\n('Cathy', 'Sun14'), ('Dan', 'Tue2'), ('Dan', 'Wed3'), ('Dan', 'Fri5'),\n('Dan', 'Sat6'), ('Dan', 'Mon8'), ('Dan', 'Tue9'), ('Dan', 'Wed10'),\n('Dan', 'Thu11'), ('Dan', 'Fri12'), ('Dan', 'Sat13'), ('Dan', 'Sun14'),\n('Ed', 'Mon1'), ('Ed', 'Tue2'), ('Ed', 'Wed3'), ('Ed', 'Thu4'),\n('Ed', 'Fri5'), ('Ed', 'Sun7'), ('Ed', 'Mon8'), ('Ed', 'Tue9'),\n('Ed', 'Thu11'), ('Ed', 'Sat13'), ('Ed', 'Sun14'), ('Fred', 'Mon1'),\n('Fred', 'Tue2'), ('Fred', 'Wed3'), ('Fred', 'Sat6'), ('Fred', 'Mon8'),\n('Fred', 'Tue9'), ('Fred', 'Fri12'), ('Fred', 'Sat13'), ('Fred', 'Sun14'),\n('Gu', 'Mon1'), ('Gu', 'Tue2'), ('Gu', 'Wed3'), ('Gu', 'Fri5'),\n('Gu', 'Sat6'), ('Gu', 'Sun7'), ('Gu', 'Mon8'), ('Gu', 'Tue9'),\n('Gu', 'Wed10'), ('Gu', 'Thu11'), ('Gu', 'Fri12'), ('Gu', 'Sat13'),\n('Gu', 'Sun14')\n])\n\n# Create initial model.\nm = gp.Model(\"workforce5\")\n\n# Initialize assignment decision variables.\n\nx = m.addVars(availability, vtype=GRB.BINARY, name=\"x\")\n\n# Slack decision variables determine the number of extra workers required to satisfy the requirements \n# of each shift\nslacks = m.addVars(shifts, name=\"Slack\")\n\n# Auxiliary variable totSlack to represent the total number of extra workers required to satisfy the \n# requirements of all the shifts.\ntotSlack = m.addVar(name='totSlack')\n\n# Auxiliary variable totShifts counts the total shifts worked by each employed worker\ntotShifts = m.addVars(workers, name=\"TotShifts\")\n\n# Constraint: All shifts requirements most be satisfied.\n\nshift_reqmts = m.addConstrs((x.sum('*',s) + slacks[s] == shiftRequirements[s] for s in shifts), name='shiftRequirement')\n\n# Constraint: set the auxiliary variable (totSlack) equal to the total number of extra workers \n# required to satisfy shift requirements\n \nnum_temps = m.addConstr(totSlack == slacks.sum(), name='totSlack')\n\n# Constraint: compute the total number of shifts for each worker\n\nnum_shifts = m.addConstrs((totShifts[w] == x.sum(w,'*') for w in workers), name='totShifts')\n\n# Auxiliary variables. \n# minShift is the minimum number of shifts allocated to workers \n# maxShift is the maximum number of shifts allocated to workers\n\nminShift = m.addVar(name='minShift')\n\nmaxShift = m.addVar(name='maxShift')\n\n# Constraint: \n# The addGenConstrMin() method of the model object m adds a new general constraint that \n# determines the minimum value among a set of variables. \n# The first argument is the variable whose value will be equal to the minimum of the other variables, \n# minShift in this case. \n# The second argument is the set variables over which the minimum will be taken, (totShifts) in \n# this case. \n# Recall that the totShifts variable is defined over the set of worker and determines the number of \n# shifts that an employed worker will work. The third argument is the name of this constraint.\n\nmin_constr = m.addGenConstrMin(minShift, totShifts, name='minShift')\n\n# Constraint: \n# Similarly, the addGenConstrMax() method of the model object m adds a new general \n# constraint that determines the maximum value among a set of variables.\n\nmax_constr = m.addGenConstrMax(maxShift, totShifts, name='maxShift')\n\n# Set global sense for ALL objectives.\n# This means that all objectives of the model object m are going to be minimized\nm.ModelSense = GRB.MINIMIZE\n\n# Set up primary objective.\n\n# The setObjectiveN() method of the model object m allows to define multiple objectives.\n# The first argument is the linear expression defining the most important objective, called primary \n# objective, in this case it is the minimization of extra workers required to satisfy shift \n# requirements. \n# The second argument is the index of the objective function, we set the index of the primary \n# objective to be equal to 0. \n# The third argument is the priority of the objective.\n# The fourth argument is the relative tolerance to degrade this objective when a lower priority\n# objective is optimized. The fifth argument is the name of this objective.\n# A hierarchical or lexicographic approach assigns a priority to each objective, and optimizes \n# for the objectives in decreasing priority order. \n# For this problem, we have two objectives, and the primary objective has the highest priority \n# which is equal to 2. \n# When the secondary objective is minimized, since the relative tolerance is 0.2, we can only \n# increase the minimum number of extra workers up to 20%. \n# For example if the minimum number extra workers is 10, then when optimizing the secondary objective \n# we can have up to 12 extra workers.\n\nm.setObjectiveN(totSlack, index=0, priority=2, reltol=0.2, name='TotalSlack')\n\n# Set up secondary objective.\n\n# The secondary objective is called fairness and its goal is to balance the workload assigned \n# to the employed workers. \n# To balance the workload assigned to the employed workers, we can minimize the difference \n# between the maximum number of shifts assigned to an employed worker and the minimum number \n# of shifts assigned to an employed worker.\n\nm.setObjectiveN(maxShift - minShift, index=1, priority=1, name='Fairness')\n\n# Save model formulation for inspection\n\nm.write('workforce.lp')\n\n# Optimize\n# This method runs the optimization engine to solve the MIP problem in the model object m\nm.optimize()\n\n# The Status attribute  provides current optimization status of the model object m\n# In workforce model, we check if the model is infeasible or unbounded and report this situation\nstatus = m.Status\nif status == GRB.Status.INF_OR_UNBD or status == GRB.Status.INFEASIBLE  or status == GRB.Status.UNBOUNDED:\n    print('The model cannot be solved because it is infeasible or unbounded')\n    sys.exit(0)\n# If the optimization status of the model is not optimal for some other reason, we report that \n# situation.\nif status != GRB.Status.OPTIMAL:\n    print('Optimization was stopped with status ' + str(status))\n    sys.exit(0)\n\n# Print total slack and the number of shifts worked for each worker\n# The KPIs for this optimization number is the number of extra worked required to satisfy \n# demand and the number of shifts that each employed worker is working.\nsolution = {}\nshifts_sol = {}\nsolution['Total slack required'] = str(totSlack.X)\nassignments_all = {}\ngant={}\n\nassignments = dict()\nfor [w, s] in availability:\n    if x[w, s].x == 1:\n        if w in assignments:\n            assignments[w].append(s)\n        else:\n            assignments[w] = [s]\n\n\nprint(pd.DataFrame.from_records(list(solution.items()), columns=['KPI', 'Value']))\nprint('-'*50)\n\nfor w in workers:\n    shifts_sol[w]=totShifts[w].X\n    assignments_all[w]=assignments.get(w, [])\n\nprint('Shifts')\nprint(pd.DataFrame.from_records(list(shifts_sol.items()), columns=['Worker', 'Number of shifts']))\n    \ny_pos = np.arange(len(shifts_sol.keys())) \nplt.bar(y_pos,shifts_sol.values() , align='center')\nplt.xticks(y_pos, shifts_sol.keys())\nplt.show()\n\nprint('-'*50)\nfor w in assignments_all:\n    gant[w] = [w]\n    for d in shifts:\n        gant[w].append('*' if d in assignments_all[w] else '-')\n\nprint('Assigments')\nprint('Symbols: \\'-\\': not working, \\'*\\': working')\npd.set_option('display.width', 1000)\nprint(pd.DataFrame.from_records(list(gant.values()), columns=['worker']+shifts))"}]}
{"meta": {"source_path": "/Users/sunyujun03/Desktop/ReLoop/gurobi-modeling-examples/offshore_wind_farming/offshore_wind_farming.ipynb", "kind": "ipynb", "title": "Offshore Wind Farming"}, "messages": [{"role": "system", "content": "You are an optimization engineer. Write correct and runnable Python code using gurobipy (Gurobi Python API). Be concise. Output only what is requested."}, {"role": "user", "content": "    Task: Reproduce the following Gurobi modeling example in Python using gurobipy.\n\n    Scenario description (from source):\n    # Offshore Wind Farming\n\n## Objective and Prerequisites\n\nIn this example, you’ll learn how to solve an offshore wind power generation problem. The goal of the problem is to figure out which underwater cables should be laid to connect an offshore wind farm power network at a minimum cost. We’ll show you how to formulate a mixed-integer programming (MIP) model of this problem using the Gurobi Python API and then find an optimal solution to the problem using the Gurobi Optimizer.\n\nThis modeling example is at the beginner level, where we assume that you know Python and that you have some knowledge about building mathematical optimization models.\n\n**Download the Repository** <br />\nYou can download the repository containing this and other examples by clicking [here](https://github.com/Gurobi/modeling-examples/archive/master.zip). \n\n## Motivation\n\nGlobal climate change has already had observable effects on the environment. Glaciers have shrunk, ice on rivers and lakes is breaking up earlier than expected, plant and animal species have  been affected and trees are flowering sooner than expected. The potential future effects of global climate change include more frequent wildfires, longer periods of drought in some regions and an increase in the number, duration and intensity of tropical storms. [1]\n\nClimate change mitigation consists of actions to limit the magnitude or rate of global warming and its related effects.\nThe first challenge for climate change mitigation is eliminating the burning of coal, oil and, eventually, natural gas. This is perhaps the most daunting challenge as denizens of richer nations literally eat, wear, work, play and even sleep on the products made from fossil fuels. Also, citizens of developing nations want and arguably deserve the same comforts. There are no perfect solutions for reducing dependence on fossil fuels (for example, carbon neutral biofuels can drive up the price of food and lead to forest destruction, and while nuclear power does not emit greenhouse gases, it does produce radioactive waste). Other alternatives include plant-derived plastics, biodiesel, and wind power. [2]\n\nOffshore wind power is the use of wind farms constructed in bodies of water, usually in the ocean, to harvest wind energy to generate electricity. Higher wind speeds are available offshore compared to on land, so offshore wind power’s electricity generation is higher per amount of capacity installed. \n\nThe advantage of locating wind turbines offshore is that the wind is much stronger off the coasts, and unlike wind over the continent, offshore breezes can be strong in the afternoon, matching the time when people are using the most electricity. Offshore turbines can also be located close to the load centers along the coasts, such as large cities, eliminating the need for new long-distance transmission lines.\n\n## Problem Description\n\nAn offshore wind farm is a collection of wind turbines placed at sea to take advantage of the strong offshore winds. These strong winds produce more electricity, but offshore wind farms are more expensive to install and operate than those on land.\n\nWe will use a MIP model to reduce part of the cost of building an offshore wind farm. We will compute a plan for how to lay the underwater cables that connect the turbines. These cables are necessary to transfer the power produced by the turbines to land. The plan we compute will minimize the cost to install the underwater cables, while ensuring that each turbine is connected to the shore and each cable has sufficient capacity to handle the electrical current generated.\n\nIn our example, a wind farm is being built off the west coast of Denmark. There is a power station on the coast where all the electricity must be transferred to be distributed to the electric grid. There are also transfer stations in the wind farm where the power from several turbines can be collected and transferred along a single cable to the shore.\n\nThere are two factors we must consider when installing the cables. First, there is a fixed cost to lay a cable on the sea floor. This cost is proportional to the distance between the two stations the cable connects. Second, we must consider how much current will flow through the cables. Connections that carry large currents need thick cables. Thick cables are more expensive than thin cables.\n\nThe goal of this optimization problem is to decide which cables should be laid to connect the wind farm power network at a minimum cost.\n\nThe model of offshore wind farming optimization problem is an instance of a more general optimization model known as fixed charge network flow problem. Fixed charge network flow problems can be applied to a large number of business problems -for example, in the planning of communication and transport networks.\n\n    Requirements:\n    - Use gurobipy (Model, GRB, addVar/addConstr, etc.)\n    - Make the script runnable as a standalone Python file if possible.\n    - Keep the code faithful to the example.\n"}, {"role": "assistant", "content": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Parameters\n\nvertices = {0: 4, 1: 3, 2: 2, 3: 0, 4: -6, 5: -3}\nedges, cap, flow_cost, fixed_cost = gp.multidict({\n    (0,4): [4,1,1],\n    (0,3): [2,1,1],\n    (1,3): [3,1,1],\n    (2,5): [2,1,1],\n    (3,4): [2,1,1],\n    (3,5): [1,1,1]\n})\n\n# MIP  model formulation\n\nm = gp.Model(\"offshore_wind_farming\")\n\n# Add variables\ninstall = m.addVars(edges, vtype=GRB.BINARY, name=\"Install\")\nflow = m.addVars(edges, vtype=GRB.CONTINUOUS, name=\"Flow\")\n\n# Add constraints\nm.addConstrs((flow.sum(v,'*') - flow.sum('*',v) == supply for v, supply in vertices.items()), name=\"Flow_conservation\")\nm.addConstrs((flow[e] <= cap[e]*install[e] for e in edges), name=\"Install2flow\")\n\n# Set objective\nm.setObjective(flow.prod(flow_cost) + install.prod(fixed_cost), GRB.MINIMIZE)\n\nm.optimize()\n\n# display which edges in the offshore wind farming network we plan to install.\n\nfor origin, end in install.keys():\n    if (abs(install[origin, end].x) > 0.5):\n        print(f\"Install cable from location {origin + 1} to location {end + 1} in the offshore wind farming network \")\n\n# Current flow capacity of each cable installed\n\nfor origin, end in flow.keys():\n    if (abs(flow[origin, end].x) > 1e-6):\n         print(f\"The capacity of cable installed from location {origin + 1} to location {end + 1} is {flow[origin, end].x} MW \")"}]}
{"meta": {"source_path": "/Users/sunyujun03/Desktop/ReLoop/gurobi-modeling-examples/text_dissimilarity/text_dissimilarity.ipynb", "kind": "ipynb", "title": "Text Dissimilarity using Linear Programming"}, "messages": [{"role": "system", "content": "You are an optimization engineer. Write correct and runnable Python code using gurobipy (Gurobi Python API). Be concise. Output only what is requested."}, {"role": "user", "content": "    Task: Reproduce the following Gurobi modeling example in Python using gurobipy.\n\n    Scenario description (from source):\n    Copyright © 2023 Gurobi Optimization, LLC\n\n# Text Dissimilarity using Linear Programming\n\nIn this notebook, we will walk-through a unique example demonstrating how you can apply optimization to assess text dissimilarity. There are numerous potential applications such as in detecting plagiarism, information retrieval, clustering, text categorization, topic detection, question answer session, machine translation and text summarization. Read here for [more](https://citeseerx.ist.psu.edu/document?repid=rep1&type=pdf&doi=1aff7b429f99f529228a4299a5794971adeb1ca3#:~:text=There%20are%20several%20applications%20or,machine%20translation%2C%20text%20summarization%20etc).\n\nThe **Word Mover's Distance** (WMD) is a popular measure of text similarity, which measures the semantic distance between two documents. In this notebook, we will achieve two goals:\n- Given two text passages, model WMD as an optimization problem and compute it\n- Examine a plagiarized passage from a book, then find the original passage in that book that has the closest semantic meaning to the given passage\n\n|<img src=\"https://raw.githubusercontent.com/Gurobi/modeling-examples/master/text_dissimilarity/figure_obama.png\" width=\"500\" align=\"center\">| \n|:--:|\n|An illustration of Word Movers' Distance to measure the similarity between two documents. <b>Image Credits: [Towards AI](https://towardsai.net/p/nlp/word-movers-distance-wmd-explained-an-effective-method-of-document-classification-89cb258401f4) </b>| \n\n## I. The data\n\n    Requirements:\n    - Use gurobipy (Model, GRB, addVar/addConstr, etc.)\n    - Make the script runnable as a standalone Python file if possible.\n    - Keep the code faithful to the example.\n"}, {"role": "assistant", "content": "import numpy as np\nimport pandas as pd\nfrom matplotlib import pyplot as plt   \nfrom gensim.models import KeyedVectors \nfrom scipy import spatial\n\nimport gensim.downloader as api\nmodel = api.load('word2vec-google-news-300')\n\nmodel['Sherlock']\n\ndocument1 = 'The little man stood glancing from one to the other of us with half-frightened, half-hopeful eyes, as one who is not sure whether he is on the verge of a windfall or of a catastrophe.'\ndocument2 = 'With a gaze that shifted back and forth between us, the diminutive figure appeared to be a mixture of apprehension and anticipation, uncertain if he was on the cusp of a fortune or a disaster.'\n\n# document1 = 'I barely saw Sherlock recently.'\n# document2 = 'Lately, I have had little opportunity to catch a glimpse of Sherlock.'\n\n# document1 = 'Obama speaks to the media in Illinois.'\n# document2 = 'The President greets the press in Chicago'\n\nimport nltk \nnltk.download('stopwords')\nnltk.download('averaged_perceptron_tagger_eng')  \nnltk.download('punkt')\nfrom nltk.corpus import stopwords\nfrom nltk.tokenize import RegexpTokenizer, word_tokenize\nfrom nltk.stem import PorterStemmer\n\ntagged_doc1 = nltk.tag.pos_tag(document1.split())\ntagged_doc2 = nltk.tag.pos_tag(document2.split()) \nprint(tagged_doc1)\nprint(tagged_doc2)\n\nedited_sentence1 = [word for word,tag in tagged_doc1 if tag not in ['NNP','NNPS']]\nedited_sentence2 = [word for word,tag in tagged_doc2 if tag not in ['NNP','NNPS']] \nprint(edited_sentence1)\nprint(edited_sentence2)\n\ntokenizer = RegexpTokenizer(r'\\w+') \nprocessed_doc1 = tokenizer.tokenize(' '.join(edited_sentence1))\nprocessed_doc2 = tokenizer.tokenize(' '.join(edited_sentence2))\nprint(processed_doc1)\nprint(processed_doc2)\n\nprocessed_doc1 = [x.lower() for x in processed_doc1]\nprocessed_doc2 = [x.lower() for x in processed_doc2]\nprocessed_doc1 = [i for i in processed_doc1 if i not in stopwords.words('english')]\nprocessed_doc2 = [i for i in processed_doc2 if i not in stopwords.words('english')]\n\nprint(processed_doc1,'\\n', processed_doc2)\n\nfrom wordcloud import WordCloud, STOPWORDS, ImageColorGenerator\n\nprint(\"Document 1:\") \nwordcloud = WordCloud(max_font_size=50, max_words=100, background_color=\"white\").generate(' '.join(processed_doc1))\nplt.imshow(wordcloud, interpolation='bilinear')\nplt.axis(\"off\")\nplt.show()\n\nprint(\"Document 2:\")\nwordcloud = WordCloud(max_font_size=50, max_words=100, background_color=\"white\").generate(' '.join(processed_doc2))\nplt.imshow(wordcloud, interpolation='bilinear')\nplt.axis(\"off\")\n\nplt.show()\n\nfreqency_D1 = {i: processed_doc1.count(i)/len(processed_doc1) for i in processed_doc1}\nfreqency_D2 = {i: processed_doc2.count(i)/len(processed_doc2) for i in processed_doc2}\n\nD1 = set(processed_doc1)\nD2 = set(processed_doc2) \nprint(D1,D2)\n\nimport numpy as np\ndistance = {(i,j): spatial.distance.cosine(model[i],model[j]) for i in D1 for j in D2} \n\n# dict(sorted(distance.items(), key=lambda item: item[1]))\n\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# Initialize Model\nm = gp.Model(\"Text_similarity\")\n\nf = m.addVars(D1,D2,name=\"f\",lb=0,ub=1)\n\nm.ModelSense = GRB.MINIMIZE\nm.setObjective(sum(f[w,w_prime]*distance[w,w_prime] for w in D1 for w_prime in D2))#/sum(cost[w,w_prime] for w in D for w_prime in D_prime))\nm.update()\n\nm.addConstrs(f.sum(w, '*') == freqency_D1[w] for w in D1)\nm.addConstrs(f.sum('*', w_prime) == freqency_D2[w_prime] for w_prime in D2)\n\nm.optimize()\n\nprint(\"Dissimilarity score:\",round((m.ObjVal),2),\"\\n\")\n\nsolution = pd.DataFrame()\nflow = {(i,j): f[i,j].X for i in D1 for j in D2 if f[i,j].X > 0} \n# flow = sorted(flow.items(), key=lambda item: item[1],reverse=True)\nsolution['word 1'] = [i for (i,j) in flow]\nsolution['word 2'] = [j for (i,j) in flow]\nsolution['flow'] = [flow[i,j] for (i,j) in flow]\nsolution['distance'] = [distance[i,j] for (i,j) in flow] \n# solution.sort_values(by='flow',ascending=False).reset_index(drop=True)\nsolution.sort_values(by='distance',ascending=True).reset_index(drop=True)\n\nimport base64\nimport requests\n\nmaster = \"https://raw.githubusercontent.com/Gurobi/modeling-examples/master/text_dissimilarity/PG1661_raw.txt\"\ncontent = requests.get(master)\ncontent = content.text\ncontent = content.replace('\\n',' ')\ncontent = content.replace('_',' ')\ncontent = content.replace('\\r','') \nsentences = list(map(str.strip, content.split(\".\")))[19:]\n\ndef pre_processing(document):\n    # Remove proper nouns\n    tagged_doc = nltk.tag.pos_tag(document.split())\n    edited_sentence = [word for word,tag in tagged_doc]  \n    edited_sentence = [word for word,tag in tagged_doc if tag not in ['NNP','NNPS']]  \n\n    # Remove punctuation \n    tokenizer = RegexpTokenizer(r'\\w+') \n    processed_doc = tokenizer.tokenize(' '.join(edited_sentence)) \n\n    # Remove stop words \n    processed_doc = [i for i in processed_doc if i not in stopwords.words('english')]  \n    \n    return processed_doc\n\nprocessed_sentences = [] # list of all sentences\nfor s in sentences: \n    processed_sentences.append(pre_processing(s))\n\ndef score_dissimilarity(D1, D2):\n\n    D1 = set(D1)\n    D2 = set(D2) \n    D2 = D2 - set([i for i in D2 if i not in model]) # in case some of the words from the book are not in the word2vec data\n    D1 = D1 - set([i for i in D1 if i not in model])\n            \n    freqency_D1 = {i: list(D1).count(i)/len(D1) for i in D1}\n    freqency_D2 = {i: list(D2).count(i)/len(D2) for i in D2}\n    \n    if len(D2) < 5: # if the sentence is too small, we set a high dissimilarity, effectively ignoring it\n        return 1\n        \n    m = gp.Model(\"Text_similarity\")\n    distance = {(i,j): spatial.distance.cosine(model[i],model[j]) for i in D1 for j in D2} \n\n    # Variables. Adjust the bounds here \n    f = m.addVars(D1,D2,name=\"f\",lb=0,ub=1) \n\n    # Minimize\n    m.ModelSense = GRB.MINIMIZE\n    m.setObjective(sum(f[w,w_prime]*distance[w,w_prime] for w in D1 for w_prime in D2))\n\n    # Add the constraints   \n    m.addConstrs(f.sum(w, '*') ==  freqency_D1[w] for w in D1)\n    m.addConstrs(f.sum('*', w_prime) == freqency_D2[w_prime] for w_prime in D2) \n    \n    m.setParam('OutputFlag', 0)\n    m.optimize()  \n    \n    return m.ObjVal\n\nsample_sentence = 'With a gaze that shifted back and forth between us, the dimunitive figure appeared to be a mixture of apprehension and anticipation, uncertain if he was on the cusp of a fortune or a disaster.'\n# sample_sentence = 'Without much conversation, yet with a friendly gesture, he gestured towards an armchair for me to sit in, offered me a box of cigars, and pointed to a liquor cabinet and a carbonated water dispenser in the corner.' \n\nprint(sample_sentence)\n\nobj_best = 1\nprint(\"#\\t Dissimilarity\\t Sentence\")\nfor i in range(len(processed_sentences)):  \n    obj = score_dissimilarity(pre_processing(sample_sentence),processed_sentences[i])  \n    if obj < obj_best: \n        print(i,\"\\t\",round((obj),2),\"\\t\",sentences[i])\n        obj_best, sentence_best = obj, sentences[i]\n\nprint(\"\\nThe closest sentence with a %f dissimilarity is:\\n\\n\"%obj_best,sentence_best)"}]}
{"meta": {"source_path": "/Users/sunyujun03/Desktop/ReLoop/gurobi-modeling-examples/electrical_power_generation/electrical_power_1.ipynb", "kind": "ipynb", "title": "Electrical Power Generation 1"}, "messages": [{"role": "system", "content": "You are an optimization engineer. Write correct and runnable Python code using gurobipy (Gurobi Python API). Be concise. Output only what is requested."}, {"role": "user", "content": "    Task: Reproduce the following Gurobi modeling example in Python using gurobipy.\n\n    Scenario description (from source):\n    # Electrical Power Generation 1\n\n## Objective and Prerequisites\n\nMajor electric power companies around the world utilize mathematical optimization to manage the flow of energy across their electrical grids. In this example, you’ll discover the power of mathematical optimization in addressing a common energy industry problem: electrical power generation. We’ll show you how to figure out the optimal set of power stations to turn on in order to satisfy anticipated power demand over a 24-hour time horizon.\n\nThis model is example 15 from the fifth edition of Model Building in Mathematical Programming by H. Paul Williams on pages 270 – 271 and 325 – 326.\n\nThis example is at the intermediate level, where we assume that you know Python and the Gurobi Python API and that you have some knowledge of building mathematical optimization models.\n\n**Download the Repository** <br />\nYou can download the repository containing this and other examples by clicking [here](https://github.com/Gurobi/modeling-examples/archive/master.zip). \n\n---\n## Problem Description\n\nIn this problem, power generation units are grouped into three distinct types, with different characteristics for each type (power output, cost per megawatt hour, startup cost, etc.).  A unit can be on or off, with a startup cost associated with transitioning from off to on, and power output that can fall anywhere between a specified minimum and maximum value when the unit is on.  A 24-hour time horizon is divided into 5 discrete time periods, each with an expected total power demand.  The model decides which units to turn on, and when, in order to satisfy demand for each time period.  The model also captures a reserve requirement, where the selected power plants must be capable of increasing their output, while still respecting their maximum output, in order to cope with the situation where actual demand exceeds predicted demand.\n\nA set of generators is available to satisfy power demand for the following day.  Anticipated demand is as follows:\n\n| Time Period | Demand (megawatts) |\n| --- | --- |\n| 12 pm to 6 am | 15000 |\n| 6 am to 9 am | 30000 |\n| 9 am to 3 pm | 25000 |\n| 3 pm to 6 pm | 40000 |\n| 6 pm to 12 pm | 27000 |\n\nGenerators are grouped into three types, with the following minimum and maximum output for each type (when they are on):\n\n| Type | Number available | Minimum output (MW) | Maximum output (MW) |\n| --- | --- | --- | --- |\n| 0 | 12 |  850 | 2000 |\n| 1 | 10 | 1250 | 1750 |\n| 2 | 5 | 1500 | 4000 |\n\nThere are costs associated with using a generator: a cost per hour when the generator is on (and generating its minimum output), a cost per megawatt hour above its minimum, and a startup cost for turning a generator on:\n\n| Type | Cost per hour (when on) | Cost per MWh above minimum | Startup cost |\n| --- | --- | --- | --- |\n| 0 | $\\$1000$ | $\\$2.00$ | $\\$2000$ |\n| 1 | $\\$2600$ | $\\$1.30$ | $\\$1000$ |\n| 2 | $\\$3000$ | $\\$3.00$ | $\\$500$ |\n\nGenerators must meet predicted demand, but they must also have sufficient reserve capacity to be able to cope with the situation where actual demand exceeds predicted demand.  For this model, the set of selected generators must be able to produce as much as 115% of predicted demand.\n\nWhich generators should be committed to meeting anticipated demand in order to minimize total cost?\n\n---\n## Model Formulation\n\n### Sets and Indices\n\n$t \\in \\text{Types}=\\{0,1,2\\}$: Types of generators.\n\n$p \\in \\text{Periods}=\\{0,1,2,3,4\\}$: Time periods.\n\n### Parameters\n\n$\\text{period_hours}_p \\in \\mathbb{N}^+$: Number of hours in each time period.\n\n$\\text{generators}_t \\in \\mathbb{N}^+$: Number of generators of type $t$.\n\n$\\text{demand}_p \\in \\mathbb{R}^+$: Total power demand for time period $p$.\n\n$\\text{start0} \\in \\mathbb{N}^+$: Number of generators that are on at the beginning of the time horizon (and available in time period 0 without paying a startup cost).\n\n$\\text{min_output}_t \\in \\mathbb{R}^+$: Minimum output for generator type $t$ (when on).\n\n$\\text{max_output}_t \\in \\mathbb{R}^+$: Maximum output for generator type $t$.\n\n$\\text{base_cost}_t \\in \\mathbb{R}^+$: Minimum operating cost (per hour) for a generator of type $t$.\n\n$\\text{per_mw_cost}_t \\in \\mathbb{R}^+$: Cost to generate one additional MW (per hour) for a generator of type $t$.\n\n$\\text{startup_cost}_t \\in \\mathbb{R}^+$: Startup cost for generator of type $t$.\n\n### Decision Variables\n\n$\\text{ngen}_{t,p} \\in \\mathbb{N}^+$: Number of generators of type $t$ that are on in time period $p$.\n\n$\\text{output}_{t,p} \\in \\mathbb{R}^+$: Total power output from generators of type $t$ in time period $p$.\n\n$\\text{nstart}_{t,p} \\in \\mathbb{N}^+$: Number of generators of type $t$ to start in time period $p$.\n\n### Objective Function\n\n- **Cost**: Minimize the cost (in USD) to satisfy the predicted electricity demand.\n\n\\begin{equation}\n\\text{Minimize} \\quad Z_{on} + Z_{extra} + Z_{startup}\n\\end{equation}\n\n\\begin{equation}\nZ_{on} = \\sum_{(t,p) \\in \\text{Types} \\times \\text{Periods}}{\\text{base_cost}_t*\\text{ngen}_{t,p}}\n\\end{equation}\n\\begin{equation}\nZ_{extra} = \\sum_{(t,p) \\in \\text{Types} \\times \\text{Periods}}{\\text{per_mw_cost}_t*(\\text{output}_{t,p} - \\text{min_load}_t})\n\\end{equation}\n\\begin{equation}\nZ_{startup} = \\sum_{(t,p) \\in \\text{Types} \\times \\text{Periods}}{\\text{startup_cost}_t*\\text{nstart}_{t,p}}\n\\end{equation}\n\n### Constraints\n\n- **Available generators**: Number of generators used must be less than or equal to the number available.\n\n\\begin{equation}\n\\text{ngen}_{t,p} \\leq \\text{generators}_{t} \\quad \\forall (t,p) \\in \\text{Types} \\times \\text{Periods}\n\\end{equation}\n\n- **Demand**: Total power generated across all generator types must meet anticipated demand for each time period $p$.\n\n\\begin{equation}\n\\sum_{t \\in \\text{Types}}{\\text{output}_{t,p}} \\geq \\text{demand}_p \\quad \\forall p \\in \\text{Periods}\n\\end{equation}\n\n- **Min/max generation**: Power generation must respect generator min/max values.\n\n\\begin{equation}\n\\text{output}_{t,p} \\geq \\text{min_output}_t*\\text{ngen}_{t,p} \\quad \\forall (t,p) \\in \\text{Types} \\times \\text{Periods}\n\\end{equation}\n\n\\begin{equation}\n\\text{output}_{t,p} \\leq \\text{max_output}_t*\\text{ngen}_{t,p} \\quad \\forall (t,p) \\in \\text{Types} \\times \\text{Periods}\n\\end{equation}\n\n- **Reserve**: Selected generators must be able to satisfy demand that is as much as 15% above the prediction.\n\n\\begin{equation}\n\\sum_{t \\in \\text{Types}}{\\text{max_output}_t*\\text{ngen}_{t,p}} \\geq 1.15 * \\text{demand}_p \\quad \\forall p \\in \\text{Periods}\n\\end{equation}\n\n- **Startup**: Establish relationship between number of active generators and number of startups (use $start0$ for period before the time horizon starts)\n\n\\begin{equation}\n\\text{ngen}_{t,p} \\leq \\text{ngen}_{t,p-1} + \\text{startup}_{t,p} \\quad \\forall (t,p) \\in \\text{Types} \\times \\text{Periods}\n\\end{equation}\n\n---\n## Python Implementation\n\nWe import the Gurobi Python Module and other Python libraries.\n\n## Input Data\nWe define all the input data of the model.\n\n## Model Deployment\n\nWe create a model and the variables. For each time period, we have: an integer decision variable to capture the number of active generators of each type (ngen), an integer variable to capture the number of generators of each type we must start (nstart), and a continuous decision variable to capture the total power output for each generator type (output).\n\nNext we insert the constraints:\n\nThe number of active generators can't exceed the number of generators.\n\n    Requirements:\n    - Use gurobipy (Model, GRB, addVar/addConstr, etc.)\n    - Make the script runnable as a standalone Python file if possible.\n    - Keep the code faithful to the example.\n"}, {"role": "assistant", "content": "import pandas as pd\n\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# tested with Python 3.11 & Gurobi 11.0\n\n# Parameters\n\nntypes = 3\nnperiods = 5\nmaxstart0 = 5\n\ngenerators = [12, 10, 5]\nperiod_hours = [6, 3, 6, 3, 6]\ndemand = [15000, 30000, 25000, 40000, 27000]\nmin_load = [850, 1250, 1500]\nmax_load = [2000, 1750, 4000]\nbase_cost = [1000, 2600, 3000]\nper_mw_cost = [2, 1.3, 3]\nstartup_cost = [2000, 1000, 500]\n\nmodel = gp.Model('PowerGeneration')\nngen = model.addVars(ntypes, nperiods, vtype=GRB.INTEGER, name=\"ngen\")\nnstart = model.addVars(ntypes, nperiods, vtype=GRB.INTEGER, name=\"nstart\")\noutput = model.addVars(ntypes, nperiods, vtype=GRB.CONTINUOUS, name=\"genoutput\")\n\n# Generator count\n\nnumgen = model.addConstrs(ngen[type, period] <= generators[type]\n                         for type in range(ntypes) for period in range(nperiods))\n\n# Respect minimum and maximum output per generator type\n\nmin_output = model.addConstrs((output[type, period] >= min_load[type] * ngen[type, period])\n                              for type in range(ntypes) for period in range(nperiods))\n\nmax_output = model.addConstrs((output[type, period] <= max_load[type] * ngen[type, period])\n                              for type in range(ntypes) for period in range(nperiods))\n\n# Meet demand\n\nmeet_demand = model.addConstrs(gp.quicksum(output[type, period] for type in range(ntypes)) >= demand[period]\n                               for period in range(nperiods))\n\n# Provide sufficient reserve capacity\n\nreserve = model.addConstrs(gp.quicksum(max_load[type]*ngen[type, period] for type in range(ntypes)) >= 1.15*demand[period]\n                    for period in range(nperiods))\n\n# Startup constraint\n\nstartup0 = model.addConstrs((ngen[type,0] <= maxstart0 + nstart[type,0])\n                            for type in range(ntypes))\n\nstartup = model.addConstrs((ngen[type,period] <= ngen[type,period-1] + nstart[type,period])\n                           for type in range(ntypes) for period in range(1,nperiods))\n\n# Objective: minimize total cost\n\nactive = gp.quicksum(base_cost[type]*period_hours[period]*ngen[type,period]\n                    for type in range(ntypes) for period in range(nperiods))\n\nper_mw = gp.quicksum(per_mw_cost[type]*period_hours[period]*(output[type,period] - min_load[type]*ngen[type,period])\n                       for type in range(ntypes) for period in range(nperiods))\n\nstartup_obj = gp.quicksum(startup_cost[type]*nstart[type,period]\n                         for type in range(ntypes) for period in range(nperiods))\n\nmodel.setObjective(active + per_mw + startup_obj)\n\nmodel.write('junk.lp')\nmodel.optimize()\n\nrows = [\"Type\" + str(t) for t in range(ntypes)]\nunits = pd.DataFrame(columns=range(nperiods), index=rows, data=0.0)\n\nfor t in range(ntypes):\n    for p in range(nperiods):\n        units.loc[\"Type\"+str(t), p] = ngen[t,p].x\nunits\n\nstartups = pd.DataFrame(columns=range(nperiods), index=rows, data=0.0)\n\nfor t in range(ntypes):\n    for p in range(nperiods):\n        startups.loc[\"Type\"+str(t), p] = int(nstart[t,p].x)\nstartups"}]}
{"meta": {"source_path": "/Users/sunyujun03/Desktop/ReLoop/gurobi-modeling-examples/electrical_power_generation/electrical_power_2.ipynb", "kind": "ipynb", "title": "Electrical Power Generation 2"}, "messages": [{"role": "system", "content": "You are an optimization engineer. Write correct and runnable Python code using gurobipy (Gurobi Python API). Be concise. Output only what is requested."}, {"role": "user", "content": "    Task: Reproduce the following Gurobi modeling example in Python using gurobipy.\n\n    Scenario description (from source):\n    # Electrical Power Generation 2\n\n## Objective and Prerequisites\n\nThis example (which is an extension of the earlier ‘Electrical Power Generation 1 ‘ example) will teach you how to choose an optimal set of power stations to turn on in order to satisfy anticipated power demand over a 24-hour time horizon – but gives you the option of using hydroelectric power plants to satisfy that demand.\n\nThis model is example 16 from the fifth edition of Model Building in Mathematical Programming by H. Paul Williams on pages 271-272 and 326-327.\n\nThis example is at the intermediate level, where we assume that you know Python and the Gurobi Python API and that you have some knowledge of building mathematical optimization models.\n\n**Download the Repository** <br />\nYou can download the repository containing this and other examples by clicking [here](https://github.com/Gurobi/modeling-examples/archive/master.zip). \n\n---\n## Problem Description\n\nIn this problem, thermal power generation units are grouped into three distinct types, with different characteristics for each type (power output, cost per megawatt hour, startup cost, etc.).  A unit can be on or off, with a startup cost associated with transitioning from off to on, and power output that can fall anywhere between a specified minimum and maximum value when the unit is on.  There are also two hydroelectric plants available, also with different cost and power generation characteristics.  A 24-hour time horizon is divided into 5 discrete time periods, each with an expected total power demand.  The model decides which units to turn on, and when, in order to satisfy demand for each time period.  The model also captures a reserve requirement, where the selected power plants must be capable of increasing their output, while still respecting their maximum output, in order to cope with the situation where actual demand exceeds predicted demand.\n\nA set of generators is available to satisfy power demand for the following day.  Anticipated demand is as follows:\n\n| Time Period | Demand (megawatts) |\n| --- | --- |\n| 12 pm to 6 am | 15000 |\n| 6 am to 9 am | 30000 |\n| 9 am to 3 pm | 25000 |\n| 3 pm to 6 pm | 40000 |\n| 6 pm to 12 pm | 27000 |\n\nThermal generators are grouped into three types, with the following minimum and maximum output for each type (when they are on):\n\n| Type | Number available | Minimum output (MW) | Maximum output (MW) |\n| --- | --- | --- | --- |\n| 0 | 12 |  850 | 2000 |\n| 1 | 10 | 1250 | 1750 |\n| 2 | 5 | 1500 | 4000 |\n\nThere are costs associated with using a thermal generator: a cost per hour when the generator is on (and generating its minimum output), a cost per megawatt hour above its minimum, and a startup cost for turning a generator on:\n\n| Type | Cost per hour (when on) | Cost per MWh above minimum | Startup cost |\n| --- | --- | --- | --- |\n| 0 | $\\$1000$ | $\\$2.00$ | $\\$2000$ |\n| 1 | $\\$2600$ | $\\$1.30$ | $\\$1000$ |\n| 2 | $\\$3000$ | $\\$3.00$ | $\\$500$ |\n\nTwo hydroelectric generators are also available, each with a fixed power output (when on):\n\n| Hydro plant | Output (MW) |\n| --- | --- |\n| A | 900 |\n| B | 1400 |\n\nThe costs associated with using a hydro plant are slightly different.  There's an hourly cost, but it is much smaller than the hourly cost of a thermal generator.  The real cost for a hydroelectric plant comes from depletion of the water in the reservoir, which happens at different rates for the two units.  The reservoir must be replenished before the end of the time horizon by pumping water into it, which consumes electricity.  A hydroelectric plant also has a startup cost.\n\n| Hydro plant | Cost per hour (when on) | Startup cost | Reservoir depth reduction (m/hr) |\n| --- | --- | --- | --- |\n| A | $\\$90$ | $\\$1500$ | 0.31 |\n| B | $\\$150$ | $\\$1200$ | 0.47 |\n\nPumping water into the reservoir consumes electricity at a rate of 3000 MWh of electricity per meter of height.  The height of the reservoir at the end of the time horizon must be equal to the height at the beginning.\n\nGenerators must meet predicted demand, but they must also have sufficient reserve capacity to be able to cope with the situation where actual demand exceeds predicted demand.  For this model, the set of selected thermal generators plus the set of hydro generators must be able to produce as much as 115% of predicted demand.\n\nWhich generators should be committed to meet anticipated demand in order to minimize total cost?\n\n---\n## Model Formulation\n\n### Sets and Indices\n\n$t \\in \\text{Types}=\\{0,1,2\\}$: Types of thermal generators.\n\n$h \\in \\text{HydroUnits}=\\{0,1\\}$: Two hydro generators.\n\n$p \\in \\text{Periods}=\\{0,1,2,3,4\\}$: Time periods.\n\n### Parameters\n\n$\\text{period_hours}_{p} \\in \\mathbb{N}^+$: Number of hours in each time period.\n\n$\\text{demand}_p \\in \\mathbb{R}^+$: Total power demand for time period $p$.\n\n$\\text{generators}_t \\in \\mathbb{N}^+$: Number of thermal generators of type $t$.\n\n$\\text{start0} \\in \\mathbb{N}^+$: Number of thermal generators that are on at the beginning of the time horizon (and available in time period 0 without paying a startup cost).\n\n$\\text{min_output}_t \\in \\mathbb{R}^+$: Minimum output for thermal generator type $t$ (when on).\n\n$\\text{max_output}_t \\in \\mathbb{R}^+$: Maximum output for thermal generator type $t$.\n\n$\\text{base_cost}_t \\in \\mathbb{R}^+$: Minimum operating cost (per hour) for a thermal generator of type $t$.\n\n$\\text{per_mw_cost}_t \\in \\mathbb{R}^+$: Cost to generate one additional MW (per hour) for a thermal generator of type $t$.\n\n$\\text{startup_cost}_t \\in \\mathbb{R}^+$: Startup cost for thermal generator of type $t$.\n\n$\\text{hydro_load}_h \\in \\mathbb{R}^+$: Output for hydro generator $h$.\n\n$\\text{hydro_cost}_h \\in \\mathbb{R}^+$: Cost for operating hydro generator $h$.\n\n$\\text{hydro_startup_cost}_h \\in \\mathbb{R}^+$: Startup cost for hydro generator $h$.\n\n$\\text{hydro_height_reduction}_h \\in \\mathbb{R}^+$: Hourly reduction in reservoir height from operating hydro generator $h$.\n\n### Decision Variables\n\n$\\text{ngen}_{t,p} \\in \\mathbb{N}^+$: Number of thermal generators of type $t$ that are on in time period $p$.\n\n$\\text{output}_{t,p} \\in \\mathbb{R}^+$: Total power output from thermal generators of type $t$ in time period $p$.\n\n$\\text{nstart}_{t,p} \\in \\mathbb{N}^+$: Number of thermal generators of type $t$ to start in time period $p$.\n\n$\\text{hydro}_{h,p} \\in [0,1]$: Indicates whether hydro generators $h$ is on in time period $p$.\n\n$\\text{hydro_start}_{h,p} \\in [0,1]$: Indicates whether hydro generator $h$ starts in time period $p$.\n\n$\\text{height}_{p} \\in \\mathbb{R}^+$: Height of reservoir in time period $p$.\n\n$\\text{pumping}_{p} \\in \\mathbb{R}^+$: Power used to replenish reservoir in time period $p$.\n\n### Objective Function\n\n- **Cost**: Minimize the cost (in USD) to satisfy the predicted electricity demand.\n\n\\begin{equation}\n\\text{Minimize} \\quad Z_{on} + Z_{extra} + Z_{startup} + Z_{hydro} + Z_{hydro\\_startup}\n\\end{equation}\n\n\\begin{equation}\nZ_{on} = \\sum_{(t,p) \\in \\text{Types} \\times \\text{Periods}}{\\text{base_cost}_t*\\text{ngen}_{t,p}}\n\\end{equation}\n\\begin{equation}\nZ_{extra} = \\sum_{(t,p) \\in \\text{Types} \\times \\text{Periods}}{\\text{per_mw_cost}_t*(\\text{output}_{t,p} - \\text{min_load}_t})\n\\end{equation}\n\\begin{equation}\nZ_{startup} = \\sum_{(t,p) \\in \\text{Types} \\times \\text{Periods}}{\\text{startup_cost}_t*\\text{nstart}_{t,p}}\n\\end{equation}\n\\begin{equation}\nZ_{hydro} = \\sum_{(h,p) \\in \\text{HydroUnits} \\times \\text{Periods}}{\\text{hydro_cost}_h*\\text{hydro}_{h,p}}\n\\end{equation}\n\\begin{equation}\nZ_{hydro\\_startup} = \\sum_{(h,p) \\in \\text{HydroUnits} \\times \\text{Periods}}{\\text{hydro_startup_cost}_h*\\text{hydro_start}_{h,p}}\n\\end{equation}\n\n### Constraints\n\n- **Available generators**: Number of generators used must be less than or equal to the number available.\n\n\\begin{equation}\n\\text{ngen}_{t,p} \\leq \\text{generators}_t  \\quad \\forall (t,p) \\in \\text{Types} \\times \\text{Periods}\n\\end{equation}\n\n- **Demand**: Total power generated across all generator types must meet anticipated demand plus pumping for each time period $p$.\n\n\\begin{equation}\n\\sum_{t \\in \\text{Types}}{\\text{output}_{t,p}} +\n\\sum_{h \\in \\text{HydroUnits}}{\\text{hydro_load}_h*\\text{hydro}_{h,p}} \\geq\n\\text{demand}_p + \\text{pumping}_p \\quad \\forall p \\in \\text{Periods}\n\\end{equation}\n\n- **Min/max generation**: Power generation must respect thermal generator min/max values.\n\n\\begin{equation}\n\\text{output}_{t,p} \\geq \\text{min_output}_t*\\text{ngen}_{t,p} \\quad \\forall (t,p) \\in \\text{Types} \\times \\text{Periods}\n\\end{equation}\n\n\\begin{equation}\n\\text{output}_{t,p} \\leq \\text{max_output}_t*\\text{ngen}_{t,p} \\quad \\forall (t,p) \\in \\text{Types} \\times \\text{Periods}\n\\end{equation}\n\n- **Reserve**: Selected thermal generators plus hydro units must be able to satisfy demand that is as much as 15% above the prediction.\n\n\\begin{equation}\n\\sum_{t \\in \\text{Types}}{\\text{max_output}_t*\\text{ngen}_{t,p}} +\n\\sum_{h \\in \\text{HydroUnits}}{\\text{hydro_load}_h} \\geq 1.15 * \\text{demand}_p \\quad \\forall p \\in \\text{Periods}\n\\end{equation}\n\n- **Thermal startup**: Establish relationship between number of active thermal generators and number of startups (use $start0$ for period before the time horizon starts)\n\n\\begin{equation}\n\\text{ngen}_{t,p} \\leq \\text{ngen}_{t,p-1} + \\text{nstart}_{t,p} \\quad \\forall (t,p) \\in \\text{Types} \\times \\text{Periods}\n\\end{equation}\n\n- **Hydro startup**: Establish relationship between hydro generator state and number of hydro startups (assume hydro plants are off at the beginning of the horizon)\n\n\\begin{equation}\n\\text{hydro}_{h,p} \\leq \\text{hydro}_{h,p-1} + \\text{hydro_start}_{h,p} \\quad \\forall (h,p) \\in \\text{HydroUnits} \\times \\text{Periods}\n\\end{equation}\n\n- **Reservoir height**: Track reservoir height.   Note that the height at the end of the final time period must equal the height at the beginning of the first.\n\n- Reservoir level constraints: Height increases due to pumping activity and decreases due to hydroelectric generation.\n\n\\begin{equation}\n\\text{height}_{p} = \\text{height}_{p-1}  + \\text{period_hours}_{p}*\\text{pumping}_{p}/3000 -\n\\sum_{h \\in \\text{HydroUnits}}{\\text{period_hours}_{p}*\\text{hydro_height_reduction}_{h}*\\text{hydro}_{h,p}} \\quad \\forall p \\in \\text{Periods}\n\\end{equation}\n\n- Cyclic constraint: Height at the first period must be equal to height at the last period.\n\n\\begin{equation}\n\\text{height}_{pfirst} = \\text{height}_{plast}  + \\text{period_hours}_{pfirst}*\\text{pumping}_{pfirst}/3000 -\n\\sum_{h \\in \\text{HydroUnits}}{\\text{period_hours}_{pfirst}*\\text{hydro_height_reduction}_{h}*\\text{hydro}_{h,pfirst}}\n\\end{equation}\n\n---\n## Python Implementation\n\nWe import the Gurobi Python Module and other Python libraries.\n\n## Input Data\nWe define all the input data of the model.\n\n## Model Deployment\n\nWe create a model and the variables. For each time period, we have: an integer decision variable to capture the number of active generators of each type (ngen), an integer variable to capture the number of generators of each type we must start (nstart), a continuous decision variable to capture the total power output for each generator type (output), a binary decision variable that indicates whether a hydro unit is active (hydro), a binary decision variable that indicates whether a hydro unit must be started (hydrstart), a continuous decision variable that captures the amount of enery used to replenish the reservoir (pumping), and a continuous decision variable that captures the height of the reservoir (height).\n\nNext we insert the constraints:\n\nThe number of active generators can't exceed the number of generators:\n\n    Requirements:\n    - Use gurobipy (Model, GRB, addVar/addConstr, etc.)\n    - Make the script runnable as a standalone Python file if possible.\n    - Keep the code faithful to the example.\n"}, {"role": "assistant", "content": "import pandas as pd\n\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# tested with Python 3.11 & Gurobi 11.0\n\n# Parameters\n\nntypes = 3\nnperiods = 5\nmaxstart0 = 5\nhydrounits = 2\n\ngenerators = [12, 10, 5]\nperiod_hours = [6, 3, 6, 3, 6]\ndemand = [15000, 30000, 25000, 40000, 27000]\nmin_load = [850, 1250, 1500]\nmax_load = [2000, 1750, 4000]\nbase_cost = [1000, 2600, 3000]\nper_mw_cost = [2, 1.3, 3]\nstartup_cost = [2000, 1000, 500]\n\nhydro_load = [900, 1400]\nhydro_cost = [90, 150]\nhydro_height_reduction = [0.31, 0.47]\nhydro_startup_cost = [1500, 1200]\n\nmodel = gp.Model('PowerGeneration2')\n\nngen = model.addVars(ntypes, nperiods, vtype=GRB.INTEGER, name=\"ngen\")\nnstart = model.addVars(ntypes, nperiods, vtype=GRB.INTEGER, name=\"nstart\")\noutput = model.addVars(ntypes, nperiods, vtype=GRB.CONTINUOUS, name=\"genoutput\")\n\nhydro = model.addVars(hydrounits, nperiods, vtype=GRB.BINARY, name=\"hydro\")\nhydrostart = model.addVars(hydrounits, nperiods, vtype=GRB.BINARY, name=\"hydrostart\")\npumping = model.addVars(nperiods, vtype=GRB.CONTINUOUS, name=\"pumping\")\nheight = model.addVars(nperiods, vtype=GRB.CONTINUOUS, name=\"height\")\n\n# Generator count\n\nnumgen = model.addConstrs(ngen[type, period] <= generators[type]\n                         for type in range(ntypes) for period in range(nperiods))\n\n# Respect minimum and maximum output per generator type\n\nmin_output = model.addConstrs((output[type, period] >= min_load[type] * ngen[type, period])\n                              for type in range(ntypes) for period in range(nperiods))\n\nmax_output = model.addConstrs((output[type, period] <= max_load[type] * ngen[type, period])\n                              for type in range(ntypes) for period in range(nperiods))\n\n# Meet demand\n\nmeet_demand = model.addConstrs(gp.quicksum(output[type, period] for type in range(ntypes)) +\n                               gp.quicksum(hydro_load[unit]*hydro[unit,period] for unit in range(hydrounits))\n                               >= demand[period] + pumping[period]\n                               for period in range(nperiods))\n\n# Reservoir levels\n\nreservoir = model.addConstrs(height[period] == height[period-1] + period_hours[period]*pumping[period]/3000 -\n                             gp.quicksum(hydro_height_reduction[unit]*period_hours[period]*hydro[unit,period] for unit in range(hydrounits))\n                             for period in range(1,nperiods))\n\n# cyclic - height at end must equal height at beginning\nreservoir0 = model.addConstr(height[0] == height[nperiods-1] + period_hours[0]*pumping[0]/3000 -\n                             gp.quicksum(hydro_height_reduction[unit]*period_hours[0]*hydro[unit,0]\n                             for unit in range(hydrounits)))\n\n# Provide sufficient reserve capacity\n\nreserve = model.addConstrs(gp.quicksum(max_load[type]*ngen[type, period] for type in range(ntypes)) >=\n                           1.15*demand[period] - sum(hydro_load)\n                           for period in range(nperiods))\n\n# Startup constraint\n\nstartup0 = model.addConstrs((ngen[type,0] <= maxstart0 + nstart[type,0])\n                            for type in range(ntypes))\n\nstartup = model.addConstrs((ngen[type,period] <= ngen[type,period-1] + nstart[type,period])\n                           for type in range(ntypes) for period in range(1,nperiods))\n\n# Hydro startup constraint\n\nhydro_startup0 = model.addConstrs((hydro[unit,0] <= hydrostart[unit,0])\n                                    for unit in range(hydrounits))\n\nhydro_startup = model.addConstrs((hydro[unit,period] <= hydro[unit,period-1] + hydrostart[unit,period])\n                           for unit in range(hydrounits) for period in range(1,nperiods))\n\n# Objective: minimize total cost\n\nactive = gp.quicksum(base_cost[type]*period_hours[period]*ngen[type,period]\n                    for type in range(ntypes) for period in range(nperiods))\n\nper_mw = gp.quicksum(per_mw_cost[type]*period_hours[period]*(output[type,period] - min_load[type]*ngen[type,period])\n                       for type in range(ntypes) for period in range(nperiods))\n\nstartup_obj = gp.quicksum(startup_cost[type]*nstart[type,period]\n                         for type in range(ntypes) for period in range(nperiods))\n\nhydro_active = gp.quicksum(hydro_cost[unit]*period_hours[period]*hydro[unit,period]\n                           for unit in range(hydrounits) for period in range(nperiods))\n\nhydro_startup = gp.quicksum(hydro_startup_cost[unit]*hydrostart[unit,period]\n                            for unit in range(hydrounits) for period in range(nperiods))\n\nmodel.setObjective(active + per_mw + startup_obj + hydro_active + hydro_startup)\n\nmodel.optimize()\n\nrows = [\"Thermal\" + str(t) for t in range(ntypes)]\nunits = pd.DataFrame(columns=range(nperiods), index=rows, data=0.0)\n\nfor t in range(ntypes):\n    for p in range(nperiods):\n        units.loc[\"Thermal\"+str(t), p] = ngen[t,p].x\nunits\n\nrows = [\"HydroA\", \"HydroB\"]\nhydrotable = pd.DataFrame(columns=range(nperiods), index=rows, data=0.0)\n\nfor p in range(nperiods):\n    hydrotable.loc[\"HydroA\", p] = int(hydro[0,p].x)\n    hydrotable.loc[\"HydroB\", p] = int(hydro[1,p].x)\nhydrotable\n\npumptable = pd.DataFrame(columns=range(nperiods), index=[\"Pumping\"], data=0.0)\n\nfor p in range(nperiods):\n        pumptable.loc[\"Pumping\", p] = pumping[p].x\npumptable"}]}
{"meta": {"source_path": "/Users/sunyujun03/Desktop/ReLoop/gurobi-modeling-examples/market_sharing/market_sharing.ipynb", "kind": "ipynb", "title": "Market Sharing"}, "messages": [{"role": "system", "content": "You are an optimization engineer. Write correct and runnable Python code using gurobipy (Gurobi Python API). Be concise. Output only what is requested."}, {"role": "user", "content": "    Task: Reproduce the following Gurobi modeling example in Python using gurobipy.\n\n    Scenario description (from source):\n    # Market Sharing\n\n## Objective and Prerequisites\n\nIn this example, we’ll show you how to solve a goal programming problem that involves allocating the retailers to two divisions of a company in order to optimize the trade-offs of several market sharing goals. You’ll learn how to create a mixed integer linear programming model of the problem using the Gurobi Python API and how to find an optimal solution to the problem using the Gurobi Optimizer.\n\nThis model is example 13 from the fifth edition of Model Building in Mathematical Programming by H. Paul Williams on pages 267-268 and 322-324.\n\nThis modeling example is at the beginner level, where we assume that you know Python and that you have some knowledge about building mathematical optimization models. The reader should also consult the  [documentation](https://www.gurobi.com/resources/?category-filter=documentation)\nof the Gurobi Python API.\n\n**Download the Repository** <br /> \nYou can download the repository containing this and other examples by clicking [here](https://github.com/Gurobi/modeling-examples/archive/master.zip). \n\n## Problem Description\n\nA large company has two divisions: D1 and D2. The company supplies retailers with oil and spirit. The goal is to allocate each retailer to either division D1 or division D2. The allocated division will be the retailer’s supplier. As far as possible, the allocation must be made so that D1 controls 40% of the market and D2 the remaining 60%. The retailers in the table below are listed as M1 to M23. Each retailer has an estimated market for oil and spirit. Retailers M1 to M8 are in region 1, retailers M9 to M18 are in region 2, and retailers M19 to M23 are in region 3. Certain retailers are considered to have good growth prospects and categorized as group A and the others are in group B. Each retailer has a certain number of delivery points. \n![retailers](retailers.PNG)\n\nWe want to make the 40%/60% split between D1 and D2 in each of the following categories:\n1. Total number of delivery points\n2. Control of spirit market\n3. Control of oil market in region 1\n4. Control of oil market in region 2\n5. Control of oil market in region 3\n6. Number of retailers in group A\n7. Number of retailers in group B.\n\nThere is flexibility in that any market share may vary by $\\pm$ 5%. That is, the share can vary between the limits 35%/65% and 45%/55%. The objective is to minimize the sum of the percentage deviations from the 40%/60% split.\n\n## Model Formulation\n\n### Sets and Indices\n\n$r \\in \\text{Retailers}=\\{\\ 1,2,...,23\\}$\n\n### Parameters\n\n$\\text{deliveryPoints}_{r} \\in \\mathbb{N}^+$: Delivery points of retailer $r$.\n\n$\\text{spiritMarket}_{r} \\in \\mathbb{R}^+$: Spirit market -in millions of gallons, of retailer $r$.\n\n$\\text{oilMarket1}_{r} \\in \\mathbb{R}^+$: Oil market -in millions of gallons of retailer $r$ in Region 1.\n\n$\\text{oilMarket2}_{r} \\in \\mathbb{R}^+$: Oil market -in millions of gallons of retailer $r$ in Region 2.\n\n$\\text{oilMarket3}_{r} \\in \\mathbb{R}^+$: Oil market -in millions of gallons of retailer $r$ in Region 3.\n\n$\\text{retailerA}_{r} \\in \\{0,1\\}$: Parameter has a value of 1 if retailer $r$  belongs to group A.\n\n$\\text{retailerB}_{r} \\in \\{0,1\\}$: Parameter has a value of 1 if retailer $r$  belongs to group B.\n\n$\\text{deliveryPoints40} \\in \\mathbb{R}^+$: Forty percent of the delivery points.\n\n$\\text{deliveryPoints5} \\in \\mathbb{R}^+$: Five percent of the delivery points.\n\n$\\text{spiritMarket40} \\in \\mathbb{R}^+$: Forty percent of  the spirit market.\n\n$\\text{spiritMarket5} \\in \\mathbb{R}^+$: Five percent of the spirit market.\n\n$\\text{oilMarket1_40} \\in \\mathbb{R}^+$: Forty percent of  the oil market in region 1.\n\n$\\text{oilMarket1_5} \\in \\mathbb{R}^+$: Five percent of  the oil market in region 1.\n\n$\\text{oilMarket2_40} \\in \\mathbb{R}^+$: Forty percent of  the oil market in region 2.\n\n$\\text{oilMarket2_5} \\in \\mathbb{R}^+$: Five percent of  the oil market in region 2.\n\n$\\text{oilMarket3_40} \\in \\mathbb{R}^+$: Forty percent of  the oil market in region 3.\n\n$\\text{oilMarket3_5} \\in \\mathbb{R}^+$: Five percent of  the oil market in region 3.\n\n$\\text{retailerA40} \\in \\mathbb{R}^+$: Forty percent of the number of retailers in group A.\n\n$\\text{retailerA5} \\in \\mathbb{R}^+$: Five percent of the number of retailers in group A.\n\n$\\text{retailerB40} \\in \\mathbb{R}^+$: Forty percent of the number of retailers in group B.\n\n$\\text{retailerB5} \\in \\mathbb{R}^+$: Five percent of the number of retailers in group B.\n\n### Decision Variables\n\n$\\text{allocate}_{r} \\in \\{0,1\\}$: This binary variable is equal 1, if retailer r is allocated to Division 1, and 0 if allocated to Division 2.\n\n$\\text{deliveryPointsPos} \\in \\mathbb{R}^+$: This decision variable measures the positive deviation of the retailers’ allocation for the goal of satisfying forty percent of the delivery points.\n\n$\\text{deliveryPointsNeg} \\in \\mathbb{R}^+$: This decision variable measures the negative deviation of the retailers’ allocation for the goal of satisfying forty percent of the delivery points.\n\n$\\text{spiritMarketPos} \\in \\mathbb{R}^+$: This decision variable measures the positive deviation of the retailers’ allocation for the goal of satisfying forty percent  of the spirit market.\n\n$\\text{spiritMarketNeg} \\in \\mathbb{R}^+$: This decision variable measures the negative deviation of the retailers’ allocation for the goal of satisfying forty percent  of the spirit market.\n\n$\\text{oilMarket1Pos} \\in \\mathbb{R}^+$: This decision variable measures the positive deviation of the retailers’ allocation for the goal of satisfying forty percent  of  the oil market in region 1.\n\n$\\text{oilMarket1Neg} \\in \\mathbb{R}^+$: This decision variable measures the negative deviation of the retailers’ allocation for the goal of satisfying forty percent  of  the oil market in region 1.\n\n$\\text{oilMarket2Pos} \\in \\mathbb{R}^+$: This decision variable measures the positive deviation of the retailers’ allocation for the goal of satisfying forty percent  of  the oil market in region 2.\n\n$\\text{oilMarket2Neg} \\in \\mathbb{R}^+$: This decision variable measures the negative deviation of the retailers’ allocation for the goal of satisfying forty percent  of the oil market in region 2.\n\n$\\text{oilMarket3Pos} \\in \\mathbb{R}^+$: This decision variable measures the positive deviation of the retailers’ allocation for the goal of satisfying forty percent  of  the oil market in region 3.\n\n$\\text{oilMarket3Neg} \\in \\mathbb{R}^+$: This decision variable measures the negative deviation of the retailers’ allocation for the goal of satisfying forty percent  of the oil market in region 3.\n\n$\\text{retailerAPos} \\in \\mathbb{R}^+$: This decision variable measures the positive deviation of the retailers’ allocation for the goal of satisfying forty percent of the number of retailers in group A.\n\n$\\text{retailerANeg} \\in \\mathbb{R}^+$: This decision variable measures the negative deviation of the retailers’ allocation for the goal of satisfying forty percent of the number of retailers in group A.\n\n$\\text{retailerBPos} \\in \\mathbb{R}^+$: This decision variable measures the positive deviation of the retailers’ allocation for the goal of satisfying forty percent of the number of retailers in group B.\n\n$\\text{retailerBNeg} \\in \\mathbb{R}^+$: This decision variable measures the negative deviation of the retailers’ allocation for the goal of satisfying forty percent of the number of retailers in group B.\n\n### Constraints\n\n**Delivery points**: The allocation of retailers at Division 1 satisfies as much as possible forty percent of the delivery points.\n\n\\begin{equation}\n\\sum_{r \\in \\text{Retailers}} \\text{deliveryPoints}_{r}*{\\text{allocate}_{r}} + \\text{deliveryPointsPos} - \\text{deliveryPointsNeg}  = \\text{deliveryPoints40}\n\\end{equation}\n\n**Spirit Market**: The allocation of retailers at Division 1 satisfies as much as possible forty percent of the spirit market.\n\n\\begin{equation}\n\\sum_{r \\in \\text{Retailers}} \\text{spiritMarket}_{r}*{\\text{allocate}_{r}} + \\text{spiritMarketPos} - \n\\text{spiritMarketNeg}  = \\text{spiritMarket40}\n\\end{equation}\n\n**Oil market region 1**: The allocation of retailers in region 1 at Division 1 satisfies as much as possible forty percent of the oil market in that region.\n\n\\begin{equation}\n\\sum_{r \\in \\text{Retailers}} \\text{oilMarket1}_{r}*{\\text{allocate}_{r}} + \\text{oilMarket1Pos} - \n\\text{oilMarket1Neg}  = \\text{oilMarket1_40}\n\\end{equation}\n\n**Oil market region 2**: The allocation of retailers in region 2 at Division 1 satisfies as much as possible forty percent of the oil market in that region.\n\n\\begin{equation}\n\\sum_{r \\in \\text{Retailers}} \\text{oilMarket2}_{r}*{\\text{allocate}_{r}} + \\text{oilMarket2Pos} - \n\\text{oilMarket2Neg}  = \\text{oilMarket2_40}\n\\end{equation}\n\n**Oil market region 3**: The allocation of retailers in region 3 at Division 1 satisfies as much as possible forty percent of the oil market in that region.\n\n\\begin{equation}\n\\sum_{r \\in \\text{Retailers}} \\text{oilMarket3}_{r}*{\\text{allocate}_{r}} + \\text{oilMarket3Pos} - \n\\text{oilMarket3Neg}  = \\text{oilMarket3_40}\n\\end{equation}\n\n**Group A**: The allocation of retailers at Division 1 satisfies as much as possible forty percent of the retailers in group A.\n\n\\begin{equation}\n\\sum_{r \\in \\text{Retailers}} \\text{retailerA40}_{r}*{\\text{allocate}_{r}} + \\text{retailerAPos} - \n\\text{retailerANeg}  = \\text{retailerA40}\n\\end{equation}\n\n**Group B**: The allocation of retailers at Division 1 satisfies as much as possible forty percent of the retailers in group B.\n\n\\begin{equation}\n\\sum_{r \\in \\text{Retailers}} \\text{retailerB40}_{r}*{\\text{allocate}_{r}} + \\text{retailerBPos} - \n\\text{retailerBNeg}  = \\text{retailerB40}\n\\end{equation}\n\n**Flexibility**: There is flexibility in that any market share may vary by $\\pm$ 5%.\n\n$$\n\\text{deliveryPointsPos} \\leq \\text{deliveryPoints5}\n$$\n\n$$\n\\text{deliveryPointsNeg}  \\leq \\text{deliveryPoints5}\n$$\n\n$$\n\\text{spiritMarketPos} \\leq \\text{spiritMarket5}\n$$\n\n$$\n\\text{spiritMarketNeg}  \\leq \\text{spiritMarket5}\n$$\n\n$$\n\\text{oilMarket1Pos} \\leq \\text{oilMarket1_5}\n$$\n\n$$\n\\text{oilMarket1Neg} \\leq \\text{oilMarket1_5}\n$$\n\n$$\n\\text{oilMarket2Pos} \\leq \\text{oilMarket2_5}\n$$\n\n$$\n\\text{oilMarket2Neg} \\leq \\text{oilMarket2_5}\n$$\n\n$$\n\\text{oilMarket3Pos} \\leq \\text{oilMarket3_5}\n$$\n\n$$\n\\text{oilMarket3Neg} \\leq \\text{oilMarket3_5}\n$$\n\n$$\n\\text{retailerAPos} \\leq \\text{retailerA5}\n$$\n\n$$\n\\text{retailerANeg} \\leq \\text{retailerA5}\n$$\n\n$$\n\\text{retailerBPos} \\leq \\text{retailerB5}\n$$\n\n$$\n\\text{retailerBNeg} \\leq \\text{retailerB5}\n$$\n\n### Objective Function\n\n**Minimize deviations**: Minimize the sum of positive and negative deviations.\n\n\\begin{equation}\n\\text{Minimize} \\quad  \\text{deliveryPointsPos} + \\text{deliveryPointsNeg} + \\text{spiritMarketPos} + \\text{spiritMarketNeg} +\n\\text{oilMarket1Pos} + \\text{oilMarket1Neg}\n\\end{equation}\n\n$$\n+ \\text{oilMarket2Pos} + \\text{oilMarket2Neg} + \\text{oilMarket3Pos} + \\text{oilMarket3Neg} \n$$\n\n$$\n+ \\text{retailerAPos} + \\text{retailerANeg} + \\text{retailerBPos} + \\text{retailerBNeg}\n$$\n\n## Python Implementation\n\nWe import the Gurobi Python Module and other Python libraries.\n\n    Requirements:\n    - Use gurobipy (Model, GRB, addVar/addConstr, etc.)\n    - Make the script runnable as a standalone Python file if possible.\n    - Keep the code faithful to the example.\n"}, {"role": "assistant", "content": "import numpy as np\nimport pandas as pd\nfrom itertools import product\n\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# tested with Python 3.11 & Gurobi 11.0\n\n# Create a dictionary to capture the delivery points and spirit market -in millions of gallons.\n\nretailers, deliveryPoints, spiritMarket = gp.multidict({\n    (1): [11,34],\n    (2): [47,411],\n    (3): [44,82],\n    (4): [25,157],\n    (5): [10,5],\n    (6): [26,183],\n    (7): [26,14],\n    (8): [54,215],\n    (9): [18,102],\n    (10): [51,21],\n    (11): [20,54],\n    (12): [105,0],\n    (13): [7,6],\n    (14): [16,96],\n    (15): [34,118],\n    (16): [100,112],\n    (17): [50,535],\n    (18): [21,8],\n    (19): [11,53],\n    (20): [19,28],\n    (21): [14,69],\n    (22): [10,65],\n    (23): [11,27]\n})\n\n# Create a dictionary to capture the oil market -in millions of gallons for region 1.\n\nretailers1,  oilMarket1 = gp.multidict({\n    (1): 9,\n    (2): 13,\n    (3): 14,\n    (4): 17,\n    (5): 18,\n    (6): 19,\n    (7): 23,\n    (8): 21\n})\n\n# Create a dictionary to capture the oil market -in millions of gallons for region 2.\n\nretailers2,  oilMarket2 = gp.multidict({\n    (9): 9,\n    (10): 11,\n    (11): 17,\n    (12): 18,\n    (13): 18,\n    (14): 17,\n    (15): 22,\n    (16): 24,\n    (17): 36,\n    (18): 43\n})\n\n# Create a dictionary to capture the oil market -in millions of gallons for region 3.\n\nretailers3,  oilMarket3 = gp.multidict({\n    (19): 6,\n    (20): 15,\n    (21): 15,\n    (22): 25,\n    (23): 39\n})\n\n# Create a dictionary to capture retailers in group A.\n\ngroupA,  retailerA = gp.multidict({\n    (1): 1,\n    (2): 1,\n    (3): 1,\n    (5): 1,\n    (6): 1,\n    (10): 1,\n    (15): 1,\n    (20): 1\n})\n\n# Create a dictionary to capture retailers in group B.\n\ngroupB,  retailerB = gp.multidict({\n    (4): 1,\n    (7): 1,\n    (8): 1,\n    (9): 1,\n    (11): 1,\n    (12): 1,\n    (13): 1,\n    (14): 1,\n    (16): 1,\n    (17): 1,\n    (18): 1,\n    (19): 1,\n    (21): 1,\n    (22): 1,\n    (23): 1\n})\n\n# Forty and five percentages of each goal\n\ndeliveryPoints40 = 292\ndeliveryPoints5 = 36.5\nspiritMarket40 = 958\nspiritMarket5 = 119.75\noilMarket1_40 = 53.6\noilMarket1_5 = 6.7\noilMarket2_40 = 86\noilMarket2_5 = 10.75\noilMarket3_40 = 40\noilMarket3_5 = 5\nretailerA40 = 3.2\nretailerA5 = 0.4\nretailerB40 = 6\nretailerB5 = 0.75\n\nmodel = gp.Model('MarketSharing')\n\n# Allocation of retailers to Division 1.\nallocate = model.addVars(retailers, vtype=GRB.BINARY, name=\"allocate\")\n\n# Positive and negative deviation of delivery points goal.\n\ndeliveryPointsPos = model.addVar(ub= deliveryPoints5, name='deliveryPointsPos')\ndeliveryPointsNeg = model.addVar(ub= deliveryPoints5, name='deliveryPointsNeg')\n\n# Positive and negative deviation of spirit market goal.\n\nspiritMarketPos = model.addVar(ub=spiritMarket5, name='spiritMarketPos')\nspiritMarketNeg = model.addVar(ub=spiritMarket5, name='spiritMarketNeg')\n\n# Positive and negative deviation of oil market in region 1 goal.\n\noilMarket1Pos = model.addVar(ub=oilMarket1_5, name='oilMarket1Pos')\noilMarket1Neg = model.addVar(ub=oilMarket1_5, name='oilMarket1Neg')\n\n# Positive and negative deviation of oil market in region 2 goal.\n\noilMarket2Pos = model.addVar(ub=oilMarket2_5, name='oilMarket2Pos')\noilMarket2Neg = model.addVar(ub=oilMarket2_5, name='oilMarket2Neg')\n\n# Positive and negative deviation of oil market in region 3 goal.\n\noilMarket3Pos = model.addVar(ub=oilMarket3_5, name='oilMarket3Pos')\noilMarket3Neg = model.addVar(ub=oilMarket3_5, name='oilMarket3Neg')\n\n# Positive and negative deviation of retailers in group A goal.\n\nretailerAPos  = model.addVar(ub=retailerA5, name='retailerAPos')\nretailerANeg  = model.addVar(ub=retailerA5, name='retailerANeg')\n\n# Positive and negative deviation of retailers in group B goal.\n\nretailerBPos  = model.addVar(ub=retailerB5, name='retailerBPos')\nretailerBNeg  = model.addVar(ub=retailerB5, name='retailerBNeg')\n\n# Delivery points constraint.\n\nDPConstr = model.addConstr((gp.quicksum(deliveryPoints[r]*allocate[r] for r in retailers) \n                            + deliveryPointsPos - deliveryPointsNeg == deliveryPoints40), name='DPConstrs')\n\n# Spirit market constraint.\n\nSMConstr = model.addConstr((gp.quicksum(spiritMarket[r]*allocate[r] for r in retailers) \n                            + spiritMarketPos - spiritMarketNeg == spiritMarket40), name='SMConstr')\n\n# Oil market in region 1 constraint.\n\nOM1Constr = model.addConstr((gp.quicksum(oilMarket1[r]*allocate[r] for r in retailers1) \n                            + oilMarket1Pos - oilMarket1Neg == oilMarket1_40), name='OM1Constr')\n\n# Oil market in region 2 constraint.\n\nOM2Constr = model.addConstr((gp.quicksum(oilMarket2[r]*allocate[r] for r in retailers2) \n                            + oilMarket2Pos - oilMarket2Neg == oilMarket2_40), name='OM2Constr')\n\n# Oil market in region 3 constraint.\n\nOM3Constr = model.addConstr((gp.quicksum(oilMarket3[r]*allocate[r] for r in retailers3) \n                            + oilMarket3Pos - oilMarket3Neg == oilMarket3_40), name='OM3Constr')\n\n# Group A constraint.\n\nAConstr = model.addConstr((gp.quicksum(retailerA[r]*allocate[r] for r in groupA) \n                            + retailerAPos - retailerANeg == retailerA40), name='AConstr')\n\n# Group B constraint.\n\nBConstr = model.addConstr((gp.quicksum(retailerB[r]*allocate[r] for r in groupB) \n                            + retailerBPos - retailerBNeg == retailerB40), name='BConstr')\n\n# Objective function\n\nobj = deliveryPointsPos + deliveryPointsNeg+ spiritMarketPos + spiritMarketNeg + oilMarket1Pos + oilMarket1Neg + oilMarket2Pos + oilMarket2Neg + oilMarket3Pos + oilMarket3Neg + retailerAPos + retailerANeg + retailerBPos + retailerBNeg \n\nmodel.setObjective(obj)\n\n# Verify model formulation\n\nmodel.write('marketSharing.lp')\n\n# Run optimization engine\n\nmodel.optimize()\n\n# Output reports\n\nprint(\"\\n\\n_________________________________________________________________________________\")\nprint(f\"The optimal allocation of retailers to Division 1 is:\")\nprint(\"_________________________________________________________________________________\")\nfor r in retailers:\n    if(allocate[r].x > 0.5):\n        print(f\"Retailer{r}\")\n\n#print(f\"\\nThe optimal objective function value is {model.objVal}\")\n\n# Test that the solution is within acceptable ranges.\n\nDeliveryPointsGoal = sum([deliveryPoints[r] for r in retailers if allocate[r].x > 0.5])\nspiritMarketGoal = sum([spiritMarket[r] for r in retailers if allocate[r].x > 0.5])\noilMarket1Goal = sum([oilMarket1[r] for r in retailers1 if allocate[r].x > 0.5])\noilMarket2Goal = sum([oilMarket2[r] for r in retailers2 if allocate[r].x > 0.5])\noilMarket3Goal = sum([oilMarket3[r] for r in retailers3 if allocate[r].x > 0.5])\nretailerAGoal = sum([retailerA[r] for r in groupA if allocate[r].x > 0.5])\nretailerBGoal = sum([retailerB[r] for r in groupB if allocate[r].x > 0.5])\n\ngoal_ranges = pd.DataFrame({\n    \"Goal\": [\"DeliveryPoints\", \"Spirit market\", \"Oil market1\", \"Oil market1\", \"Oil market3\", \"Group A\", \"Group B\"],\n    \"Min_35\": [round(val*(0.35/0.40),2) for val in (deliveryPoints40, spiritMarket40, oilMarket1_40, oilMarket2_40, oilMarket3_40, retailerA40, retailerB40)],\n    \"Actual\": [round(val,2) for val in (DeliveryPointsGoal, spiritMarketGoal, oilMarket1Goal, oilMarket2Goal, oilMarket3Goal, retailerAGoal, retailerBGoal)],\n    \"Max_45\": [round(val*(0.45/0.40),2)  for val in (deliveryPoints40, spiritMarket40, oilMarket1_40, oilMarket2_40, oilMarket3_40, retailerA40, retailerB40)],\n})\ngoal_ranges.index=[''] * len(goal_ranges)\ngoal_ranges"}]}
{"meta": {"source_path": "/Users/sunyujun03/Desktop/ReLoop/gurobi-modeling-examples/supply_network_design/supply_network_design_2.ipynb", "kind": "ipynb", "title": "Supply Network Design 2"}, "messages": [{"role": "system", "content": "You are an optimization engineer. Write correct and runnable Python code using gurobipy (Gurobi Python API). Be concise. Output only what is requested."}, {"role": "user", "content": "    Task: Reproduce the following Gurobi modeling example in Python using gurobipy.\n\n    Scenario description (from source):\n    # Supply Network Design 2\n\n## Objective and Prerequisites\n\nTake your supply chain network design skills to the next level in this example. We’ll show you how – given a set of factories, depots, and customers – you can use mathematical optimization to determine which depots to open or close in order to minimize overall costs.\n\nThis model is example 20 from the fifth edition of Model Building in Mathematical Programming, by H. Paul Williams on pages 275-276 and 332-333.\n\nThis example is of beginning difficulty; we assume that you know Python and have some knowledge of the Gurobi Python API and building mathematical optimization models.\n\n**Download the Repository** <br />\nYou can download the repository containing this and other examples by clicking [here](https://github.com/Gurobi/modeling-examples/archive/master.zip). \n\n---\n## Problem Description\n\nIn this problem, we have six end customers, each with a known demand for a product.  Customer demand can be satisfied from a set of six depots, or directly from a set of two factories.  Each depot can support a maximum volume of product moving through it, and each factory can produce a maximum amount of product.  There are known costs associated with transporting the product, from a factory to a depot, from a depot to a customer, or from a factory directly to a customer. This extension provides the opportunity to choose which four of the six possible depots to open.  It also provides an option of expanding capacity at one specific depot.\n\nOur supply network has two factories, in Liverpool and Brighton, that produce a product.  Each has a maximum production capacity:\n\n| Factory | Supply (tons) |\n| --- | --- |\n| Liverpool | 150,000 |\n| Brighton |  200,000 |\n\nThe product can be shipped from a factory to a set of six depots.  Each depot has a maximum throughput.  Depots don't produce or consume the product; they simply pass the product through to customers.\n\n| Depot | Throughput (tons) |\n| --- | --- |\n| Newcastle | 70,000 |\n| Birmingham | 50,000 |\n| London | 100,000 |\n| Exeter | 40,000 |\n| Bristol | 30,000 |\n| Northampton | 25,000 |\n\nWe can actually only choose four of the six depots to open.  Opening a depot has a cost:\n\n| Depot | Cost to open |\n| --- | --- |\n| Newcastle | 10,000 |\n| Exeter | 5,000 |\n| Bristol | 12,000 |\n| Northampton | 4,000 |\n\n(Note that the description in the book talks about the cost of opening Bristol or Northampton, and the savings from closing Newcastle or Exeter, but these are simply different ways of phrasing the same choice).\n\nWe also have the option of expanding the capacity at Birmingham by 20,000 tons, for a cost of \\$3000.\n\nOur network has six customers, each with a given demand.\n\n| Customer | Demand (tons) |\n| --- | --- |\n| C1 | 50,000 |\n| C2 | 10,000 |\n| C3 | 40,000 |\n| C4 | 35,000 |\n| C5 | 60,000 |\n| C6 | 20,000 |\n\nShipping costs are given in the following table (in dollars per ton).  Columns are source cities and rows are destination cities.  Thus, for example, it costs $1 per ton to ship the product from Liverpool to London.  A '-' in the table indicates that that combination is not possible, so for example it is not possible to ship from the factory in Brighton to the depot in Newcastle.\n\n| To | Liverpool | Brighton | Newcastle | Birmingham | London | Exeter | Briston | Northhampton\n| --- | --- | --- | --- | --- | --- | --- | --- | --- |\n| Depots |\n| Newcastle   | 0.5 |   - |\n| Birmingham  | 0.5 | 0.3 |\n| London      | 1.0 | 0.5 |\n| Exeter      | 0.2 | 0.2 |\n| Bristol     | 0.6 | 0.4 |\n| Northampton | 0.4 | 0.3 |\n| Customers |\n| C1 | 1.0 | 2.0 |   - | 1.0 |   - |   - | 1.2 |   - |\n| C2 |   - |   - | 1.5 | 0.5 | 1.5 |   - | 0.6 | 0.4 |\n| C3 | 1.5 |   - | 0.5 | 0.5 | 2.0 | 0.2 | 0.5 |   - |\n| C4 | 2.0 |   - | 1.5 | 1.0 |   - | 1.5 |   - | 0.5 |\n| C5 |   - |   - |   - | 0.5 | 0.5 | 0.5 | 0.3 | 0.6 |\n| C6 | 1.0 |   - | 1.0 |   - | 1.5 | 1.5 | 0.8 | 0.9 |\n\nThe questions to be answered: (i) Which four depots should be opened? (ii) Should Birmingham be expanded? (iii) Which depots should be used to satisfy customer demand?\n\n---\n## Model Formulation\n\n### Sets and Indices\n\n$f \\in \\text{Factories}=\\{\\text{Liverpool}, \\text{Brighton}\\}$\n\n$d \\in \\text{Depots}=\\{\\text{Newcastle}, \\text{Birmingham}, \\text{London}, \\text{Exeter}, \\text{Bristol}, \\text{Northampton}\\}$\n\n$c \\in \\text{Customers}=\\{\\text{C1}, \\text{C2}, \\text{C3}, \\text{C4}, \\text{C5}, \\text{C6}\\}$\n\n$\\text{Cities} = \\text{Factories} \\cup \\text{Depots} \\cup \\text{Customers}$\n\n### Parameters\n\n$\\text{cost}_{s,t} \\in \\mathbb{R}^+$: Cost of shipping one ton from source $s$ to destination $t$.\n\n$\\text{supply}_f \\in \\mathbb{R}^+$: Maximum possible supply from factory $f$ (in tons).\n\n$\\text{through}_d \\in \\mathbb{R}^+$: Maximum possible flow through depot $d$ (in tons).\n\n$\\text{demand}_c \\in \\mathbb{R}^+$: Demand for goods at customer $c$ (in tons).\n\n$\\text{opencost}_d \\in \\mathbb{R}^+$: Cost of opening depot $d$ (in dollars).\n\n### Decision Variables\n\n$\\text{flow}_{s,t} \\in \\mathbb{N}^+$: Quantity of goods (in tons) that is shipped from source $s$ to destionation $t$.\n\n$\\text{open}_{d} \\in [0,1]$: Is depot $d$ open?\n\n$\\text{expand} \\in [0,1]$: Should Birmingham be expanded?\n\n### Objective Function\n\n- **Cost**: Minimize total shipping costs plus costs of opening depots.\n\n\\begin{equation}\n\\text{Minimize} \\quad Z = \\sum_{(s,t) \\in \\text{Cities} \\times \\text{Cities}}{\\text{cost}_{s,t}*\\text{flow}_{s,t}} +\n                          \\sum_{{d} \\in \\text{Depots}}{\\text{opencost}_d*\\text{open}_d} +\n                          3000 * \\text{expand}\n\\end{equation}\n\n### Constraints\n\n- **Factory output**: Flow of goods from a factory must respect maximum capacity.\n\n\\begin{equation}\n\\sum_{t \\in \\text{Cities}}{\\text{flow}_{f,t}} \\leq \\text{supply}_{f} \\quad \\forall f \\in \\text{Factories}\n\\end{equation}\n\n- **Customer demand**: Flow of goods must meet customer demand.\n\n\\begin{equation}\n\\sum_{s \\in \\text{Cities}}{\\text{flow}_{s,c}} = \\text{demand}_{c} \\quad \\forall c \\in \\text{Customers}\n\\end{equation}\n\n- **Depot flow**: Flow into a depot equals flow out of the depot.\n\n\\begin{equation}\n\\sum_{s \\in \\text{Cities}}{\\text{flow}_{s,d}} = \n\\sum_{t \\in \\text{Cities}}{\\text{flow}_{d,t}}\n\\quad \\forall d \\in \\text{Depots}\n\\end{equation}\n\n- **Depot capacity (all but Birmingham)**: Flow into a depot must respect depot capacity, and is only allowed if the depot is open.\n\n\\begin{equation}\n\\sum_{s \\in \\text{Cities}}{\\text{flow}_{s,d}} \\leq \\text{through}_{d} * \\text{open}_{d}\n\\quad \\forall d \\in \\text{Depots} - \\text{Birmingham}\n\\end{equation}\n\n- **Depot capacity (Birmingham)**: Flow into Birmingham must respect depot capacity, which may have been expanded.\n\n\\begin{equation}\n\\sum_{s \\in \\text{Cities}} \\text{flow}_{s,\\text{Birmingham}} \\leq \\text{through}_{\\text{Birmingham}} + 20000 * \\text{expand}\n\\end{equation}\n\n- **Open depots**: At most 4 open depots (no choice for Birmingham or London).\n\n\\begin{equation}\n\\sum_{d \\in \\text{Depots}}{\\text{open}_{d}} \\leq 4\n\\end{equation}\n\n\\begin{equation}\n\\text{open}_{\\text{Birmingham}} = \\text{open}_{\\text{London}} = 1\n\\end{equation}\n\n---\n## Python Implementation\n\nWe import the Gurobi Python Module and other Python libraries.\n\n## Input Data\nWe define all the input data for the model.\n\n## Model Deployment\n\nWe create a model and the variables. The 'flow' variables simply capture the amount of product that flows along each allowed path between a source and destination.  The 'open' variable capture decisions about which depots to open.  The 'expand' variable captures the choice of whether to expand Birmingham.  Objective coefficients are provided here, so we don't need to provide an optimization objective later.\n\nOur first constraints require the total flow along arcs leaving a factory to be at most as large as the supply capacity of that factory.\n\n    Requirements:\n    - Use gurobipy (Model, GRB, addVar/addConstr, etc.)\n    - Make the script runnable as a standalone Python file if possible.\n    - Keep the code faithful to the example.\n"}, {"role": "assistant", "content": "import pandas as pd\n\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# tested with Python 3.11 & Gurobi 11.0\n\n# Create dictionaries to capture factory supply limits, depot throughput limits, cost of opening depots, and customer demand.\n\nsupply = dict({'Liverpool': 150000,\n               'Brighton': 200000})\n\nthrough = dict({'Newcastle': 70000,\n                'Birmingham': 50000,\n                'London': 100000,\n                'Exeter': 40000,\n                'Bristol': 30000,\n                'Northampton': 25000})\n\nopencost = dict({'Newcastle': 10000,\n                 'Birmingham': 0,\n                 'London': 0,\n                 'Exeter': 5000,\n                 'Bristol': 12000,\n                 'Northampton': 4000})\n\ndemand = dict({'C1': 50000,\n               'C2': 10000,\n               'C3': 40000,\n               'C4': 35000,\n               'C5': 60000,\n               'C6': 20000})\n\n# Create a dictionary to capture shipping costs.\n\narcs, cost = gp.multidict({\n    ('Liverpool', 'Newcastle'): 0.5,\n    ('Liverpool', 'Birmingham'): 0.5,\n    ('Liverpool', 'London'): 1.0,\n    ('Liverpool', 'Exeter'): 0.2,\n    ('Liverpool', 'Bristol'): 0.6,\n    ('Liverpool', 'Northampton'): 0.4,\n    ('Liverpool', 'C1'): 1.0,\n    ('Liverpool', 'C3'): 1.5,\n    ('Liverpool', 'C4'): 2.0,\n    ('Liverpool', 'C6'): 1.0,\n    ('Brighton', 'Birmingham'): 0.3,\n    ('Brighton', 'London'): 0.5,\n    ('Brighton', 'Exeter'): 0.2,\n    ('Brighton', 'Bristol'): 0.4,\n    ('Brighton', 'Northampton'): 0.3,\n    ('Brighton', 'C1'): 2.0,\n    ('Newcastle', 'C2'): 1.5,\n    ('Newcastle', 'C3'): 0.5,\n    ('Newcastle', 'C5'): 1.5,\n    ('Newcastle', 'C6'): 1.0,\n    ('Birmingham', 'C1'): 1.0,\n    ('Birmingham', 'C2'): 0.5,\n    ('Birmingham', 'C3'): 0.5,\n    ('Birmingham', 'C4'): 1.0,\n    ('Birmingham', 'C5'): 0.5,\n    ('London', 'C2'): 1.5,\n    ('London', 'C3'): 2.0,\n    ('London', 'C5'): 0.5,\n    ('London', 'C6'): 1.5,\n    ('Exeter', 'C3'): 0.2,\n    ('Exeter', 'C4'): 1.5,\n    ('Exeter', 'C5'): 0.5,\n    ('Exeter', 'C6'): 1.5,\n    ('Bristol', 'C1'): 1.2,\n    ('Bristol', 'C2'): 0.6,\n    ('Bristol', 'C3'): 0.5,\n    ('Bristol', 'C5'): 0.3,\n    ('Bristol', 'C6'): 0.8,\n    ('Northampton', 'C2'): 0.4,\n    ('Northampton', 'C4'): 0.5,\n    ('Northampton', 'C5'): 0.6,\n    ('Northampton', 'C6'): 0.9\n})\n\nmodel = gp.Model('SupplyNetworkDesign2')\n\ndepots = through.keys()\nflow = model.addVars(arcs, obj=cost, name=\"flow\")\nopen = model.addVars(depots, obj=opencost, vtype=GRB.BINARY, name=\"open\")\nexpand = model.addVar(obj=3000, vtype=GRB.BINARY, name=\"expand\")\n\nopen['Birmingham'].lb = 1\nopen['London'].lb = 1\nmodel.objcon = -(opencost['Newcastle'] + opencost['Exeter']) # Phrased as 'savings from closing'\n\n# Production capacity limits\n\nfactories = supply.keys()\nfactory_flow = model.addConstrs((gp.quicksum(flow.select(factory, '*')) <= supply[factory]\n                                 for factory in factories), name=\"factory\")\n\n# Customer demand\n\ncustomers = demand.keys()\ncustomer_flow = model.addConstrs((gp.quicksum(flow.select('*', customer)) == demand[customer]\n                                  for customer in customers), name=\"customer\")\n\n# Depot flow conservation\n\ndepot_flow = model.addConstrs((gp.quicksum(flow.select(depot, '*')) == gp.quicksum(flow.select('*', depot))\n                               for depot in depots), name=\"depot\")\n\n# Depot throughput\n\nall_but_birmingham = list(set(depots) - set(['Birmingham']))\n\ndepot_capacity = model.addConstrs((gp.quicksum(flow.select(depot, '*')) <= through[depot]*open[depot]\n                                   for depot in all_but_birmingham), name=\"depot_capacity\")\n\nbirmingham_capacity = model.addConstr(gp.quicksum(flow.select('*', 'Birmingham')) <= through['Birmingham'] +\n                                      20000*expand, name=\"birmingham_capacity\")\n\n# Depot count\n\ndepot_count = model.addConstr(open.sum() <= 4)\n\nmodel.optimize()\n\nprint('List of open depots:', [d for d in depots if open[d].x > 0.5])\nif expand.x > 0.5:\n    print('Expand Birmingham')\n\nproduct_flow = pd.DataFrame(\n    [{\"From\": arc[0], \"To\": arc[1], \"Flow\": flow[arc].x} for arc in arcs if flow[arc].x > 1e-6]\n)\nproduct_flow.index=[''] * len(product_flow)\nproduct_flow"}]}
{"meta": {"source_path": "/Users/sunyujun03/Desktop/ReLoop/gurobi-modeling-examples/supply_network_design/supply_network_design_1.ipynb", "kind": "ipynb", "title": "Supply Network Design 1"}, "messages": [{"role": "system", "content": "You are an optimization engineer. Write correct and runnable Python code using gurobipy (Gurobi Python API). Be concise. Output only what is requested."}, {"role": "user", "content": "    Task: Reproduce the following Gurobi modeling example in Python using gurobipy.\n\n    Scenario description (from source):\n    # Supply Network Design 1\n\n## Objective and Prerequisites\n\nTry this Jupyter Notebook Modeling Example to learn how to solve a classic supply network design problem that involves finding the minimum cost flow through a network. We’ll show you how – given a set of factories, depots, and customers – you can use mathematical optimization to determine the best way to satisfy customer demand while minimizing shipping costs.\n\nThis model is example 19 from the fifth edition of Model Building in Mathematical Programming, by H. Paul Williams on pages 273-275 and 330-332.\n\nThis example is of beginning difficulty; we assume that you know Python and have some knowledge of the Gurobi Python API and building mathematical optimization models.\n\n**Download the Repository** <br />\nYou can download the repository containing this and other examples by clicking [here](https://github.com/Gurobi/modeling-examples/archive/master.zip). \n\n---\n## Problem Description\n\nIn this problem, we have six end customers, each with a known demand for a product.  Customer demand can be satisfied from a set of four depots, or directly from a set of two factories.  Each depot can support a maximum volume of product moving through it, and each factory can produce a maximum amount of product.  There are known costs associated with transporting the product, from a factory to a depot, from a depot to a customer, or from a factory directly to a customer.\n\nOur supply network has two factories, in Liverpool and Brighton, that produce a product.  Each has a maximum production capacity:\n\n| Factory | Supply (tons) |\n| --- | --- |\n| Liverpool | 150,000 |\n| Brighton |  200,000 |\n\nThe product can be shipped from a factory to a set of four depots.  Each depot has a maximum throughput.  Depots don't produce or consume the product; they simply pass the product on to customers.\n\n| Depot | Throughput (tons) |\n| --- | --- |\n| Newcastle | 70,000 |\n| Birmingham | 50,000 |\n| London | 100,000 |\n| Exeter | 40,000 |\n\nOur network has six customers, each with a given demand.\n\n| Customer | Demand (tons) |\n| --- | --- |\n| C1 | 50,000 |\n| C2 | 10,000 |\n| C3 | 40,000 |\n| C4 | 35,000 |\n| C5 | 60,000 |\n| C6 | 20,000 |\n\nShipping costs are given in the following table (in dollars per ton).  Columns are source cities and rows are destination cities.  Thus, for example, it costs $1 per ton to ship the product from Liverpool to London.  A '-' in the table indicates that that combination is not possible, so for example it is not possible to ship from the factory in Brighton to the depot in Newcastle.\n\n| To | Liverpool | Brighton | Newcastle | Birmingham | London | Exeter |\n| --- | --- | --- | --- | --- | --- | --- |\n| Depots |\n| Newcastle  | 0.5 |   - |\n| Birmingham | 0.5 | 0.3 |\n| London     | 1.0 | 0.5 |\n| Exeter     | 0.2 | 0.2 |\n| Customers |\n| C1 | 1.0 | 2.0 |   - | 1.0 |   - |   - |\n| C2 |   - |   - | 1.5 | 0.5 | 1.5 |   - |\n| C3 | 1.5 |   - | 0.5 | 0.5 | 2.0 | 0.2 |\n| C4 | 2.0 |   - | 1.5 | 1.0 |   - | 1.5 |\n| C5 |   - |   - |   - | 0.5 | 0.5 | 0.5 |\n| C6 | 1.0 |   - | 1.0 |   - | 1.5 | 1.5 |\n\nThe question to be answered is how to satisfy the demands of the end customers while minimizing shipping costs.\n\n---\n## Model Formulation\n\n### Sets and Indices\n\n$f \\in \\text{Factories}=\\{\\text{Liverpool}, \\text{Brighton}\\}$\n\n$d \\in \\text{Depots}=\\{\\text{Newcastle}, \\text{Birmingham}, \\text{London}, \\text{Exeter}\\}$\n\n$c \\in \\text{Customers}=\\{\\text{C1}, \\text{C2}, \\text{C3}, \\text{C4}, \\text{C5}, \\text{C6}\\}$\n\n$\\text{Cities} = \\text{Factories} \\cup \\text{Depots} \\cup \\text{Customers}$\n\n### Parameters\n\n$\\text{cost}_{s,t} \\in \\mathbb{R}^+$: Cost of shipping one ton from source $s$ to destination $t$.\n\n$\\text{supply}_f \\in \\mathbb{R}^+$: Maximum possible supply from factory $f$ (in tons).\n\n$\\text{through}_d \\in \\mathbb{R}^+$: Maximum possible flow through depot $d$ (in tons).\n\n$\\text{demand}_c \\in \\mathbb{R}^+$: Demand for goods at customer $c$ (in tons).\n\n### Decision Variables\n\n$\\text{flow}_{s,t} \\in \\mathbb{N}^+$: Quantity of goods (in tons) that is shipped from source $s$ to destionation $t$.\n\n### Objective Function\n\n- **Cost**: Minimize total shipping costs.\n\n\\begin{equation}\n\\text{Minimize} \\quad Z = \\sum_{(s,t) \\in \\text{Cities} \\times \\text{Cities}}{\\text{cost}_{s,t}*\\text{flow}_{s,t}}\n\\end{equation}\n\n### Constraints\n\n- **Factory output**: Flow of goods from a factory must respect maximum capacity.\n\n\\begin{equation}\n\\sum_{t \\in \\text{Cities}}{\\text{flow}_{f,t}} \\leq \\text{supply}_{f} \\quad \\forall f \\in \\text{Factories}\n\\end{equation}\n\n- **Customer demand**: Flow of goods must meet customer demand.\n\n\\begin{equation}\n\\sum_{s \\in \\text{Cities}}{\\text{flow}_{s,c}} = \\text{demand}_{c} \\quad \\forall c \\in \\text{Customers}\n\\end{equation}\n\n- **Depot flow**: Flow into a depot equals flow out of the depot.\n\n\\begin{equation}\n\\sum_{s \\in \\text{Cities}}{\\text{flow}_{s,d}} = \n\\sum_{t \\in \\text{Cities}}{\\text{flow}_{d,t}}\n\\quad \\forall d \\in \\text{Depots}\n\\end{equation}\n\n- **Depot capacity**: Flow into a depot must respect depot capacity.\n\n\\begin{equation}\n\\sum_{s \\in \\text{Cities}}{\\text{flow}_{s,d}} \\leq \\text{through}_{d}\n\\quad \\forall d \\in \\text{Depots}\n\\end{equation}\n\n---\n## Python Implementation\n\nWe import the Gurobi Python Module and other Python libraries.\n\n## Input Data\nWe define all the input data for the model.\n\n## Model Deployment\n\nWe create a model and the variables. The variables simply capture the amount of product that flows along each allowed path between a source and destination.  Objective coefficients are provided here (in $\\text{cost}$) , so we don't need to provide an optimization objective later.\n\nOur first constraints require the total flow along arcs leaving a factory to be at most as large as the supply capacity of that factory.\n\n    Requirements:\n    - Use gurobipy (Model, GRB, addVar/addConstr, etc.)\n    - Make the script runnable as a standalone Python file if possible.\n    - Keep the code faithful to the example.\n"}, {"role": "assistant", "content": "import pandas as pd\n\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# tested with Python 3.11 & Gurobi 11.0\n\n# Create dictionaries to capture factory supply limits, depot throughput limits, and customer demand.\n\nsupply = dict({'Liverpool': 150000,\n               'Brighton': 200000})\n\nthrough = dict({'Newcastle': 70000,\n                'Birmingham': 50000,\n                'London': 100000,\n                'Exeter': 40000})\n\ndemand = dict({'C1': 50000,\n               'C2': 10000,\n               'C3': 40000,\n               'C4': 35000,\n               'C5': 60000,\n               'C6': 20000})\n\n# Create a dictionary to capture shipping costs.\n\narcs, cost = gp.multidict({\n    ('Liverpool', 'Newcastle'): 0.5,\n    ('Liverpool', 'Birmingham'): 0.5,\n    ('Liverpool', 'London'): 1.0,\n    ('Liverpool', 'Exeter'): 0.2,\n    ('Liverpool', 'C1'): 1.0,\n    ('Liverpool', 'C3'): 1.5,\n    ('Liverpool', 'C4'): 2.0,\n    ('Liverpool', 'C6'): 1.0,\n    ('Brighton', 'Birmingham'): 0.3,\n    ('Brighton', 'London'): 0.5,\n    ('Brighton', 'Exeter'): 0.2,\n    ('Brighton', 'C1'): 2.0,\n    ('Newcastle', 'C2'): 1.5,\n    ('Newcastle', 'C3'): 0.5,\n    ('Newcastle', 'C5'): 1.5,\n    ('Newcastle', 'C6'): 1.0,\n    ('Birmingham', 'C1'): 1.0,\n    ('Birmingham', 'C2'): 0.5,\n    ('Birmingham', 'C3'): 0.5,\n    ('Birmingham', 'C4'): 1.0,\n    ('Birmingham', 'C5'): 0.5,\n    ('London', 'C2'): 1.5,\n    ('London', 'C3'): 2.0,\n    ('London', 'C5'): 0.5,\n    ('London', 'C6'): 1.5,\n    ('Exeter', 'C3'): 0.2,\n    ('Exeter', 'C4'): 1.5,\n    ('Exeter', 'C5'): 0.5,\n    ('Exeter', 'C6'): 1.5\n})\n\nmodel = gp.Model('SupplyNetworkDesign')\nflow = model.addVars(arcs, obj=cost, name=\"flow\")\n\n# Production capacity limits\n\nfactories = supply.keys()\nfactory_flow = model.addConstrs((gp.quicksum(flow.select(factory, '*')) <= supply[factory]\n                                 for factory in factories), name=\"factory\")\n\n# Customer demand\n\ncustomers = demand.keys()\ncustomer_flow = model.addConstrs((gp.quicksum(flow.select('*', customer)) == demand[customer]\n                                  for customer in customers), name=\"customer\")\n\n# Depot flow conservation\n\ndepots = through.keys()\ndepot_flow = model.addConstrs((gp.quicksum(flow.select(depot, '*')) == gp.quicksum(flow.select('*', depot))\n                               for depot in depots), name=\"depot\")\n\n# Depot throughput\n\ndepot_capacity = model.addConstrs((gp.quicksum(flow.select('*', depot)) <= through[depot]\n                                   for depot in depots), name=\"depot_capacity\")\n\nmodel.optimize()\n\nproduct_flow = pd.DataFrame(\n    [{\"From\": arc[0], \"To\": arc[1], \"Flow\": flow[arc].x} for arc in arcs if flow[arc].x > 1e-6]\n)\nproduct_flow.index=[''] * len(product_flow)\nproduct_flow"}]}
{"meta": {"source_path": "/Users/sunyujun03/Desktop/ReLoop/gurobi-modeling-examples/battery_scheduling/battery_scheduling.ipynb", "kind": "ipynb", "title": "Optimization Guide to Battery Scheduling with Gurobi"}, "messages": [{"role": "system", "content": "You are an optimization engineer. Write correct and runnable Python code using gurobipy (Gurobi Python API). Be concise. Output only what is requested."}, {"role": "user", "content": "    Task: Reproduce the following Gurobi modeling example in Python using gurobipy.\n\n    Scenario description (from source):\n    #  Optimization Guide to Battery Scheduling with Gurobi\n\nThis notebook provides a beginner-friendly introduction to battery scheduling using mathematical optimization and Gurobi. Basic knowledge about mathematical optimization and Python programming are required as taught in [Optimization 101 for Data Scientists](https://www.gurobi.com/events/optimization-101-for-data-scientists/) as well as the basics in battery energy management. The notebook is structured as follows: \n- First we introduce the battery scheduling problem in 3 different variants with increasing complexity.\n- Second we define example parameters for 3 days of battery operations. \n- Third we build the 3 different model variants in gurobipy.\n- Fourth we run the Gurobi Optimizer on a selected model.\n- Fifth we visualize the optimized battery operations schedule. \n\n## 1. Introduction\n\nThe battery scheduling problem is about deciding when to charge and discharge a behind-the-meter battery to maximize profit (or minimize cost) given predictions of time-dependent electricity prices (tariffs). In this notebook, we also consider photovoltaic (PV) generation, and technical constraints of the battery.\n\n---\n\n### Load & Generation (LG) Model\nWe start very simple to set a baseline for the economic costs: Import electricity from the grid to compensate deficits resulting from a higher load than PV generation. Vice versa, export electricity to the grid if PV generates more power than the load is. There is no battery considered yet.\n\n<div style=\"text-align: center;\">\n    <img src=\"Picture1.svg\" width=\"640\">\n\n</div>\n\nWe are given:\n- A discrete time horizon $ \\mathcal{T} = \\{0, \\ldots, T-1\\} $ with step size $ \\Delta t $ (hours)\n- Load $ L_t $ (kW) and PV $ G_t $ (kW) profiles\n- Import price $ p^{\\mathrm{imp}}_t $ (€/kWh) and export price $ p^{\\mathrm{exp}}_t $ (€/kWh)\n\nWe decide per time step $ t $:\n- Imports $ P^{\\mathrm{imp}}_t \\ge 0 $, exports $ P^{\\mathrm{exp}}_t \\ge 0 $ (kW)\n\nWe maximize profit:\n\n$$\n\\max \\sum_{t \\in \\mathcal{T}}\n\\Delta t \\,\\big( p^{\\mathrm{exp}}_t\\, P^{\\mathrm{exp}}_t - p^{\\mathrm{imp}}_t\\, P^{\\mathrm{imp}}_t \\big)\n$$\n\nsubject to:\n- The overall energy balance:\n\n  $$\n  P^{\\mathrm{imp}}_t \\;-\\; P^{\\mathrm{exp}}_t \\;=\\; L_t \\;-\\; G_t\n  \\qquad \\forall t \\in \\mathcal{T}\n  $$\n\n<i>**Solution:** To get the highest profit possible, we simply import power for deficits (as much as needed) and export for surplusses (as much as possible). No optimization model is needed.</i>\n\n---\n\n### Storage (S) Model\n\nNext, we include the battery. But this time, there is no load & PV system yet. The battery is simply used for price arbitrage given the time-dependent import & export prices in the grid. \n\n<div style=\"text-align: center;\">\n    <img src=\"Picture2.svg\" width=\"640\">\n</div>\n\nWe are given:\n- A discrete time horizon $ \\mathcal{T} = \\{0, \\ldots, T-1\\} $ with step size $ \\Delta t $ (hours)\n- Import price $ p^{\\mathrm{imp}}_t $ (€/kWh) and export price $ p^{\\mathrm{exp}}_t $ (€/kWh)\n- Battery with usable energy capacity $ E_{\\max} $ (kWh), charge/discharge power limits $ P^{\\mathrm{ch}}_{\\max},\\, P^{\\mathrm{dis}}_{\\max} $ (kW), efficiencies $ \\eta_{\\mathrm{ch}},\\, \\eta_{\\mathrm{dis}} $, and initial state of charge (SoC) $ E_0 $ (kWh)\n\nWe decide per time step $ t $:\n- Charge power $ x^{\\mathrm{ch}}_t \\ge 0 $ as imports from the grid, discharge power $ x^{\\mathrm{dis}}_t \\ge 0 $ (kW) as exports to the grid\n- State of charge $ E_t $ (kWh)\n\nWe maximize profit:\n\n$$\n\\max \\sum_{t \\in \\mathcal{T}}\n\\Delta t \\,\\big( p^{\\mathrm{exp}}_t\\, x^{\\mathrm{dis}}_t - p^{\\mathrm{imp}}_t\\, x^{\\mathrm{ch}}_t \\big)\n$$\n\nsubject to:\n\n- The battery state-of-charge balance:\n\n  $$\n  E_t \\;=\\; E_{t-1} \\;+\\; \\eta_{\\mathrm{ch}}\\, x^{\\mathrm{ch}}_t \\,\\Delta t \\;-\\; \\frac{1}{\\eta_{\\mathrm{dis}}}\\, x^{\\mathrm{dis}}_t \\,\\Delta t\n  \\qquad \\forall t \\in \\mathcal{T}\n  $$\n\n- The battery state-of-charge bounds: $ 0 \\le E_t \\le E_{\\max} $\n\n- The battery (dis)charge bounds: $ x^{\\mathrm{ch}}_t \\le P_{\\max} $, $ x^{\\mathrm{dis}}_t \\le P_{\\max} $\n\n<i>**Solution:** To get the highest profit possible, we need an optimization model to decide when and how much to import/export from/to the grid and (dis)charge to the battery.</i>\n\n---\n\n### Load, Generation & Storage (LGS) Model\n\nNext, we connect the battery to the load & PV system and introduce battery degradation costs as an example of non-linear constraints.\n\n<div style=\"text-align: center;\">\n    <img src=\"Picture3.svg\" width=\"640\">\n</div>\n\nWe are given:\n- A discrete time horizon $ \\mathcal{T} = \\{0, \\ldots, T-1\\} $ with step size $ \\Delta t $ (hours)\n- Load $ L_t $ (kW) and PV $ G_t $ (kW) profiles\n- Import price $ p^{\\mathrm{imp}}_t $ (€/kWh) and export price $ p^{\\mathrm{exp}}_t $ (€/kWh)\n- Battery with usable energy capacity $ E_{\\max} $ (kWh), charge/discharge power limits $ P^{\\mathrm{ch}}_{\\max},\\, P^{\\mathrm{dis}}_{\\max} $ (kW), efficiencies $ \\eta_{\\mathrm{ch}},\\, \\eta_{\\mathrm{dis}} $, and initial state of charge (SoC) $ E_0 $ (kWh)\n- Nonlinear degradation cost parameters:\n  - $ \\kappa_{\\mathrm{cyc}} > 0 $ (€/EFC): cost per equivalent full cycle (one full charge–discharge of $E_{\\max}$)\n  - $ \\beta $: mild power-law exponent describing degradation growth with (normalized) throughput\n\n  We normalize per-step throughput by capacity to obtain the C-flow (fraction of an equivalent full cycle within the step).\n\nWe decide per time step $ t $:\n- Charge power $ x^{\\mathrm{ch}}_t \\ge 0 $, discharge power $ x^{\\mathrm{dis}}_t \\ge 0 $ (kW)\n- Imports $ P^{\\mathrm{imp}}_t \\ge 0 $, exports $ P^{\\mathrm{exp}}_t \\ge 0 $ (kW)\n- State of charge $ E_t $ (kWh)\n\nWe maximize profit:\n\n$$\n\\max \\sum_{t \\in \\mathcal{T}}\n\\Big[\n\\Delta t \\,\\big( p^{\\mathrm{exp}}_t\\, P^{\\mathrm{exp}}_t - p^{\\mathrm{imp}}_t\\, P^{\\mathrm{imp}}_t \\big)\n\\Big]\n\\;-\\;\n\\sum_{t \\in \\mathcal{T}} \n\\kappa_{\\mathrm{cyc}} \\,\n\\bigg(\n\\underbrace{ \n\\Delta t \\,\\frac{x^{\\mathrm{ch}}_t + x^{\\mathrm{dis}}_t}{E_{\\max}}\n}_{c_t\\;\\text{(C-flow per step)}}\n\\bigg)^{\\beta}\n$$\n\nsubject to:\n\n- The overall energy balance:\n\n  $$\n  P^{\\mathrm{imp}}_t \\;-\\; P^{\\mathrm{exp}}_t \\;+\\; x^{\\mathrm{dis}}_t \\;-\\; x^{\\mathrm{ch}}_t\n  \\;=\\; L_t \\;-\\; G_t\n  \\qquad \\forall t \\in \\mathcal{T}\n  $$\n\n- The battery state-of-charge balance:\n\n  $$\n  E_t \\;=\\; E_{t-1} \\;+\\; \\eta_{\\mathrm{ch}}\\, x^{\\mathrm{ch}}_t \\,\\Delta t \\;-\\; \\frac{1}{\\eta_{\\mathrm{dis}}}\\, x^{\\mathrm{dis}}_t \\,\\Delta t\n  \\qquad \\forall t \\in \\mathcal{T}\n  $$\n\n- The battery state-of-charge bounds: $ 0 \\le E_t \\le E_{\\max} $\n\n- The battery (dis)charge bounds: $ x^{\\mathrm{ch}}_t \\le P^{\\mathrm{ch}}_{\\max} $, $ x^{\\mathrm{dis}}_t \\le P^{\\mathrm{dis}}_{\\max} $\n\n- Note:\nThis model incorporates non-linear degradation costs in the objective function. The degradation of the maximum battery capacity $E_{\\max}$ could be modeled in the same way leading to a non-linear constrained model.\n\n<i>**Solution:** To get the highest profit possible, we need an optimization model to decide when and how much to import/export from/to the grid and (dis)charge to the battery given load & PV power generation as well as battery wearout.</i>\n\n## 2. Model Parameters\n\nWe define a set of realistic model parameters for a 24 hours cycle (this design can be altered).\n\n## 3. Models \n\nNext, we build the 3 models with increasing complexity. For the first model, we don't need the Gurobi Optimizer yet. For the second and third model, we use the [gurobipy](https://www.gurobi.com/faqs/gurobipy/) package.\n\n- **Load & Generation (LG)**: Use imports/exports to balance deficits/surpluses resulting from load/PV without battery.\n- **Storage (S)**: Use battery for price arbitrage (no load/no PV).  \n- **Load, Generation & Storage (LGS)**: Use battery behind-the-meter (BTM) for price arbitrage, with load/PV, and battery degradation costs.  \n\n## 4. Optimization with Gurobi \n\nPick modelVariant and run the cell:  \n\n**LG** = Load & Generation, **S** = Storage , **LGS** = Load, Generation & Storage\n\n    Requirements:\n    - Use gurobipy (Model, GRB, addVar/addConstr, etc.)\n    - Make the script runnable as a standalone Python file if possible.\n    - Keep the code faithful to the example.\n"}, {"role": "assistant", "content": "# Import all necessary packages\nimport math\nimport pandas as pd\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom gurobipy import GRB\n\n# === INSTANCE CONFIGURATION ===\n\n# Horizon\nT = 24 \ndt_h = 1.0  # hours per step\n\n# Tariff and cost parameters\nbeta = 1.5                # power-law exponent for nonlinear degradation\nkappa_cyc = 1              # €/EFC (cost per equivalent full cycle)\n\n# Battery\nE_max_kwh = 13.5\nP_ch_max_kw = 5.0\nP_dis_max_kw = 5.0\neta_ch = 0.96\neta_dis = 0.96\nSoC0_kwh = 6.0\nSoC_terminal = 6.0\n\n# === INSTANCE GENERATION ===\ndef default_24h_profiles():\n    load_24 = [2.4,2.4,2.3,2.2,2.1,2.0, 1.6,1.6,1.7,1.8,2.0,2.2,\n               2.3,2.4,2.5,2.4,2.2,2.0, 2.1,2.3,2.6,2.8,2.8,2.6]\n    pv_24   = [0.0,0.0,0.0,0.0,0.0,0.0, 0.2,0.5,1.0,2.0,3.2,3.8,\n               4.0,4.2,3.6,2.8,1.8,0.8, 0.2,0.1,0.0,0.0,0.0,0.0]\n    imp_24  = [0.16,0.15,0.14,0.14,0.15,0.17, 0.18,0.17,0.16,0.16,0.15,0.15,\n               0.16,0.18,0.20,0.22,0.24,0.26, 0.30,0.34,0.38,0.40,0.38,0.34]\n    exp_24  = [0.1,0.1,0.1,0.1,0.1,0.1, 0.1,0.1,0.1,0.1,0.1,0.1,\n               0.14,0.16,0.18,0.20,0.22,0.24, 0.29,0.3,0.3,0.4,0.3,0.3]\n    return load_24, pv_24, imp_24, exp_24\n\nload, pv, imp, exp = default_24h_profiles()\n\n# Quick glance at the first day\ndf_preview = pd.DataFrame({\n    \"t\": list(range(24)),\n    \"load_kW\": load[:24],\n    \"pv_kW\": pv[:24],\n    \"import €/kWh\": imp[:24],\n    \"export €/kWh\": exp[:24]\n})\ndf_preview.head(24)\n\n# For the load & generation (LG) model, the profit is simply caluclated by the net energy demand/surplus in each time step multiplied by the import/export price.\n\ndef build_lg(load_kw, pv_kw, import_price, export_price, dt_h):\n    # Setup the time and import/export profiles\n    T = len(load_kw)\n    P_imp0, P_exp0 = [], []\n    # Compute import/export costs for each time step\n    for t in range(T):\n        net = load_kw[t] - pv_kw[t]  # calculate power deficit/surplus \n        P_imp0.append(max(0.0, net)); P_exp0.append(max(0.0, -net))\n    # Compute profit by cumulating import/export costs across all time steps\n    profit = 0.0\n    for t in range(T):\n        imp_cost = import_price[t] * P_imp0[t] * dt_h\n        exp_rev  = export_price[t] * P_exp0[t] * dt_h\n        profit += (exp_rev - imp_cost)\n                    \n    return profit, P_imp0, P_exp0\n\n# For storage (S) model, we need an optimization model. We start by importing the gurobipy package.\nimport gurobipy as gp\nfrom gurobipy import GRB   # GRB holds Gurobi constants such as GRB.MAXIMIZE\n\ndef build_s(T, dt_h, import_price, export_price,\n                        E_max_kwh, Pmax_kw, eta_ch, eta_dis, SoC0_kwh,\n                        SoC_terminal=None):\n    # -----------------------------\n    # 1. Create the optimization model\n    # -----------------------------\n    # gp.Model() creates an empty optimization model in Gurobi.\n    # The string \"s_model\" is just a name to identify the model.\n    m = gp.Model(\"s_model\")\n\n    # -----------------------------\n    # 2. Set basic solver parameters\n    # -----------------------------\n    # Gurobi has many parameters that control how the solver runs.\n    # We access them via 'm.Params.<ParameterName>'.\n    # OutputFlag:\n    #   1  -> print solver log to the console\n    #   0  -> run silently (no log)\n    m.Params.OutputFlag = 1\n    # TimeLimit:\n    #   Maximum solve time in seconds.\n    #   Either the solution is already optimal in less than 10 seconds, or Gurobi hits the time limit, and then returns a usually sub-optimal solution.\n    m.Params.TimeLimit = 10\n\n    # -----------------------------\n    # 3. Create decision variables\n    # -----------------------------\n    # We first define a Python index set for the time steps 0, 1, ..., T-1.\n    rng = range(T)\n\n    # Now we add variables to the model using m.addVars().\n    # addVars(index_set, lb=..., ub=..., name=...) creates a set of variables at once, in our case indexed by time t.\n    #   - lb: lower bounds are the minimum values that these variables can take; here same minimum (0) for all variables in the set\n    #   - ub: upper bound are the maximum values that these variables can take; here same maximum (Pmax_kw or E_max_kwh) for all variables in the set\n    #   - name: base name for variables (Gurobi will generate x_ch[0], x_ch[1], ...)\n\n    # Charging power at each time step (kW), bounded between 0 and Pmax_kw\n    x_ch = m.addVars(rng, lb=0.0, ub=Pmax_kw, name=\"x_ch\")\n\n    # Discharging power at each time step (kW), also between 0 and Pmax_kw\n    x_dis = m.addVars(rng, lb=0.0, ub=Pmax_kw, name=\"x_dis\")\n\n    # State of charge (SoC) at each time step (kWh), between 0 and E_max_kwh\n    SoC = m.addVars(rng, lb=0.0, ub=E_max_kwh, name=\"SoC\")\n\n    # -----------------------------\n    # 4. Create constraints: Battery SoC balance\n    # -----------------------------\n    # Now we add constraints to describe how the SoC evolves over time.\n    #\n    # For each time t:\n    #   inflow  = energy charged into the battery  (kWh)\n    #   outflow = energy discharged from the battery (kWh)  \n\n    for t in rng:\n        inflow  = eta_ch * x_ch[t] * dt_h          # charge * efficiency * hours\n        outflow = (1.0 / eta_dis) * x_dis[t] * dt_h  # discharge / efficiency * hours\n        # The SoC balance is SoC[t] = SoC[t-1] + inflow - outflow.\n        # At t = 0, we use the given initial SoC (SoC0_kwh).\n        if t == 0:\n            # First time step: link SoC[0] to initial SoC\n            m.addConstr(SoC[t] == SoC0_kwh + inflow - outflow, name=f\"soc_balance_{t}\")\n        else:\n            # Subsequent time steps: link SoC[t] to SoC[t-1]\n            m.addConstr(SoC[t] == SoC[t-1] + inflow - outflow, name=f\"soc_balance_{t}\")\n\n    # Optional terminal SoC constraint:\n    # If SoC_terminal is provided (not None), enforce that the battery ends with at least this SoC at the final time step.\n    if SoC_terminal is not None:\n        m.addConstr(SoC[T - 1] >= SoC_terminal, name=\"terminal_soc\")\n\n    # -----------------------------\n    # 5. Create objective function: Profit maximization\n    # -----------------------------\n    # Profit is revenue from discharging minus cost of charging.\n    #\n    # For each time t:\n    #   revenue_t = export_price[t] * x_dis[t] * dt_h\n    #   cost_t    = import_price[t] * x_ch[t] * dt_h\n    #\n    # The total profit is the sum over all t.\n    #\n    # We use gp.quicksum(...) to efficiently build linear sums in Gurobi.\n\n    profit = gp.quicksum(\n        (export_price[t] * x_dis[t] - import_price[t] * x_ch[t]) * dt_h\n        for t in rng\n    )\n\n    # Next, we tell Gurobi what to optimize and in which direction:\n    #   - First argument: the expression to optimize (here: profit)\n    #   - Second argument: GRB.MAXIMIZE or GRB.MINIMIZE\n    m.setObjective(profit, GRB.MAXIMIZE)\n\n    # At this point, the model is fully defined.\n    # We return:\n    #   - the model object 'm'\n    #   - and a dictionary of the main decision variables for easy access later    \n    return m, {\"x_ch\": x_ch, \"x_dis\": x_dis, \"SoC\": SoC}\n\n# For the load, generation & storage model, we need an optimization model that includes not only the battery, but also the grid connection \"behind the meter\" (BTM).\n# We start by importing the gurobipy package.\nimport gurobipy as gp\nfrom gurobipy import GRB   # GRB holds Gurobi constants such as GRB.MAXIMIZE  \n\ndef build_lgs(T, dt_h, load_kw, pv_kw, import_price, export_price,\n                    E_max_kwh, P_ch_max_kw, P_dis_max_kw, eta_ch, eta_dis, SoC0_kwh,\n                    kappa_cyc, beta, SoC_terminal=None):\n    # -----------------------------\n    # 1. Create the optimization model\n    # -----------------------------\n    # gp.Model() creates an empty Gurobi model instance.\n    # The string \"lgs_model\" is just a name used to identify this model.\n    m = gp.Model(\"lgs_model\")\n\n    # -----------------------------\n    # 2. Set basic solver parameters\n    # -----------------------------\n    # Gurobi has many parameters that control how the solver runs.\n    # We access them via 'm.Params.<ParameterName>'.\n    # OutputFlag:\n    #   1  -> print solver log to the console\n    #   0  -> run silently (no log)\n    m.Params.OutputFlag = 1\n    # TimeLimit:\n    #   Maximum solve time in seconds.\n    #   Either the solution is already optimal in less than 10 seconds, or Gurobi hits the time limit, and then returns a usually sub-optimal solution.\n    m.Params.TimeLimit = 10\n\n    # -----------------------------\n    # 3. Create decision variables\n    # -----------------------------\n    # We first define an index set for time steps: 0, 1, ..., T-1.\n    rng = range(T)\n\n    # Next, we add variables to the model using m.addVars().\n    # addVars(index_set, lb=..., ub=..., name=...) creates a set of variables at once, in our case indexed by time t.\n\n    # Charging power of the battery (kW) at each time step, bounded between 0 and P_ch_max_kw.\n    x_ch = m.addVars(rng, lb=0.0, ub=P_ch_max_kw, name=\"x_ch\")\n\n    # Discharging power of the battery (kW) at each time step, bounded between 0 and P_dis_max_kw.\n    x_dis = m.addVars(rng, lb=0.0, ub=P_dis_max_kw, name=\"x_dis\")\n\n    # State of charge (SoC) of the battery (kWh) at each time step, bounded between 0 and E_max_kwh.\n    SoC = m.addVars(rng, lb=0.0, ub=E_max_kwh, name=\"SoC\")\n\n    # Power imported from the grid (kW) at each time step.\n    # Lower bound is 0; we do not set an explicit upper bound here as unlimited imports will not be profit-maximizing with import costs > 0.\n    P_imp = m.addVars(rng, lb=0.0, name=\"P_imp\")\n\n    # Power exported to the grid (kW) at each time step.\n    # Again, nonnegative with no explicit upper bound here as unlimited exports are not possible with battery SoC>=0 and limited PV generation.\n    P_exp = m.addVars(rng, lb=0.0, name=\"P_exp\")\n\n    # -----------------------------\n    # 4. Create constraints: Battery SoC balance\n    # -----------------------------\n    # We now describe how the SoC evolves over time.\n    #\n    # For each time t:\n    #   inflow  = energy charged into the battery (kWh)\n    #   outflow = energy discharged from the battery (kWh)\n    for t in rng:\n        inflow  = eta_ch * x_ch[t] * dt_h           # charging energy: power * efficiency * hours\n        outflow = (1.0 / eta_dis) * x_dis[t] * dt_h # discharging energy: power / efficiency * hours\n     \n        # SoC[t] = SoC[t-1] + inflow - outflow\n        #\n        # For t = 0, we use SoC0_kwh as the initial SoC.\n        if t == 0:\n            # First time step: link SoC[0] to the given initial SoC.\n            m.addConstr(\n                SoC[t] == SoC0_kwh + inflow - outflow,\n                name=f\"soc_balance_{t}\"\n            )\n        else:\n            # Subsequent time steps: link SoC[t] to SoC[t-1].\n            m.addConstr(\n                SoC[t] == SoC[t-1] + inflow - outflow,\n                name=f\"soc_balance_{t}\"\n            )\n\n    # -----------------------------\n    # 5. Create constraints: Energy balance behind the meter\n    # -----------------------------\n    # The power balance at each time step t is:\n    #\n    #   P_imp[t] - P_exp[t] + x_dis[t] - x_ch[t] = load_kw[t] - pv_kw[t]\n    #\n    # Interpretation:\n    #   left-hand side  = net power coming from the grid and battery\n    #   right-hand side = net demand (load minus PV generation)\n    #\n    # If load_kw[t] > pv_kw[t], we need additional power from the grid and/or the battery.\n    # If load_kw[t] < pv_kw[t], there is surplus PV power that can charge the battery and/or be exported.\n\n    for t in rng:\n        rhs = load_kw[t] - pv_kw[t]  \n        m.addConstr(\n            P_imp[t] - P_exp[t] + x_dis[t] - x_ch[t] == rhs,\n            name=f\"meter_balance_{t}\"\n        )\n\n    # -----------------------------\n    # 6. Optional terminal SoC constraint\n    # -----------------------------\n    # If SoC_terminal is provided (not None), we enforce that the battery ends with at least this state of charge at the final time step.\n    if SoC_terminal is not None:\n        m.addConstr(\n            SoC[T - 1] >= SoC_terminal,\n            name=\"terminal_soc\"\n        )\n\n    # -----------------------------\n    # 7. Objective function (part 1): Profit from imports/exports\n    # -----------------------------\n    # We define profit (just like in the storage model) as:\n    #\n    #   profit = sum_t (export_price[t] * P_exp[t] - import_price[t] * P_imp[t]) * dt_h\n    #\n    # i.e., revenue from selling power to the grid minus the cost of buying power over all time steps.\n    #\n    # We use gp.quicksum(...) to efficiently build this linear sum.\n\n    profit = gp.quicksum(\n        (export_price[t] * P_exp[t] - import_price[t] * P_imp[t]) * dt_h\n        for t in rng\n    )\n\n    # -----------------------------\n    # 8. Objective function (part 2): Non-linear degradation cost\n    # -----------------------------\n    # Next, we add the non-linear degradation term to penalize battery usage.\n    #\n    # Define:\n    #   c_flow_pow = sum_t ( dt_h * (x_ch[t] + x_dis[t]) / E_max_kwh )^beta\n    #\n    # This is a non-linear expression in the decision variables x_ch and x_dis.\n    #\n    # To model this in Gurobi:\n    #   1) We create a variable c_flow_pow to represent this non-linear expression.\n    #   2) We use m.addConstr(...) to link c_flow_pow to the non-linear expression.\n\n    # Step 1: Create variable for the non-linear expression\n    c_flow_pow = m.addVar(lb=0.0, name=\"c_flow_pow\")\n\n    # Step 2: Create non-linear expression and set c_flow_pow to be equal to this expression:\n    m.addConstr(c_flow_pow == gp.quicksum((dt_h * (x_ch[t] + x_dis[t]) / E_max_kwh) ** beta for t in rng), name=\"pow\")\n\n    # The degradation cost is then:\n    #   deg_cost = kappa_cyc * c_flow_pow\n    deg_cost = kappa_cyc * c_flow_pow\n\n    # We subtract this cost from the profit:\n    # Note that both profit and deg_cost are Gurobi expressions which simply are combined at this point\n    profit -= deg_cost\n\n    # -----------------------------\n    # 9. Set the model objective\n    # -----------------------------\n    # Finally, we tell Gurobi what to optimize.\n    # Here we want to maximize total profit (including the degradation cost).\n    m.setObjective(profit, GRB.MAXIMIZE)\n\n    # At this point, the model is fully defined.\n    # We return:\n    #   - the model object 'm'\n    #   - and a dictionary of the main decision variables for easy access later   \n    return m, {\"x_ch\": x_ch, \"x_dis\": x_dis, \"SoC\": SoC, \"P_imp\": P_imp, \"P_exp\": P_exp}\n\n# -----------------------------------------------------------\n# MODEL CONFIGURATION AND EXECUTION\n# -----------------------------------------------------------\n\n# Choose model variant:\n#   LG  = Load & Generation Model\n#   S   = Storage Model \n#   LGS = Load, Generation & Storage Model \nmodelVariant = \"LGS\"\n\ntry:\n\n    match modelVariant:\n    # -----------------------------\n    # Load & Generation Model\n    # -----------------------------\n        case \"LG\":\n            base_profit, P_imp0, P_exp0 = build_lg(\n                load_kw=load,\n                pv_kw=pv,\n                import_price=imp,\n                export_price=exp,\n                dt_h=dt_h\n            )\n\n    # -----------------------------\n    # Storage Model \n    # -----------------------------\n        case \"S\":\n            m, v = build_s(\n                T, dt_h, imp, exp,\n                E_max_kwh=E_max_kwh,\n                Pmax_kw=P_ch_max_kw,  # as simplification take the charge rate as both the maximum charge and discharge rate for the storage model\n                eta_ch=eta_ch, eta_dis=eta_dis,\n                SoC0_kwh=SoC0_kwh,\n                SoC_terminal=SoC_terminal\n            )\n\n            # Optional: write model to an MPS file for inspection / sharing / tuning\n            # m.write(\"s_model.mps\")\n\n    # -----------------------------\n    # Load, Generation & Storage Model\n    # -----------------------------\n        case \"LGS\":\n            m, v = build_lgs(\n                T, dt_h, load, pv, imp, exp,\n                E_max_kwh, P_ch_max_kw, P_dis_max_kw,\n                eta_ch, eta_dis, SoC0_kwh,\n                kappa_cyc=kappa_cyc, beta=beta,\n                SoC_terminal=SoC_terminal\n            )\n\n            # Optional: write model to MPS file for inspection / sharing / tuning\n            # m.write(\"lgs_model.mps\")\n\n    # -----------------------------\n    # Solve model (for S and LGS model)\n    # -----------------------------\n    if modelVariant in (\"S\", \"LGS\"):\n        m.optimize()\n        # After m.optimize(), Gurobi stores information about how the optimization process ended in the attribute m.Status.\n        # m.Status is an integer code, but Gurobi also provides named constants. Some common ones are:\n        #   GRB.OPTIMAL    -> an optimal solution was found\n        #   GRB.SUBOPTIMAL -> a feasible solution was found, but optimality is not guaranteed \n        #   GRB.INFEASIBLE -> the model has no feasible solution\n        #   GRB.UNBOUNDED  -> the objective can be improved infinitely without a bound\n        #   GRB.TIME_LIMIT -> time limit reached; best solution (if any) is returned\n        status = m.Status\n        print(\"Gurobi status:\", status)\n        # Print objective value if we obtained a usable solution\n        # The objective value of the optimized model is stored in m.ObjVal.\n        if status in (GRB.OPTIMAL, GRB.SUBOPTIMAL):\n            print(f\"Objective (profit) = {m.ObjVal:.2f} €\")\n\n    # -----------------------------\n    # Post-processing for LG model\n    # -----------------------------\n    elif modelVariant == \"LG\":\n        print(f\"Baseline (no battery) profit = {base_profit:.2f} €\")\n\n# Handle Gurobi-specific exceptions\nexcept gp.GurobiError as e:\n    print(\"Gurobi error:\", e.message)\n\n# As we set the OutputFlag of the model to 1, what follows is the solver log.\n# Please refer to https://docs.gurobi.com/projects/optimizer/en/current/concepts/logging.html for more explanations.\n\n# -----------------------------------------------------------\n# UNIFIED VISUALIZATION TOOLKIT\n# -----------------------------------------------------------\n\n\n# Helper: Annotate a plot with a text box (e.g., profits or messages)\ndef _annotate(ax, lines):\n    ax.text(\n        0.01, 0.98, \"\\n\".join(lines),\n        transform=ax.transAxes,\n        va=\"top\", ha=\"left\",\n        bbox=dict(boxstyle=\"round\", facecolor=\"white\", alpha=0.85),\n        fontsize=10,\n    )\n\n\n# -----------------------------------------------------------\n# MAIN WRAPPER FUNCTION\n# -----------------------------------------------------------\ndef plot_results(modelVariant, m, v,\n                 load, pv, imp, exp,\n                 dt_h, T,\n                 E_max_kwh):\n\n    # =======================================================\n    # 1. Compute baseline\n    # =======================================================\n    base_profit, P_imp0, P_exp0 = build_lg(\n        load_kw=load, pv_kw=pv,\n        import_price=imp, export_price=exp,\n        dt_h=dt_h\n    )\n\n    # =======================================================\n    # LG model\n    # =======================================================\n    if modelVariant == \"LG\":\n        # Put baseline import and export series into a DataFrame for plotting\n        df0 = pd.DataFrame({\n            \"t\": np.arange(T),\n            \"P_imp0_kW\": P_imp0,\n            \"P_exp0_kW\": P_exp0,\n        })\n\n        fig, ax = plt.subplots(figsize=(10, 4))\n        df0.plot(\n            x=\"t\",\n            y=[\"P_imp0_kW\", \"P_exp0_kW\"],\n            ax=ax,\n            drawstyle=\"steps-post\",\n            title=\"Baseline: Grid Imports/Exports (kW)\",\n            color=[\"blue\", \"orange\"]\n        )\n        ax.set_xlabel(\"Time step\")\n        ax.set_ylabel(\"kW\")\n        _annotate(ax, [f\"Baseline profit: {base_profit:.2f} €\"])\n\n        plt.tight_layout()\n        plt.show()\n        return  \n\n    # =======================================================\n    # Optimized Models (S or LGS)\n    # =======================================================\n    # An infeasible model will have no solution values to extract which throws an error. Therefore we check the model status first.\n    if m.Status == GRB.INFEASIBLE:\n        print(\"Model infeasible — no visualization possible.\")\n        return\n\n    # -------------------------------------------------------\n    # 2. Extract solution values from the Gurobi model\n    # -------------------------------------------------------\n    # We now build a small \"results table\" (pandas DataFrame) from the\n    # Gurobi decision variables. This makes plotting and analysis easier.\n    #\n    # We start with a time index t = 0, 1, ..., T-1, and then add columns\n    # for each variable that exists in the current model variant.\n    #\n    # Note that v is a Python dictionary of Gurobi variables (as returned from the model building functions),\n    # e.g. v[\"x_ch\"][t] is the Gurobi variable for x_ch at time t.\n    # To get the numerical value, we use the \".X\" attribute.\n\n    data = {\"t\": np.arange(T)}  # time column\n\n    # We loop over all potential variable names and check if the\n    # corresponding entry exists in v for this model variant.\n    for name in [\"x_ch\", \"x_dis\", \"P_imp\", \"P_exp\", \"SoC\"]:\n        if name in v:\n            # For each time step t, extract the solution value of v and collect them in a Python list.\n            data[name] = [v[name][t].X for t in range(T)]\n\n    # Create a pandas DataFrame from the collected data.\n    # Each column corresponds to a time series (e.g. x_ch, SoC, P_imp, ...).\n    df = pd.DataFrame(data)\n\n    # The objective value of the optimized model is stored in m.ObjVal.\n    # This is the total profit (including degradation cost for the LGS model).\n    opt_profit = m.ObjVal\n\n    # -------------------------------------------------------\n    # 3. Build a multi-panel figure\n    # -------------------------------------------------------\n    n_rows = 3 if modelVariant == \"LGS\" else 2\n    fig, axes = plt.subplots(\n        n_rows, 1,\n        figsize=(12, 12),\n        sharex=True\n    )\n\n    # -------------------------------------------------------\n    # Panel 1 — Flows (charge/discharge/import/export)\n    # -------------------------------------------------------\n    ax = axes[0]\n    flow_cols = [c for c in [\"x_ch\", \"x_dis\", \"P_imp\", \"P_exp\"] if c in df.columns]\n    flow_colors = {\n        \"x_ch\": \"green\",\n        \"x_dis\": \"red\",\n        \"P_imp\": \"blue\",\n        \"P_exp\": \"orange\",\n    }\n\n    if flow_cols:\n        df.plot(\n            x=\"t\",\n            y=flow_cols,\n            ax=ax,\n            drawstyle=\"steps-post\",\n            color=[flow_colors[c] for c in flow_cols],\n            title=f\"Energy Flows (kW) - {modelVariant} Model\"\n        )\n        ax.set_ylabel(\"kW\")\n        _annotate(ax, [f\"Optimized profit: {opt_profit:.2f} €\"])\n\n    # -------------------------------------------------------\n    # Panel 2 — State of Charge\n    # -------------------------------------------------------\n    ax = axes[1]\n    if \"SoC\" in df.columns:\n        df.plot(\n            x=\"t\",\n            y=[\"SoC\"],\n            ax=ax,\n            color=[\"purple\"],\n            drawstyle=\"steps-post\",\n            title=f\"State of Charge (kWh) - {modelVariant} Model\"\n        )\n        ax.set_ylim(0, E_max_kwh)\n        ax.set_ylabel(\"kWh\")\n\n    # -------------------------------------------------------\n    # Panel 3 — Baseline import/export (only for BTM model)\n    # -------------------------------------------------------\n    if modelVariant == \"LGS\":\n        df0 = pd.DataFrame({\n            \"t\": np.arange(T),\n            \"P_imp0\": P_imp0,\n            \"P_exp0\": P_exp0,\n        })\n\n        ax = axes[2]\n        df0.plot(\n            x=\"t\",\n            y=[\"P_imp0\", \"P_exp0\"],\n            ax=ax,\n            drawstyle=\"steps-post\",\n            color=[\"blue\", \"orange\"],\n            title=f\"Energy Flows (kW) - {'LG'} Model\"\n        )\n        ax.set_ylabel(\"kW\")\n        _annotate(ax, [f\"Baseline profit: {base_profit:.2f} €\"])\n\n    # Final layout: set x-label only on the last row and tighten spacing\n    axes[-1].set_xlabel(\"Time step\")\n    plt.tight_layout()\n    plt.show()\n\n\n# -----------------------------------------------------------\n# CALL THE VISUALIZATION TOOL\n# -----------------------------------------------------------\n\nplot_results(\n    modelVariant=modelVariant,\n    m=m if modelVariant in (\"S\", \"LGS\") else None,\n    v=v if modelVariant in (\"S\", \"LGS\") else None,\n    load=load, pv=pv,\n    imp=imp, exp=exp,\n    dt_h=dt_h, T=T,\n    E_max_kwh=E_max_kwh\n)"}]}
{"meta": {"source_path": "/Users/sunyujun03/Desktop/ReLoop/gurobi-modeling-examples/portfolio_selection_optimization/portfolio_selection_optimization.ipynb", "kind": "ipynb", "title": "Portfolio Selection Optimization"}, "messages": [{"role": "system", "content": "You are an optimization engineer. Write correct and runnable Python code using gurobipy (Gurobi Python API). Be concise. Output only what is requested."}, {"role": "user", "content": "    Task: Reproduce the following Gurobi modeling example in Python using gurobipy.\n\n    Scenario description (from source):\n    # Portfolio Selection Optimization\nThis model is an example of the classic [Markowitz portfolio selection optimization model](https://en.wikipedia.org/wiki/Markowitz_model). We want to find the fraction of the portfolio to invest among a set of stocks that balances risk and return. It is a Quadratic Programming (QP) model with vector and matrix data for returns and risk, respectively. This is best suited to a matrix formulation, so we use the Gurobi Python *matrix* interface. The basic model is fairly simple, so we also solve it parametrically to find the efficient frontier.\n\n**Download the Repository** <br /> \nYou can download the repository containing this and other examples by clicking [here](https://github.com/Gurobi/modeling-examples/archive/master.zip). \n\n## Model Formulation\n### Parameters\n\nWe use the [Greek values](https://en.wikipedia.org/wiki/Greeks_\\(finance\\)) that are traditional in finance:\n\n- $\\delta$: n-element vector measuring the change in price for each stock\n- $\\sigma$: n x n matrix measuring the covariance among stocks\n\nThere is one additional parameter when solving the model parametrically:\n\n- r: target return\n\n### Decision Variables\n- $x \\ge 0$: n-element vector where each element represents the fraction of the porfolio to invest in each stock\n\n### Objective Function\nMinimize the total risk, a convex quadratic function:\n\n\\begin{equation}\n\\min x^t \\cdot \\sigma \\cdot x\n\\end{equation}\n\n### Constraints\n\nAllocate the entire portfolio: the total investments should be 1.0 (100%), where $e$ is a unit vector (all 1's):\n\n\\begin{equation}\ne \\cdot x = 1\n\\end{equation}\n\nReturn: When we solve the model parametrically for different return values $r$, we add a constraint on the target return:\n\n\\begin{equation}\n\\delta \\cdot x = r\n\\end{equation}\n\n## Python Implementation\n### Stock data\nUse [yfinance](https://pypi.org/project/yfinance/) library to get the latest 2 years of _actual stock data_ from the 20 most profitable US companies, [according to Wikipedia in April 2021](https://en.wikipedia.org/wiki/List_of_largest_companies_in_the_United_States_by_revenue#List_of_companies_by_profit).\nWe use dummy data. Uncomment and comment the respected lines if you want to try data import with yfinance.\n\n### Compute Greeks\nUsing the downloaded stock data, find the delta (return), sigma (covariance) and standard deviation values for stock prices:\n\n## Minimize risk by solving QP model\n\n    Requirements:\n    - Use gurobipy (Model, GRB, addVar/addConstr, etc.)\n    - Make the script runnable as a standalone Python file if possible.\n    - Keep the code faithful to the example.\n"}, {"role": "assistant", "content": "#%pip install gurobipy yfinance\n\n#import yfinance as yf\nimport pandas as pd\n\nstocks = ['BRK-A', 'AAPL', 'MSFT', 'JPM', 'GOOG', 'BAC', 'INTC', 'WFC',\n          'C', 'VZ', 'META', 'PFE', 'JNJ', 'WMT', 'XOM',\n          'FNMA', 'T', 'UNH', 'CMCSA', 'V' ]\n\n#data = yf.download(stocks, period='2y')\n\n# dummy data for the case import with yfinance is not working\ncsv_path = \"dummy_yfinance_2y.csv\"  # <- your CSV path\ndata = pd.read_csv(csv_path, header=[0,1], index_col=0, parse_dates=True)\n\nimport numpy as np\n\ncloses = np.transpose(np.array(data.Close)) # matrix of daily closing prices\nabsdiff = np.diff(closes)                   # change in closing price each day\nreldiff = np.divide(absdiff, closes[:,:-1]) # relative change in daily closing price\ndelta = np.mean(reldiff, axis=1)            # mean price change\nsigma = np.cov(reldiff)                     # covariance (standard deviations)\nstd = np.std(reldiff, axis=1)               # standard deviation\n\nimport gurobipy as gp\nfrom gurobipy import GRB\nfrom math import sqrt\n\n# Create an empty model\nm = gp.Model('portfolio')\n\n# Add matrix variable for the stocks\nx = m.addMVar(len(stocks))\n\n# Objective is to minimize risk (squared).  This is modeled using the\n# covariance matrix, which measures the historical correlation between stocks\nportfolio_risk = x @ sigma @ x\nm.setObjective(portfolio_risk, GRB.MINIMIZE)\n\n# Fix budget with a constraint\nm.addConstr(x.sum() == 1, 'budget')\n\n# Verify model formulation\nm.write('portfolio_selection_optimization.lp')\n\n# Optimize model to find the minimum risk portfolio\nm.optimize()\n\nimport pandas as pd\nminrisk_volatility = sqrt(m.ObjVal)\nminrisk_return = delta @ x.X\npd.DataFrame(data=np.append(x.X, [minrisk_volatility, minrisk_return]),\n             index=stocks + ['Volatility', 'Expected Return'],\n             columns=['Minimum Risk Portfolio'])\n\n# Create an expression representing the expected return for the portfolio\nportfolio_return = delta @ x\ntarget = m.addConstr(portfolio_return == minrisk_return, 'target')\n\n# Solve for efficient frontier by varying target return\nfrontier = np.empty((2,0))\nfor r in np.linspace(delta.min(), delta.max(), 25):\n    target.rhs = r\n    m.optimize()\n    frontier = np.append(frontier, [[sqrt(m.ObjVal)],[r]], axis=1)\n\nimport matplotlib.pyplot as plt\n#plt.figure(figsize=(10,10))\n\nfig, ax = plt.subplots(figsize=(10,8))\n\n# Plot volatility versus expected return for individual stocks\nax.scatter(x=std, y=delta,\n           color='Blue', label='Individual Stocks')\nfor i, stock in enumerate(stocks):\n    ax.annotate(stock, (std[i], delta[i]))\n\n# Plot volatility versus expected return for minimum risk portfolio\nax.scatter(x=minrisk_volatility, y=minrisk_return, color='DarkGreen')\nax.annotate('Minimum\\nRisk\\nPortfolio', (minrisk_volatility, minrisk_return),\n            horizontalalignment='right')\n\n# Plot efficient frontier\nax.plot(frontier[0], frontier[1], label='Efficient Frontier', color='DarkGreen')\n\n# Format and display the final plot\nax.axis([frontier[0].min()*0.7, frontier[0].max()*1.3, delta.min()*1.2, delta.max()*1.2])\nax.set_xlabel('Volatility (standard deviation)')\nax.set_ylabel('Expected Return')\nax.legend()\nax.grid()\nplt.show()"}]}
{"meta": {"source_path": "/Users/sunyujun03/Desktop/ReLoop/gurobi-modeling-examples/colgen-cutting_stock/colgen-cutting_stock.ipynb", "kind": "ipynb", "title": "Column Generation for the Cutting Stock Problem"}, "messages": [{"role": "system", "content": "You are an optimization engineer. Write correct and runnable Python code using gurobipy (Gurobi Python API). Be concise. Output only what is requested."}, {"role": "user", "content": "    Task: Reproduce the following Gurobi modeling example in Python using gurobipy.\n\n    Scenario description (from source):\n    # Column Generation for the Cutting Stock Problem\n\n## Objectives and Prerequisites\n\nIn this notebook, you will:\n\n1. Learn about the Cutting Stock Problem, a classical problem from the Integer Programming (IP) literature.\n2. Discover how delayed column generation can be implemented in Gurobi to solve this problem more efficiently.\n\nThis modelling example is at the advanced level. To fully understand the content of this notebook, the reader should be familiar with the following:\n\n- Object-Oriented Programming.\n- The Knapsack Problem.\n- Delayed column generation as a decomposition technique.\n\n-----\n\n## Motivation\n\nDespite the great advancements that we've seen in mathematical optimization solver technology, some problems are still challenging to solve due to their large number of variables or constraints. Decomposition techniques — such as delayed column generation or Benders decomposition — apply the principle of \"divide and conquer\" to tackle these challenging problems.\n\nDelayed column generation is typically used with large problems, which have so many variables that it's not possible to consider all of them explicitly. Experience with large problems indicates that, usually, most of these variables never enter the basis. Therefore, only a subset of these variables need to ever be considered when solving the problem. Delayed column generation exploits this fact to only generate variables (i.e. columns) that have the potential to improve the objective function. It's interesting to note that generating a column in the primal formulation amounts to adding a constraint to its dual. Thus, you can think of this technique as a cutting plane method in the dual space.\n\nDelayed column generation has been successfully applied to many problems such as crew scheduling, vehicle routing, the capacitated p-median problem, and the Cutting Stock Problem. We will use the latter to illustrate how this technique can be implemented in the Gurobi-Python interface.\n\n-----\n\n## Problem Description\n\nThe Cutting Stock Problem deals with the problem of cutting stock material with the same, fixed width — such as paper rolls — into smaller pieces, according to a set of orders specifying both the widths and the demand requirements, so as to minimize the amount of wasted material.\n\n![image](./csp_ex.png)\n\n-----\n\n## Solution Approach\n\nMathematical programming is a declarative approach where the modeler formulates a mathematical optimization model that captures the key aspects of a complex decision problem. The Gurobi Optimizer solves such models using state-of-the-art mathematics and computer science.\n\nA mathematical optimization model has five components, namely:\n\n- Sets and indices.\n- Parameters.\n- Decision variables.\n- Objective function(s).\n- Constraints.\n\nFirst, we present a naïve IP that doesn't scale well because its linear relaxation is not tight. Then, we introduce a Full Master Problem that explicitly enumerates all possible cut patterns, which turns out to be amenable to delayed column generation.\n\n### Naïve IP\n\n#### Sets and Indices\n\n$i \\in \\text{Stock}=\\{1,2,\\dots, N\\}$: Set of available stock material units.\n\n$j \\in \\text{Pieces}$: Set of final pieces.\n\n#### Parameters\n\n$N \\in \\mathbb{N}$: Upper bound for the number of stock material units that can be used.\n\n$\\text{Stock_length} \\in \\mathbb{R}^+$: Length of any stock material unit.\n\n$\\text{Piece_length}_j \\in \\mathbb{R}^+$: Length of final piece $j$.\n\n$\\text{Requirement}_j \\in \\mathbb{N}$: Demand requirement of final piece $j$.\n\n#### Decision Variables\n\n$\\text{use}_i \\in \\{0,1\\}$: 1 if stock material unit $i$ is used; 0 otherwise.\n\n$\\text{cut}_{i,j} \\in \\mathbb{N}$: Number of pieces of type $j$ cut out from stock material unit $i$.\n\n#### Objective Function\n\n- **Material Consumption:** Minimize the number of stock material units used.\n\n$$\n\\begin{equation}\n\\text{Min} \\sum_{i \\in \\text{Stock}}{\\text{use}_i}\n\\tag{1.0}\n\\end{equation}\n$$\n\n#### Constraints\n\n- **Satisfy Demand:** Total number of final pieces of type $j$ obtained must satisfy its demand requirement.\n\n$$\n\\begin{equation}\n\\sum_{i \\in \\text{Stock}}{\\text{cut}_{i,j}} \\geq \\text{Requirement}_j \\quad \\forall j \\in \\text{Pieces}\n\\tag{1.1}\n\\end{equation}\n$$\n\n- **Capacity:** Total length of the pieces cut out from stock material unit $i$ cannot exceed its length.\n\n$$\n\\begin{equation}\n\\sum_{j \\in \\text{Pieces}}{\\text{Piece_length}_j \\cdot \\text{cut}_{i,j}} \\leq \\text{Stock_length} \\cdot \\text{use}_i \\quad \\forall i \\in \\text{Stock}\n\\tag{1.2}\n\\end{equation}\n$$\n\n- **Symmetry breaking:** Stock material unit $i+1$ cannot be used if the previous unit $i$ wasn't. Note that this constraint set is not needed for correctness, but certainly helps to reduce the search space.\n\n$$\n\\begin{equation}\n\\text{use}_{i+1} \\leq \\text{use}_i \\quad \\forall i \\in \\text{Stock} \\setminus \\{N\\}\n\\tag{1.3}\n\\end{equation}\n$$\n\n### Full Master Problem\n\nNow, instead of focusing on which stock material unit a particular piece is to be cut from, we consider all possible patterns (potentially generating multiple pieces of different widths) that can be used to cut from a stock material unit. The task is now to find how many times a particular pattern should be used.\n\n#### Sets and Indices\n\n$p \\in \\text{Patterns}$: Set of all possible cutting patterns, whose size grows exponentially with the number of final pieces. Note that each of these patterns implicitly considers the lengths of the final pieces and the stock material units, which in fact can be viewed as a knapsack constraint.\n\n$j \\in \\text{Pieces}$: Set of final pieces.\n\n#### Parameters\n\n$\\text{Requirement}_j \\in \\mathbb{N}$: Demand requirement of final piece $j$.\n\n$\\text{Frequency}_{p,j} \\in \\mathbb{N}$: Number of pieces of type $j$ cut out from pattern $p$.\n\n#### Decision Variables\n\n$\\text{count}_p \\in \\mathbb{N}$: Number of times pattern $p$ is used.\n\n#### Objective Function\n\n- **Material Consumption:** Minimize the number of stock material units used.\n\n$$\n\\begin{equation}\n\\text{Min} \\sum_{p \\in \\text{Patterns}}{\\text{count}_p}\n\\tag{2.0}\n\\end{equation}\n$$\n\n#### Constraints\n\n- **Satisfy Demand:** Total number of final pieces of type $j$ obtained must satisfy its demand requirement.\n\n$$\n\\begin{equation}\n\\sum_{p \\in \\text{Patterns}}{\\text{Frequency}_{p,j} \\cdot \\text{count}_p} \\geq \\text{Requirement}_j \\quad \\forall j \\in \\text{Pieces}\n\\tag{2.1}\n\\end{equation}\n$$\n\nRecall that the number of patterns grows exponentially with the number of final pieces, so in practice the Full Master Problem cannot be solved in one shot. Instead, we consider a Restricted Master Problem (RMP), initialized with a few trivial patterns. Then we follow an iterative approach, alternating between solving a knapsack problem (i.e. the subproblem) to generate a new pattern (i.e. the entering column) and solving a larger RMP to update the objective function — representing the reduced cost of the next pattern to be selected — of the subproblem. This cycle is repeated until the reduced cost of the entering column is non-negative.\n\n-----\n\n## Python Implementation\n\nIn the following implementation of column generation, we use two main libraries:\n\n- Numpy for scientific computing.\n- Gurobi for mathematical optimization.\n\n### Test Instance\n\nWe now test our implementation using a toy example with 13 final pieces to be cut out from stock material units of 5,600 cm. The set of orders specifying the lengths and the demand requirements of final pieces is presented below:\n\n| ID | Final Piece Length (cm) | Demand (units)|\n|----|----|----|\n| 0 | 1380 | 22 |\n| 1 |  1520 | 25 |\n| 2 | 1560 | 12 |\n| 3 | 1710 | 14 |\n| 4 | 1820 | 18 |\n| 5 | 1880 | 18 |\n| 6 | 1930 | 20 |\n| 7 | 2000 | 10 |\n| 8 | 2050 | 12 |\n| 9 | 2100 | 14 |\n| 10 | 2140 | 16 |\n| 11 | 2150 | 18 |\n| 12 | 2200 | 20 |\n\nThe patterns generated are the following:\n\nThe patterns that are actually used and their respective frequency are reported below:\n\n| Pattern ID | Frequency | Description |\n|----|----|----|\n| 4 | 1 | 3 units of final piece 4 |\n| 17 | 7 | 1 unit and 2 units of final pieces 0 and 9 |\n| 19 | 2 | 1 unit of final pieces 2, 5, and 10 |\n| 20 | 4 | 2 unit and 1 units of final pieces 3 and 10 |\n| 22 | 1 | 2 unit and 1 units of final pieces 3 and 11 | \n| 26 | 5 | 1 unit of final pieces 1, 5, and 10 |\n| 28 | 17 | 1 unit of final pieces 1, 6, and 11 |\n| 29 | 4 | 1 unit and 2 units of final pieces 4 and 5 |\n| 31 | 10 | 1 unit of final pieces 0, 7, and 12 |\n| 32 | 3 | 1 unit of final pieces 2, 6, and 8 |\n| 34 | 4 | 1 unit of final pieces 3, 4, and 8 |\n| 35 | 5 | 1 unit of final pieces 0, 8, and 10 |\n| 36 | 3 | 1 unit of final pieces 1, 5, and 12 |\n| 38 | 7 | 1 unit of final pieces 2, 4, and 12 |\n\n    Requirements:\n    - Use gurobipy (Model, GRB, addVar/addConstr, etc.)\n    - Make the script runnable as a standalone Python file if possible.\n    - Keep the code faithful to the example.\n"}, {"role": "assistant", "content": "import numpy as np\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n\nclass MasterProblem:\n    def __init__(self):\n        self.model = gp.Model(\"master\")\n        self.vars = None\n        self.constrs = None\n        \n    def setup(self, patterns, demand):\n        num_patterns = len(patterns)\n        self.vars = self.model.addVars(num_patterns, obj=1, name=\"Pattern\")\n        self.constrs = self.model.addConstrs((gp.quicksum(patterns[pattern][piece]*self.vars[pattern]\n                                                          for pattern in range(num_patterns))\n                                              >= demand[piece] for piece in demand.keys()),\n                                             name=\"Demand\")\n        self.model.modelSense = GRB.MINIMIZE\n        # Turning off output because of the iterative procedure\n        self.model.params.outputFlag = 0\n        self.model.update()\n        \n    def update(self, pattern, index):\n        new_col = gp.Column(coeffs=pattern, constrs=self.constrs.values())\n        self.vars[index] = self.model.addVar(obj=1, column=new_col,\n                                             name=f\"Pattern[{index}]\")\n        self.model.update()\n\n\nclass SubProblem:\n    def __init__(self):\n        self.model = gp.Model(\"subproblem\")\n        self.vars = {}\n        self.constr = None\n        \n    def setup(self, stock_length, lengths, duals):\n        self.vars = self.model.addVars(len(lengths), obj=duals, vtype=GRB.INTEGER,\n                                       name=\"Frequency\")\n        self.constr = self.model.addConstr(self.vars.prod(lengths) <= stock_length,\n                                           name=\"Knapsack\")\n        self.model.modelSense = GRB.MAXIMIZE\n        # Turning off output because of the iterative procedure\n        self.model.params.outputFlag = 0\n        # Stop the subproblem routine as soon as the objective's best bound becomes\n        #less than or equal to one, as this implies a non-negative reduced cost for\n        #the entering column.\n        self.model.params.bestBdStop = 1\n        self.model.update()\n        \n    def update(self, duals):\n        self.model.setAttr(\"obj\", self.vars, duals)\n        self.model.update()\n\n\nclass CuttingStock:\n    def __init__(self, stock_length, pieces):\n        self.stock_length = stock_length\n        self.pieces, self.lengths, self.demand = gp.multidict(pieces)\n        self.patterns = None\n        self.duals = [0]*len(self.pieces)\n        piece_reqs = [length*req for length, req in pieces.values()]\n        self.min_rolls = np.ceil(np.sum(piece_reqs)/stock_length)\n        self.solution = {}\n        self.master = MasterProblem()\n        self.subproblem = SubProblem()\n        \n    def _initialize_patterns(self):\n        # Find trivial patterns that consider one final piece at a time,\n        #fitting as many pieces as possible into the stock material unit\n        patterns = []\n        for idx, length in self.lengths.items():\n            pattern = [0]*len(self.pieces)\n            pattern[idx] = self.stock_length // length\n            patterns.append(pattern)\n        self.patterns = patterns\n        \n    def _generate_patterns(self):\n        self._initialize_patterns()\n        self.master.setup(self.patterns, self.demand)\n        self.subproblem.setup(self.stock_length, self.lengths, self.duals)\n        while True:\n            self.master.model.optimize()\n            self.duals = self.master.model.getAttr(\"pi\", self.master.constrs)\n            self.subproblem.update(self.duals)\n            self.subproblem.model.optimize()\n            reduced_cost = 1 - self.subproblem.model.objVal\n            if reduced_cost >= 0:\n                break\n            \n            pattern = [0]*len(self.pieces)\n            for piece, var in self.subproblem.vars.items():\n                if var.x > 0.5:\n                    pattern[piece] = round(var.x)\n            self.master.update(pattern, len(self.patterns))\n            self.patterns.append(pattern)\n    def solve(self):\n        \"\"\"\n        Gurobi does not support branch-and-price, as this requires to add columns\n        at local nodes of the search tree. A heuristic is used instead, where the\n        integrality constraints for the variables of the final root LP relaxation\n        are installed and the resulting MIP is solved. Note that the optimal\n        solution could be overlooked, as additional columns are not generated at\n        the local nodes of the search tree.\n        \"\"\"\n        self._generate_patterns()\n        self.master.model.setAttr(\"vType\", self.master.vars, GRB.INTEGER)\n        self.master.model.optimize()\n        for pattern, var in self.master.vars.items():\n            if var.x > 0.5:\n                self.solution[pattern] = round(var.x)\n\n# Dictionary that maps each final piece ID with their width and demand requirement\norders = {0:[1380,22],\n          1:[1520,25],\n          2:[1560,12],\n          3:[1710,14],\n          4:[1820,18],\n          5:[1880,18],\n          6:[1930,20],\n          7:[2000,10],\n          8:[2050,12],\n          9:[2100,14],\n          10:[2140,16],\n          11:[2150,18],\n          12:[2200,20]}\n\nmycsp = CuttingStock(5600, orders)\nmycsp.solve()\n\nmycsp.patterns\n\nprint(mycsp.solution)\n\nprint(mycsp.min_rolls)\n\nsum(mycsp.solution.values())"}]}
{"meta": {"source_path": "/Users/sunyujun03/Desktop/ReLoop/gurobi-modeling-examples/3d_tic_tac_toe/3d_tic_tac_toe.ipynb", "kind": "ipynb", "title": "3D Tic-Tac-Toe"}, "messages": [{"role": "system", "content": "You are an optimization engineer. Write correct and runnable Python code using gurobipy (Gurobi Python API). Be concise. Output only what is requested."}, {"role": "user", "content": "    Task: Reproduce the following Gurobi modeling example in Python using gurobipy.\n\n    Scenario description (from source):\n    # 3D Tic-Tac-Toe\n\n## Objective and Prerequisites\n\nTry this logic programming example to learn how to solve the problem of arranging X’s and O’s on a three-dimensional Tic-Tac-Toe board so as to minimize the number of completed lines or diagonals. This example will show you how a binary programming model can be used to capture simple logical constraints.\n\nThis is example 17 from the fifth edition of Model Building in Mathematical Programming by H. Paul Williams on pages 272 and 327 – 328.\n\nThis modeling example is at the beginning level. We assume that you have some familiarity with Python and the Gurobi Python API, but you can hopefully pick up any missing concepts from the example.\n\n**Download the Repository** <br /> \nYou can download the repository containing this and other examples by clicking [here](https://github.com/Gurobi/modeling-examples/archive/master.zip). \n\n---\n## Problem Description\n\nGiven a 3-D tic-tac-toe board, where players take turns placing $X$'s and $O$'s, the game typically ends when one player completes a line or diagonal; that is, when they manage to place their symbols in three cells that form a line or diagonal in the grid.  The twist that is tackled here is that the game continues until every cell contains a symbol, and the goal is to arrange the symbols to minimize the number of completed lines or diagonals.\n\n---\n## Model Formulation\n\n### Decision Variables\n\n$\\text{isX}_{ijk} \\in [0,1]$: Does cell $(i,j,k)$ contain an $X$ ($isX=1$) or an $O$ ($isX=0$)?\n\n$\\text{isLine}_{l} \\in [0,1]$: Does line/diagonal $l$ contain 3 of the same symbol?\n\n### Objective Function\n\n- **Lines**: Minimize the number of completed lines or diagonals\n\n\\begin{equation}\n\\text{Minimize} \\quad Z = \\sum_{l \\in \\text{Lines}}\\text{isLine}_l\n\\end{equation}\n\n### Constraints\n\n- **Take turns**: The board must contain 14 $X$'s and 13 $O$'s ($X$ goes first).\n\n\\begin{equation}\n\\sum_{ijk} \\text{isX}_{ijk} = 14\n\\end{equation}\n\n- **Lines**: For a line to not be complete, one cell must have a different value.  The simple observation here is that the sum of the corresponding 3 binary variables would be 3 if they are all $X$ and 0 if they were all $O$.   We need to forbid those outcomes whenever $isLine_l == 0$.  Note that $l_0$ is the first cell in line $l$, $l_1$ is the second, and $l_2$ is the third.\n\n\\begin{equation}\n\\text{isLine}_l == 0 \\implies isX[l_0] + isX[l_1] + isX[l_2] >= 1 \\quad \\forall l \\in \\text{Lines}\n\\end{equation}\n\n\\begin{equation}\n\\text{isLine}_l == 0 \\implies isX[l_0] + isX[l_1] + isX[l_2] <= 2 \\quad \\forall l \\in \\text{Lines}\n\\end{equation}\n\n---\n## Python Implementation\n\nWe import the Gurobi Python Module.\n\n## Model Deployment\n\nWe first create a list of all possible lines and diagonals in a 3-D tic-tac-toe board.  Each is represented as a Python tuple with 3 entries, where each entry gives the (i,j,k) position of the corresponding cell.  There are 49 in total.\n\nNext we create our model and our decision variables.\n\nNow we create the constraints.  The first states the board will contain 14 X's (and 13 O's):\n\n    Requirements:\n    - Use gurobipy (Model, GRB, addVar/addConstr, etc.)\n    - Make the script runnable as a standalone Python file if possible.\n    - Keep the code faithful to the example.\n"}, {"role": "assistant", "content": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# tested with Python 3.11 & Gurobi 11.0\n\nlines = []\nsize = 3\n\nfor i in range(size):\n    for j in range(size):\n        for k in range(size):\n            if i == 0:\n                lines.append(((0,j,k), (1,j,k), (2,j,k)))\n            if j == 0:\n                lines.append(((i,0,k), (i,1,k), (i,2,k)))\n            if k == 0:\n                lines.append(((i,j,0), (i,j,1), (i,j,2)))\n            if i == 0 and j == 0:\n                lines.append(((0,0,k), (1,1,k), (2,2,k)))\n            if i == 0 and j == 2:\n                lines.append(((0,2,k), (1,1,k), (2,0,k)))\n            if i == 0 and k == 0:\n                lines.append(((0,j,0), (1,j,1), (2,j,2)))\n            if i == 0 and k == 2:\n                lines.append(((0,j,2), (1,j,1), (2,j,0)))\n            if j == 0 and k == 0:\n                lines.append(((i,0,0), (i,1,1), (i,2,2)))\n            if j == 0 and k == 2:\n                lines.append(((i,0,2), (i,1,1), (i,2,0)))\nlines.append(((0,0,0), (1,1,1), (2,2,2)))\nlines.append(((2,0,0), (1,1,1), (0,2,2)))\nlines.append(((0,2,0), (1,1,1), (2,0,2)))\nlines.append(((0,0,2), (1,1,1), (2,2,0)))\n\nmodel = gp.Model('Tic_Tac_Toe')\nisX = model.addVars(size, size, size, vtype=GRB.BINARY, name=\"isX\")\nisLine = model.addVars(lines, vtype=GRB.BINARY, name=\"isLine\")\n\nx14 = model.addConstr(isX.sum() == 14)\n\nfor line in lines:\n    model.addGenConstrIndicator(isLine[line], False, isX[line[0]] + isX[line[1]] + isX[line[2]] >= 1)\n    model.addGenConstrIndicator(isLine[line], False, isX[line[0]] + isX[line[1]] + isX[line[2]] <= 2)\n\nmodel.setObjective(isLine.sum())\n\nmodel.optimize()\n\nimport matplotlib.pyplot as plt\n\nfig, ax = plt.subplots(1, 3, figsize=(10,5))\nfor i in range(3):\n    ax[i].grid()\n    ax[i].set_xticks(range(4))\n    ax[i].set_yticks(range(4))\n    ax[i].tick_params(labelleft=False, labelbottom=False)\n    \nfor cell in isX.keys():\n    if isX[cell].x > 0.5:\n        ax[cell[0]].add_patch(plt.Rectangle((cell[1],cell[2]), 1, 1))\n\nplt.show()"}]}
{"meta": {"source_path": "/Users/sunyujun03/Desktop/ReLoop/gurobi-modeling-examples/price_optimization/price_optimization_gurobiML_wls.ipynb", "kind": "ipynb", "title": "Do you have a Gurobi WLS?"}, "messages": [{"role": "system", "content": "You are an optimization engineer. Write correct and runnable Python code using gurobipy (Gurobi Python API). Be concise. Output only what is requested."}, {"role": "user", "content": "    Task: Reproduce the following Gurobi modeling example in Python using gurobipy.\n\n    Scenario description (from source):\n    # Do you have a Gurobi WLS?\nUse the cell below to add your license information and carry on. \n\nIf you don't, no problem. You can work though a lighter version of this notebook using a [free limited license here](https://colab.research.google.com/github/Gurobi/modeling-examples/blob/master/price_optimization/price_optimization_gurobiML.ipynb).\n\n# Part Two: Avocado Pricing and Supply Using Mathematical Optimization\n\nThis is a second part of an example on price optimization: [How Much Is Too Much? Avocado Pricing and Supply Using Mathematical Optimization](https://github.com/Gurobi/modeling-examples/tree/master/price_optimization)\n\nIn the first part, an ordinary linear regression model (OLS) was used to establish the relationship between price and demand based on data from the [Hass Avocado Board](https://hassavocadoboard.com/) (HAB).\n\nPart Two replaces the OLS model with a trained `Scikit-learn` model and uses the [Gurobi Machine Learning](https://gurobi-machinelearning.readthedocs.io/en/stable/#) package to embed it in a Gurobi optimization model.\n\nIn this example, we will also use `gurobipy-pandas`, which is another Gurobi open-source package and serves as a convenient (and optional) wrapper to connect pandas with gurobipy.\n\nIf you are already familiar with the example from the other notebook, you can jump directly to [building the regression model](#Part-2:-Predict-the-Sales)\nand then to [formulating the optimization problem](#Part-3:-Optimize-for-Price-and-Supply-of-Avocados).\n\n**Goal**: Develop a data science and decision-making pipeline for pricing and distribution of avocados to maximize revenue.\n\nTo accomplish this, the notebook will walk trough three stages:\n\n1. A quick review of the HAB data\n2. Build a prediction model for avocado demand as a function of price, region, year and seasonality.\n3. Design an optimization model that sets the optimal price and supply quantity to maximize the net revenue while incorporating transportation and costs.\n\n## Load the Packages and Prepare the Dataset\n\nJust as in the first example, we use real HAB sales data.\n\nThe dataset from HAB contains sales data for the years 2019-2022. This data is augmented by a previous download from HAB available on\n[Kaggle](https://www.kaggle.com/datasets/timmate/avocado-prices-2020) with sales for the years 2015-2018.\n\nThis notebook will skip a lot of the preprocessing from the first version of this example.\n\n    Requirements:\n    - Use gurobipy (Model, GRB, addVar/addConstr, etc.)\n    - Make the script runnable as a standalone Python file if possible.\n    - Keep the code faithful to the example.\n"}, {"role": "assistant", "content": "params = {\n\"WLSACCESSID\": ---- ,\n\"WLSSECRET\":  ---- ,\n\"LICENSEID\": ---- ,\n}\n\nimport pandas as pd\nimport warnings\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\ndata_url = \"https://raw.githubusercontent.com/Gurobi/modeling-examples/master/price_optimization/\"\navocado = pd.read_csv(data_url+\"HAB_data_2015to2022.csv\")\navocado[\"date\"] = pd.to_datetime(avocado[\"date\"])\navocado = avocado.sort_values(by=\"date\")\navocado\n\nregions = [\n    \"Great_Lakes\",\n    \"Midsouth\",\n    \"Northeast\",\n    \"Northern_New_England\",\n    \"SouthCentral\",\n    \"Southeast\",\n    \"West\",\n    \"Plains\"\n]\ndf = avocado[(avocado.region.isin(regions))] # & (avocado.peak==0)\ndf.drop(columns=['date']) #,'peak'\n\nplt.figure(figsize=(10, 6))\nr_plt = sns.scatterplot(data=df, x='price', y='units_sold', hue='region')\nr_plt.legend(fontsize=8)\nplt.show()\n\nfrom sklearn.model_selection import train_test_split\n\nX = df[[\"region\", \"price\", \"year\", \"peak\"]]\ny = df[\"units_sold\"]\n# Split the data for training and testing\nX_train, X_test, y_train, y_test = train_test_split(\n    X, y, train_size=0.7, random_state=1\n)\n\nfrom sklearn.preprocessing import OneHotEncoder\nfrom sklearn.preprocessing import StandardScaler\nfrom sklearn.compose import make_column_transformer\n\nfeat_transform = make_column_transformer(\n    (OneHotEncoder(drop=\"first\"), [\"region\"]),\n    (StandardScaler(), [\"price\", \"year\"]),\n    (\"passthrough\", [\"peak\"]),\n    verbose_feature_names_out=False,\n    remainder='drop'\n)\n\nfrom sklearn.linear_model import LinearRegression\nfrom sklearn.model_selection import cross_val_score\nfrom sklearn.pipeline import make_pipeline\nfrom sklearn.metrics import r2_score\n\nreg = make_pipeline(feat_transform, LinearRegression())\nscores = cross_val_score(reg, X_train, y_train, cv=5)\nprint(\"%0.4f R^2 with a standard deviation of %0.4f\" % (scores.mean(), scores.std()))\n\n# Find model score on test data\nreg.fit(X_train, y_train)\ny_pred = reg.predict(X_test)\nprint(f\"The R^2 value in the test set is {np.round(r2_score(y_test, y_pred),5)}\")\n\nreg.fit(X, y)\ny_pred_full = reg.predict(X)\nprint(f\"The R^2 value in the full dataset is {np.round(r2_score(y, y_pred_full),5)}\")\n\nyear = 2019\npeak_or_not = 1\nfig, axs = plt.subplots(4, 2, figsize=(10, 7))\n\nfor k in range(8):\n  r = regions[k]\n  i = k//2\n  j = k%2\n  X_r = df.loc[(df.region==r) & (df.peak==peak_or_not),[\"price\", \"year\",\"units_sold\"]]\n  x_plt = X_r.price\n  p_new = np.linspace(.9*min(x_plt),1.1*max(x_plt),50)\n  x_new = pd.DataFrame(\n      data={\n          \"year\": year,\n          \"peak\": peak_or_not,\n          \"region\": r,\n          \"price\": p_new\n      },\n      index=range(50)\n  )\n  x_new['units_sold'] = reg.predict(x_new)\n  sns.lineplot(data=x_new, x='price', y='units_sold', c='orange', ax=axs[i,j])\n  sns.scatterplot(data=X_r, x='price', y='units_sold', legend=0, ax=axs[i,j])\n  axs[i, j].legend(title=r, loc='upper right', prop={'size': 3}, handles = []);\n\n# Sets and parameters\nyear = 2022\nB = 30  # total amount of avocado supply\npeak_or_not = 0  # 1 if it is the peak season; 0 if isn't\nc_waste = 0.1  # the cost ($) of wasting an avocado\n# the cost of transporting an avocado\nc_transport = pd.Series(\n    {\n        \"Great_Lakes\": 0.3,\n        \"Midsouth\": 0.1,\n        \"Northeast\": 0.4,\n        \"Northern_New_England\": 0.5,\n        \"SouthCentral\": 0.3,\n        \"Southeast\": 0.2,\n        \"West\": 0.2,\n        \"Plains\": 0.2,\n    }, name='transport_cost'\n)\nc_transport = c_transport.loc[regions]\n\na_min = 0  # minimum avocado price\na_max = 2  # maximum avocado price\n\n# Get the lower and upper bounds from the dataset for the price and the number of products to be stocked\ndata = pd.concat([c_transport,\n                  df.groupby(\"region\")[\"units_sold\"].min().rename('min_delivery'),\n                  df.groupby(\"region\")[\"units_sold\"].max().rename('max_delivery'),\n                  df.groupby(\"region\")[\"price\"].max().rename('max_price'),], axis=1)\n\ndata\n\nimport gurobipy_pandas as gppd\nfrom gurobi_ml import add_predictor_constr\n\nfeats = pd.DataFrame(\n    data={\n        \"year\": year,\n        \"peak\": peak_or_not,\n        \"region\": regions,\n    },\n    index=regions\n)\nfeats\n\nimport gurobipy as gp\n\nenv = gp.Env(params=params)\n\n#Create the model within the Gurobi environment\nm = gp.Model(\"Avocado_Price_Allocation\", env=env)\n\np = gppd.add_vars(m, data, name=\"price\", lb=a_min, ub=a_max) # price of an avocado for each region 'max_price'\nx = gppd.add_vars(m, data, name=\"x\", lb='min_delivery', ub='max_delivery') # number of avocados supplied to each reagion\ns = gppd.add_vars(m, data, name=\"s\") # predicted amount of sales in each region for the given price\nu = gppd.add_vars(m, data, name=\"w\") # unsold inventory, excess wasteage in each region\nd = gppd.add_vars(m, data, lb=-gp.GRB.INFINITY, name=\"demand\") # Add variables for the regression\nm.update()\n\n# Display one of the variables\np\n\nm.addConstr(x.sum() == B)\nm.update()\n\ngppd.add_constrs(m, s, gp.GRB.LESS_EQUAL, x)\ngppd.add_constrs(m, s, gp.GRB.LESS_EQUAL, d)\nm.update()\n\ngppd.add_constrs(m, u, gp.GRB.EQUAL, x - s)\nm.update()\n\nm_feats = pd.concat([feats, p], axis=1)[[\"region\", \"price\", \"year\",\"peak\"]]\nm_feats\n\npred_constr = add_predictor_constr(m, reg, m_feats, d)\npred_constr.print_stats()\nprint(m)\n\nm.setObjective((p * s).sum() - c_waste * u.sum() - (c_transport * x).sum(),\n               gp.GRB.MAXIMIZE)\n\nm.Params.NonConvex = 2\nm.optimize()\n\nsolution = pd.DataFrame(index=regions)\n\nsolution[\"Price\"] = p.gppd.X\nsolution[\"Historical_Max\"] = data.max_price\nsolution[\"Allocated\"] = x.gppd.X\nsolution[\"Sold\"] = s.gppd.X\nsolution[\"Wasted\"] = u.gppd.X\nsolution[\"Pred_demand\"] = d.gppd.X\n\nopt_revenue = m.ObjVal\nprint(\"\\n The optimal net revenue: $%f million\" % opt_revenue)\nsolution.round(3)\n\nprint(\n    \"Maximum error in approximating the regression {:.6}\".format(\n        np.max(pred_constr.get_error())\n    )\n)\n\nfrom sklearn.ensemble import GradientBoostingRegressor\n\nreg = make_pipeline(feat_transform, GradientBoostingRegressor(n_estimators=100, max_leaf_nodes = 20,\n                                              loss = 'absolute_error', random_state = 123))\nscores = cross_val_score(reg, X_train, y_train, cv=5)\nprint(\"%0.4f R^2 with a standard deviation of %0.4f\" % (scores.mean(), scores.std()))\n# Fit to entire training data\nreg.fit(X_train, y_train)\ny_pred = reg.predict(X_test)\nprint(f\"The R^2 value in the test set is {np.round(r2_score(y_test, y_pred),5)}\")\nreg.fit(X, y)\ny_pred_full = reg.predict(X)\nprint(f\"The R^2 value in the full dataset is {np.round(r2_score(y, y_pred_full),5)}\")\n\npred_constr.remove()\npred_constr = add_predictor_constr(m, reg, m_feats, d)\npred_constr.print_stats()\nm.update()\n\nm.optimize()\n\nsolution = pd.DataFrame(index=regions)\n\nsolution[\"Price\"] = p.gppd.X\nsolution[\"Max_Price\"] = data.max_price\nsolution[\"Allocated\"] = x.gppd.X\nsolution[\"Sold\"] = s.gppd.X\nsolution[\"Wasted\"] = u.gppd.X\nsolution[\"Pred_demand\"] = d.gppd.X\n\nopt_revenue = m.ObjVal\nprint(\"\\n The optimal net revenue: $%f million\" % opt_revenue)\nsolution.round(3)\n\nsolution = pd.DataFrame(index=regions)\n\nsolution[\"Price\"] = p.gppd.X\nsolution[\"Max_Price\"] = data.max_price\nsolution[\"Allocated\"] = x.gppd.X\nsolution[\"Sold\"] = s.gppd.X\nsolution[\"Wasted\"] = u.gppd.X\nsolution[\"Pred_demand\"] = d.gppd.X\n\nopt_revenue = m.ObjVal\nprint(\"\\n The optimal net revenue: $%f million\" % opt_revenue)\nsolution.round(3)\n\nyear = 2019\nfig, axs = plt.subplots(4, 2, figsize=(12, 7))\n\nfor k in range(8):\n  r = regions[k]\n  i = k//2\n  j = k%2\n  X_r = df.loc[(df.region==r) & (df.peak==peak_or_not),[\"price\", \"year\",\"units_sold\"]]\n  x_plt = X_r.price\n  p_new = np.linspace(.9*min(x_plt),1.1*max(x_plt),50)\n  x_new = pd.DataFrame(\n      data={\n          \"year\": year,\n          \"peak\": peak_or_not,\n          \"region\": r,\n          \"price\": p_new\n      },\n      index=range(50)\n  )\n  x_new['units_sold'] = reg.predict(x_new)\n  sns.lineplot(data=x_new, x='price', y='units_sold', c='orange', ax=axs[i,j])\n  sns.scatterplot(data=X_r, x='price', y='units_sold',legend=0, ax=axs[i,j])\n  axs[i, j].legend(title=r, loc='upper right', prop={'size': 3}, handles = []);"}]}
{"meta": {"source_path": "/Users/sunyujun03/Desktop/ReLoop/gurobi-modeling-examples/price_optimization/price_optimization.ipynb", "kind": "ipynb", "title": "How Much Is Too Much? Avocado Pricing and Supply Using Mathematical Optimization"}, "messages": [{"role": "system", "content": "You are an optimization engineer. Write correct and runnable Python code using gurobipy (Gurobi Python API). Be concise. Output only what is requested."}, {"role": "user", "content": "    Task: Reproduce the following Gurobi modeling example in Python using gurobipy.\n\n    Scenario description (from source):\n    Copyright © 2022 Gurobi Optimization, LLC\n\n# How Much Is Too Much? Avocado Pricing and Supply Using Mathematical Optimization\n\nA [Food Network article](https://www.foodnetwork.com/fn-dish/news/2018/3/avocado-unseats-banana-as-america-s-top-fruit-import-by-value) from March 2017 declared, \"Avocado unseats banana as America's top fruit import.\" This declaration is incomplete and debatable for reasons other than whether  avocado is a fruit. Avocados are expensive.\n\nAs a supplier, setting an appropriate avocado price requires a delicate trade-off. \nSet it too high and you lose customers. Set it too low and you won't make a profit.\nEquipped with good data, the avocado pricing and supply problem is *ripe* with opportunities for demonstrating the power of optimization and data science.\n\nThey say when life gives you avocados, make guacamole.\nJust like the perfect guacamole needs the right blend of onion, lemon and spices, finding an optimal avocado price needs the right blend of descriptive, predictive and prescriptive analytics.\n\n|<img src=\"avocado_image_grocery.jpeg\" width=\"500\" align=\"center\">| \n|:--:|\n| <b>Avocados: a quintessential corner of a grocery store. Image Credits: [New York Post](https://nypost.com/2022/02/15/us-will-halt-mexico-avocado-imports-as-long-as-necessary/) </b>| \n\n**Goal**: Develop a data science pipeline for pricing and distribution of avocados to maximize revenue.\n\nThis notebook walks through a decision-making pipeline that culminates in a mathematical optimization model.\nThere are three stages: \n- First, understand the dataset and infer the relationships between categories such as the sales, price, region, and seasonal trends.\n- Second, build a prediction model that predicts the demand for avocados as a function of price, region, year and the seasonality.\n- Third, design an optimization problem that sets the optimal price and supply quantity to maximize the net revenue while incorporating costs for wastage and transportation.\n\n## Load the Packages and the Datasets\n\nWe use real sales data provided by the [Hass Avocado Board](https://hassavocadoboard.com/) (HAB), whose aim is to \"make avocados America’s most popular fruit\". This dataset contains consolidated information on several years' worth of market prices and sales of avocados. \n\nWe will now load the following packages for analyzing and visualizing the data.\n\nThe dataset from HAB contains sales data for the years 2019-2022. This data is augmented by a previous download from HAB available on [Kaggle](https://www.kaggle.com/datasets/timmate/avocado-prices-2020) with sales for the years 2015-2018.\n\nEach row in the dataset is the weekly number of avocados sold and the weekly average price of an avocado categorized by region and type of avocado. There are two types of avocados: conventional and organic. In this notebook, we will only consider the conventional avocados.\nThere are eight large regions, namely the Great Lakes, Midsouth, North East, Northern New England, South Central, South East, West and Plains.\n\nNow, load the data and store into a Pandas dataframe.\n\n## Prepare the Dataset\n\nWe will now prepare the data for making sales predictions. Add new columns to the dataframe for the year and seasonality. Let each year from 2015 through 2022 be given an index from 0 through 7 in the increasing order of the year. We will define the peak season to be the months of February through July. These months are set based on visual inspection of the trends, but you can try setting other months.\n\n    Requirements:\n    - Use gurobipy (Model, GRB, addVar/addConstr, etc.)\n    - Make the script runnable as a standalone Python file if possible.\n    - Keep the code faithful to the example.\n"}, {"role": "assistant", "content": "import pandas as pd\nimport warnings\nwarnings.filterwarnings(\"ignore\")\nimport matplotlib.pyplot as plt\nfrom sklearn import tree \nimport seaborn as sns\nimport sklearn \nimport numpy as np\n\navocado = pd.read_csv('https://raw.githubusercontent.com/Gurobi/modeling-examples/master/price_optimization/HABdata_2019_2022.csv') # dataset downloaded directly from HAB\n# avocado = pd.read_csv('HABdata_2019_2022.csv') # dataset downloaded directly from HAB\navocado_old = pd.read_csv('https://raw.githubusercontent.com/Gurobi/modeling-examples/master/price_optimization/kaggledata_till2018.csv') # dataset downloaded from Kaggle\n# avocado_old = pd.read_csv('kaggledata_till2018.csv') # dataset downloaded from Kaggle\navocado = pd.concat([avocado, avocado_old], ignore_index=True)\navocado\n\n# Add the index for each year from 2015 through 2022\navocado['date'] = pd.to_datetime(avocado['date'])\navocado['year'] = pd.DatetimeIndex(avocado['date']).year\navocado['year_index'] = avocado['year'] - 2015\navocado = avocado.sort_values(by='date')\n\n# Define the peak season\navocado['month'] = pd.DatetimeIndex(avocado['date']).month\npeak_months = range(2,8)        # <--------- Set the months for the \"peak season\"\ndef peak_season(row):\n    return 1 if int(row['month']) in peak_months else 0  \n\navocado['peak'] = avocado.apply(lambda row: peak_season(row), axis=1)\n\n# Scale the number of avocados to millions\navocado['units_sold'] = avocado['units_sold']/1000000\n\n# Select only conventional avocados\navocado = avocado[avocado['type'] == 'Conventional'] \n\navocado = avocado[['date','units_sold','price','region','year','month','year_index','peak']].reset_index(drop = True)\n\navocado\n\ndf_Total_US = avocado[avocado['region']=='Total_US']\n\nfig, axes = plt.subplots(nrows=1, ncols=1, figsize=(10, 5)) \n\nmean = df_Total_US.groupby('year')['units_sold'].mean()\nstd  = df_Total_US.groupby('year')['units_sold'].std()\naxes.errorbar(mean.index, mean, xerr=0.5, yerr=2*std, linestyle='') \naxes.set_ylabel('Units Sold (millions)')\naxes.set_xlabel('Year') \n \nfig.tight_layout()\n\nfig, axes = plt.subplots(nrows=1, ncols=1, figsize=(10, 5)) \n\nmean = df_Total_US.groupby('month')['units_sold'].mean()\nstd  = df_Total_US.groupby('month')['units_sold'].std()\n \naxes.errorbar(mean.index, mean, xerr=0.5, yerr=2*std, linestyle='') \naxes.set_ylabel('Units Sold (millions)')\naxes.set_xlabel('Month') \n \nfig.tight_layout()\n \nplt.xlabel('Month')\naxes.set_xticks(range(1,13)) \nplt.ylabel('Units sold (millions)')\nplt.show()\n\nfig, axes = plt.subplots(nrows=1, ncols=1, figsize=(15, 5)) \nsns.heatmap(df_Total_US[['units_sold', 'price', 'year', 'peak']].corr(),annot=True, center=0,ax=axes) \n\naxes.set_title('Correlations for conventional avocados') \nplt.show()\n\nfig, axes = plt.subplots(nrows=1, ncols=1, figsize=(10, 5)) \n\nregions = ['Great_Lakes','Midsouth','Northeast','Northern_New_England','SouthCentral','Southeast','West','Plains'] \ndf = avocado[avocado.region.isin(regions)]  \n\nmean = df.groupby('region')['units_sold'].mean()\nstd  = df.groupby('region')['units_sold'].std() \n \naxes.errorbar(range(len(mean)), mean, xerr=0.5, yerr=2*std, linestyle='')  \n\nfig.tight_layout()\n \nplt.xlabel('Region') \nplt.xticks(range(len(mean)), pd.DataFrame(mean)['units_sold'].index,rotation=20)\nplt.ylabel('Units sold (millions)')\nplt.show()\n\nimport statsmodels.api as sm\nimport statsmodels.formula.api as smf\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.metrics import r2_score\n\n# Split the data for training and testing\ntrain, test = train_test_split(df, train_size=0.8, random_state=1)\ndf_train = pd.DataFrame(train, columns=df.columns)\ndf_test = pd.DataFrame(test, columns=df.columns)\n \n# Train the model\nformula = 'units_sold ~ price + year_index + C(region)+ peak'\nmod = smf.ols(formula,data=df_train)\nresult = mod.fit()\nresult.summary()\n\n# Get R^2 from test data\ny_true = df_test['units_sold']\ny_pred = result.predict(df_test)\nprint(\"The R^2 value in the test set is\",r2_score(y_true, y_pred))\n\nformula = 'units_sold ~ price + year_index + C(region)+ peak'\nmod_full = smf.ols(formula,data=df)\nresult_full = mod_full.fit()\n\ny_true_full = df['units_sold']\ny_pred_full = result_full.predict(df)\nprint(\"The R^2 value in the full dataset is\",r2_score(y_true_full, y_pred_full))\n\n# Get the weights and store it\ncoef_dict = result_full.params.to_dict() \ncoef_dict['C(region)[T.Great_Lakes]'] = 0\n\nimport gurobipy as gp \nfrom gurobipy import GRB\n\nm = gp.Model(\"Avocado_Price_Allocation\")\n\n# Sets and parameters\nR = regions   # set of all regions\n\nB = 30  # total amount ot avocado supply\n\npeak_or_not = 1 # 1 if it is the peak season; 1 if isn't\nyear = 2022\n\nc_waste = 0.1 # the cost ($) of wasting an avocado\nc_transport = {'Great_Lakes': .3,'Midsouth':.1,'Northeast':.4,'Northern_New_England':.5,'SouthCentral':.3,'Southeast':.2,'West':.2,'Plains':.2}\n# the cost of transporting an avocado\n\n# Get the lower and upper bounds from the dataset for the price and the number of products to be stocked \na_min = {r: 0 for r in R} # minimum avocado price in each region \na_max = {r: 2 for r in R} # maximum avocado price in each region \nb_min = dict(df.groupby('region')['units_sold'].min())  # minimum number of avocados allocated to each region\nb_max = dict(df.groupby('region')['units_sold'].max())   # maximum number of avocados allocated to each region\n\np = m.addVars(R,name=\"p\",lb=a_min, ub=a_max)   # price of avocados in each region\nx = m.addVars(R,name=\"x\",lb=b_min,ub=b_max)  # quantity supplied to each region\ns = m.addVars(R,name=\"s\",lb=0)   # predicted amount of sales in each region for the given price\nw = m.addVars(R,name=\"w\",lb=0)   # excess wasteage in each region\n\nd = {r: (coef_dict['Intercept']+coef_dict['price']*p[r] + coef_dict['C(region)[T.%s]'%r] + coef_dict['year_index']*(year-2015) + coef_dict['peak']*peak_or_not) for r in R}\nfor r in R:\n    print(d[r])\n\nm.setObjective(sum(p[r]*s[r] - c_waste*w[r] - c_transport[r]*x[r] for r in R)) \nm.ModelSense = GRB.MAXIMIZE\n\nm.addConstr(sum(x[r] for r in R) == B)\nm.update()\n\nm.addConstrs((s[r] <= x[r] for r in R))\nm.addConstrs((s[r] <= d[r] for r in R)) \nm.update()\n\nm.addConstrs((w[r] == x[r]-s[r] for r in R))\nm.update()\n\nm.Params.NonConvex = 2 \nm.optimize()\n\nsolution = pd.DataFrame() \nsolution['Region'] = R\nsolution['Price'] = [p[r].X for r in R]\nsolution['Allocated'] = [round(x[r].X,8) for r in R]\nsolution['Sold'] = [round(s[r].X,8) for r in R]\nsolution['Wasted'] = [round(w[r].X,8) for r in R]  \nsolution['Pred_demand'] = [(coef_dict['Intercept']+coef_dict['price']*p[r].X + coef_dict['C(region)[T.%s]'%r] + coef_dict['year_index']*(year-2015) + coef_dict['peak']*peak_or_not) for r in R]\n\nopt_revenue = m.ObjVal\nprint(\"\\n The optimal net revenue: $%f million\"%opt_revenue) \nsolution\n\nfig, ax = plt.subplots(1,1) \nplot_sol = sns.scatterplot(data=solution,x='Price',y='Sold',hue='Region',s=100)\nplot_waste = sns.scatterplot(data=solution,x='Price',y='Wasted',marker='x',hue='Region',s=100,legend = False)\n\nplot_sol.legend(loc='center left', bbox_to_anchor=(1.25, 0.5), ncol=1)\nplot_waste.legend(loc='center left', bbox_to_anchor=(1.25, 0.5), ncol=1)\nplt.ylim(0, 5)\nplt.xlim(1, 2.2)\nax.set_xlabel('Price per avocado ($)')\nax.set_ylabel('Number of avocados sold (millions)')\nplt.show() \nprint(\"The circles represent sales quantity and the cross markers represent the wasted quantity.\")\n\nfrom ipywidgets import interact, interactive, fixed, interact_manual\nimport ipywidgets as widgets \n \nimport plotly.express as px\n\npeak_or_not = 1 # \nyear = 2021\n\n# Sets and parameters\nR = regions  \nc_waste = 0.1 \nc_transport = {'Great_Lakes': .3,'Midsouth':.1,'Northeast':.4,'Northern_New_England':.5,'SouthCentral':.3,'Southeast':.2,'West':.2,'Plains':.2}\n\n# Get the lower and upper bounds for price (p) and amount to be stocked (x) from the dataset\nprice_min = dict(df.groupby('region')['price'].min())\nprice_max = dict(df.groupby('region')['price'].max())\nsold_min = dict(df.groupby('region')['units_sold'].min()) \nsold_max = dict(df.groupby('region')['units_sold'].max())   \n\n\n\ndef solve_MIQP(x):\n    B = x\n    \n    # Initialize Model\n    m = gp.Model(\"Avocado_Price_Allocation\")\n\n    # Variables. Adjust the bounds here \n    x = m.addVars(R,name=\"x\",lb=sold_min,ub=sold_max) \n    p = m.addVars(R,name=\"p\",lb=0, ub=2)   \n    s = m.addVars(R,name=\"s\",lb=0)  \n    w = m.addVars(R,name=\"w\",lb=0) \n    i = m.addVars(R,name=\"i\",vtype=GRB.BINARY) \n\n    # Predictor expression for demand\n    d = {r: (coef_dict['Intercept']+coef_dict['price']*p[r] + coef_dict['C(region)[T.%s]'%r] + coef_dict['year_index']*(year-2015) + coef_dict['peak']*peak_or_not) for r in R}\n \n    \n    # Set the objective\n    m.ModelSense = GRB.MAXIMIZE\n    m.setObjective(sum(p[r]*s[r] - c_waste*w[r] - c_transport[r]*x[r] for r in R)) \n\n    # Add the constraints \n    m.addConstrs((s[r] <= x[r] for r in R))\n    m.addConstrs((s[r] <= d[r] for r in R)) \n    m.addConstrs((x[r] == w[r]+s[r] for r in R))\n    m.addConstr(sum(x[r] for r in R) == B)\n\n    # Solve   \n    m.setParam('OutputFlag', 0)\n    m.Params.NonConvex = 2\n    m.update()\n    m.optimize() \n    if m.status == 4:\n        print('The problem is infeasible. Try changing the parameter values.')\n    else:\n        global solution, opt_revenue\n        solution = pd.DataFrame() \n        solution['Region'] = R\n        solution['Price'] = [p[r].X for r in R]\n        solution['Allocated'] = [round(x[r].X,8) for r in R]\n        solution['Sold'] = [round(s[r].X,8) for r in R]\n        solution['Wasted'] = [round(w[r].X,8) for r in R]  \n        solution['Demand'] = [(coef_dict['Intercept']+coef_dict['price']*p[r].X + coef_dict['C(region)[T.%s]'%r] + coef_dict['year_index']*(year-2015) + coef_dict['peak']*peak_or_not) for r in R]\n\n        opt_revenue = m.ObjVal\n        if display_figures:\n            print(\"\\n Net revenue: $%f million\"%opt_revenue)\n            print(\"\\nThe optimal solution is as follows. Price per avocado in dollars. Allocated avocados, wasted avocados, and predicted demand in millions.\\n\")\n            print(solution)\n            \n            print(\"\\n Scatter plot of price vs number of avocados sold (millions) for the eight regions:\")\n            fig, ax = plt.subplots(1,1) \n            plot_sol = sns.scatterplot(data=solution,x='Price',y='Sold',hue='Region',s=100)\n            plot_waste = sns.scatterplot(data=solution,x='Price',y='Wasted',marker='x',hue='Region',s=100,legend = False)\n\n            plot_sol.legend(loc='center left', bbox_to_anchor=(1.25, 0.5), ncol=1)\n            plot_waste.legend(loc='center left', bbox_to_anchor=(1.25, 0.5), ncol=1)\n            plt.ylim(0, 5)\n            plt.xlim(1, 2.2)\n            ax.set_xlabel('Price per avocado ($)')\n            ax.set_ylabel('Number of avocados sold (millions)')\n            plt.show() \n            print(\"The circles represent sales quantity and the cross markers represent the wasted quantity.\")\n            \n            \n        return m.ObjVal, solution\n        \n        \ndisplay_figures = 1\nprint(\"Select a value for the available inventory (B) (in millions):\\n\")\ninteract(solve_MIQP, x=(15,40,1))\n\n# Create a subset of data for the given year and season\ndf_subset = df[(df['year']==year) & (df['peak']==peak_or_not)]\ndf_subset['price_minus_transport'] = df_subset['price'] - df_subset['region'].map(c_transport) \ndates = sorted(list(set(df_subset.date))) \n\n# Run the optimizer for each week\nactual, optimal, display_figures = [], [], 0\nfor date in dates: \n    df_date = df_subset[df_subset['date']==date] \n    weekly_sold = (df_date['units_sold']).values.sum()  \n    optimal.append(solve_MIQP(weekly_sold)[0]) \n    \n    actual_weekly_revenue = (df_date['units_sold']*(df_date['price_minus_transport'])).values.sum() \n    actual.append(actual_weekly_revenue) \n\n# Plot the two scatter plots\nfig_comparison, ax_comparison = plt.subplots(1,1) \nactual_plot = plt.scatter(dates, actual)\noptimal_plot = plt.scatter(dates, optimal)\nplt.legend((optimal_plot,actual_plot),('Optimal weekly net revenue','Actual weekly net revenue'),loc='center left', bbox_to_anchor=(1.25, 0.5), ncol=1)\nx_ticks_labels = list(dict.fromkeys([date.strftime(\"%B\") for date in  dates])) \nax_comparison.set_xticklabels(x_ticks_labels, rotation=20, fontsize=12)\nax_comparison.set_xlabel('Date')\nax_comparison.set_ylabel('Net revenue in $million')\n\nplt.show()\n\ndifference = [(i - j)/j for i, j in zip(optimal, actual)]\nprint(\"For the average peak season week in %i, the optimal solution yields %f %% more net revenue than the actual supply chain.\"%(year,100*sum(difference)/len(difference)))\n\ndef compare_with_actual(x):\n    df_date = df_subset[df_subset['date']==x]\n    weekly_sold = (df_date['units_sold']).values.sum()  \n    print(weekly_sold)\n    opt_revenue, opt_solution = solve_MIQP(weekly_sold) \n\n    df_comparison = df_date.merge(opt_solution, left_on='region', right_on='Region')\n\n    df_comparison = df_comparison[['Region','price','Price','units_sold','Sold']]\n    df_comparison = df_comparison.rename({'price': 'Actual price', 'Price': 'Optimal price','units_sold': 'Actual sold', 'Sold': 'Optimal sold'}, axis=1)\n    print(df_comparison.sort_values(by='Region').reset_index(drop=True))\n\ndisplay_figures = 0\nprint(\"Select a value for the available inventory (B) (in millions):\\n\")\ninteract(compare_with_actual, x=dates)\n\ngp.disposeDefaultEnv()"}]}
{"meta": {"source_path": "/Users/sunyujun03/Desktop/ReLoop/gurobi-modeling-examples/price_optimization/price_optimization_gurobiML.ipynb", "kind": "ipynb", "title": "Do you have a Gurobi WLS?"}, "messages": [{"role": "system", "content": "You are an optimization engineer. Write correct and runnable Python code using gurobipy (Gurobi Python API). Be concise. Output only what is requested."}, {"role": "user", "content": "    Task: Reproduce the following Gurobi modeling example in Python using gurobipy.\n\n    Scenario description (from source):\n    # Do you have a Gurobi WLS?\nThis notebook can be ran using the limited licese but at a smaller level of detail. If you have a Gurobi WLS, you can go to a version of this notebook equipped for that license by [clicking here](https://colab.research.google.com/github/Gurobi/modeling-examples/blob/master/price_optimization/price_optimization_gurobiML_wls.ipynb).\n\nIf you don't, no worries! You can still work through this version using a free limited Gurobi license.\n\n# Part Two: Avocado Pricing and Supply Using Mathematical Optimization \n\nThis is a second part of an example on price optimization: [How Much Is Too Much? Avocado Pricing and Supply Using Mathematical Optimization](https://github.com/Gurobi/modeling-examples/tree/master/price_optimization)\n\nIn the first part, an ordinary linear regression model (OLS) was used to establish the relationship between price and demand based on data from the.... Part Two replaces the OLS model with a trained `Scikit-learn` model and uses the [Gurobi Machine Learning](https://gurobi-machinelearning.readthedocs.io/en/stable/#) package to embed it in a Gurobi optimization model.\n\nIn this example, we will also use `gurobipy-pandas`, which is another Gurobi open-source package and serves as a convenient (and optional) wrapper to connect pandas with gurobipy. \n\nIf you are already familiar with the example from the other notebook, you can\njump directly to [building the regression model](#Part-2:-Predict-the-Sales)\nand then to [formulating the optimization problem](#Part-3:-Optimize-for-Price-and-Supply-of-Avocados).\n\n**Goal**: Develop a data science and decision-making pipeline for pricing and distribution of avocados to maximize revenue.\n\nTo accomplish this, the notebook will walk trough three stages:\n\n1. A quick review of the [Hass Avocado Board](https://hassavocadoboard.com/) (HAB) data\n2. Build a prediction model for avocado demand as a function of price, region, year and seasonality.\n3. Design an optimization model that sets the optimal price and supply quantity to maximize the net revenue while incorporating transportation and costs.\n\n## Load the Packages and Prepare the Dataset\n\nJust as in the first example, we use real HAB sales data. \n\nThe dataset from HAB contains sales data for the years 2019-2022. This data is augmented by a previous download from HAB available on\n[Kaggle](https://www.kaggle.com/datasets/timmate/avocado-prices-2020) with sales for the years 2015-2018.\n\nThis notebook will skip a lot of the preprocessing from the first version of this example.\n\n    Requirements:\n    - Use gurobipy (Model, GRB, addVar/addConstr, etc.)\n    - Make the script runnable as a standalone Python file if possible.\n    - Keep the code faithful to the example.\n"}, {"role": "assistant", "content": "import pandas as pd\nimport warnings\nimport numpy as np\n\ndata_url = \"https://raw.githubusercontent.com/Gurobi/modeling-examples/master/price_optimization/\"\navocado = pd.read_csv(data_url+\"HAB_data_2015to2022.csv\")\navocado[\"date\"] = pd.to_datetime(avocado[\"date\"])\navocado = avocado.sort_values(by=\"date\")\navocado\n\nregions = [\n    \"Great_Lakes\",\n    \"Midsouth\",\n    \"Northeast\",\n    \"Northern_New_England\",\n    \"SouthCentral\",\n    \"Southeast\",\n    \"West\",\n    \"Plains\"\n]\ndf = avocado[avocado.region.isin(regions)]\n\nfrom sklearn.model_selection import train_test_split\n\nX = df[[\"region\", \"price\", \"year\", \"peak\"]]\ny = df[\"units_sold\"]\n# Split the data for training and testing\nX_train, X_test, y_train, y_test = train_test_split(\n    X, y, train_size=0.8, random_state=1\n)\n\nfrom sklearn.preprocessing import OneHotEncoder\nfrom sklearn.preprocessing import StandardScaler\nfrom sklearn.compose import make_column_transformer\nfrom sklearn.linear_model import LinearRegression\nfrom sklearn.pipeline import make_pipeline\nfrom sklearn.metrics import r2_score\n\nfeat_transform = make_column_transformer(\n    (OneHotEncoder(drop=\"first\"), [\"region\"]),\n    (StandardScaler(), [\"price\", \"year\"]),\n    (\"passthrough\", [\"peak\"]),\n    verbose_feature_names_out=False,\n    remainder='drop'\n)\n\nreg = make_pipeline(feat_transform, LinearRegression())\nreg.fit(X_train, y_train)\n\n# Get R^2 from test data\ny_pred = reg.predict(X_test)\nprint(f\"The R^2 value in the test set is {np.round(r2_score(y_test, y_pred),5)}\")\n\nreg.fit(X, y)\n\ny_pred_full = reg.predict(X)\nprint(f\"The R^2 value in the full dataset is {np.round(r2_score(y, y_pred_full),5)}\")\n\n# Sets and parameters\nB = 35  # total amount of avocado supply\n\npeak_or_not = 1  # 1 if it is the peak season; 0 if isn't\nyear = 2022\n\nc_waste = 0.1  # the cost ($) of wasting an avocado\n\n# the cost of transporting an avocado\nc_transport = pd.Series(\n    {\n        \"Great_Lakes\": 0.3,\n        \"Midsouth\": 0.1,\n        \"Northeast\": 0.4,\n        \"Northern_New_England\": 0.5,\n        \"SouthCentral\": 0.3,\n        \"Southeast\": 0.2,\n        \"West\": 0.2,\n        \"Plains\": 0.2,\n    }, name='transport_cost'\n)\nc_transport = c_transport.loc[regions]\n\na_min = 0  # minimum avocado price \na_max = 3  # maximum avocado price\n\n# Get the lower and upper bounds from the dataset for the price and the number of products to be stocked\ndata = pd.concat([c_transport,\n                  df.groupby(\"region\")[\"units_sold\"].min().rename('min_delivery'),\n                  df.groupby(\"region\")[\"units_sold\"].max().rename('max_delivery')], axis=1)\n\ndata\n\nimport gurobipy_pandas as gppd\nfrom gurobi_ml import add_predictor_constr\n\nfeats = pd.DataFrame(\n    data={\n        \"year\": year,\n        \"peak\": peak_or_not,\n        \"region\": regions,\n    },\n    index=regions\n)\nfeats\n\nimport gurobipy as gp\n\nm = gp.Model(\"Avocado_Price_Allocation\")\n\np = gppd.add_vars(m, data, name=\"price\", lb=a_min, ub=a_max) # price of an avocado for each region\nx = gppd.add_vars(m, data, name=\"x\", lb='min_delivery', ub='max_delivery') # number of avocados supplied to each reagion\ns = gppd.add_vars(m, data, name=\"s\") # predicted amount of sales in each region for the given price\nw = gppd.add_vars(m, data, name=\"w\") # excess wasteage in each region\nd = gppd.add_vars(m, data, lb=-gp.GRB.INFINITY, name=\"demand\") # Add variables for the regression\n\nm.update()\n\n# Display one of the variables\np\n\nm.addConstr(x.sum() == B)\nm.update()\n\ngppd.add_constrs(m, s, gp.GRB.LESS_EQUAL, x)\ngppd.add_constrs(m, s, gp.GRB.LESS_EQUAL, d)\nm.update()\n\ngppd.add_constrs(m, w, gp.GRB.EQUAL, x - s)\nm.update()\n\nm_feats = pd.concat([feats, p], axis=1)[[\"region\", \"price\", \"year\", \"peak\"]]\nm_feats\n\npred_constr = add_predictor_constr(m, reg, m_feats, d)\npred_constr.print_stats()\n\nm\n\nm.setObjective((p * s).sum() - c_waste * w.sum() - (c_transport * x).sum(),\n               gp.GRB.MAXIMIZE)\n\nm.Params.NonConvex = 2\nm.optimize()\n\nsolution = pd.DataFrame(index=regions)\n\nsolution[\"Price\"] = p.gppd.X\nsolution[\"Allocated\"] = x.gppd.X\nsolution[\"Sold\"] = s.gppd.X\nsolution[\"Wasted\"] = w.gppd.X\nsolution[\"Pred_demand\"] = d.gppd.X\n\nopt_revenue = m.ObjVal\nprint(\"\\n The optimal net revenue: $%f million\" % opt_revenue)\nsolution.round(4)\n\nprint(\n    \"Maximum error in approximating the regression {:.6}\".format(\n        np.max(pred_constr.get_error())\n    )\n)"}]}
{"meta": {"source_path": "/Users/sunyujun03/Desktop/ReLoop/gurobi-modeling-examples/mining/mining.ipynb", "kind": "ipynb", "title": "Mining"}, "messages": [{"role": "system", "content": "You are an optimization engineer. Write correct and runnable Python code using gurobipy (Gurobi Python API). Be concise. Output only what is requested."}, {"role": "user", "content": "    Task: Reproduce the following Gurobi modeling example in Python using gurobipy.\n\n    Scenario description (from source):\n    # Mining\n\n## Objective and Prerequisites\n\nPut your planning skills to the test in this example, where you’ll learn how to model and solve a production planning problem that involves optimizing the operations of a group of mines over a five-year period.\n\nMore information on this type of model can be found in example # 7 of the fifth edition of Modeling Building in Mathematical Programming by H. P. Williams on pages 261 – 262 and 310 – 312.\n\nThis modeling example is at the intermediate level, where we assume that you know Python and are familiar with the Gurobi Python API. In addition, you should have some knowledge about building mathematical optimization models.\n\n**Download the Repository** <br />\nYou can download the repository containing this and other examples by clicking [here](https://github.com/Gurobi/modeling-examples/archive/master.zip). \n\n---\n## Problem Description\n\nA mining company needs to create a five-year operating plan for a certain area with four mines in it.\n\nThey can only operate a maximum of three mines in this area in any given year. However, even though a mine may not operate in a given year, the company still must pay royalties on that mine if there is an expectation that it will operate again in the future. Otherwise, it can be permanently closed and no more royalties need to be paid.\n\nThe yearly royalties due for each open mine (operating or not) are as follows:\n\n| <i></i> | Royalties |\n| --- | --- |\n| Mine 1 | $\\$5 Million$ |\n| Mine 2 | $\\$4 Million$ |\n| Mine 3 | $\\$4 Million$ |\n| Mine 4 | $\\$5 Million$ |\n\nThere is a maximum amount of ore that can be extracted from each mine in a given year. These limits are as follows:\n\n| <i></i> | Max Production |\n| --- | --- |\n| Mine 1 | $2.0\\times10^6$ Tons |\n| Mine 2 | $2.5\\times10^6$ Tons |\n| Mine 3 | $1.3\\times10^6$ Tons |\n| Mine 4 | $3.0\\times10^6$ Tons |\n\nEach mine produces a different grade of ore. This grade is measured on a scale such that blending ores together results in a linear combination of the quality requirements. For example, if equal quantities of ore from two different mines were combined, the resulting ore would have a grade that is the average of the grade for each of the two ores. The grade for each mine’s ore is as follows:\n\n| <i></i> | Ore Quality |\n| --- | --- |\n| Mine 1 | 1.0 |\n| Mine 2 | 0.7 |\n| Mine 3 | 1.5 |\n| Mine 4 | 0.5 |\n\nEach year, the ore produced from each operating mine must be combined to produce ore of a certain grade. The yearly objectives for the combined ore are as follows:\n\n| <i></i> | Quality Target |\n| --- | --- |\n| Year 1 | 0.9 |\n| Year 2 | 0.8 |\n| Year 3 | 1.2 |\n| Year 4 | 0.6 |\n| Year 5 | 1.0 |\n\nThe final blended ore sells for $\\$10$/ton. Revenues and costs for future years are discounted at the rate of $10\\%$ per annum.\n\nThe key question for the mining company is: Which mines should be operated each year and how much ore should be extracted from each mine?\n\nThis problem is based on a larger one faced by the firm of English China Clays, which had to in decide which mines to work. In that problem (in the 1970s), the goal was to work up to four mines out of 20 in each year.\n\n---\n## Model Formulation\n\n### Sets and Indices\n\n$t \\in \\text{Years}=\\{1,2,\\dots,5\\}$: Set of years.\n\n$m \\in \\text{Mines}=\\{1,2,\\dots,4\\}$: Set of mines.\n\n### Parameters\n\n$\\text{price} \\in \\mathbb{R}^+$: Selling price (in USD) of one ton of blended ore.\n\n$\\text{max_mines} \\in \\mathbb{N}$: Maximum number of mines that can operate in any given year.\n\n$\\text{royalties}_m \\in \\mathbb{R}^+$: Yearly royalties (in USD) for having mine $m$ open.\n\n$\\text{capacity}_m \\in \\mathbb{R}^+$: Maximum tons of ore that can be extracted from mine $m$ in any given year.\n\n$\\text{quality}_m \\in \\mathbb{R}^+$: Quality of the ore extracted from mine $m$.\n\n$\\text{target} \\in \\mathbb{R}^+$: Quality target of the blended ore in year $t$.\n\n$\\text{time_discount}_t \\in [0,1] \\subset \\mathbb{R}^+$: Time discount for revenue and cost in year $t$.\n\n### Decision Variables\n\n$\\text{blend}_t \\in \\mathbb{R}^+$: Tons of blended ore in year $t$.\n\n$\\text{extract}_{t,m} \\in \\mathbb{R}^+$: Tons of ore extracted from mine $m$ in year $t$.\n\n$\\text{working}_{t,m} \\in \\{0,1\\}$: 1 if mine $m$ is working in year $t$, 0 otherwise.\n\n$\\text{available}_{t,m} \\in \\{0,1\\}$: 1 if mine $m$ is open in year $t$, 0 otherwise.\n\n### Objective Function\n\n- **Profit**: Maximize the total profit (in USD) of the planning horizon.\n\n\\begin{equation}\n\\text{Maximize} \\quad Z = \\sum_{t \\in \\text{Years}}\\sum_{m \\in \\text{Mines}}{\\text{time_discount}_t*(\\text{price}*\\text{blend}_t-\\text{royalties}_m*\\text{extract}_{t,m})}\n\\tag{0}\n\\end{equation}\n\n### Constraints\n\n- **Operating Mines**: The total number of operating mines in year $t$ cannot exceed the limit.\n\n\\begin{equation}\n\\sum_{m \\in \\text{Mines}}{\\text{working}_{t,m}} \\leq \\text{max_mines} \\quad \\forall t \\in \\text{Years}\n\\tag{1}\n\\end{equation}\n\n- **Quality**: The final quality of the ore blended in year $t$ must meet the target.\n\n\\begin{equation}\n\\sum_{m \\in \\text{Mines}}{\\text{quality}_m*\\text{extract}_{t,m}} = \\text{target}_t*\\text{blended}_t \\quad \\forall t \\in \\text{Years}\n\\tag{2}\n\\end{equation}\n\n- **Mass Conservation**: Total tons of ore extracted in year $t$ should be equal to the Tons of the ore blended in that year.\n\n\\begin{equation}\n\\sum_{m \\in \\text{Mines}}{\\text{extract}_{t,m}} = \\text{blend}_t \\quad \\forall t \\in \\text{Years}\n\\tag{3}\n\\end{equation}\n\n- **Mine Capacity**: Total tons of ore extracted from mine $m$ in year $t$ cannot exceed the yearly capacity of that mine.\n\n\\begin{equation}\n\\sum_{m \\in \\text{Mines}}{\\text{extract}_{t,m}} \\leq \\text{capacity}_m*\\text{working}_{t,m} \\quad \\forall t \\in \\text{Years}\n\\tag{4}\n\\end{equation}\n\n- **Open to Operate**: Mine $m$ can be operated in year $t$ only if it is open in that year. \n\n\\begin{equation}\n\\text{working}_{t,m} \\leq \\text{available}_{t,m} \\quad \\forall (t,m) \\in \\text{Years} \\times \\text{Mines}\n\\tag{5}\n\\end{equation}\n\n- **Shut Down**: If mine $m$ is closed in year $t$, it cannot be opened again in the future.\n\n\\begin{equation}\n\\text{available}_{t+1,m} \\leq \\text{available}_{t,m} \\quad \\forall (t < 5,m) \\in \\text{Years} \\times \\text{Mines}\n\\tag{6}\n\\end{equation}\n\n---\n## Python Implementation\n\nWe import the Gurobi Python Module and other Python libraries.\n\n## Input Data\nWe define all the input data of the model.\n\n**Note:** The present value of a future amount at period $n$ is given by the formula: $\\text{present_value} = \\frac{1}{(1+\\text{interest_rate})^n}*\\text{future_value} $\n\n## Model Deployment\nWe create a model and the variables. For each year and each mine, we have (i) a variable that captures production, in millions of tons, (ii) a decision variable which tells us if the mine is open, and (iii) a decision variable which tells us if the mine is operational.\n\nNext, we insert the constraints.\n\nIn each year only three mines can be operational.\n\n    Requirements:\n    - Use gurobipy (Model, GRB, addVar/addConstr, etc.)\n    - Make the script runnable as a standalone Python file if possible.\n    - Keep the code faithful to the example.\n"}, {"role": "assistant", "content": "import numpy as np\nimport pandas as pd\n\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# tested with Python 3.11 & Gurobi 11.0\n\n# Parameters\n\nyears = [1, 2, 3, 4, 5]\nmines = [1, 2, 3, 4]\n\nroyalties = {1: 5e6, 2: 4e6, 3: 4e6, 4: 5e6}\ncapacity = {1: 2e6, 2: 2.5e6, 3: 1.3e6, 4: 3e6}\nquality  = {1: 1.0, 2: 0.7, 3: 1.5, 4: 0.5}\ntarget = {1: 0.9, 2: 0.8, 3: 1.2, 4: 0.6, 5: 1.0}\ntime_discount = {year: (1/(1+1/10.0)) ** (year-1) for year in years}\n\nmax_mines = 3\nprice = 10\n\nmining = gp.Model('Mining')\n\nblend = mining.addVars(years, name=\"Blend\")\nextract = mining.addVars(years, mines, name=\"Extract\")\nworking = mining.addVars(years, mines, vtype=GRB.BINARY, name=\"Working\")\navailable = mining.addVars(years, mines, vtype=GRB.BINARY, name=\"Available\")\n\n#1. Operating Mines\n\nOperatingMines = mining.addConstrs((working.sum(year, '*') <= max_mines for year in years), \"Operating_mines\")\n\n#2. Quality\n\nQuality = mining.addConstrs((gp.quicksum(quality[mine]*extract[year, mine] for mine in mines)\n                   == target[year]*blend[year] for year in years), \"Quality\")\n\n#3. Mass Conservation\n\nMassConservation = mining.addConstrs((extract.sum(year, '*') == blend[year] for year in years), \"Mass Conservation\")\n\n#4. Mine Capacity\n\nMineCapacity = mining.addConstrs((extract[year, mine] <= capacity[mine]*working[year, mine] for year, mine in extract), \"Capacity\")\n\n# Open to operate\nOpenToOperate = mining.addConstrs((working[year, mine] <= available[year, mine] for year, mine in available), \"Open to Operate\")\n\n# Shutdown Mine\nShutdownMine = mining.addConstrs((available[year+1, mine] <= available[year, mine]\n                   for year, mine in available if year < years[-1]), \"Shut down\")\n\n#0. Objective function\nobj = gp.quicksum(price*time_discount[year]*blend[year] for year in years) \\\n- gp.quicksum(royalties[mine] * time_discount[year] * available[year, mine] for year, mine in available)\nmining.setObjective(obj, GRB.MAXIMIZE)\n\nmining.optimize()\n\nrows = years.copy()\ncolumns = mines.copy()\nextraction = pd.DataFrame(columns=columns, index=rows, data=0.0)\n\nfor year, mine in extract.keys():\n    if (abs(extract[year, mine].x) > 1e-6):\n        extraction.loc[year, mine] = np.round(extract[year, mine].x / 1e6, 2)\nextraction\n\nrows = years.copy()\nsales = pd.DataFrame(columns=['Sales'], index=rows, data=0.0)\n\nfor year in blend.keys():\n    if (abs(blend[year].x) > 1e-6):\n        sales.loc[year, 'Sales'] = np.round(blend[year].x / 1e6, 2)\nsales"}]}
{"meta": {"source_path": "/Users/sunyujun03/Desktop/ReLoop/gurobi-modeling-examples/index_tracking/index_tracking.ipynb", "kind": "ipynb", "title": "Index Tracking with Gurobi"}, "messages": [{"role": "system", "content": "You are an optimization engineer. Write correct and runnable Python code using gurobipy (Gurobi Python API). Be concise. Output only what is requested."}, {"role": "user", "content": "    Task: Reproduce the following Gurobi modeling example in Python using gurobipy.\n\n    Scenario description (from source):\n    # Index Tracking with Gurobi\n\nThis Python notebook is part of the webinar [Proven Techniques for Solving Financial Problems with Gurobi](https://www.gurobi.com/events/proven-techniques-for-solving-financial-problems-with-gurobi/).\n\nThe sequence of python code will:\n1. Import stock data from yahoo finance\n2. Clean up the data and change format\n3. Perform an index tracking experiment\n\n## Importing Data from YFinance\n\n- Adjusted Stock price data for SP100 constitutents \n- Data from 2010 to 2022\n\n## Importing Dummy Data\n\nIn case the import with yfinance does not work, we read dummy data from csv files\n\n    Requirements:\n    - Use gurobipy (Model, GRB, addVar/addConstr, etc.)\n    - Make the script runnable as a standalone Python file if possible.\n    - Keep the code faithful to the example.\n"}, {"role": "assistant", "content": "# import pandas as pd\n# from utils.data_import import get_mkt_constitution, get_yf_data\n# import os\n# from datetime import datetime\n\n# # Options\n# FIRST_DATE  = \"2015-01-01\"\n# LAST_DATE   = \"2022-01-01\"\n# N_PROCESSES = 10\n# MKT_INDEX   = \"^SP100\" # ^GSPC for SP500 or ^SP100 \n# #MKT_INDEX   = \"^GSPC\"\n\n# if not os.path.exists(\"data\"):\n#     os.mkdir(\"data\")\n    \n# # get mkt constitutents    \n# tickers = get_mkt_constitution(MKT_INDEX)\n\n# today = datetime.today().strftime('%Y-%m-%d')\n# print(f\"Available Tickers for {MKT_INDEX} at {today}\")\n# print(tickers)\n# print(\" \")\n\n# df_prices = get_yf_data(tickers, \n#                         FIRST_DATE,\n#                         LAST_DATE,\n#                         N_PROCESSES)\n\n# print(\"\\n\\nOriginal price data\")\n# print(df_prices.head())\n\nimport pandas as pd\nMKT_INDEX   = \"^SP100\"\n\ntickers = pd.read_csv(\"data/constituents_SP100.csv\")[\"Ticker\"].tolist()\nprint(len(tickers), tickers[:5])\n\ndf_prices = pd.read_csv(\"data/prices_SP100_2015-01-01_2022-01-01.csv\", parse_dates=['Date'])\n# Normalize headers in case your editor added spaces/BOM\ndf_prices.columns = df_prices.columns.str.strip().str.replace('\\ufeff','', regex=False)\ndf_prices = df_prices.set_index('Date')\n\n# Quick sanity checks\nassert {'ticker','Adj Close'} <= set(df_prices.columns), df_prices.columns.tolist()\nassert (df_prices['Adj Close'].notna()).all()  # no gaps\nassert (df_prices.loc[df_prices['ticker'].eq('^SP100')].shape[0] > 0)  # market series present\n\nfrom sklearn.model_selection import train_test_split\nimport numpy  as np\nimport matplotlib.pyplot as plt\nfrom utils.data_clean import clean_data\n\n\nTHRESH_VALID_DATA = 0.95 # defines where to cut stocks with missing data\nPERC_SIZE_TRAIN = 0.75   # defines the size of train dataset (in %)\n\ndf_ret, df_train, df_test  = clean_data(\n    df_prices, \n    MKT_INDEX,\n    thresh_valid_data = THRESH_VALID_DATA,\n    size_train = PERC_SIZE_TRAIN\n)\n\ndf_train.to_parquet(\"data/ret-data-cleaned-TRAIN.parquet\")\ndf_test.to_parquet(\"data/ret-data-cleaned-TEST.parquet\")\n\nimport gurobipy as gp\nfrom random import sample, seed\n\nseed(20220209) # reproducibility\n\nmkt_index = \"^SP100\"\nn_assets = 20\n\n# data from main notebook\nr_it = pd.read_parquet(\"data/ret-data-cleaned-TRAIN.parquet\")\n\nr_mkt = r_it[mkt_index]\n\nr_it = r_it.drop(mkt_index, axis = 1)\n\ntickers = list(r_it.columns)\n\nsampled_tickers = sample(tickers, n_assets)\n\nr_it = r_it[sampled_tickers]\n\nprint(r_it.head())\n\n# Create an empty model\nm = gp.Model('gurobi_index_tracking')\n\n# PARAMETERS \n\n# w_i: the i_th stock gets a weight w_i\nw = pd.Series(m.addVars(sampled_tickers, \n                         lb = 0,\n                         ub = 1,\n                         vtype = gp.GRB.CONTINUOUS), \n               index=sampled_tickers)\n\n# CONSTRAINTS\n\n# sum(w_i) = 1: portfolio budget constrain (long only)\nm.addConstr(w.sum() == 1, 'port_budget')\n\nm.update()\n\n# eps_t = R_{i,t}*w - R_{M,t}\nmy_error = r_it.dot(w) - r_mkt\n\n# set objective function\nm.setObjective(\n    gp.quicksum(my_error.pow(2)), \n    gp.GRB.MINIMIZE)     \n\n# Optimize model\nm.setParam('OutputFlag', 0)\nm.optimize()\n\nw_hat  = [i.X for i in m.getVars()]\n\nprint(f\"Solution:\") \n\nfor i, i_ticker in enumerate(sampled_tickers):\n    print(f\"{i_ticker}:\\t {w_hat[i]*100:.2f}%\")\n\n# check constraints\nprint(f\"\\nchecking constraints:\")\nprint(f\"sum(w) = {np.sum(w_hat)}\")\n\n# check out of sample plot\nimport matplotlib.pyplot as plt\n\ndf_test = pd.read_parquet(\"data/ret-data-cleaned-TEST.parquet\")\n\nprint(df_test.columns)\nprint(sampled_tickers)\ndf_test_mkt = df_test[mkt_index]\n\nr_hat = df_test[sampled_tickers].dot(w_hat)\n\ncumret_r = np.cumprod(1+ r_hat)\ncumret_mkt = np.cumprod(1+ df_test_mkt)\n\nfig, ax = plt.subplots()\nax.plot(cumret_mkt.index,\n        cumret_mkt, \n       label = mkt_index)\n\nax.plot(cumret_r.index,\n        cumret_r,\n       label = f\"ETF ({n_assets} assets)\")\n\nax.legend()\nax.set_title(f'ETF and {mkt_index}')\nax.set_xlabel('')\nax.set_ylabel('Cumulative Returns')\n\nplt.xticks(rotation = 90)\n\nplt.show()\n\n# Create an empty model\nm = gp.Model('gurobi_index_tracking')\n\n# PARAMETERS \n\nmax_assets = 10\n\n# w_i: the i_th stock gets a weight w_i\nw = pd.Series(m.addVars(sampled_tickers, \n                         lb = 0,\n                         ub = 0.2,\n                         vtype = gp.GRB.CONTINUOUS), \n               index=sampled_tickers)\n\n# [NEW] z_i: the i_th stock gets a binary z_i\nz = pd.Series(m.addVars(sampled_tickers,\n                        vtype = gp.GRB.BINARY),\n                index=sampled_tickers)\n\n# CONSTRAINTS\n\n# sum(w_i) = 1: portfolio budget constrain (long only)\nm.addConstr(w.sum() == 1, 'port_budget')\n\n# [NEW]  w_i <= z_i: restrictions of values of w_i so take it chose particular tickers\nfor i_ticker in sampled_tickers:\n    m.addConstr(w[i_ticker] <= z[i_ticker], \n                f'dummy_restriction_{i_ticker}')\n\n# [NEW] sum(z_i) <= max_assets: number of assets constraint\nm.addConstr(z.sum() <= max_assets, 'max_assets_restriction')\n\nm.update()\n\n# eps_t = R_{i,t}*w - R_{M,t}\nmy_error = r_it.dot(w) - r_mkt\n\n# set objective function\nm.setObjective(\n    gp.quicksum(my_error.pow(2)), \n    gp.GRB.MINIMIZE)     \n\n# Optimize model\nm.setParam('OutputFlag', 0)\nm.setParam('TimeLimit', 60*5) # in secs\n#m.setParam('MIPGap', 0.05) # in secs\nm.optimize()\n\nparams = [i.X for i in m.getVars()]\n\nn_assets = len(sampled_tickers)\nw_hat = params[0:n_assets]\nz_hat = params[n_assets:]\nMIPGap = m.getAttr('MIPGap')\nstatus = m.getAttr(\"Status\")\n\nprint(f\"Solution for w:\") \n\nfor i, i_ticker in enumerate(sampled_tickers):\n    print(f\"{i_ticker}:\\t {w_hat[i]*100:.2f}%\")\n\n# check constraints\nprint(f\"\\nchecking constraints:\")\nprint(f\"sum(w) = {np.sum(w_hat)}\")\nprint(f\"sum(z) = {np.sum(z_hat)}\")\nprint(f\"w <= z = {w_hat <= z_hat}\")\nprint(f\"MIPGap={MIPGap}\")\nprint(f\"Status={status}\")\n\n# check out of sample plot\nimport matplotlib.pyplot as plt\n\ndf_test = pd.read_parquet(\"data/ret-data-cleaned-TEST.parquet\")\n\nprint(df_test.columns)\nprint(sampled_tickers)\ndf_test_mkt = df_test[mkt_index]\n\nr_hat = df_test[sampled_tickers].dot(w_hat)\n\ncumret_r = np.cumprod(1+ r_hat)\ncumret_mkt = np.cumprod(1+ df_test_mkt)\n\nfig, ax = plt.subplots()\nax.plot(cumret_mkt.index,\n        cumret_mkt, \n       label = mkt_index)\n\nax.plot(cumret_r.index,\n        cumret_r,\n       label = f\"ETF ({n_assets} assets)\")\n\nax.legend()\nax.set_title(f'ETF and {mkt_index}')\nax.set_xlabel('')\nax.set_ylabel('Cumulative Returns')\n\nplt.xticks(rotation = 90)\n\nplt.show()"}]}
{"meta": {"source_path": "/Users/sunyujun03/Desktop/ReLoop/gurobi-modeling-examples/milk_collection/milk_collection.ipynb", "kind": "ipynb", "title": "Milk Collection Problem"}, "messages": [{"role": "system", "content": "You are an optimization engineer. Write correct and runnable Python code using gurobipy (Gurobi Python API). Be concise. Output only what is requested."}, {"role": "user", "content": "    Task: Reproduce the following Gurobi modeling example in Python using gurobipy.\n\n    Scenario description (from source):\n    # Milk Collection Problem\n\n## Objective and Prerequisites\n\nIn this example, you’ll discover how mathematical optimization can be leveraged to solve a capacitated vehicle routing problem: the Milk Collection Problem. With only one tanker truck with limited capacity, you will need to determine the best possible route for the tanker to take to collect milk every day from a set of farms. It’s a complicated problem to solve, but mathematical optimization will help show you the way!\n\nThis model is example 23 from the fifth edition of Model Building in Mathematical Programming by H. Paul Williams on pages 278-281 and 336-337.\n\nThis modeling example is at the advanced level, where we assume that you know Python and the Gurobi Python API and you have advanced knowledge of building mathematical optimization models. Typically, the objective function and/or constraints of these examples are complex or require advanced features of the Gurobi Python API\n\n**Download the Repository** <br />\nYou can download the repository containing this and other examples by clicking [here](https://github.com/Gurobi/modeling-examples/archive/master.zip). \n\n---\n## Problem Description\n\nA small milk processing company is committed to collecting milk from 20 farms and taking it back to the depot for processing. The company has one tanker lorry with the capacity to carry 80 000 liters of milk. Eleven of the farms are small and need a collection only every other day. The other nine farms need a collection every day. The positions of the farms in relation to the depot (numbered 1) are given in the following table together with their collection requirements.\n\n![farmCoordinates](farmCoordinates.PNG)\n\nThe goal is to find the optimal route for the tanker lorry on each day, bearing in mind that it has to: \n1. Visit all the ‘every day’ farms. \n2. Visit some of the ‘every other day’ farms. \n3. Work within its capacity. \n\nOn alternate days, it must again visit the ‘every day’ farms and also visit the ‘every other day’ farms not visited on the\nprevious day.\n\n---\n## Model Formulation\n\n### Sets and Indices\n$i, j \\in \\text{Farms} = \\{0,1,2, ..,20 \\}$: Indices and set of farms. The depot index number is 0.\n\n$\\text{everyDay} = \\{0,1,2, ..,9 \\} \\subset \\text{Farms}$: Farms that need to visit every day.\n\n$\\text{otherDay} = \\{10,11, 12, ..,20 \\} \\subset \\text{Farms}$: Farms that need to visit every other day.\n\n$k \\in K = \\{1,2 \\} $: Day type for farms that are visited every other day.\n\n$\\text{Edges}= \\{(i,j) \\in Farms \\times Farms \\}$: Set of allowed Edges\n\n$S_k \\in S  $: Subtour in route of day $k$.\n\n$G = (\\text{Farms} , \\text{Edges})$: A graph where the set $\\text{Farms}$ defines the set of nodes and the set $\\text{Edges}$ defines the set of edges. \n\n### Parameters \n\n$d_{i, j} \\in \\mathbb{R}^+$: Distance from farm $i$ to farm $j$, for all $(i, j) \\in \\text{Edges}$. \n\nNotice that the distance from farm $i$ to farm $j$ is the same as the distance from farm $j$ to farm $i$, i.e. $d_{i, j} = d_{j, i}$.\n\n$C \\in \\mathbb{R}^+$: The capacity of the tanker lorry.\n\n$R_i \\in \\mathbb{R}^+$: Milk collection requirements of farm $i$.\n\n### Decision Variables\n$x_{i, j, k} \\in \\{0, 1\\}$: This variable is equal to 1, if the tour on day $k$ connects directly farm $i$ with farm $j$. Otherwise, the decision variable is equal to zero.\n\n$y_{i, k} \\in \\{0, 1\\}$: This variable is equal to 1, if farm $i \\in otherDay$ is visited on the tour of day $k \\in K$. \n\n### Objective Function\n- **Shortest Route**. Minimize the total distance of both routes. \n\n\\begin{equation}\n\\text{Min} \\quad Z = \\sum_{k \\in K} \\sum_{(i,j) \\in \\text{Edges}} \\frac{1}{2} d_{i,j} \\cdot x_{i,j,k}\n\\tag{0}\n\\end{equation}\n\n### Constraints \n- **Symmetry Constraints**. For each edge $(i,j)$, ensure that the farm $i$ and $j$ are connected, if the former is visited immediately before or after visiting the latter.\n\n\\begin{equation}\nx_{i, j, k} = x_{j, i, k} \\quad \\forall k \\in dayType, \\; (i, j) \\in Edges\n\\tag{1}\n\\end{equation}\n\n- **Entering and leaving an every day farm**. For each farm $i$, ensure that this farm is connected to two other farms. \n\n\\begin{equation}\n\\sum_{j: (i,j) \\in \\text{Edges}} x_{i,j,k} = 2 \\quad \\forall  i \\in everyDay, \\; k \\in dayType \n\\tag{2}\n\\end{equation}\n\n- **Entering and leaving an every other day farm**. For each farm $i$, ensure that this farm is connected to two other farms. \n\n\\begin{equation}\n\\sum_{j: (i,j) \\in \\text{Edges}} x_{i,j,k}  = 2 \\cdot y_{i, k} \\quad \\forall  i \\in otherDay, \\; k \\in dayType \n\\tag{3}\n\\end{equation}\n\n- **Tanker capacity**. The tanker has limited capacity.\n\\begin{equation}\n\\sum_{i \\in \\text{otherDay}} R_{i} \\cdot y_{i,k} \\leq C -\\sum_{i \\in everyDay} R_{i} \\quad \\forall  k \\in K \n\\tag{4}\n\\end{equation}\n\n- **Farms visited**. Limit on visiting some farms only every other day.\n\n\\begin{equation}\ny_{i,1} + y_{i,2}  = 1 \\quad \\forall  i \\in \\text{otherDay}\n\\tag{5}\n\\end{equation}\n\n- **Subtour elimination**. These constraints ensure that for each route there is no cycle. \n\n\\begin{equation}\n\\sum_{(i,j) \\in S_k}x_{i,j,k} \\leq |S_k|-1 \\quad \\forall  k \\in K, \\;   S_k \\in S\n\\tag{6}\n\\end{equation}\n\nWhere the subset $S$ is the set of farms visited by the tour, and this tour is defined by the values of the decision variables in the LHS of the inequality.\n\n## Python Implementation\n\nWe import the Gurobi Python Module and other Python libraries.\n\n    Requirements:\n    - Use gurobipy (Model, GRB, addVar/addConstr, etc.)\n    - Make the script runnable as a standalone Python file if possible.\n    - Keep the code faithful to the example.\n"}, {"role": "assistant", "content": "import gurobipy as gp\nfrom gurobipy import GRB\n\nimport math\nfrom itertools import combinations\n\n# tested with Python 3.7.0 & Gurobi 9.1.0\n\n# Create a dictionary to capture the farm coordinates (10 miles) and collection requirements (1,000).\n\nfarms, coordinates, collect  = gp.multidict({\n    0: [(0,0),0],\n    1: [(-3,3),5],\n    2: [(1,11),4],\n    3: [(4,7),3],\n    4: [(-5,9),6],\n    5: [(-5,-2),7],\n    6: [(-4,-7),3],\n    7: [(6,0),4],\n    8: [(3,-6),6],\n    9: [(-1,-3),5],\n    10: [(0,-6),4],\n    11: [(6,4),7], \n    12: [(2,5),3],\n    13: [(-2,8),4],\n    14: [(6,10),5],\n    15: [(1,8),6],\n    16: [(-3,1),8],\n    17: [(-6,5),5],\n    18: [(2,9),7],\n    19: [(-6,-5),6],\n    20: [(5,-4),6]\n})\n\n# List of farm  including the depot\nfarms = [*range(0,21)]\n\n# List of farms that are visited everyday\neveryDay = [*range(0,10)]\n\n# List of farms that are visited each other day\notherDay = [*range(10,21)]\n\n# List of day types\ndayType = [1,2]\n\n# Tanker lorry capacity (1,000)\ntankerCap = 80\n\n# Every day farms requirements\neveryDayReq = 0\nfor i in everyDay:\n    everyDayReq += collect[i]\n\n# Compute pairwise distance matrix\n# numpy linalg norm = euclidean n=2\n\ndef distance(city1, city2):\n    c1 = coordinates[city1]\n    c2 = coordinates[city2]\n    diff = (c1[0]-c2[0], c1[1]-c2[1])\n    return math.sqrt(diff[0]*diff[0]+diff[1]*diff[1])\n\ndist = {(c1, c2): distance(c1, c2) for c1, c2 in combinations(farms, 2)}\n\n# Create the model object m\nm = gp.Model('MilkCollection.lp')\n\n# Decision variables: \n\n# Edge variables = 1, if farm 'i' is adjacent to farm 'j' on the tour of day type 'k'.\nvars = m.addVars(dist, dayType, vtype=GRB.BINARY, name='x')\n\n# Other day variables = 1, if farm 'i' is visited on the tour of day type 'k'.\nother_var = m.addVars(otherDay, dayType, vtype=GRB.BINARY, name='y') \n\n# Symmetry constraints: copy the object (not a constraint)\nvars.update({(j,i,k):vars[i,j,k] for i,j,k in vars.keys()})\n\n# Every day constraints: two edges incident to an every day farm on tour of day type 'k'. \nm.addConstrs((vars.sum(i,'*',k) == 2 for i in everyDay for k in dayType  ), name='everyDay')\n\n# Other day constraints: two edges incident to an other day farm on tour of day type 'k'.\nm.addConstrs((vars.sum(i,'*',k) == 2*other_var[i,k] for i in otherDay for k in dayType ), name='otherDay')\n\n# Tanker capacity constraint.\nm.addConstrs(( gp.quicksum(collect[i]*other_var[i,k] for i in otherDay ) <= tankerCap-everyDayReq for k in dayType ),\n             name='tankerCap')\n\n# Other day farms are visited on day type 1 or 2.\notherDayFarms = m.addConstrs((other_var.sum(i, '*') == 1 for i in otherDay), name='visited')\n\n# Avoid symmetric alternative solutions\nother_var[11,1].lb = 1\n\n# Objective function: minimize total distance travel\nm.setObjective(gp.quicksum(dist[i,j]*vars[i,j,k] for i,j in dist.keys() for k in dayType), GRB.MINIMIZE)\n\n# Find the edges from solution values, as a tuplelist for each dayType\ndef selected(vals):\n    s = {k:gp.tuplelist() for k in dayType}\n    for i, j, k in vals.keys():\n        if vals[i,j,k] > 0.5:\n            s[k].append((i,j))\n    return s\n# Alternately, using comprehension syntax:\n#    return {k:gp.tuplelist((i, j) for i, j, k in vals.keys().select('*','*',k) if vals[i,j,k] > 0.5) for k in dayType}\n            \n# Given a tuplelist of edges, find the shortest subtour\ndef subtour(edges):\n    nodes = set(i for e in edges for i in e)\n    unvisited = list(nodes)\n    cycle = list(nodes)\n    while unvisited:  \n        thiscycle = []\n        neighbors = unvisited\n        while neighbors:\n            current = neighbors[0]\n            thiscycle.append(current)\n            unvisited.remove(current)\n            neighbors = [j for i, j in edges.select(current, '*')\n                         if j in unvisited]\n        if len(thiscycle) <= len(cycle): # even if it's the same, we reuse it so that we get the final tour in order\n            cycle = thiscycle # New shortest subtour\n    return cycle\n\n# Callback - use lazy constraints to eliminate sub-tours\ndef subtourelim(model, where):\n    if where == GRB.Callback.MIPSOL:\n        # get edges selected in the current solution\n        vals = model.cbGetSolution(model._vars)\n        edges = selected(vals)\n        for k in dayType:\n            tour = subtour(edges[k])\n            if len(tour) < 0.5*len(edges[k]): # 0.5 due to symmetry: there are both edges i,j and j,i\n                # add subtour elimination constr. for farms visited that day\n                model.cbLazy(gp.quicksum(model._vars[i, j, k] for i, j in combinations(tour, 2))\n                             <= len(tour)-1)\n\n# Optimize the model\n\nm.reset()\nm._vars = vars\nm.Params.lazyConstraints = 1\nm.optimize(subtourelim)\n\n# Print optimal routes and distance traveled\n\nprint(f\"The optimal distance traveled is: {10*round(m.objVal)} miles.\")\n\nvals = m.getAttr('X', vars)\nedges = selected(vals)\n\nfor k in dayType:\n    tour = subtour(edges[k])\n    tour.append(0) # return to depot\n    print (\"Route for day type %i: %s\" % (k, \" -> \".join(map(str, tour))))"}]}
{"meta": {"source_path": "/Users/sunyujun03/Desktop/ReLoop/gurobi-modeling-examples/protein_comparison/protein_comparison.ipynb", "kind": "ipynb", "title": "Protein Comparison"}, "messages": [{"role": "system", "content": "You are an optimization engineer. Write correct and runnable Python code using gurobipy (Gurobi Python API). Be concise. Output only what is requested."}, {"role": "user", "content": "    Task: Reproduce the following Gurobi modeling example in Python using gurobipy.\n\n    Scenario description (from source):\n    # Protein Comparison\n\n## Objective and Prerequisites\n\nIn this example, we’ll show you how to use mathematical optimization to address a Protein Comparison problem. You’ll learn how to model this problem – which involves measuring the similarities of two proteins – as a quadratic assignment problem using the Gurobi Python API and find an optimal solution to it with the Gurobi Optimizer.\n\nThis model is example 29 from the fifth edition of Model Building in Mathematical Programming by H. Paul Williams on pages 290-291 and 345.\n\nThis modeling example is at the advanced level, where we assume that you know Python and the Gurobi Python API and that you have advanced knowledge of building mathematical optimization models. Typically, the objective function and/or constraints of these examples are complex or require advanced features of the Gurobi Python API.\n\n**Download the Repository** <br /> \nYou can download the repository containing this and other examples by clicking [here](https://github.com/Gurobi/modeling-examples/archive/master.zip). \n\n## Problem Description\n\nThis problem is based on one problem discussed in a paper by Forrester and Greenberg (2008).\nIt is concerned with measuring the similarities of two proteins. A protein can be\nrepresented by a graph with the acids represented by the nodes and\nthe edges being present when two acids are within a threshold distance of each\nother. This graphical representation is known as the contact map of the protein.\nGiven two contact maps representing proteins, we would like to find the largest\n(measured by the number of corresponding edges) isomorphic subgraphs in each\ngraph. The acids in each of the proteins are ordered. We need to preserve this\nordering in each of the subgraphs, which implies that there can be no crossovers\nin the comparison. This is illustrated in the following figure. \n\n![crossover](crossover.PNG)\n\nIf $i < k$ in the contact map for the first protein then we cannot have $l < j$ in the second protein, if $i$ is to be\nassociated with $j$ and $k$ with $l$ in the comparison. The following figure gives a comparison between two small contact\nmaps leading to five corresponding edges.\n\n![comparison](comparison.PNG)\n\nThe goal is to compare the contact maps given by the following figures.\n\nMapping of the first protein:\n\n![map1](map1.PNG)\n\nMapping of the second protein:\n\n![map1](map2.PNG)\n\n## Model Formulation\n\nThe mapping of the first protein is represented by the graph $G_{1} = (N_{1},E_{1})$, and the  mapping of the second protein is represented by the  graph $G_{2} = (N_{2},E_{2})$\n\n### Sets and Indices\n\n$i,k \\in N_{1} =\\{1,2,...,9\\}$: Nodes in graph $G_{1}$ which are the acids in the first protein.\n\n$E_{1} = \\{(1,2),(2,9),(3,4),(3,5),(5,6),(6,7),(7,9),(8,9) \\}$: Edges in graph $G_{1}$.\n\n$j,l \\in N_{2} =\\{1,2,...,11\\} $: Nodes in graph $G_{2}$ which are the acids in the second protein.\n\n$E_{2} = \\{(1,4),(2,3),(4,6),(4,7),(5,6),(6,8),(7,8),(7,10),(9,10),(10,11) \\}$: Edges in graph $G_{2}$.\n\n### Decision variables\n\n$\\text{map}_{i,j} = x_{i,j} = 1$, iff node $i$ in $G_{1}$ is matched with node $j$ in $G_{2}$.\n\n$ w_{i,j,k,l} = x_{i,j}*x_{k,l}  = 1$, iff an edge $(i,k) \\in E_{1}$ is matched with edge $(j,l) \\in E_{2}$.\n\n### Constraints\n\n**$G_{1}$ matching**: No node in $G_{1}$ can be matched with more than one  in $G_{2}$.\n\n$$\n\\sum_{i \\in N_{1} } x_{i,j} \\leq 1 \\quad \\forall j \\in N_{2}\n$$\n\n**$G_{2}$ matching**: No node in $G_{2}$ can be matched with more than one  in $G_{1}$.\n\n$$\n\\sum_{j \\in N_{2} } x_{i,j} \\leq 1 \\quad \\forall i \\in N_{1}\n$$\n\n**Edge matching**: if edges $(i, k)$ and $(j, l)$ are matched then so are the corresponding nodes.\n\n$$\n w_{i,j,k,l} \\leq x_{i,j}, \\;  w_{i,j,k,l} \\leq x_{k,l} \\quad \\forall \n (i,j,k,l) \\in ijkl = \\{ i,k \\in N_{1}, j,l \\in N_{2}: (i,k) \\in E_{1},  (j,l) \\in E_{2}  \\}\n$$\n\n**No crossovers**: There can be no crossovers.\n\n$$\nx_{i,j} +  x_{k,l} \\leq 1 \\quad \\forall \n(i,j,k,l) \\in ijklx = \\{ (i,j,k,l) \\in ijkl: i < k \\in N_{1},  j > l \\in N_{2}  \\}\n$$\n\n### Objective function\nThe objective is to maximize the number of edge matchings.\n\n$$\n\\sum_{(i,j,k,l) \\in ijkl} w_{i,j,k,l}\n$$\n\nThis linear integer programming formulation of the Protein Comparison problem is in fact a linearization of a quadratic assignment formulation of this problem. With Gurobi 9.1.0, you can directly solve the quadratic assignment formulation of the Protein Comparison problem without the auxiliary variables and the logical constraints.\n\n### Objective function\nThe objective is to maximize the number of edge matchings.\n\n$$\n\\sum_{(i,j,k,l) \\in ijkl} x_{i,j}*x_{k,l}\n$$\n\n### Constraints\n\n**$G_{1}$ matching**: No node in $G_{1}$ can be matched with more than one  in $G_{2}$.\n\n$$\n\\sum_{i \\in N_{1} } x_{i,j} \\leq 1 \\quad \\forall j \\in N_{2}\n$$\n\n**$G_{2}$ matching**: No node in $G_{2}$ can be matched with more than one  in $G_{1}$.\n\n$$\n\\sum_{j \\in N_{2} } x_{i,j} \\leq 1 \\quad \\forall i \\in N_{1}\n$$\n\n**No crossovers**: There can be no crossovers.\n\n$$\nx_{i,j} +  x_{k,l} \\leq 1 \\quad \\forall \n(i,j,k,l) \\in ijklx = \\{ (i,j,k,l) \\in ijkl: i < k \\in N_{1},  j > l \\in N_{2}  \\}\n$$\n\n## Input Data\n\n    Requirements:\n    - Use gurobipy (Model, GRB, addVar/addConstr, etc.)\n    - Make the script runnable as a standalone Python file if possible.\n    - Keep the code faithful to the example.\n"}, {"role": "assistant", "content": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# tested with Python 3.7.0 & Gurobi 9.1.0\n\n# nodes in G1\n\nnodes1 = [*range(1,10)]\n\n# edges (i,k) in G1\n\nedges1 = [(1,2),(2,9),(3,4),(3,5),(5,6),(6,7),(7,9),(8,9)]\n\n# nodes in G2\n\nnodes2 = [*range(1,12)]\n\n# edges (j,l) in G2\n\nedges2 = [(1,4),(2,3),(4,6),(4,7),(5,6),(6,8),(7,8),(7,10),(9,10),(10,11)]\n\n# Node matching: matchings of nodes in G1 with nodes in G2\n\nlist_ij = []\n\nfor i in nodes1:\n    for j in nodes2:\n        tp = i,j\n        list_ij.append(tp)\n        \nij = gp.tuplelist(list_ij)\n\n# Edge matching: matchings of edges in G1 with edges in G2\n\nlist_ijkl = []\n\nfor i,k in edges1:\n    for j,l in edges2:\n        tp = i,j,k,l\n        list_ijkl.append(tp)\n        \nijkl = gp.tuplelist(list_ijkl)\n\n# No crossover \n\nlist_nox = []\n\nfor i,j in ij:\n    for k,l in ij:\n        if i < k and l < j:\n            tp = i,j,k,l\n            list_nox.append(tp)\n            \nnox = gp.tuplelist(list_nox)\n\nmodel = gp.Model('ProteinComparison')\n\n# Map nodes in G1 with nodes in G2\nmap_nodes = model.addVars(ij, vtype=GRB.BINARY, name=\"map\")\n\n# At most one node in G1 is matched with a node in G2\n\nnode1_match = model.addConstrs((gp.quicksum(map_nodes[i,j] for i in nodes1) <= 1 for j in nodes2 ) ,name='node1_match')\n\n# At most one node in G2 is matched with a node in G1\n\nnode2_match = model.addConstrs((gp.quicksum(map_nodes[i,j] for j in nodes2) <= 1 for i in nodes1 ) ,name='node2_match')\n\n# No crossovers\n\nno_crossover = model.addConstrs((map_nodes[i,j] + map_nodes[k,l] <= 1 for i,j,k,l in nox), name='no_crossover')\n\n# Objective function\n\nmodel.setObjective(gp.quicksum(map_nodes[i,j]*map_nodes[k,l] for i,j,k,l in ijkl ) , GRB.MAXIMIZE )\n\n# Verify model formulation\n\nmodel.write('ProteinComparison.lp')\n\n# Run optimization engine\n\nmodel.optimize()\n\n# Output report\n\nprint(f\"Maximum number of edge matches: {round(model.objVal)}\") \n\n\nfor i,j,k,l in ijkl:\n    if map_nodes[i,j].x*map_nodes[k,l].x > 0.5:\n        print(f\"Edge {i,k} in G1 is mapped with edge {j,l} in G2\")"}]}
{"meta": {"source_path": "/Users/sunyujun03/Desktop/ReLoop/gurobi-modeling-examples/linear_regression/l0_regression.ipynb", "kind": "ipynb", "title": "Best Subset Selection: L0-Regression"}, "messages": [{"role": "system", "content": "You are an optimization engineer. Write correct and runnable Python code using gurobipy (Gurobi Python API). Be concise. Output only what is requested."}, {"role": "user", "content": "    Task: Reproduce the following Gurobi modeling example in Python using gurobipy.\n\n    Scenario description (from source):\n    # Best Subset Selection: L0-Regression\n\n## Objective and Prerequisites\n\nIn this example, you will learn how to perform linear regression with feature selection using mathematical programming. We’ll show you how to construct a mixed-integer quadratic programming (MIQP) model of this linear regression problem, implement this model in the Gurobi Python API, and generate an optimal solution.\n\nThis modeling example is at the intermediate level, where we assume that you know Python and are familiar with the Gurobi Python API. In addition, you should have some knowledge about building mathematical optimization models.\n\n**Download the Repository** <br />\nYou can download the repository containing this and other examples by clicking [here](https://github.com/Gurobi/modeling-examples/archive/master.zip). \n\n---\n## Motivation\n\nLinear regression was invented at the beginning of the 19th century and today, after more than 200 years, it is still used extensively in practical applications for description and prediction purposes:\n\n- In econometrics, it is useful to estimate the price elasticity of a particular product by regressing sales revenue on price and possibly other features such as demographics and competitor and retail information.\n- In health sciences, it can be applied to predict how long a patient will remain (i.e. length of stay) in the ER of a hospital based on patient information, triage assessment, medical test results, and the date/time of arrival.\n- In social sciences, it may shed light on future academic performance of students, so proactive measures can be taken to improve their learning outcomes.\n\nIn general, linear regression is used to model the relationship between a continuous variable and other explanatory variables, which can be either continuous or categorical. When applying this technique, finding the subset of features that maximizes its perfomance is often of interest.\n\n---\n## Problem Description\n\nLinear regression is a supervised learning algorithm used to predict a quantitative response. It assumes that there is a linear relationship between the feature vector $x_i \\in \\mathbb{R}^d$ and the response $y_i \\in \\mathbb{R}$. Mathematically speaking, for sample $i$ we have $y_i = \\beta^T x_i + \\epsilon_i$, where $\\beta \\in \\mathbb{R}^d$ is the vector of feature weights, including the intercept, and  $\\epsilon_i$ is a normally-distributed random variable with zero mean and constant variance representing the error term. We can learn the weights from a training dataset with $n$ observations $\\{X \\in \\mathbb{M}^{nxd},y \\in \\mathbb{R}^n\\}$ by minimizing the Residual Sum of Squares (RSS): $e^Te =(y-X\\beta)^T (y-X\\beta)=\\beta^T X^T X\\beta- 2y^TX\\beta+y^T y$. The Ordinary Least Squares (OLS) method achieves this by taking the derivative of this quadratic and convex function and then finding the stationary point: $\\beta_{OLS}=(X^T X)^{-1} X^T y$.\n\nIn practice, some of the features are in fact not associated with the response. By including them, we only add unnecessary complexity to the model and increase variance to the weight estimates. However, finding the best performing model is no simple task as there is an exponential number of candidates, as one has to test $\\sum_{s=1}^{d-1}{{d-1} \\choose s}$ models. Since OLS rarely yields estimates that are exactly zero, thus discarding the features related to them, we need to resort to feature selection methods. Popular methods include:\n\n- Subset selection, e.g. stepwise selection.\n- Dimensionality reduction, e.g. principal component regression.\n- Shrinkage, e.g. the Lasso.\n\nThe Lasso has undoubtedly been the method of choice for the last decade. Basically it fits a model containing all $d$ predictors, while incorporating a budget constraint based on the L1-norm of $\\beta$, disregarding the intercept component. In fact, this method minimizes the RSS, subject to $\\sum_{l=1}^{d-1}\\mathopen|\\beta_l\\mathclose| \\leq s$, where $s$ is a hyper-parameter representing the budget that is usually tuned via cross-validation. This constraint has the effect of shrinking all weight estimates, allowing some of them to be exactly zero when $s$ is small enough. Finally, it is worth noting that the unconstrained version of the Lasso is more frequently used. This version solves an unconstrained optimization problem where $RSS + \\lambda \\sum_{l=1}^{d-1}\\mathopen|\\beta_l\\mathclose|$ is minimized, for a given value of the —modified— lagrangian multiplier $\\lambda \\in \\mathbb{R}^+$.  \n\nA similar formulation is now presented, where the L0-norm is used instead (although it is not really a proper norm). We now seek to minimize the RSS, subject to $\\sum_{l=1}^{d-1}I(\\beta_l \\neq 0) \\leq s$, where $I(\\beta_l \\neq 0)$ is an indicator function taking on the value of 1 if $\\beta_j \\neq 0$ and 0 otherwise. In this setting, $s$ represents the number of features to consider in the model. This optimization problem may be casted as a Mixed Integer Quadratic Program (MIQP). Traditionally, the feature selection problem has not been tackled this way because of the common belief in the statistics community that large-scale problems are intractable. But this is no longer the case, considering the computing power currently available and the performance of modern optimization solvers such as Gurobi.\n\n---\n## Solution Approach\n\nMathematical programming is a declarative approach where the modeler formulates a mathematical optimization model that captures the key aspects of a complex decision problem. The Gurobi Optimizer solves such models using state-of-the-art mathematics and computer science. \n\nA mathematical optimization model has five components, namely:\n\n- Sets and indices.\n- Parameters.\n- Decision variables.\n- Objective function(s).\n- Constraints.\n\nWe now present a MIQP formulation that finds the weight estimates for a linear regression problem, where exactly $s$ of those weights can be nonzero:\n\n### Sets and Indices\n\n$l \\in L$: Set of features, where the intercept is excluded.\n\n### Parameters\n\n$s \\in \\mathbb{N}$: Number of features to include in the model, ignoring the intercept.\n\n### Decision Variables\n\n$\\beta \\in \\mathbb{R}^d$: Vector of feature weights, where the j-th element represents the change in the response variable per unit-change of feature $j$. Recall that the last component corresponds to the intercept.\n\n$\\text{norm}_0 \\in \\mathbb{R}$: Number of non-zero elements of vector $\\beta$, disregarding the intercept.\n\n### Objective Function\n\n- **Training error**: Minimize the Residual Sum of Squares (RSS):\n\n\\begin{equation}\n\\text{Min} \\quad Z = \\beta^T X^T X\\beta- 2y^TX\\beta+y^T y\n\\tag{0}\n\\end{equation}\n\n### Constraints\n\n- **L0-norm**: Compute the number of features with non-zero weights:\n\n\\begin{equation}\n\\text{norm}_0 = \\sum_{l \\in L}I(\\beta_l \\neq 0)\n\\tag{1}\n\\end{equation}\n\n- **Budget constraint**: Exactly $s$ feature weights can be non-zero:\n\n\\begin{equation}\n\\text{norm}_0 = s\n\\tag{2}\n\\end{equation}\n\nThis model, by means of constraint 2, implicitly considers all ${{d-1} \\choose s}$ feature subsets at once. However, we also need to find the value for $s$ that maximizes the performance of the regression on unseen observations. Notice that the training RSS decreases monotonically as more features are considered (which translates to relaxing the MIQP), so it is not advisable to use it as the performance metric. Instead, we will estimate the Mean Squared Error (MSE) via cross-validation. This metric is defined as $\\text{MSE}=\\frac{1}{n}\\sum_{i=1}^{n}{(y_i-\\hat{y}_i)^2}$, where $y_i$ and $\\hat{y}_i$ are the observed and predicted values for the ith observation, respectively. Then, we will fine-tune $s$ using grid search, provided that the set of possible values is quite small.\n\n---\n## Python Implementation\n\nIn the following implementation, we use four main libraries:\n\n- **Numpy** for scientific computing.\n- **Scikit learn** for machine learning algorithms.\n- **Gurobi** for mathematical optimization.\n- **Matplotlib** for visualization.\n\n---\n## Benchmark\n\nWe now compare the performance of the aforementioned approach w.r.t. OLS regression on all features and the Lasso. The Boston dataset is used for this purpose. This dataset measures the prices of 506 houses, along with 13 features that provide insights about their neighbourhoods. We will use the original feature terminology, so the interested reader can visit [this website](https://www.cs.toronto.edu/~delve/data/boston/bostonDetail.html) for more information.\n\nNote that 20% of the samples are reserved for computing the out-of-sample MSE. The resulting metrics are displayed in a bar chart (shown below) to facilitate the comparison between models.\n\nNotice that the Lasso performs poorly, as we did not standardize the features to be expressed in the same units (with an average of zero and variance of one). Contrary to OLS and L0-Regression, the Lasso is not scale-invariant because the budget constraint is based on the L1-norm. Remember that $\\beta_l$ is interpreted as the change in the response per unit-change of feature $l$. Since the L1-norm takes the sum of absolute values, how much of the budget $\\beta_l$ consumes depends on the units of measurement of the feature associated to it. \n\nSuch preprocessing entails three steps, namely:\n\nFor each feature $x_l$:\n1. Compute its sample average $\\mu_l$ and sample standard deviation $\\sigma_l$.\n2. Center by subtracting $\\mu_l$ from $x_l$.\n3. Scale by dividing the resulting difference by $\\sigma_l$.\n\nIn order to report the performance of the Lasso after applying standardization, we need to perform hyper-parameter tuning on the L1-norm penalty via cross-validation. Unfortunately, we must not use the model class `LassoCV`. This is due to the fact that standardization is not supported, and doing that beforehand over the whole dataset would contaminate the folds. In order to prevent that from happening, we will perform random search as follows:\n\nLet's now compare the performance of the models considered when the features are preprocessed. Notice that our user-defined function `L0-regression` does support standardization of the features:\n\n    Requirements:\n    - Use gurobipy (Model, GRB, addVar/addConstr, etc.)\n    - Make the script runnable as a standalone Python file if possible.\n    - Keep the code faithful to the example.\n"}, {"role": "assistant", "content": "# Let's import all the necessary libraries\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport pandas as pd\nfrom itertools import product\nfrom sklearn.preprocessing import StandardScaler\nfrom sklearn.pipeline import make_pipeline\nfrom sklearn.model_selection import cross_val_score\nfrom sklearn import linear_model\nfrom sklearn.metrics import mean_squared_error as mse\nfrom sklearn.model_selection import train_test_split\n\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# Create and deploy the optimization model\n\n# NOTE: This function assumes the design matrix features does not contain\n#a column for the intercept\ndef miqp(features, response, non_zero, verbose=False):\n    \"\"\"\n    Deploy and optimize the MIQP formulation of L0-Regression.\n    \"\"\"\n    assert isinstance(non_zero, (int, np.integer))\n    # Create a Gurobi environment and a model object\n    with gp.Env() as env, gp.Model(\"\", env=env) as regressor:\n        samples, dim = features.shape\n        assert samples == response.shape[0]\n        assert non_zero <= dim\n\n        # Append a column of ones to the feature matrix to account for the y-intercept\n        X = np.concatenate([features, np.ones((samples, 1))], axis=1)  \n\n        # Decision variables\n        norm_0 = regressor.addVar(lb=non_zero, ub=non_zero, name=\"norm\")\n        beta = regressor.addMVar((dim + 1,), lb=-GRB.INFINITY, name=\"beta\") # Weights\n        intercept = beta[dim] # Last decision variable captures the y-intercept\n\n        regressor.setObjective(beta.T @ X.T @ X @ beta\n                               - 2*response.T @ X @ beta\n                               + np.dot(response, response), GRB.MINIMIZE)\n\n        # Budget constraint based on the L0-norm\n        regressor.addGenConstrNorm(norm_0, beta[:-1], which=0, name=\"budget\")\n\n        if not verbose:\n            regressor.params.OutputFlag = 0\n        regressor.params.timelimit = 60\n        regressor.params.mipgap = 0.001\n        regressor.optimize()\n\n        coeff = np.array([beta[i].X for i in range(dim)])\n        return intercept.X, coeff\n\n# Define functions necessary to perform hyper-parameter tuning via cross-validation\n\ndef split_folds(features, response, train_mask):\n    \"\"\"\n    Assign folds to either train or test partitions based on train_mask.\n    \"\"\"\n    xtrain = features[train_mask,:]\n    xtest = features[~train_mask,:]\n    ytrain = response[train_mask]\n    ytest = response[~train_mask]\n    return xtrain, xtest, ytrain, ytest\n\ndef cross_validate(features, response, non_zero, folds, standardize, seed):\n    \"\"\"\n    Train an L0-Regression for each fold and report the cross-validated MSE.\n    \"\"\"\n    if seed is not None:\n        np.random.seed(seed)\n    samples, dim = features.shape\n    assert samples == response.shape[0]\n    fold_size = int(np.ceil(samples / folds))\n    # Randomly assign each sample to a fold\n    shuffled = np.random.choice(samples, samples, replace=False)\n    mse_cv = 0\n    # Exclude folds from training, one at a time, \n    #to get out-of-sample estimates of the MSE\n    for fold in range(folds):\n        idx = shuffled[fold * fold_size : min((fold + 1) * fold_size, samples)]\n        train_mask = np.ones(samples, dtype=bool)\n        train_mask[idx] = False\n        xtrain, xtest, ytrain, ytest = split_folds(features, response, train_mask)\n        if standardize:\n            scaler = StandardScaler()\n            scaler.fit(xtrain)\n            xtrain = scaler.transform(xtrain)\n            xtest = scaler.transform(xtest)\n        intercept, beta = miqp(xtrain, ytrain, non_zero)\n        ypred = np.dot(xtest, beta) + intercept\n        mse_cv += mse(ytest, ypred) / folds\n    # Report the average out-of-sample MSE\n    return mse_cv\n\ndef L0_regression(features, response, folds=5, standardize=False, seed=None):\n    \"\"\"\n    Select the best L0-Regression model by performing grid search on the budget.\n    \"\"\"\n    dim = features.shape[1]\n    best_mse = np.inf\n    best = 0\n    # Grid search to find best number of features to consider\n    for i in range(1, dim + 1):\n        val = cross_validate(features, response, i, folds=folds,\n                             standardize=standardize, seed=seed)\n        if val < best_mse:\n            best_mse = val\n            best = i\n    if standardize:\n        scaler = StandardScaler()\n        scaler.fit(features)\n        features = scaler.transform(features)\n    intercept, beta = miqp(features, response, best)\n    return intercept, beta\n\n# Define how the bar chart should be displayed\n\ndef plot_bar_chart(performance):\n    \"\"\"\n    Display the performance of all three models in a bar chart.\n    \"\"\"\n    bar = plt.bar([1, 2, 3], performance, color=['r', 'g', 'y'],\n                  tick_label=['OLS', 'Lasso', 'L0-Regression'])\n    plt.title('Out-of-Sample MSE')\n    x1, x2, y1, y2 = plt.axis()\n    plt.axis((x1, x2, np.floor(np.min(performance)),\n              np.ceil(np.max(performance))))\n    plt.show()\n\n# Load data and split into train (80%) and test (20%)\ndata_url = \"http://lib.stat.cmu.edu/datasets/boston\"\nraw_df = pd.read_csv(data_url, sep=\"\\s+\", skiprows=22, header=None)\nX = np.hstack([raw_df.values[::2, :], raw_df.values[1::2, :2]])\ny = raw_df.values[1::2, 2]\nXtrain, Xtest, ytrain, ytest = train_test_split(X, y, test_size=0.20,\n                                                random_state=10101)\n\n# OLS regression using all features\nlr = linear_model.LinearRegression()\nlr.fit(Xtrain, ytrain)\n# Lasso with cross-validated penalization (lambda)\nlasso = linear_model.LassoCV(cv=5)\nlasso.fit(Xtrain, ytrain)\n# L0-regression where the best feature subset is selected via cross-validation\nintercept, beta = L0_regression(Xtrain, ytrain, seed=10101)\n\n# Compare their performance using a bar chart\nperformance = []\nperformance.append(mse(ytest, lr.predict(Xtest)))\nperformance.append(mse(ytest, lasso.predict(Xtest)))\nperformance.append(mse(ytest, np.dot(Xtest, beta) + intercept))\nplot_bar_chart(performance)\n\nnp.random.seed(10101)\nnum_tries = 500\nbest_alpha = None\nbest_score = -np.inf\nfor i in range(num_tries):\n    # log-linear search for alpha in the domain [0.001, 1000]\n    exponent = np.random.uniform(-3, 3)\n    alpha = np.power(10, exponent)\n    pipeline = make_pipeline(StandardScaler(), linear_model.Lasso(alpha=alpha))\n    scores = cross_val_score(pipeline, Xtrain, ytrain, cv=5, scoring='neg_mean_squared_error')\n    avg_score = np.mean(scores)\n    if avg_score > best_score:\n        best_score = avg_score\n        best_alpha = alpha\n\n# Standardize the features so they have an avg of 0 and a sample var of 1\nscaler = StandardScaler()\nscaler.fit(Xtrain)\nXtrain_std = scaler.transform(Xtrain)\nXtest_std = scaler.transform(Xtest)\n\n# OLS regression using all features\nlr = linear_model.LinearRegression()\nlr.fit(Xtrain_std, ytrain)\n\n# Lasso with cross-validated penalization (lambda)\nlasso = linear_model.Lasso(alpha=best_alpha)\nlasso.fit(Xtrain_std, ytrain)\n# L0-regression where the best feature subset is selected via cross-validation\nintercept, beta = L0_regression(Xtrain, ytrain, standardize=True, seed=10101)\n\n# Compare their performance using a Bar chart\nperformance = []\nperformance.append(mse(ytest, lr.predict(Xtest_std)))\nperformance.append(mse(ytest, lasso.predict(Xtest_std)))\nperformance.append(mse(ytest, np.dot(Xtest_std, beta) + intercept))\nplot_bar_chart(performance)\n\nols_features = np.sum(np.abs(lr.coef_) >= 1e-8)\nlasso_features = np.sum(np.abs(lasso.coef_) >= 1e-8)\nl0_features = np.sum(np.abs(beta) >= 1e-8)\nprint(\"OLS regression kept {0} features.\".format(ols_features))\nprint(\"The Lasso kept {0} features.\".format(lasso_features))\nprint(\"L0-Regression kept {0} features.\".format(l0_features))"}]}
{"meta": {"source_path": "/Users/sunyujun03/Desktop/ReLoop/gurobi-modeling-examples/cell_tower_coverage/cell_tower.ipynb", "kind": "ipynb", "title": "Cell Tower Coverage"}, "messages": [{"role": "system", "content": "You are an optimization engineer. Write correct and runnable Python code using gurobipy (Gurobi Python API). Be concise. Output only what is requested."}, {"role": "user", "content": "    Task: Reproduce the following Gurobi modeling example in Python using gurobipy.\n\n    Scenario description (from source):\n    # Cell Tower Coverage\n\n## Objective and Prerequisites\n\nWant to learn how to configure a network of cell towers to provide signal coverage to the largest number of people possible? In this example, you’ll learn how to solve this simple covering problem. We’ll show you how to construct a mixed-integer programming (MIP) model of the problem, implement this model in the Gurobi Python API, and find an optimal solution using the Gurobi Optimizer.\n\nThis modeling example is at the beginner level, where we assume that you know Python and that you have some knowledge about building mathematical optimization models.\n\n**Download the Repository:** <br />\nYou can download the repository containing this and other examples by clicking [here](https://github.com/Gurobi/modeling-examples/archive/master.zip). \n\n## Motivation\n\nOver the last ten years, smartphones have revolutionized our lives in ways that go well beyond how we communicate. Besides calling, texting, and emailing, more than two billion people around the world now use these devices to navigate to book cab rides, to compare product reviews and prices, to follow the news, to watch movies, to listen to music, to play video games,to take photographs, to participate in social media, and for numerous other applications.\n\nA cellular network is a network of handheld smartphones in which each phone communicates with the telephone network by radio waves through a local antenna at a cellular base station (cell tower). One important problem is the placement of cell towers to provide signal coverage to the largest number of people.\n\n## Problem Description\n\nA telecom company needs to build a set of cell towers to provide signal coverage  for the inhabitants of a given city. A number of potential locations where the towers could be built have been identified. The towers have a fixed range, and -due to budget constraints- only a limited number of them can be built. Given these restrictions, the company wishes to provide coverage to the largest percentage of the population possible. To simplify the problem, the company has split the area it wishes to cover into a set of regions, each of which has a known population. The goal is then to choose  which of the potential locations the company should build cell towers on -in order to provide coverage to as many people as possible.\n\nThe Cell Tower Coverage Problem is an instance of the Maximal Covering Location Problem [1]. It is also related to the Set Cover Problem. Set covering problems occur in many different fields, and very important applications come from the airlines industry. For example, Crew Scheduling and Tail Assignment Problem [2].\n\n    Requirements:\n    - Use gurobipy (Model, GRB, addVar/addConstr, etc.)\n    - Make the script runnable as a standalone Python file if possible.\n    - Keep the code faithful to the example.\n"}, {"role": "assistant", "content": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# tested with Gurobi v9.0.0 and Python 3.7.0\n\n# Parameters\nbudget = 20\nregions, population = gp.multidict({\n    0: 523, 1: 690, 2: 420,\n    3: 1010, 4: 1200, 5: 850,\n    6: 400, 7: 1008, 8: 950\n})\n\nsites, coverage, cost = gp.multidict({\n    0: [{0,1,5}, 4.2],\n    1: [{0,7,8}, 6.1],\n    2: [{2,3,4,6}, 5.2],\n    3: [{2,5,6}, 5.5],\n    4: [{0,2,6,7,8}, 4.8],\n    5: [{3,4,8}, 9.2]\n})\n\n# MIP  model formulation\nm = gp.Model(\"cell_tower\")\n\nbuild = m.addVars(len(sites), vtype=GRB.BINARY, name=\"Build\")\nis_covered = m.addVars(len(regions), vtype=GRB.BINARY, name=\"Is_covered\")\n\nm.addConstrs((gp.quicksum(build[t] for t in sites if r in coverage[t]) >= is_covered[r]\n                        for r in regions), name=\"Build2cover\")\nm.addConstr(build.prod(cost) <= budget, name=\"budget\")\n\nm.setObjective(is_covered.prod(population), GRB.MAXIMIZE)\n\nm.optimize()\n\n# display optimal values of decision variables\n\nfor tower in build.keys():\n    if (abs(build[tower].x) > 1e-6):\n        print(f\"\\n Build a cell tower at location Tower {tower}.\")\n\n# Percentage of the population covered by the cell towers built is computed as follows.\n\ntotal_population = 0\n\nfor region in range(len(regions)):\n    total_population += population[region]\n\ncoverage = round(100*m.objVal/total_population, 2)\n\nprint(f\"\\n The population coverage associated to the cell towers build plan is: {coverage} %\")\n\n# Percentage of budget consumed to build cell towers\n\ntotal_cost = 0\n\nfor tower in range(len(sites)):\n    if (abs(build[tower].x) > 0.5):\n        total_cost += cost[tower]*int(build[tower].x)\n\nbudget_consumption = round(100*total_cost/budget, 2)\n\nprint(f\"\\n The percentage of budget consumed associated to the cell towers build plan is: {budget_consumption} %\")"}]}
{"meta": {"source_path": "/Users/sunyujun03/Desktop/ReLoop/gurobi-modeling-examples/optimization101/Modeling_Session_2/completed_Exercise_Set2.ipynb", "kind": "ipynb", "title": "Exercise Set 2"}, "messages": [{"role": "system", "content": "You are an optimization engineer. Write correct and runnable Python code using gurobipy (Gurobi Python API). Be concise. Output only what is requested."}, {"role": "user", "content": "    Task: Reproduce the following Gurobi modeling example in Python using gurobipy.\n\n    Scenario description (from source):\n    # Exercise Set 2\n\n### True or False\n\n**Q1.** Suppose the solar forecast for the week totaled more energy than the total demand. In this case it's guaranteed that no energy will be bought from the grid.\n- True\n- `False`\n\n### Formualtion and Coding\n\n    Requirements:\n    - Use gurobipy (Model, GRB, addVar/addConstr, etc.)\n    - Make the script runnable as a standalone Python file if possible.\n    - Keep the code faithful to the example.\n"}, {"role": "assistant", "content": "import gurobipy as gp\nfrom gurobipy import GRB\n\nbatteries = [\"Battery0\", \"Battery1\"]\ntime_periods = range(180)\ncapacity = {\"Battery0\": 60, \"Battery1\": 80} \np_loss = {\"Battery0\": 0.95, \"Battery1\": 0.9} \ninitial = {\"Battery0\": 20, \"Battery1\": 30} \n\nm = gp.Model() \n\n# flow_in = m.addVars(batteries, time_periods, name=\"flow_in\") \n# flow_out = m.addVars(batteries, time_periods, name=\"flow_out\")\n# grid = m.addVars(time_periods, name=\"grid\")\n# state = m.addVars(batteries, time_periods, name=\"state\") \n# gen = m.addVars(time_periods, name=\"gen\")\n\n#### gurobipy code\ngrid = m.addVars(time_periods, obj = 1, name=\"grid\")\nm.write('model.lp')\n\n#### gurobipy code\nstate = m.addVars(batteries, time_periods, name=\"state\") \ndepth_of_discharge = m.addConstrs((gp.quicksum(state[b,t] for b in batteries) >= 0.3*sum(capacity[b] for b in batteries) for t in time_periods), name = 'depth_restriction')\n\n#### gurobipy code\nm = gp.Model() # define the model again to make sure it is reset\nstate = m.addVars(batteries, time_periods, name=\"state\") \nstart_of_day = m.addConstrs((state[b,t] >= 0.4*capacity[b] for b in batteries for t in [30,60,90,120,150]), name = 'start_of_day') #in time_periods if t"}]}
{"meta": {"source_path": "/Users/sunyujun03/Desktop/ReLoop/gurobi-modeling-examples/optimization101/Modeling_Session_2/Exercise_Set2.ipynb", "kind": "ipynb", "title": "Exercise Set 2"}, "messages": [{"role": "system", "content": "You are an optimization engineer. Write correct and runnable Python code using gurobipy (Gurobi Python API). Be concise. Output only what is requested."}, {"role": "user", "content": "    Task: Reproduce the following Gurobi modeling example in Python using gurobipy.\n\n    Scenario description (from source):\n    # Exercise Set 2\n\n### True or False\n\n**Q1.** Suppose the solar forecast for the week totaled more energy than the total demand. In this case it's guaranteed that no energy will be bought from the grid.\n- True\n- False\n\n### Formualtion and Coding\n\n    Requirements:\n    - Use gurobipy (Model, GRB, addVar/addConstr, etc.)\n    - Make the script runnable as a standalone Python file if possible.\n    - Keep the code faithful to the example.\n"}, {"role": "assistant", "content": "import gurobipy as gp\nfrom gurobipy import GRB\n\nbatteries = [\"Battery0\", \"Battery1\"]\ntime_periods = range(180)\ncapacity = {\"Battery0\": 60, \"Battery1\": 80} \np_loss = {\"Battery0\": 0.95, \"Battery1\": 0.9} \ninitial = {\"Battery0\": 20, \"Battery1\": 30} \n\nm = gp.Model() \n\n# flow_in = m.addVars(batteries, time_periods, name=\"flow_in\") \n# flow_out = m.addVars(batteries, time_periods, name=\"flow_out\")\n# grid = m.addVars(time_periods, name=\"grid\")\n# state = m.addVars(batteries, time_periods, name=\"state\") \n# gen = m.addVars(time_periods, name=\"gen\")\n\n#### gurobipy code\n\n#### gurobipy code\nstate = m.addVars(batteries, time_periods, name=\"state\")\n\n#### gurobipy code\nm = gp.Model() # define the model again to make sure it is reset\nstate = m.addVars(batteries, time_periods, name=\"state\")"}]}
{"meta": {"source_path": "/Users/sunyujun03/Desktop/ReLoop/gurobi-modeling-examples/optimization101/Modeling_Session_2/energy_storage_ML.ipynb", "kind": "ipynb", "title": "Time Series Forecasting With Prophet: Creating Input for an Optimization Model"}, "messages": [{"role": "system", "content": "You are an optimization engineer. Write correct and runnable Python code using gurobipy (Gurobi Python API). Be concise. Output only what is requested."}, {"role": "user", "content": "    Task: Reproduce the following Gurobi modeling example in Python using gurobipy.\n\n    Scenario description (from source):\n    # Time Series Forecasting With Prophet: Creating Input for an Optimization Model\n\n## Introduction\n\nThe need to transition from traditional fossil fuel-based energy resources to renewable ones has intensified the adoption of solar and wind energy production. Yet, the sun is not always shining and the wind is not always blowing. When customers need energy might not coincide with those of high wind and solar potential which is a key chalenge associated with renewables energy sources. Batteries can be a solution to this problem making it possible to use energy that has been stored can be used at any time during the day by discharging the energy stored in the battery.\n\nIn this example, we will utilize solar energy with batteries to satisfy the energy demands of operating a university building and the associated courses that are taking place. In the next sections, we will describe the problem statement, and demonstrate how data science and mathematical optimization can be used to optimally solve the given problem.\n\nThe information used for this example have been adopted from [IEEE's Predict+Optimize Technical Challenge](https://ieee-dataport.org/competitions/ieee-cis-technical-challenge-predictoptimize-renewable-energy-scheduling).\n\n## Objective and Prerequisites\n\nIn this example, we consider a single university building on campus in Melbourne, Australia that has a set of courses scheduled over the course six days (Monday - Saturday). \n\nThe building and each courses have a certain energy demand that needs to be satisfied. The buidling's energy demand is assumed to known and each of the courses has a different demand based on the resources required (e.g. class size or a lab). The building has two solar panels installed which are capable of providing energy and there is also the capability of purchasing power directly from the electricity grid to satisfy the demand. Additionally, the building is equipped with two batteries which can store the energy provided from the solar panels, and can provide this energy when needeed. \n\nThe key learning component of this project is to integrate time series data forecasting with mathematical optimization. In contrast to the other examples in this library, here we incorporate a prediction horizon for the solar forecast which will be the major input for the optimization problem. \n\nThis example is for beginners in mathematical optimization. It assumes that you have some knowledge of data handling and data-driven modeling, as well as a basic understanding of Python and using the Gurobi Python API.\n\nThe presented problem requires the installation of the following Python packages:\n\n- **pandas**: for data analysis and manipulation \n- **numpy**: for mathematical calculations\n- **matplotlib**: for plotting and visualizing information\n- **prophet**: for predicting the future solar output\n\n## Problem Statement\n\nGiven a course schedule for the upcoming week and historical data about the solar potential, the objective is to determine the optimal battery charging and discharging schedule are in order to satisfy the energy demand for a building where the courses are held. The total energy demand is composed of the demand from the building itself plus the amount needed for each course. The example will look at two objectives:\n- Minimize the total electricity purchased from the grid during the upcoming week\n- Since elctricity prices fluctuate, minimize the total cost of electricy purchaced from the grid\n\nAt the same time, batteries have a finite capacity as well a limits on how much it can charge or discharge over a period of time. These impose constraints on the problem and make it difficult to solve. Additionally, while the solar panels can both provide electricty to meet demand directly, *each panel can charge only one battery*.\n\nFor simplicity, the time considered for each day will be limited to between 5am and 8pm. If you have access to a full Gurobi license (e.g. through our [Academic Program](https://www.gurobi.com/academia/academic-program-and-licenses/)) feel free to expand this to solve a much larger version of the problem. \n\nHere is a view of what the week's schedule will look like:\n\n<img src=\"ClassSchedule.png\" width=\"800\" align=\"left\"/>\n<br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>\n\n<h2> Solution Approach </h2>\n\nThe solution approach of the problem consists of two components: 1) **a forecasting component** for the solar availability and 2) **an optimization component** to determine what is the battery schedule as well as the amount of elecetricity purhcased from the grid.\n\nInitially, we will utilize the historical information about the solar potential of the area close to the university campus to forecast the solar output for the next week at a 15 minute interval. Given this information, as well as the demand of the university building and the energy demand of each of the courses in the building, we will formulate and solve a mixted-integer programming (MIP) problem to find the optimal solution to the problem for each of the above objectives using gurobipy.\n\n    Requirements:\n    - Use gurobipy (Model, GRB, addVar/addConstr, etc.)\n    - Make the script runnable as a standalone Python file if possible.\n    - Keep the code faithful to the example.\n"}, {"role": "assistant", "content": "import logging\nlogger = logging.getLogger()\nlogger.setLevel(logging.CRITICAL)\n\nimport pandas as pd\nimport numpy as np\nimport matplotlib\nimport matplotlib.pyplot as plt\nimport matplotlib.dates as mdates\nfrom matplotlib.dates import date2num\nfrom prophet import Prophet\nfrom prophet.diagnostics import cross_validation\nfrom datetime import datetime\nfrom gurobipy import Model, GRB, quicksum\n\nsolarData = pd.read_csv(r'SolarPanel.csv')\nsolarData.start_timestamp = pd.to_datetime(solarData.start_timestamp)\n# make the time local to Melbourne\nsolarData['start_timestamp'] += pd.to_timedelta(10, unit='h')\n\nplt.figure(figsize=(12,5))\nplt.scatter(solarData.start_timestamp, solarData.series_values, c='blue')\nplt.gcf().autofmt_xdate()\nplt.ylabel('Solar Power Generation (kW)');\n\nstart_date = '2020-07-15 05:00:00'\nend_date = '2020-07-16 19:45:00'\nplt.figure(figsize=(12,5))\nplt.plot(solarData.start_timestamp[(solarData.start_timestamp >= start_date) & (solarData.start_timestamp < end_date)], \n           solarData.series_values[(solarData.start_timestamp >= start_date) & (solarData.start_timestamp < end_date)], '-o', c='blue')\nplt.ylabel('Solar Power Generation (kW)');\n\ns0 = solarData[(solarData.start_timestamp >= '2020-04-03 15:30:00') & (solarData.start_timestamp < '2020-05-15 07:00:00')]\nplt.figure(figsize=(12,5))\nplt.scatter(s0.start_timestamp, s0.series_values, c='blue')\nplt.gcf().autofmt_xdate()\n\nsolarB = pd.DataFrame()\nsolarB['ds'] = solarData.start_timestamp\nsolarB['y'] = solarData.series_values\nsolarB = solarB.loc[~solarB.index.isin(s0.index)]\nmodelB = Prophet(changepoints=['2019-11-01','2019-12-01','2020-01-01','2020-02-01','2020-03-01','2020-06-01','2020-07-01','2020-08-01','2020-09-01'])\nmodelB.add_seasonality(name='daily', period=1, fourier_order=5, prior_scale=10, mode = 'multiplicative')\nmodelB.fit(solarB)\nfutureB = modelB.make_future_dataframe(periods=452, freq='30min')\nforecastB = modelB.predict(futureB)\n\ndiff = solarB.merge(forecastB[['ds','yhat']])\nrmse = np.sqrt(np.mean(np.square(diff.y - diff.yhat)))\nmae = np.mean(np.abs(diff.y - diff.yhat))\nprint(f\"RMSE:{round(rmse,6)} MAE:{round(mae,6)}\")\nplt.figure(figsize=(12,5))\nplt.plot(diff.ds[diff.ds >= '2020-09-28 05:00:00'], diff.y[diff.ds >= '2020-09-28 05:00:00'], '-o', c = 'grey')\nplt.plot(diff.ds[diff.ds >= '2020-09-28 05:00:00'], diff.yhat[diff.ds >= '2020-09-28 05:00:00'], '-o', c = 'blue')\nplt.ylabel('Solar Power Generation (kW)');\n\nforecastB_October = forecastB[(forecastB.ds >= '2020-10-05')]\nforecastB_October = forecastB_October.set_index('ds')\nforecastB_October_Optimization = forecastB_October.copy().between_time('05:00:00','19:30:00')\nforecastB_October_Optimization.iloc[forecastB_October_Optimization.yhat < 0,] = 0\n\n# This is the output file we'll use in the optimization model\nforecastB_October_Optimization.to_csv('pred_solar_values.csv', index = False)"}]}
{"meta": {"source_path": "/Users/sunyujun03/Desktop/ReLoop/gurobi-modeling-examples/optimization101/Modeling_Session_2/completed_modeling2.ipynb", "kind": "ipynb", "title": "Utilizing Renewables and Energy Storage to Minimize Electricity Use"}, "messages": [{"role": "system", "content": "You are an optimization engineer. Write correct and runnable Python code using gurobipy (Gurobi Python API). Be concise. Output only what is requested."}, {"role": "user", "content": "    Task: Reproduce the following Gurobi modeling example in Python using gurobipy.\n\n    Scenario description (from source):\n    # Utilizing Renewables and Energy Storage to Minimize Electricity Use\n\n## Introduction\n\nUsing renewable energy has gained popularity with the adoption of solar and wind energy production technologies. Yet, the sun is not always shining and the wind is not always blowing. When customers need energy might not coincide with those of high wind and solar potential which is a key challenge associated with renewable energy sources. Batteries can be a solution to this problem making it possible to use energy that has been stored can be used at any time during the day by discharging the energy stored in the battery.\n\nIn this example, we will utilize solar energy along with battery storage to satisfy the energy demands of operating a university building and the associated courses that are taking place. In the next sections, we will describe the problem statement, and demonstrate how data science and mathematical optimization can be used to optimally solve the given problem.\n\nThe information used for this example have been adopted from [IEEE's Predict+Optimize Technical Challenge](https://ieee-dataport.org/competitions/ieee-cis-technical-challenge-predictoptimize-renewable-energy-scheduling).\n\n## Objective and Prerequisites\n\nIn this example, we consider a single university building on campus in Melbourne, Australia that has a set of courses scheduled over the course of six days (Monday - Saturday). \n\nThe building and each course it holds have a certain energy demand that needs to be satisfied. The building's energy demand is assumed to known and each of the courses has a different demand based on the resources required (e.g. class size or a lab). The building has a solar panel installed which is capable of providing energy directly while there is also the ability of purchasing power directly from the electricity grid to satisfy the demand. Additionally, the building is equipped with two batteries which can store the energy provided from the solar panels, and can provide this energy when needed. We also allow for the batteries to be charged from the grid. \n\nThis example will integrate time series data forecasting with mathematical optimization as we will incorporate a solar generation forecast as the key input for an optimization problem. \n\n## Problem Statement\n\nGiven a course schedule for the upcoming week and historical data about the solar potential, the objective is to determine the optimal battery charging and discharging schedule are in order to satisfy the energy demand for a building where the courses are held. The total energy demand is composed of the demand from the building itself plus the amount needed for each course. The example will look at two objectives:\n- Minimize the total electricity purchased from the grid during the upcoming week\n- Since electricity prices fluctuate, minimize the total cost of electricity purchased from the grid\n\nAt the same time, batteries have a finite capacity as well as limits on how much it can charge or discharge over a period of time. These impose constraints on the problem and make it difficult to solve.\n\nFor simplicity, the time considered for each day will be limited to between 5am and 8pm. If you have access to a full Gurobi license (e.g. through our [Academic Program](https://www.gurobi.com/academia/academic-program-and-licenses/)) feel free to expand this to solve a much larger version of the problem. \n\nHere is a view of what the week's schedule will look like:\n![sched](ClassSchedule.png)\n\n## Solution Approach\n\nThe solution approach of the problem consists of two components: 1) **a forecasting component** for the solar availability and 2) **an optimization component** to determine the battery schedule as well as the amount of electricity purchased from the grid.\n\n### Solar Power Forecasting\n\nThe forecasting component was completed in the [energy_storage_ML](energy_storage_ML.ipynb) notebook in this folder. We'll use a given forecast from that model, as well as the demand of building and each of the courses to formulate and solve a mixed-integer programming (MIP) problem to find the optimal solution to the problem for each of the above objectives using gurobipy.\n\nWe begin our solution approach by installing and loading the necessary packages which will be needed:\n\n### Optimal Battery Schedule\nNow that we have a forecast of solar generation, we will create an optimization model that will schedule the charging and discharging of two batteries to help meet the building and course energy demand.\n\nThere are two batteries available that can be charged and discharged. Hence, we need an index to describe the existence and operation of each of the batteries. Finally, given that we would like to create the battery schedule in 30-minute intervals for the next month, we need to define an index for the time periods too. \n\n**Sets**\n\n$B = \\{\\texttt{Battery0, Battery1}\\}$\n\n$T = \\{0,1,...,179\\}$ for the first Monday through Saturday of October, 2020\n\n**Indices**\n\n$b$: denotes the battery (0 or 1)\n\n$t$: denotes the time periods (from 0 to 179)\n\n    Requirements:\n    - Use gurobipy (Model, GRB, addVar/addConstr, etc.)\n    - Make the script runnable as a standalone Python file if possible.\n    - Keep the code faithful to the example.\n"}, {"role": "assistant", "content": "import pandas as pd\nimport matplotlib.pyplot as plt\nimport gurobipy as gp\nfrom gurobipy import GRB\n\nbatteries = [\"Battery0\", \"Battery1\"]\npath = 'https://raw.githubusercontent.com/Gurobi/modeling-examples/master/optimization101/Modeling_Session_2/'\nsolar_values_read = pd.read_csv(path+'pred_solar_values.csv')\n# solar_values_read = pd.read_csv('pred_solar_values.csv')\ntime_periods = range(len(solar_values_read))\n\ncapacity = {\"Battery0\": 60, \"Battery1\": 80} # in Kw\np_loss = {\"Battery0\": 0.95, \"Battery1\": 0.9} # proportion\ninitial = {\"Battery0\": 0, \"Battery1\": 0} # in kW\n\nsolar_values = round(solar_values_read.yhat,3)\nsolar_values.reset_index(drop = True, inplace = True)\n\nschedule = pd.read_csv(path+'schedule_demand.csv')\n# schedule = pd.read_csv('schedule_demand.csv')\navg_building = pd.read_csv(path+'building_demand.csv')\n# avg_building = pd.read_csv('building_demand.csv')\ntotal_demand = schedule.sched_demand + avg_building.build_demand\nprint(f\"Total Solar Generation: {solar_values.sum()} \\nTotal Demand: {total_demand.sum()}\")\n\nm = gp.Model() #this defines the model that we'll add to as we finish the formulation\n\nflow_in = m.addVars(batteries, time_periods, name=\"flow_in\") \nflow_out = m.addVars(batteries, time_periods, name=\"flow_out\")\n\ngrid = m.addVars(time_periods, name=\"grid\")\n\nstate = m.addVars(batteries, time_periods, name=\"state\") \ngen = m.addVars(time_periods, name=\"gen\")\n\nzwitch = m.addVars(batteries, time_periods, vtype=GRB.BINARY, name=\"zwitch\")\n\nm.addConstrs((gp.quicksum(flow_out[b,t] - p_loss[b]*flow_in[b,t] for b in batteries) + gen[t] + grid[t] == total_demand[t] \n                  for t in time_periods), name=\"power_balance\");\n\nm.addConstrs((state[b,0] == initial[b] + p_loss[b]*flow_in[b,0] - flow_out[b,0] for b in batteries), name=\"initial_state\")\nm.addConstrs((state[b,t] == state[b,t-1] + p_loss[b]*flow_in[b,t] - flow_out[b,t] for b in batteries for t in time_periods if t >= 1), name=\"subsequent_states\");\n\nm.addConstrs((flow_in['Battery0',t] + flow_in['Battery1',t] + gen[t] <= solar_values[t] for t in time_periods), name = \"solar_avail\");\n\nm.addConstrs((flow_in[b,t] <= 20*zwitch[b,t] for b in batteries for t in time_periods), name = \"to_charge\")\nm.addConstrs((flow_out[b,t] <= 20*(1-zwitch[b,t]) for b in batteries for t in time_periods), name = \"or_not_to_charge\");\n\nfor b, t in state:\n    state[b,t].UB = capacity[b]\n\nm.setObjective(gp.quicksum(grid[t] for t in time_periods), GRB.MINIMIZE)\n\nm.optimize()\nprint(f\"Total energy purchased from the grid: {round(m.objVal,3)} kWh\")\n\nsol_in = pd.Series(m.getAttr('X',flow_in))\nsol_out = pd.Series(m.getAttr('X',flow_out))\nsol_level = pd.Series(m.getAttr('X',state))\n\nprint(f\"Periods Battery0 charges: {sum(sol_in['Battery0'] > 0)}\")\nprint(f\"Periods Battery1 charges: {sum(sol_in['Battery1'] > 0)}\")\nprint(f\"Periods Battery0 discharges: {sum(sol_out['Battery0'] > 0)}\")\nprint(f\"Periods Battery1 discharges: {sum(sol_out['Battery1'] > 0)}\")\n\nplt.figure(figsize=(12,5))\ns0, = plt.plot(sol_level['Battery0'], c = 'orange')\ns1, = plt.plot(sol_level['Battery1'], c = 'blue')\nplt.ylabel('Battery State (kWhr)')\nplt.xlabel('Time Period')\nplt.legend([s0,s1],[\"Battery0\", \"Battery1\"])\nplt.axhline(y=capacity['Battery0'], c='orange', linestyle='--', alpha = 0.5)\nplt.axhline(y=capacity['Battery1'], c='blue', linestyle='--', alpha = 0.5)\nprint(f\"Periods at Battery0 at Full Capacity: {sum(sol_level['Battery0']==capacity['Battery0'])}\")\nprint(f\"Periods at Battery1 at Full Capacity: {sum(sol_level['Battery1']==capacity['Battery1'])}\");\n\nsol_grid = pd.Series(m.getAttr('X',grid))\nplt.figure(figsize=(12,5))\nplt.plot(sol_grid)\nplt.ylabel('Power Purchased (kWhr)')\nplt.xlabel('Time Period');\nprint(f\"Proportion of time periods where electrity is purchaced from the grid: {round(sum(sol_grid > 0)/len(sol_grid),3)}\")\n\navg_price = pd.read_csv(path+'expected_price.csv')\n# avg_price = pd.read_csv('expected_price.csv')\nplt.figure(figsize=(12,5))\nplt.plot(avg_price.index, avg_price.price, '-o');\n\nm.setObjective(gp.quicksum(avg_price.price[time]*grid[time] for time in time_periods), GRB.MINIMIZE)\n\nm.optimize() # run the optimization again\nprint(f\"Energy cost for the week: ${round(m.objVal,2)}\")\n\nsol_level_cost = pd.Series(m.getAttr('X',state))\nplt.figure(figsize=(12,5))\nplt.plot(sol_level_cost['Battery0'], c ='orange')\nplt.plot(sol_level_cost['Battery1'], c ='blue')\nplt.legend([s0,s1],[\"Battery0\", \"Battery1\"])\nplt.axhline(y=capacity['Battery0'], c='orange', linestyle='--', alpha = 0.5)\nplt.axhline(y=capacity['Battery1'], c='blue', linestyle='--', alpha = 0.5)\nprint(f\"Periods at Battery0 at Full Capacity: {sum(sol_level_cost['Battery0']==capacity['Battery0'])}\")\nprint(f\"Periods at Battery1 at Full Capacity: {sum(sol_level_cost['Battery1']==capacity['Battery1'])}\");"}]}
{"meta": {"source_path": "/Users/sunyujun03/Desktop/ReLoop/gurobi-modeling-examples/optimization101/Modeling_Session_2/modeling2.ipynb", "kind": "ipynb", "title": "Utilizing Renewables and Energy Storage to Minimize Electricity Use"}, "messages": [{"role": "system", "content": "You are an optimization engineer. Write correct and runnable Python code using gurobipy (Gurobi Python API). Be concise. Output only what is requested."}, {"role": "user", "content": "    Task: Reproduce the following Gurobi modeling example in Python using gurobipy.\n\n    Scenario description (from source):\n    # Utilizing Renewables and Energy Storage to Minimize Electricity Use\n\n## Introduction\n\nUsing renewable energy has gained popularity with the adoption of solar and wind energy production technologies. Yet, the sun is not always shining and the wind is not always blowing. When customers need energy might not coincide with those of high wind and solar potential which is a key challenge associated with renewable energy sources. Batteries can be a solution to this problem making it possible to use energy that has been stored can be used at any time during the day by discharging the energy stored in the battery.\n\nIn this example, we will utilize solar energy along with battery storage to satisfy the energy demands of operating a university building and the associated courses that are taking place. In the next sections, we will describe the problem statement, and demonstrate how data science and mathematical optimization can be used to optimally solve the given problem.\n\nThe information used for this example have been adopted from [IEEE's Predict+Optimize Technical Challenge](https://ieee-dataport.org/competitions/ieee-cis-technical-challenge-predictoptimize-renewable-energy-scheduling).\n\n## Objective and Prerequisites\n\nIn this example, we consider a single university building on campus in Melbourne, Australia that has a set of courses scheduled over the course of six days (Monday - Saturday). \n\nThe building and each course it holds have a certain energy demand that needs to be satisfied. The building's energy demand is assumed to known and each of the courses has a different demand based on the resources required (e.g. class size or a lab). The building has a solar panel installed which is capable of providing energy directly while there is also the ability of purchasing power directly from the electricity grid to satisfy the demand. Additionally, the building is equipped with two batteries which can store the energy provided from the solar panels, and can provide this energy when needed. We also allow for the batteries to be charged from the grid. \n\nThis example will integrate time series data forecasting with mathematical optimization as we will incorporate a solar generation forecast as the key input for an optimization problem. \n\n## Problem Statement\n\nGiven a course schedule for the upcoming week and historical data about the solar potential, the objective is to determine the optimal battery charging and discharging schedule are in order to satisfy the energy demand for a building where the courses are held. The total energy demand is composed of the demand from the building itself plus the amount needed for each course. The example will look at two objectives:\n- Minimize the total electricity purchased from the grid during the upcoming week\n- Since electricity prices fluctuate, minimize the total cost of electricity purchased from the grid\n\nAt the same time, batteries have a finite capacity as well as limits on how much it can charge or discharge over a period of time. These impose constraints on the problem and make it difficult to solve.\n\nFor simplicity, the time considered for each day will be limited to between 5am and 8pm. If you have access to a full Gurobi license (e.g. through our [Academic Program](https://www.gurobi.com/academia/academic-program-and-licenses/)) feel free to expand this to solve a much larger version of the problem. \n\nHere is a view of what the week's schedule will look like:\n![sched](ClassSchedule.png)\n\n## Solution Approach\n\nThe solution approach of the problem consists of two components: 1) **a forecasting component** for the solar availability and 2) **an optimization component** to determine the battery schedule as well as the amount of electricity purchased from the grid.\n\n### Solar Power Forecasting\n\nThe forecasting component was completed in the [energy_storage_ML](energy_storage_ML.ipynb) notebook in this folder. We'll use a given forecast from that model, as well as the demand of building and each of the courses to formulate and solve a mixed-integer programming (MIP) problem to find the optimal solution to the problem for each of the above objectives using gurobipy.\n\nWe begin our solution approach by installing and loading the necessary packages which will be needed:\n\n### Optimal Battery Schedule\nNow that we have a forecast of solar generation, we will create an optimization model that will schedule the charging and discharging of two batteries to help meet the building and course energy demand.\n\nThere are two batteries available that can be charged and discharged. Hence, we need an index to describe the existence and operation of each of the batteries. Finally, given that we would like to create the battery schedule in 30-minute intervals for the next month, we need to define an index for the time periods too. \n\n**Sets**\n\n$B = \\{\\texttt{Battery0, Battery1}\\}$\n\n$T = \\{0,1,...,179\\}$ for the first Monday through Saturday of October, 2020\n\n**Indices**\n\n$b$: denotes the battery (0 or 1)\n\n$t$: denotes the time periods (from 0 to 179)\n\n    Requirements:\n    - Use gurobipy (Model, GRB, addVar/addConstr, etc.)\n    - Make the script runnable as a standalone Python file if possible.\n    - Keep the code faithful to the example.\n"}, {"role": "assistant", "content": "import pandas as pd\nimport matplotlib.pyplot as plt\nimport gurobipy as gp\nfrom gurobipy import GRB\n\nbatteries = [\"Battery0\", \"Battery1\"]\npath = 'https://raw.githubusercontent.com/Gurobi/modeling-examples/master/optimization101/Modeling_Session_2/'\nsolar_values_read = pd.read_csv(path+'pred_solar_values.csv')\n# solar_values_read = pd.read_csv('pred_solar_values.csv')\ntime_periods = range(len(solar_values_read))\n\ncapacity = {\"Battery0\": 60, \"Battery1\": 80} # in Kw\np_loss = {\"Battery0\": 0.95, \"Battery1\": 0.9} # proportion\ninitial = {\"Battery0\": 0, \"Battery1\": 0} # in kW\n\nsolar_values = round(solar_values_read.yhat,3)\nsolar_values.reset_index(drop = True, inplace = True)\n\nschedule = pd.read_csv(path+'schedule_demand.csv')\n# schedule = pd.read_csv('schedule_demand.csv')\navg_building = pd.read_csv(path+'building_demand.csv')\n# avg_building = pd.read_csv('building_demand.csv')\ntotal_demand = schedule.sched_demand + avg_building.build_demand\nprint(f\"Total Solar Generation: {solar_values.sum()} \\nTotal Demand: {total_demand.sum()}\")\n\nm = gp.Model() #this defines the model that we'll add to as we finish the formulation\n\nflow_in = m.addVars(batteries, time_periods, name=\"flow_in\") \nflow_out = m.addVars(batteries, time_periods, name=\"flow_out\")\n\ngrid = m.addVars(time_periods, name=\"grid\")\n\nstate = m.addVars(batteries, time_periods, name=\"state\") \ngen = m.addVars(time_periods, name=\"gen\")\n\nzwitch = m.addVars(batteries, time_periods, ??? , name=\"zwitch\")\n\nm.addConstrs((gp.quicksum( ???\n                  for t in time_periods), name=\"power_balance\");\n\nm.addConstrs((state[b,0] == initial[b] + p_loss[b]*flow_in[b,0] - flow_out[b,0] for b in batteries), name=\"initial_state\")\nm.addConstrs((state[b,t] == state[b,t-1] + p_loss[b]*flow_in[b,t] - flow_out[b,t] for b in batteries for t in time_periods if t >= 1), name=\"subsequent_states\");\n\nm.addConstrs((   ???   ), name = \"solar_avail\");\n\nm.addConstrs((flow_in[b,t] <= 20*zwitch[b,t] for b in batteries for t in time_periods), name = \"to_charge\")\nm.addConstrs((flow_out[b,t] <= 20*(1-zwitch[b,t]) for b in batteries for t in time_periods), name = \"or_not_to_charge\");\n\nfor b, t in state:\n    state[b,t].UB = capacity[b]\n\nm.setObjective(gp.quicksum(grid[t] for t in time_periods), GRB.MINIMIZE)\n\nm.optimize()\nprint(f\"Total energy purchased from the grid: {round(m.objVal,3)} kWh\")\n\nsol_in = pd.Series(m.getAttr('X',flow_in))\nsol_out = pd.Series(m.getAttr('X',flow_out))\nsol_level = pd.Series(m.getAttr('X',state))\n\nprint(f\"Periods Battery0 charges: {sum(sol_in['Battery0'] > 0)}\")\nprint(f\"Periods Battery1 charges: {sum(sol_in['Battery1'] > 0)}\")\nprint(f\"Periods Battery0 discharges: {sum(sol_out['Battery0'] > 0)}\")\nprint(f\"Periods Battery1 discharges: {sum(sol_out['Battery1'] > 0)}\")\n\nplt.figure(figsize=(12,5))\ns0, = plt.plot(sol_level['Battery0'], c = 'orange')\ns1, = plt.plot(sol_level['Battery1'], c = 'blue')\nplt.ylabel('Battery State (kWhr)')\nplt.xlabel('Time Period')\nplt.legend([s0,s1],[\"Battery0\", \"Battery1\"])\nplt.axhline(y=capacity['Battery0'], c='orange', linestyle='--', alpha = 0.5)\nplt.axhline(y=capacity['Battery1'], c='blue', linestyle='--', alpha = 0.5)\nprint(f\"Periods at Battery0 at Full Capacity: {sum(sol_level['Battery0']==capacity['Battery0'])}\")\nprint(f\"Periods at Battery1 at Full Capacity: {sum(sol_level['Battery1']==capacity['Battery1'])}\");\n\nsol_grid = pd.Series(m.getAttr('X',grid))\nplt.figure(figsize=(12,5))\nplt.plot(sol_grid)\nplt.ylabel('Power Purchased (kWhr)')\nplt.xlabel('Time Period');\nprint(f\"Proportion of time periods where electrity is purchaced from the grid: {round(sum(sol_grid > 0)/len(sol_grid),3)}\")\n\navg_price = pd.read_csv(path+'expected_price.csv')\n# avg_price = pd.read_csv('expected_price.csv')\nplt.figure(figsize=(12,5))\nplt.plot(avg_price.index, avg_price.price, '-o');\n\nm.setObjective(gp.quicksum(avg_price.price[time]*grid[time] for time in time_periods), GRB.MINIMIZE)\n\nm.optimize() # run the optimization again\nprint(f\"Energy cost for the week: ${round(m.objVal,2)}\")\n\nsol_level_cost = pd.Series(m.getAttr('X',state))\nplt.figure(figsize=(12,5))\nplt.plot(sol_level_cost['Battery0'], c ='orange')\nplt.plot(sol_level_cost['Battery1'], c ='blue')\nplt.legend([s0,s1],[\"Battery0\", \"Battery1\"])\nplt.axhline(y=capacity['Battery0'], c='orange', linestyle='--', alpha = 0.5)\nplt.axhline(y=capacity['Battery1'], c='blue', linestyle='--', alpha = 0.5)\nprint(f\"Periods at Battery0 at Full Capacity: {sum(sol_level_cost['Battery0']==capacity['Battery0'])}\")\nprint(f\"Periods at Battery1 at Full Capacity: {sum(sol_level_cost['Battery1']==capacity['Battery1'])}\");"}]}
{"meta": {"source_path": "/Users/sunyujun03/Desktop/ReLoop/gurobi-modeling-examples/optimization101/bike_share/bike_rebalancing.ipynb", "kind": "ipynb", "title": "Bike Share Rebalancing With Mathematical Optimization"}, "messages": [{"role": "system", "content": "You are an optimization engineer. Write correct and runnable Python code using gurobipy (Gurobi Python API). Be concise. Output only what is requested."}, {"role": "user", "content": "    Task: Reproduce the following Gurobi modeling example in Python using gurobipy.\n\n    Scenario description (from source):\n    # Bike Share Rebalancing With Mathematical Optimization\n\nBike share systems have become an effective commuting method globally for everyday urban dwellers as well as tourists.\n\nCiti-Bike in NYC being the largest Bike-Sharing network had 1,588 active stations and 25,575 active bikes in July 2022.\n\nOver 3 million rides were completed July 2022 that cover NYC/Hoboken/Jersey City, with around 150,000 active annual members.\n\nDuring rush hours there are many bike stations that have a high demand for bikes, which means their out-flow of bikes is greater than their in-flow in these stations. \n\nMeanwhile there are stations that have a high demand for docks (riders return their bikes to these stations) which means their in-flow of bikes is greater than their out-flow.\n\nLack of available bikes or docks in high-demand stations can cause major imbalance in the bike sharing network and result in customer dissatisfaction and lost revenue.\n\nTo tackle this problem, bikes are relocated between stations to create a balance between supply and demand.\n\n## Problem Statement and Solution Approach\n\nUsing historical Citi-bike data in NYC and Jersey area during July 2022, we like to know:\n- What is the demand for bikes per hour at each station during the first week of August?\n- Knowing the demand, how can we minimize loss of sale?\n\nLoss of sale is caused by lack of bikes when customers demand them. So, bikes should be transferred from stations with higher in-flow of bikes to those with higher out-flow of bikes. \n\nSo, first, number of bikes to be added to or removed from each station during each hour should be determined. Then, the physical transfer of bikes between stations should be scheduled. \n\nIn this notebook, we'll focus on the first part and at the end, discuss how the second part can be solved.\nWe'll use a mixture of Machine Learning (ML) and Mathematical Optimization (MO) to solve this problem. \n\n**Solution Approach**\nThe solution approach is comprised of two steps:\n- **Step 1**: We use the historical Citi-bike data in NYC and Jersey area during July 2022 and use an ML model to predict the number of in-flow and out-flow of bikes per hour at each station for the first week of August. This is done in [predict_bike_flow](predict_bike_flow.ipynb) Notebook.\n- **Step 2**: We use an MO model to decide how many bikes should be added to or removed from each station during each hour so that the total loss of sale is minimized.\n\nTo ensure that everyone can run the notebook with the Gurobi restricted license, we reduce the size of the data. To achieve that, we focus on the top 50 stations during the morning rush hours (7 am to 9 am).\n\nThe top stations are chosen using the PageRank algorithm.\n\n    Requirements:\n    - Use gurobipy (Model, GRB, addVar/addConstr, etc.)\n    - Make the script runnable as a standalone Python file if possible.\n    - Keep the code faithful to the example.\n"}, {"role": "assistant", "content": "import datetime\nimport gurobipy as gp\nimport pandas as pd\nfrom gurobipy import GRB\n\nstations = pd.read_csv('https://raw.githubusercontent.com/Gurobi/modeling-examples/master/optimization101/bike_share/top_stations.csv', index_col='station')\n# run locally\n# stations = pd.read_csv('top_stations.csv', index_col='station')\nstations.head()\n\nstations_flow = pd.read_csv('https://raw.githubusercontent.com/Gurobi/modeling-examples/master/optimization101/bike_share/stations_flow.csv')\n# run locally\n# stations_flow = pd.read_csv('stations_flow.csv')\nstations_flow['datetime'] = pd.to_datetime(stations_flow['datetime'])\nstations_flow.head(25)\n\n# Pandas will give a few SettingWithCopyWarning here when new columns are created. \n# They are false alarms. So, we suppress them.\npd.options.mode.chained_assignment = None\nmorning_flow = stations_flow[stations_flow['datetime'].dt.hour.between(7, 9)]\nmorning_flow['date'] = morning_flow['datetime'].dt.date\nmorning_flow['time'] = morning_flow['datetime'].dt.hour\n# For now, let's run the MO model for the first date: 08/01/2022\nflow_df = morning_flow.loc[morning_flow['date'] == datetime.date(2022, 8, 1)]\nflow_df.set_index(['station', 'time'], inplace=True)\nflow_df.head(10)\n\nnum_bikes = 25  # N: Number of bikes at hand that we can assign to stations at a given hour\nstation_names = list(stations.index)  # set I\ntime_rng = morning_flow['time'].drop_duplicates().values  # set T\n\nstation_time = flow_df.index  # pair of (i,t) index\nstart_forecast = flow_df.start_forecast  # s\nend_forecast = flow_df.end_forecast  # e\ncapacity = stations.capacity  # c\n\nmdl = gp.Model('bike_rebalancing')\n# Variables\n\ny = mdl.addVars(station_time, lb=0, vtype=GRB.CONTINUOUS, name='y')\n# y = mdl.addVars(station_names, time_rng, lb=0, vtype=GRB.CONTINUOUS, name='y')  # alternatively\nz = mdl.addVars(station_time, lb=0, vtype=GRB.CONTINUOUS, name='z')\nl = mdl.addVars(station_time, lb=0, vtype=GRB.CONTINUOUS, name='l')\n\n# Bounds of Y\n... # ???\n\n# Bounds of z\n... # ???\n\nt0 = 7\n# setting up initial inventory\n... # ???\n\n# loss definition\n... # ???\n\n# limit on number of bikes added\n... # ???\n\nmdl.setObjective(l.sum(), GRB.MINIMIZE)\n\nmdl.optimize()\n\ndf = pd.DataFrame()\nif mdl.status == GRB.Status.OPTIMAL:\n    df = flow_df.copy()\n    df = df.merge(stations[['capacity']], left_on='station', right_index=True)\n    df[['bikes_added', 'bikes_removed', 'loss_sale', 'beginning_inventory']] = 0\n    for k, v in y.items():\n        df.loc[k, 'bikes_added'] = v.x\n        df.loc[k, 'bikes_removed'] = z[k].x\n        df.loc[k, 'beginning_inventory'] = q[k].x\n        df.loc[k, 'loss_sale'] = l[k].x\n    df.reset_index(inplace=True)\n    print(f'Total Loss : {mdl.objVal}')\n    total_bikes_added = df.groupby('time')['bikes_added'].sum()\n    print(f'Total number of bikes added in each hour:\\n {total_bikes_added}')\nelse:\n    print('Could not find a feasible solution!')\ndf.head(10)\n\nx = mdl.addVars(station_time, vtype=GRB.BINARY, name='x')  # 1 if y_{i,t} >= 0 \nw = mdl.addVars(station_time, vtype=GRB.BINARY, name='w')  # 1 if z_{i,t} >= 0\n\nbig_m = 1000  # large number\n# relation between y and x\nmdl.addConstrs((y[i, t] <= big_m * x[i, t] for i, t in station_time), 'rel_y_x')\n# relation between z and w\nmdl.addConstrs((z[i, t] <= big_m * w[i, t] for i, t in station_time), 'rel_z_w')\n\n# new objective\nobj = l.sum() + (x.sum() + w.sum())\nmdl.setObjective(obj, GRB.MINIMIZE)\nmdl.optimize()\n\ndf = pd.DataFrame()\nif mdl.status == GRB.Status.OPTIMAL:\n    df = flow_df.copy()\n    df = df.merge(stations[['capacity']], left_on='station', right_index=True)\n    df[['bikes_added', 'bikes_removed', 'loss_sale', 'beginning_inventory']] = 0\n    for k, v in y.items():\n        df.loc[k, 'bikes_added'] = v.x\n        df.loc[k, 'bikes_removed'] = z[k].x\n        df.loc[k, 'beginning_inventory'] = q[k].x\n        df.loc[k, 'loss_sale'] = l[k].x\n    df.reset_index(inplace=True)\n    print(f'Total Loss : {mdl.objVal}')\n    total_bikes_added = df.groupby('time')['bikes_added'].sum()\n    print(f'Total number of bikes added in each hour:\\n {total_bikes_added}')\nelse:\n    print('Could not find a feasible solution!')\ndf.head(10)"}]}
{"meta": {"source_path": "/Users/sunyujun03/Desktop/ReLoop/gurobi-modeling-examples/optimization101/bike_share/bike_rebalancing_complete.ipynb", "kind": "ipynb", "title": "Bike Share Rebalancing With Mathematical Optimization"}, "messages": [{"role": "system", "content": "You are an optimization engineer. Write correct and runnable Python code using gurobipy (Gurobi Python API). Be concise. Output only what is requested."}, {"role": "user", "content": "    Task: Reproduce the following Gurobi modeling example in Python using gurobipy.\n\n    Scenario description (from source):\n    # Bike Share Rebalancing With Mathematical Optimization\n\nBike share systems have become an effective commuting method globally for everyday urban dwellers as well as tourists.\n\nCiti-Bike in NYC being the largest Bike-Sharing network had 1,588 active stations and 25,575 active bikes in July 2022.\n\nOver 3 million rides were completed July 2022 that cover NYC/Hoboken/Jersey City, with around 150,000 active annual members.\n\nDuring rush hours there are many bike stations that have a high demand for bikes, which means their out-flow of bikes is greater than their in-flow in these stations. \n\nMeanwhile there are stations that have a high demand for docks (riders return their bikes to these stations) which means their in-flow of bikes is greater than their out-flow.\n\nLack of available bikes or docks in high-demand stations can cause major imbalance in the bike sharing network and result in customer dissatisfaction and lost revenue.\n\nTo tackle this problem, bikes are relocated between stations to create a balance between supply and demand.\n\n## Problem Statement and Solution Approach\n\nUsing historical Citi-bike data in NYC and Jersey area during July 2022, we like to know:\n- What is the demand for bikes per hour at each station during the first week of August?\n- Knowing the demand, how can we minimize loss of sale?\n\nLoss of sale is caused by lack of bikes when customers demand them. So, bikes should be transferred from stations with higher in-flow of bikes to those with higher out-flow of bikes. \n\nSo, first, number of bikes to be added to or removed from each station during each hour should be determined. Then, the physical transfer of bikes between stations should be scheduled. \n\nIn this notebook, we'll focus on the first part and at the end, discuss how the second part can be solved.\nWe'll use a mixture of Machine Learning (ML) and Mathematical Optimization (MO) to solve this problem. \n\n**Solution Approach**\nThe solution approach is comprised of two steps:\n- **Step 1**: We use the historical Citi-bike data in NYC and Jersey area during July 2022 and use an ML model to predict the number of in-flow and out-flow of bikes per hour at each station for the first week of August. This is done in [predict_bike_flow](predict_bike_flow.ipynb) Notebook.\n- **Step 2**: We use an MO model to decide how many bikes should be added to or removed from each station during each hour so that the total loss of sale is minimized.\n\nTo ensure that everyone can run the notebook with the Gurobi restricted license, we reduce the size of the data. To achieve that, we focus on the top 50 stations during the morning rush hours (7 am to 9 am).\n\nThe top stations are chosen using the PageRank algorithm.\n\n    Requirements:\n    - Use gurobipy (Model, GRB, addVar/addConstr, etc.)\n    - Make the script runnable as a standalone Python file if possible.\n    - Keep the code faithful to the example.\n"}, {"role": "assistant", "content": "import datetime\nimport gurobipy as gp\nimport pandas as pd\nfrom gurobipy import GRB\n\nstations = pd.read_csv('https://raw.githubusercontent.com/Gurobi/modeling-examples/master/optimization101/bike_share/top_stations.csv', index_col='station')\n# run locally\n# stations = pd.read_csv('top_stations.csv', index_col='station')\nstations.head()\n\nstations_flow = pd.read_csv('https://raw.githubusercontent.com/Gurobi/modeling-examples/master/optimization101/bike_share/stations_flow.csv')\n# run locally\n# stations_flow = pd.read_csv('stations_flow.csv')\nstations_flow['datetime'] = pd.to_datetime(stations_flow['datetime'])\nstations_flow.head()\n\n# Pandas will give a few SettingWithCopyWarning here when new columns are created. \n# They are false alarms. So, we suppress them.\npd.options.mode.chained_assignment = None\nmorning_flow = stations_flow[stations_flow['datetime'].dt.hour.between(7, 9)]\nmorning_flow['date'] = morning_flow['datetime'].dt.date\nmorning_flow['time'] = morning_flow['datetime'].dt.hour\n# For now, let's run the MO model for the first date: 08/01/2022\nflow_df = morning_flow.loc[morning_flow['date'] == datetime.date(2022, 8, 1)]\nflow_df.set_index(['station', 'time'], inplace=True)\nflow_df.head()\n\nnum_bikes = 25  # N: Number of bikes at hand that we can assign to stations at a given hour\nstation_names = list(stations.index)  # set I\ntime_rng = morning_flow['time'].drop_duplicates().values  # set T\n\nstation_time = flow_df.index  # pair of (i,t) index\nstart_forecast = flow_df.start_forecast  # s\nend_forecast = flow_df.end_forecast  # e\ncapacity = stations.capacity  # c\n\nmdl = gp.Model('bike_rebalancing')\n# Variables\n\ny = mdl.addVars(station_time, lb=0, vtype=GRB.CONTINUOUS, name='y')\n# y = mdl.addVars(station_names, time_rng, lb=0, vtype=GRB.CONTINUOUS, name='y')  # alternatively\nz = mdl.addVars(station_time, lb=0, vtype=GRB.CONTINUOUS, name='z')\nq = mdl.addVars(station_time, lb=0, vtype=GRB.CONTINUOUS, name='q')\nl = mdl.addVars(station_time, lb=0, vtype=GRB.CONTINUOUS, name='l')\n\n# UB of y\nmdl.addConstrs((y[i, t] <= capacity[i] for i, t in station_time), 'ub_y')\n\n# LB of z\nmdl.addConstrs(\n    (z[i, t] >= (end_forecast[i, t] - start_forecast[i, t] - capacity[i])\n     for i, t in station_time), 'lb_z')\n#     for i in station_names for t in time_rng), 'lb_z')\n\n# UB of z\nmdl.addConstrs(\n        (z[i, t] <= max(0, end_forecast[i, t] - start_forecast[i, t])\n         for i, t in station_time), 'ub_z');  # add \";\" here to stop the cell to print the constraints\n\nt0 = 7\n# setting up initial inventory\nmdl.addConstrs((q[i, t0] == 0 for i in stations.index), name='initial_inv');\n\na = mdl.addVars(station_time, lb=-GRB.INFINITY, vtype=GRB.CONTINUOUS, name='a')  # auxiliary variable\n# defintion of auxiliary variable\nmdl.addConstrs((a[i, t] == end_forecast[i, t - 1] + y[i, t - 1] + q[i, t - 1]\n                - start_forecast[i, t - 1] - z[i, t - 1]\n                for i, t in station_time if t != t0), name='aux_def')\n# definition of inventory\nmdl.addConstrs((q[i, t] == gp.max_(a[i, t], 0) for i, t in station_time if t!=t0), name='inv_def');\n\n# UB of inventory\nmdl.addConstrs((q[i, t] <= capacity[i] for i, t in station_time), 'ub_inv');\n\n# loss definition\nmdl.addConstrs(\n    (l[i, t] >= start_forecast[i, t] + z[i, t]\n     - end_forecast[i, t] - y[i, t] - q[i, t]\n     for i, t in station_time), 'loss_def');\n\n# limit on number of bikes added\nmdl.addConstrs((y.sum('*', t) <= num_bikes for t in time_rng), name='total_bikes');\n\nmdl.setObjective(l.sum(), GRB.MINIMIZE)\n\nmdl.optimize()\n\ndf = pd.DataFrame()\nif mdl.status == GRB.Status.OPTIMAL:\n    df = flow_df.copy()\n    df = df.merge(stations[['capacity']], left_on='station', right_index=True)\n    df[['bikes_added', 'bikes_removed', 'loss_sale', 'beginning_inventory']] = 0\n    for k, v in y.items():\n        df.loc[k, 'bikes_added'] = v.x\n        df.loc[k, 'bikes_removed'] = z[k].x\n        df.loc[k, 'beginning_inventory'] = q[k].x\n        df.loc[k, 'loss_sale'] = l[k].x\n    df.reset_index(inplace=True)\n    print(f'Total Loss : {mdl.objVal}')\n    total_bikes_added = df.groupby('time')['bikes_added'].sum()\n    print(f'Total number of bikes added in each hour:\\n {total_bikes_added}')\nelse:\n    print('Could not find a feasible solution!')\ndf.head(10)\n\ndef bike_rebalancing(flow_df, num_bikes):\n    station_time = flow_df.index  # pair of (i,t) index\n    start_forecast = flow_df.start_forecast  # s\n    end_forecast = flow_df.end_forecast  # e\n    capacity = stations.capacity  # c\n    mdl = gp.Model('bike_rebalancing')\n\n    # Variables\n    y = mdl.addVars(station_time, lb=0, vtype=GRB.CONTINUOUS, name='y')\n    z = mdl.addVars(station_time, lb=0, vtype=GRB.CONTINUOUS, name='z')\n    q = mdl.addVars(station_time, lb=0, vtype=GRB.CONTINUOUS, name='q')\n    l = mdl.addVars(station_time, lb=0, vtype=GRB.CONTINUOUS, name='l')\n    a = mdl.addVars(station_time, lb=-GRB.INFINITY, vtype=GRB.CONTINUOUS, name='a')\n\n    # Constraints\n    mdl.addConstrs((y[i, t] <= capacity[i] for i, t in station_time), 'ub_y')\n\n    mdl.addConstrs(\n        (z[i, t] >= (end_forecast[i, t] - start_forecast[i, t] - capacity[i])\n         for i, t in station_time), 'lb_z')\n    \n    mdl.addConstrs(\n        (z[i, t] <= max(0, end_forecast[i, t] - start_forecast[i, t])\n         for i, t in station_time), 'ub_z')\n\n    t0 = 7\n    mdl.addConstrs((q[i, t0] == 0 for i in stations.index), name='initial_inv')\n\n    mdl.addConstrs((a[i, t] == end_forecast[i, t - 1] + y[i, t - 1] + q[i, t - 1]\n                    - start_forecast[i, t - 1] - z[i, t - 1]\n                    for i, t in station_time if t != t0), name='aux_def')\n\n    mdl.addConstrs((q[i, t] == gp.max_(a[i, t], 0) for i, t in station_time if t != t0), name='inv_def')\n\n    mdl.addConstrs((q[i, t] <= capacity[i] for i, t in station_time), 'ub_inv')\n\n    mdl.addConstrs((l[i, t] >= start_forecast[i, t] + z[i, t]\n                    - end_forecast[i, t] - y[i, t] - q[i, t] for i, t in station_time), 'loss_def')\n\n    mdl.addConstrs((y.sum('*', t) <= num_bikes for t in time_rng), name='total_bikes')\n\n    # Objectives\n    mdl.setObjective(l.sum(), GRB.MINIMIZE)\n    mdl.optimize()\n\n    # create output\n    df = pd.DataFrame()\n    if mdl.status == GRB.Status.OPTIMAL:\n        df = flow_df.copy()\n        df = df.merge(stations[['capacity']], left_on='station', right_index=True)\n        df[['bikes_added', 'bikes_removed', 'loss_sale', 'beginning_inventory']] = 0\n        for k, v in y.items():\n            df.loc[k, 'bikes_added'] = v.x\n            df.loc[k, 'bikes_removed'] = z[k].x\n            df.loc[k, 'beginning_inventory'] = q[k].x\n            df.loc[k, 'loss_sale'] = l[k].x\n        df.reset_index(inplace=True)\n        print(f'Total Loss : {mdl.objVal}')\n        total_bikes_added = df.groupby('time')['bikes_added'].sum()\n        print(f'Total number of bikes added in each hour:\\n {total_bikes_added}')\n    else:\n        print('Could not find a feasible solution!')\n    return df\n\n# run the model daily\nall_outputs = []\ng = morning_flow.set_index(['station', 'time']).groupby('date')\nfor x in g.groups:\n    df = g.get_group(x)\n    odf = bike_rebalancing(df, num_bikes)\n    all_outputs.append(odf)\noutput_df = pd.concat(all_outputs)\n\noutput_df.head(10)\n\nx = mdl.addVars(station_time, vtype=GRB.BINARY, name='x')  # 1 if y_{i,t} >= 0 \nw = mdl.addVars(station_time, vtype=GRB.BINARY, name='w')  # 1 if z_{i,t} >= 0\n\nbig_m = 1000  # large number\n# relation between y and x\nmdl.addConstrs((y[i, t] <= big_m * x[i, t] for i, t in station_time), 'rel_y_x')\n# relation between z and w\nmdl.addConstrs((z[i, t] <= big_m * w[i, t] for i, t in station_time), 'rel_z_w')\n\n# new objective\nobj = l.sum() + (x.sum() + w.sum())\nmdl.setObjective(obj, GRB.MINIMIZE)\nmdl.optimize()\n\ndf = pd.DataFrame()\nif mdl.status == GRB.Status.OPTIMAL:\n    df = flow_df.copy()\n    df = df.merge(stations[['capacity']], left_on='station', right_index=True)\n    df[['bikes_added', 'bikes_removed', 'loss_sale', 'beginning_inventory']] = 0\n    for k, v in y.items():\n        df.loc[k, 'bikes_added'] = v.x\n        df.loc[k, 'bikes_removed'] = z[k].x\n        df.loc[k, 'beginning_inventory'] = q[k].x\n        df.loc[k, 'loss_sale'] = l[k].x\n    df.reset_index(inplace=True)\n    print(f'Total Loss : {mdl.objVal}')\n    total_bikes_added = df.groupby('time')['bikes_added'].sum()\n    print(f'Total number of bikes added in each hour:\\n {total_bikes_added}')\nelse:\n    print('Could not find a feasible solution!')\ndf.head(10)"}]}
{"meta": {"source_path": "/Users/sunyujun03/Desktop/ReLoop/gurobi-modeling-examples/optimization101/Modeling_Session_1/Exercise_Set1.ipynb", "kind": "ipynb", "title": "Exercise_Set1"}, "messages": [{"role": "system", "content": "You are an optimization engineer. Write correct and runnable Python code using gurobipy (Gurobi Python API). Be concise. Output only what is requested."}, {"role": "user", "content": "    Task: Reproduce the following Gurobi modeling example in Python using gurobipy.\n\n    Scenario description (from source):\n    ## Exercise Set 1\n\n### Multiple Choice \n**Q1.** Which of these are NOT key components for an optimization model?\n- decision variables\n- parameters\n- objective function\n- hyperparameters\n\n**Q2.** MO can be used as a strict replacement for nearly all ML problems\n- True\n- False\n\n**Q3.** ML can be used as a strict replacement for nearly all MO problems\n- True\n- False\n\n**Q4.** Which of the following is a type of decision variables in mathematical optimization?\n- binary\n- complex\n- feature\n- complimentary\n\n    Requirements:\n    - Use gurobipy (Model, GRB, addVar/addConstr, etc.)\n    - Make the script runnable as a standalone Python file if possible.\n    - Keep the code faithful to the example.\n"}, {"role": "assistant", "content": "import pandas as pd\nimport gurobipy as gp\nfrom gurobipy import GRB\n\nproduction = ['Baltimore','Cleveland','Little Rock','Birmingham','Charleston']\ndistribution = ['Columbia','Indianapolis','Lexington','Nashville','Richmond','St. Louis']\n\npath = 'https://raw.githubusercontent.com/Gurobi/modeling-examples/master/optimization101/Modeling_Session_1/'\ntransp_cost = pd.read_csv(path + 'cost.csv', index_col=[0,1]).squeeze(\"columns\")\nmax_prod = pd.Series([180,200,140,80,180], index = production, name = \"max_production\")\nn_demand = pd.Series([89,95,121,101,116,181], index = distribution, name = \"demand\") \nfrac = 0.75\n\nm = gp.Model('widgets')\nx = m.addVars(production, distribution, name = 'prod_ship')\nmeet_demand = m.addConstrs((gp.quicksum(x[p,d] for p in production) >= n_demand[d] for d in distribution), name = 'meet_demand')\ncan_produce = m.addConstrs((gp.quicksum(x[p,d] for d in distribution) <= max_prod[p] for p in production), name = 'can_produce')\nmust_produce = m.addConstrs((gp.quicksum(x[p,d] for d in distribution) >= frac*max_prod[p] for p in production), name = 'must_produce')\nm.setObjective(gp.quicksum(transp_cost[i,j]*x[i,j] for i in production for j in distribution), GRB.MINIMIZE) \nm.optimize()\n\ntime_prod_limit = m.addConstrs((gp.quicksum(x[p,d,???] + x[p,d,???] for d in distribution) <= max_prod[p] for p in production for t in ??? if t ???), name = 'time_prod_limit')"}]}
{"meta": {"source_path": "/Users/sunyujun03/Desktop/ReLoop/gurobi-modeling-examples/optimization101/Modeling_Session_1/completed_Exercise_Set1.ipynb", "kind": "ipynb", "title": "completed_Exercise_Set1"}, "messages": [{"role": "system", "content": "You are an optimization engineer. Write correct and runnable Python code using gurobipy (Gurobi Python API). Be concise. Output only what is requested."}, {"role": "user", "content": "    Task: Reproduce the following Gurobi modeling example in Python using gurobipy.\n\n    Scenario description (from source):\n    ## Exercise Set 1\n\n### Multiple Choice \n**Q1.** Which of these are NOT key components for an optimization model?\n- decision variables\n- parameters\n- objective function\n- `hyperparameters`\n\n**Q2.** MO can be used as a strict replacement for nearly all ML problems\n- True\n- `False`\n\n**Q3.** ML can be used as a strict replacement for nearly all MO problems\n- True\n- `False`\n\n**Q4.** Which of the following is a type of decision variables in mathematical optimization?\n- `binary`\n- complex\n- feature\n- complimentary\n\n    Requirements:\n    - Use gurobipy (Model, GRB, addVar/addConstr, etc.)\n    - Make the script runnable as a standalone Python file if possible.\n    - Keep the code faithful to the example.\n"}, {"role": "assistant", "content": "import pandas as pd\nimport gurobipy as gp\nfrom gurobipy import GRB\n\nproduction = ['Baltimore','Cleveland','Little Rock','Birmingham','Charleston']\ndistribution = ['Columbia','Indianapolis','Lexington','Nashville','Richmond','St. Louis']\n\npath = 'https://raw.githubusercontent.com/Gurobi/modeling-examples/master/optimization101/Modeling_Session_1/'\ntransp_cost = pd.read_csv(path + 'cost.csv', index_col=[0,1]).squeeze(\"columns\")\nmax_prod = pd.Series([180,200,140,80,180], index = production, name = \"max_production\")\nn_demand = pd.Series([89,95,121,101,116,181], index = distribution, name = \"demand\") \nfrac = 0.75\n\nm = gp.Model('widgets')\nx = m.addVars(production, distribution, name = 'prod_ship')\nmeet_demand = m.addConstrs((gp.quicksum(x[p,d] for p in production) >= n_demand[d] for d in distribution), name = 'meet_demand')\ncan_produce = m.addConstrs((gp.quicksum(x[p,d] for d in distribution) <= max_prod[p] for p in production), name = 'can_produce')\nmust_produce = m.addConstrs((gp.quicksum(x[p,d] for d in distribution) >= frac*max_prod[p] for p in production), name = 'must_produce')\nm.setObjective(gp.quicksum(transp_cost[i,j]*x[i,j] for i in production for j in distribution), GRB.MINIMIZE) \nm.optimize()\n\nm.addConstrs(x[p,d] >= 20 for p in production for d in distribution)\nm.update()\n\nx = m.addVars(production, distribution, range(4), name = 'prod_ship')\n\ntime_prod_limit = m.addConstrs((gp.quicksum(x[p,d,???] + x[p,d,???] for d in distribution) <= max_prod[p] for p in production for t in ??? if t ???), name = 'time_prod_limit')\n\ntime_prod_limit = m.addConstrs((gp.quicksum(x[p,d,t] + x[p,d,t-1] for d in distribution) <= max_prod[p] for p in production for t in range(4) if t > 0), name = 'time_prod_limit')"}]}
{"meta": {"source_path": "/Users/sunyujun03/Desktop/ReLoop/gurobi-modeling-examples/optimization101/Modeling_Session_1/completed_modeling1.ipynb", "kind": "ipynb", "title": "Translating a Decision Problem to an Optimization Model"}, "messages": [{"role": "system", "content": "You are an optimization engineer. Write correct and runnable Python code using gurobipy (Gurobi Python API). Be concise. Output only what is requested."}, {"role": "user", "content": "    Task: Reproduce the following Gurobi modeling example in Python using gurobipy.\n\n    Scenario description (from source):\n    # Translating a Decision Problem to an Optimization Model\n\nIn the first video we discussed a few key concepts that are necessary for mathematical optimization:\n- parameters \n- decision variables\n- constraints\n- objective function\n\nIn this first modeling example we will see how these are used to formulate a decision problem as an optimization model and code the formulation using `gurobipy`. For more information on all of the commands in the Python API check out our [documentation](https://www.gurobi.com/documentation/10.0/refman/py_python_api_details.html).\n\n## The Decision Problem\nWe make widgets. Have a set of production facilities that produce boxes of widgets. There is also a set of distribution locations that will then distribute the widgets for sale. Each distribution center has a forecasted demand and each production facility has a min and max number of widgets it can make during this period. We need to ensure that each distribution facility receives enough widgets to satisfy demand from production and we want to do this at minimal cost. The minimum production is 75% of the production facilities max value. \n\n## Sets and Define Model\nOur sets are:\n- $P = \\{\\texttt{'Baltimore', 'Cleveland', 'Little Rock', 'Birmingham', 'Charleston'}\\} \\quad\\quad\\quad\\quad\\quad\\quad\\quad\\space\\space \\texttt{production}$\n- $D = \\{\\texttt{'Columbia', 'Indianapolis', 'Lexington', 'Nashville', 'Richmond', 'St. Louis'}\\} \\quad\\quad\\quad \\texttt{distribution}$\n\nTo index each set, we'll use the lowercase letter of each set. Letters used for sets and indices are up to you. Typically, capital letters are for sets and corresponding lowercase will be the index. Single letters are used mainly for conciseness.\n\n## Parameters\n\nParameters of a math optimization problem are values treated as constants in the model and are associated with the decision variables. For this decision problem these values are the limits of each production facility, the demand for each distribution center, and the pairwise costs between production and distribution locations. \n\n- $m_p$ is the max production in location $p$, $\\forall p \\in P \\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\space\\space \\texttt{max}\\_\\texttt{prod[p]}$\n- $n_d$ is the number of customers for a distribution center $d$, $\\forall d \\in D \\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad \\texttt{n}\\_\\texttt{demand[d]}$\n- $c_{p,d}$ is the cost to ship a widget between location $p$ and location $d$, $\\forall p \\in P, d \\in D \\quad\\quad\\quad \\texttt{cost[p,d]}$\n\nWe also have the requirement that each production facility needs to produce at 75% of this maximum output. We'll denote this value by $a$ in the formulation \"frac\" for the fraction of maximum production required. Initially we set $a = 0.75$.\n\n## Decision Variables\nThis is what the optimization solver determines, which are the actions you have control over. As a reminder, they come in three main flavors:\n- `Continuous`: Price of a product\n- `Integer`: The number of food trucks to use for an event\n- `Binary`: Yes/no decision to include a certain stock in a portfolio\n\nDecision variables (and parameters) are indexed using elements of sets that we define for the problem. In this example, let's start with a set of cities that produce our widget, which we call set $P$ for the formulation but can define as 'production' in the code. And a set of cities that distribute the widget $D$ and 'distribution' similarly. The decision here is to determine the number of boxes to send from each production facility to each distribution location. \n\nLet $x_{p,d}$ be the number of widgets that are produced at facility $i$ and shipped to location $j$.\n\n### Add Variables in gurobipy\n`gurobipy` let's you add decision variables primarily with two (similar) commands:\n- [addVar()](https://www.gurobi.com/documentation/10.0/refman/py_model_addvar.html) adds a single variable\n- [addVars()](https://www.gurobi.com/documentation/10.0/refman/py_model_addvar.html) adds a group of variables by sets/indices\n\nWhen using `addVars` you have to provide the indices of the variables you want to add, which for us are the production and distribution locations. There are other arguments we can use and will cover a couple of them later on.  \n\n### Our Decision Variables\nAs is often the case in writing code, there are several ways to get to the same point. Below we can see three different ways to create the decision variables.\n\n    Requirements:\n    - Use gurobipy (Model, GRB, addVar/addConstr, etc.)\n    - Make the script runnable as a standalone Python file if possible.\n    - Keep the code faithful to the example.\n"}, {"role": "assistant", "content": "# First, import packages\nimport pandas as pd\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# Sets P and D, respectively\n# When we code sets we can be more descriptive in the name\nproduction = ['Baltimore','Cleveland','Little Rock','Birmingham','Charleston']\ndistribution = ['Columbia','Indianapolis','Lexington','Nashville','Richmond','St. Louis']\n\n# Define a gurobipy model for the decision problem\nm = gp.Model('widgets')\n\n# Use .squeeze(\"columns\") to make the costs a series\npath = 'https://raw.githubusercontent.com/Gurobi/modeling-examples/master/optimization101/Modeling_Session_1/'\ntransp_cost = pd.read_csv(path + 'cost.csv', index_col=[0,1]).squeeze(\"columns\")\n# transp_cost = pd.read_csv('cost.csv', index_col=[0,1]).squeeze(\"columns\")\n# Pivot to view the costs a bit easier\ntransp_cost.reset_index().pivot(index='production', columns='distribution', values='cost')\n\nmax_prod = pd.Series([180,200,140,80,180], index = production, name = \"max_production\")\nn_demand = pd.Series([89,95,121,101,116,181], index = distribution, name = \"demand\") \nmax_prod.to_frame()\n#n_demand.to_frame()\n\nfrac = 0.75\n\n# loop through each p and d combination to create a decision variable\nm = gp.Model('widgets')\nx = {}\nfor p in production:\n    for d in distribution:\n        x[p,d] = m.addVar(name = p+\"_to_\"+d)\nm.update()\nx\n\n# Provide each set for the indices \nm = gp.Model('widgets')\nx = m.addVars(production, distribution, name = 'prod_ship')\nm.update()\nx\n\n# The index of the tranporation costs have each combination of prodiction and distribution location\nm = gp.Model('widgets')\nx = m.addVars(transp_cost.index, name = 'prod_ship')\nm.update()\nx\n\nmeet_demand = m.addConstrs((gp.quicksum(x[p,d] for p in production) >= n_demand[d] for d in distribution), name = 'meet_demand')\n#meet_demand = m.addConstrs(x.sum('*', j) >= demand[j] for j in distribution)\nm.update()\nmeet_demand\n\ncan_produce = m.addConstrs((gp.quicksum(x[p,d] for d in distribution) <= max_prod[p] for p in production), name = 'can_produce')# (x.sum(i, '*')\nmust_produce = m.addConstrs((gp.quicksum(x[p,d] for d in distribution) >= frac*max_prod[p] for p in production), name = 'must_produce')\nm.update()\ncan_produce\n\nm.setObjective(gp.quicksum(transp_cost[i,j]*x[i,j] for i in production for j in distribution), GRB.MINIMIZE)\n\nm.write('widget_shipment.lp')\n\nm.optimize()\n\nx_values = pd.Series(m.getAttr('X', x), name = \"shipment\", index = transp_cost.index)\nsol = pd.concat([transp_cost, x_values], axis=1)\n#sol \nsol[sol.shipment > 0]\n\n# You can get the name and value of all the decision variables:\nall_vars = {v.varName: v.x for v in m.getVars()} \nall_vars\n\nxvals = {k: v.x for k,v in x.items() if v.x > 0} \nxvals\n\nx_values.sum(), n_demand.sum()\n\n# Sum the shipment amount by production facility\nship_out = sol.groupby('production')['shipment'].sum()\npd.DataFrame({'Remaining':max_prod - ship_out, 'Utilization':ship_out/max_prod})\n\npd.DataFrame({'Remaining':[can_produce[p].Slack for p in production], \n              'Utilization':[1-can_produce[p].Slack/max_prod[p] for p in production]}, \n             index = production)\n\n# We use m2 for the second model\n# These parts are the same as above outside of the new model name\nm2 = gp.Model('widgets2')\nx = m2.addVars(production, distribution, obj = transp_cost, name = 'prod_ship')\nmeet_demand = m2.addConstrs((gp.quicksum(x[p,d] for p in production) >= n_demand[d] for d in distribution), name = 'meet_demand')\n\ncan_produce = m2.addConstrs((gp.quicksum(x[p,d] for d in distribution) <= max_prod[p] for p in production if p != 'Birmingham'), name = 'can_produce')\nmust_produce =  m2.addConstrs((gp.quicksum(x[p,d] for d in distribution) >= frac*max_prod[p] for p in production if p != 'Birmingham'), name = 'must_produce')\n\nxprod = m2.addVars(range(2), vtype = GRB.BINARY, obj = [50, 75], name = 'expand_Birmingham_prod')\n\nBirmingham_max = m2.addConstr(gp.quicksum(x['Birmingham',d] for d in distribution) <= max_prod['Birmingham'] + 25*xprod[0] + 50*xprod[1], name = 'Birmingham_add_max')\nBirmingham_min = m2.addConstr(gp.quicksum(x['Birmingham',d] for d in distribution) >= frac*(max_prod['Birmingham'] + 25*xprod[0] + 50*xprod[1]), name = 'Birmingham_add_min')\n\nBirmingham_lim = m2.addConstr(gp.quicksum(xprod[i] for i in range(2)) <= 1, name = 'expansion_choice')\n\nm2.optimize()\n\nobj1 = m.getObjective()\nobj2 = m2.getObjective()\nprint(f\"The original model had a total cost of {round(obj1.getValue(),2)}\")\nprint(f\"The new formualtion has a total cost of {round(obj2.getValue(),2)}\")\n\npd.Series(m2.getAttr('X', xprod))\n\nx2_values = pd.Series(m2.getAttr('X', x), name = \"shipment\", index = transp_cost.index)\nsol2 = pd.concat([transp_cost, x2_values], axis=1)\nsol2[sol2.shipment > 0]\n\nm.dispose()\nm2.dispose()\ngp.disposeDefaultEnv()"}]}
{"meta": {"source_path": "/Users/sunyujun03/Desktop/ReLoop/gurobi-modeling-examples/optimization101/Modeling_Session_1/modeling1.ipynb", "kind": "ipynb", "title": "Translating a Decision Problem to an Optimization Model"}, "messages": [{"role": "system", "content": "You are an optimization engineer. Write correct and runnable Python code using gurobipy (Gurobi Python API). Be concise. Output only what is requested."}, {"role": "user", "content": "    Task: Reproduce the following Gurobi modeling example in Python using gurobipy.\n\n    Scenario description (from source):\n    # Translating a Decision Problem to an Optimization Model\n\nIn the first video we discussed a few key concepts that are necessary for mathematical optimization:\n- parameters \n- decision variables\n- constraints\n- objective function\n\nIn this first modeling example we will see how these are used to formulate a decision problem as an optimization model and code the formulation using `gurobipy`. For more information on all of the commands in the Python API check out our [documentation](https://www.gurobi.com/documentation/10.0/refman/py_python_api_details.html).\n\n## The Decision Problem\nWe make widgets. Have a set of production facilities that produce boxes of widgets. There is also a set of distribution locations that will then distribute the widgets for sale. Each distribution center has a forecasted demand and each production facility has a min and max number of widgets it can make during this period. We need to ensure that each distribution facility receives enough widgets to satisfy demand from production and we want to do this at minimal cost. The minimum production is 75% of the production facilities max value. \n\n## Sets and Define Model\nOur sets are:\n- $P = \\{\\texttt{'Baltimore', 'Cleveland', 'Little Rock', 'Birmingham', 'Charleston'}\\} \\quad\\quad\\quad\\quad\\quad\\quad\\quad\\space\\space \\texttt{production}$\n- $D = \\{\\texttt{'Columbia', 'Indianapolis', 'Lexington', 'Nashville', 'Richmond', 'St. Louis'}\\} \\quad\\quad\\quad \\texttt{distribution}$\n\nTo index each set, we'll use the lowercase letter of each set. Letters used for sets and indices are up to you. Typically, capital letters are for sets and corresponding lowercase will be the index. Single letters are used mainly for conciseness.\n\n## Parameters\n\nParameters of a math optimization problem are values treated as constants in the model and are associated with the decision variables. For this decision problem these values are the limits of each production facility, the demand for each distribution center, and the pairwise costs between production and distribution locations. \n\n- $m_p$ is the max production in location $p$, $\\forall p \\in P \\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\space\\space \\texttt{max}\\_\\texttt{prod[p]}$\n- $n_d$ is the number of customers for a distribution center $d$, $\\forall d \\in D \\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad \\texttt{n}\\_\\texttt{demand[d]}$\n- $c_{p,d}$ is the cost to ship a widget between location $p$ and location $d$, $\\forall p \\in P, d \\in D \\quad\\quad\\quad \\texttt{cost[p,d]}$\n\nWe also have the requirement that each production facility needs to produce at 75% of this maximum output. We'll denote this value by $a$ in the formulation \"frac\" for the fraction of maximum production required. Initially we set $a = 0.75$.\n\n## Decision Variables\nThis is what the optimization solver determines, which are the actions you have control over. As a reminder, they come in three main flavors:\n- `Continuous`: Price of a product\n- `Integer`: The number of food trucks to use for an event\n- `Binary`: Yes/no decision to include a certain stock in a portfolio\n\nDecision variables (and parameters) are indexed using elements of sets that we define for the problem. In this example, let's start with a set of cities that produce our widget, which we call set $P$ for the formulation but can define as 'production' in the code. And a set of cities that distribute the widget $D$ and 'distribution' similarly. The decision here is to determine the number of boxes to send from each production facility to each distribution location. \n\nLet $x_{p,d}$ be the number of widgets that are produced at facility $p$ and shipped to location $d$.\n\n### Add Variables in gurobipy\n`gurobipy` let's you add decision variables primarily with two (similar) commands:\n- [addVar()](https://www.gurobi.com/documentation/10.0/refman/py_model_addvar.html) adds a single variable\n- [addVars()](https://www.gurobi.com/documentation/10.0/refman/py_model_addvar.html) adds a group of variables by sets/indices\n\nWhen using `addVars` you have to provide the indices of the variables you want to add, which for us are the production and distribution locations. There are other arguments we can use and will cover a couple of them later on.  \n\n### Our Decision Variables\nAs is often the case in writing code, there are several ways to get to the same point. Below we can see three different ways to create the decision variables.\n\n    Requirements:\n    - Use gurobipy (Model, GRB, addVar/addConstr, etc.)\n    - Make the script runnable as a standalone Python file if possible.\n    - Keep the code faithful to the example.\n"}, {"role": "assistant", "content": "# Import packages\nimport pandas as pd\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# Sets P and D, respectively\n# When we code sets we can be more descriptive in the name\nproduction = ['Baltimore','Cleveland','Little Rock','Birmingham','Charleston']\ndistribution = ['Columbia','Indianapolis','Lexington','Nashville','Richmond','St. Louis']\n\n# Define a gurobipy model for the decision problem\nm = gp.Model('widgets')\n\n# Use .squeeze(\"columns\") to make the costs a series\npath = 'https://raw.githubusercontent.com/Gurobi/modeling-examples/master/optimization101/Modeling_Session_1/'\ntransp_cost = pd.read_csv(path + 'cost.csv', index_col=[0,1]).squeeze(\"columns\")\n# transp_cost = pd.read_csv('cost.csv', index_col=[0,1]).squeeze(\"columns\")\n# Pivot to view the costs a bit easier\ntransp_cost.reset_index().pivot(index='production', columns='distribution', values='cost')\n\nmax_prod = pd.Series([180,200,140,80,180], index = production, name = \"max_production\")\nn_demand = pd.Series([89,95,121,101,116,181], index = distribution, name = \"demand\") \nmax_prod.to_frame()\n#n_demand.to_frame()\n\nfrac = 0.75\n\n# loop through each p and d combination to create a decision variable\nm = gp.Model('widgets')\n\n# Provide each set for the indices \nm = gp.Model('widgets')\n\n# The index of the tranporation costs have each combination of prodiction and distribution location\nm = gp.Model('widgets')\n\nm.write('widget_shipment.lp')\n\nm.optimize()\n\nx_values = pd.Series(m.getAttr('X', x), name = \"shipment\", index = transp_cost.index)\nsol = pd.concat([transp_cost, x_values], axis=1)\n#sol \nsol[sol.shipment > 0]\n\n# You can get the name and value of all the decision variables:\nall_vars = {v.varName: v.x for v in m.getVars()} \nall_vars\n\nxvals = {k: v.x for k,v in x.items() if v.x > 0} \nxvals\n\n# Sum the shipment amount by production facility\nship_out = sol.groupby('production')['shipment'].sum()\npd.DataFrame({'Remaining':max_prod - ship_out, 'Utilization':ship_out/max_prod})\n\npd.DataFrame({'Remaining':[can_produce[p].Slack for p in production], \n              'Utilization':[1-can_produce[p].Slack/max_prod[p] for p in production]}, \n             index = production)\n\n# We use m2 for the second model\n# These parts are the same as above outside of the new model name\nm2 = gp.Model('widgets2')\nx = m2.addVars(production, distribution, obj = transp_cost, name = 'prod_ship')\nmeet_demand = m2.addConstrs((gp.quicksum(x[p,d] for p in production) >= n_demand[d] for d in distribution), name = 'meet_demand')\n\nm2.optimize()\n\nobj1 = m.getObjective()\nobj2 = m2.getObjective()\nprint(f\"The original model had a total cost of {round(obj1.getValue(),2)}\")\nprint(f\"The new formualtion has a total cost of {round(obj2.getValue(),2)}\")\n\npd.Series(m2.getAttr('X', xprod))\n\nx2_values = pd.Series(m2.getAttr('X', x), name = \"shipment\", index = transp_cost.index)\nsol2 = pd.concat([transp_cost, x2_values], axis=1)\nsol2[sol2.shipment > 0]"}]}
{"meta": {"source_path": "/Users/sunyujun03/Desktop/ReLoop/gurobi-modeling-examples/curve_fitting/curve_fitting.ipynb", "kind": "ipynb", "title": "Curve Fitting"}, "messages": [{"role": "system", "content": "You are an optimization engineer. Write correct and runnable Python code using gurobipy (Gurobi Python API). Be concise. Output only what is requested."}, {"role": "user", "content": "    Task: Reproduce the following Gurobi modeling example in Python using gurobipy.\n\n    Scenario description (from source):\n    # Curve Fitting\n\n## Objective and Prerequisites\n\nTry this Jupyter Notebook Modeling Example to learn how you can fit a function to a set of observations. We will formulate this regression problem as a linear programming problem using the Gurobi Python API and then solve it with the Gurobi Optimizer.\n\nThis model is example 11 from the fifth edition of Model Building in Mathematical Programming, by H. Paul Williams on pages 266 and 319-320.\n\nThis modeling example is at the beginner level, where we assume that you know Python and that you have some knowledge about building mathematical optimization models. The reader should also consult the \n[documentation](https://www.gurobi.com/resources/?category-filter=documentation) \nof the Gurobi Python API.\n\n**Download the Repository** <br />\nYou can download the repository containing this and other examples by clicking [here](https://github.com/Gurobi/modeling-examples/archive/master.zip). \n\n## Model Formulation\n\n### Sets and Indices\n\n$i \\in \\text{Observations}=\\{1, .. ,n\\}$.\n\n### Parameters\n\n$x_{i} \\in \\mathbb{R}$: Independent variable value at observation $i$.\n\n$y_{i} \\in \\mathbb{R}$: Dependent variable value at observation $i$.\n\n### Decision Variables\n\n$a \\in \\mathbb{R}$: Value of the constant term in the function that explains the values of $y$ in terms of the values of $x$.\n\n$b \\in \\mathbb{R}$: Coefficient of the linear term in the function that explains the values of $y$ in terms of the values of $x$.\n\n$u_{i} \\in \\mathbb{R}^+$: Positive deviation of the proposed function of x with respect to the value of y at observation $i$.\n\n$v_{i} \\in \\mathbb{R}^+$: Negative deviation of the proposed function of x with respect to the value of y at observation $i$.\n\n$z$: Value of the maximum deviation.\n\nWe model the problem for the first goal:\n\n* Fit a line $y=a+bx$ to the given data set in order to minimize the sum of absolute deviations of each observed value of $y$ from the value predicted by the linear relationship.\n\n### Constraints Problem 1\n\n**Deviation**: Each pair of corresponding data values $(x_{i},y_{i})$ gives rise to the following constraint.\n\n\\begin{equation}\nbx_{i} + a + u_{i} - v_{i} = y_{i}  \\quad \\forall i \\in \\text{Observations}\n\\end{equation}\n\nWhere $x_{i}$  and $y_{i}$  are  the given values in the set of observations, $b$, $a$, $u_{i}$ and $v_{i}$ are variables. \nThe positive deviation $u_{i}$ and the negative deviation $v_{i}$ give the amounts by which the values of $y_{i}$ proposed by the linear expression differ from the observed values.\n\n### Objective Function Problem 1\n\n**Total deviation**: The objective is to minimize the total positive and negative deviations.\n\n\\begin{equation}\n\\text{Minimize} \\quad \\sum_{i \\in \\text{Observations}} (u_{i} + v_{i})\n\\end{equation}\n\nWe now provide a model formulation for the second goal:\n\n* Fit a line $y=a+bx$ to the given data set in order to  minimize the maximum deviation of all the observed values of $y$ from the value predicted by the linear relationship.\n\nFor this new formulation, in addition to the \"Deviation constraints\", we need to include the following constraints.\n\n### Constraints Problem 2\n\n**Maximum deviation**: The following constraints ensure that the decision variable $z$ takes the value of the maximum deviation.\n\n\\begin{equation}\nz \\geq u_{i}  \\quad \\forall i \\in \\text{Observations}\n\\end{equation}\n\n\\begin{equation}\nz \\geq v_{i}  \\quad \\forall i \\in \\text{Observations}\n\\end{equation}\n\n### Objective Function Problem 2\n\n**Minimum/Maximum deviation**: The objective is to minimize the maximum deviation.\n\n\\begin{equation}\n\\text{Minimize} \\quad z\n\\end{equation}\n\n## Python Implementation\n\nWe import the Gurobi Python Module.\n\n## Input data\n\nWe define the corresponding values for $x$ and $y$ in the set of observations.\n\n    Requirements:\n    - Use gurobipy (Model, GRB, addVar/addConstr, etc.)\n    - Make the script runnable as a standalone Python file if possible.\n    - Keep the code faithful to the example.\n"}, {"role": "assistant", "content": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# tested with Python 3.7.0 & Gurobi 9.1.0\n\n# Sample data: values of independent variable x and dependent variable y\n\nobservations, x, y = gp.multidict({\n    ('1'): [0,1],\n    ('2'): [0.5,0.9],\n    ('3'): [1,0.7],\n    ('4'): [1.5,1.5],\n    ('5'): [1.9,2],\n    ('6'): [2.5,2.4],\n    ('7'): [3,3.2],\n    ('8'): [3.5,2],\n    ('9'): [4,2.7],\n    ('10'): [4.5,3.5],\n    ('11'): [5,1],\n    ('12'): [5.5,4],\n    ('13'): [6,3.6],\n    ('14'): [6.6,2.7],\n    ('15'): [7,5.7],\n    ('16'): [7.6,4.6],\n    ('17'): [8.5,6],\n    ('18'): [9,6.8],\n    ('19'): [10,7.3]\n})\n\nmodel = gp.Model('CurveFitting')\n\n# Constant term of the function f(x). This is a free continuous variable that can take positive and negative values. \na = model.addVar(lb=-GRB.INFINITY, ub=GRB.INFINITY, vtype=GRB.CONTINUOUS, name=\"a\")\n\n# Coefficient of the linear term of the function f(x). This is a free continuous variable that can take positive \n# and negative values.\nb = model.addVar(lb=-GRB.INFINITY, ub=GRB.INFINITY, vtype=GRB.CONTINUOUS, name=\"b\")\n\n# Non-negative continuous variables that capture the positive deviations\nu = model.addVars(observations, vtype=GRB.CONTINUOUS, name=\"u\")\n\n# Non-negative continuous variables that capture the negative deviations\nv = model.addVars(observations, vtype=GRB.CONTINUOUS, name=\"v\")\n\n# Non-negative continuous variables that capture the value of the maximum deviation\nz = model.addVar(vtype=GRB.CONTINUOUS, name=\"z\")\n\n# Deviation constraints\n\ndeviations = model.addConstrs( (b*x[i] + a + u[i] - v[i] == y[i] for i in observations), name='deviations')\n\n# Objective function of problem 1\n\nmodel.setObjective(u.sum('*') + v.sum('*'))\n\n# Verify model formulation\n\nmodel.write('CurveFitting.lp')\n\n# Run optimization engine\n\nmodel.optimize()\n\n# Output report\n\nprint(\"\\n\\n_________________________________________________________________________________\")\nprint(f\"The best straight line that minimizes the absolute value of the deviations is:\")\nprint(\"_________________________________________________________________________________\")\nprint(f\"y = {b.x:.4f}x + ({a.x:.4f})\")\n\n# Maximum deviation constraints\n\nmaxPositive_deviation = model.addConstrs( (z >= u[i] for i in observations), name='maxPositive_deviation')\n\nmaxNegative_deviation = model.addConstrs( (z >= v[i] for i in observations), name='maxNegative_deviation')\n\n# Objective function for Problem 2\n\nmodel.setObjective(z)\n\n# Run optimization engine\n\nmodel.optimize()\n\n# Output report\n\nprint(\"\\n\\n_________________________________________________________________________________\")\nprint(f\"The best straight line that minimizes the maximum deviation is:\")\nprint(\"_________________________________________________________________________________\")\nprint(f\"y = {b.x:.4f}x + ({a.x:.4f})\")"}]}
{"meta": {"source_path": "/Users/sunyujun03/Desktop/ReLoop/gurobi-modeling-examples/covid19_facility_location/covid19_facility_location.ipynb", "kind": "ipynb", "title": "COVID-19: Healthcare Facility Capacity Optimization"}, "messages": [{"role": "system", "content": "You are an optimization engineer. Write correct and runnable Python code using gurobipy (Gurobi Python API). Be concise. Output only what is requested."}, {"role": "user", "content": "    Task: Reproduce the following Gurobi modeling example in Python using gurobipy.\n\n    Scenario description (from source):\n    # COVID-19: Healthcare Facility Capacity Optimization\n\n## Objective and Prerequisites\n\nThis COVID-19 Healthcare Facility Capacity Optimization problem shows you how to determine the optimal location and capacity of healthcare facilities in order to:\n\n* Satisfy demand from COVID-19 patients for treatment,\n* Minimize the cost of opening temporary facilities for healthcare providers, and\n* Predict the allocation of COVID-19 patients from a specific county to a specific healthcare facility.\n\nThis modeling example is at the beginner level, where we assume that you know Python and that you have some knowledge of how to build mathematical optimization models.\n\n**Download the Repository** <br />\nYou can download the repository containing this and other examples by clicking [here](https://github.com/Gurobi/modeling-examples/archive/master.zip). \n\n---\n## Problem Description\n\nHospitals in various counties throughout the US are reaching full capacity due to a surge in COVID-19 patients. Many hospitals are considering creating temporary facilities to increase their capacity to handle COVID-19 patients.\n\n![temporary facility](covid19-trailerFacilty.jpg)\n\nIn this example, we focus on nine counties in the US. Each county has existing facilities to treat COVID-19 patients, and also has the option of building temporary facilities to increase the overall capacity to handle COVID-19 patients.\n\nThe following table defines the coordinates of the centroid and the forecasted demand (i.e. the projected number of COVID-19 patients) of each county. To estimate this demand, we consider the population of nine fictional counties in California, the current number of COVID-19 cases per day in California, the average percentage of COVID-19 cases who require hospitalization, and the average number of days that a COVID-19 patient stays in the hospital.\n\n| Centroid | Coordinates |  Demand |\n| --- | --- | --- |\n| county 1 | (1, 1.5) | 351 |\n| county 2 | (3, 1) | 230 |\n| county 3 | (5.5, 1.5) | 529 |\n| county 4 | (1, 4.5 ) | 339 |\n| county 5 | (3, 3.5) | 360 |\n| county 6 | (5.5, 4.5) | 527 |\n| county 7 | (1, 8) | 469 |\n| county 8 | (3, 6) | 234 |\n| county 9 | (4.5, 8) | 500 |\n\nThe following table defines the coordinates and capacity of existing facilities. The capacity of existing facilities is calculated as 80% of the forecasted demand of the county in which the existing facilities are located. The exception to this is county 9, where we assume that we have an excess of existing capacity.\n\n| Existing | Coordinates |  Capacity |\n| --- | --- | --- |\n| facility 1 | (1, 2) | 281 |\n| facility 2 | (2.5, 1) | 187 |\n| facility 3 | (5, 1) | 200 |\n| facility 4 | (6.5, 3.5) | 223 |\n| facility 5 | (1, 5) | 281 |\n| facility 6 | (3, 4) | 281 |\n| facility 7 | (5, 4) | 222 |\n| facility 8 | (6.5, 5.5) | 200 |\n| facility 9 | (1, 8.5) | 250 |\n| facility 10 | (1.5, 9.5) | 125 |\n| facility 11 | (8.5, 6) | 187 |\n| facility 12 | (5, 8) | 300 |\n| facility 13 | (3, 9) | 300 |\n| facility 14 | (6, 9) | 243 |\n\nThe following table defines the coordinates and capacity of new temporary facilities. The cost of building a temporary facility\nwith a capacity of treating one hundred COVID-19 patients is $\\$500,000$.\n\n| Temporary | Coordinates |  Capacity |\n| --- | --- | --- |\n| facility 15 | (1.5, 1) | 100 |\n| facility 16 | (3.5, 1.5) | 100 |\n| facility 17 | (5.5, 2.5) | 100 |\n| facility 18 | (1.5, 3.5) | 100 |\n| facility 19 | (3.5, 2.5) | 100 |\n| facility 20 | (4.5, 4.5) | 100 |\n| facility 21 | (1.5, 6.5) | 100 |\n| facility 22 | (3.5, 6.5) | 100 |\n| facility 23 | (5.5, 6.5) | 100 |\n\nThe coordinates of the three tables are in tens of miles. We assume that each increase of 10 miles in the distance to a COVID-19 facility results in a $\\$5$ increase in driving costs for each COVID-19 patient.\n\nIn this example, the goal is to identify which temporary facilities to build in order to be able to accommodate demand for treatment by COVID-19 patients while minimizing the total cost of COVID-19 patients driving to an existing or temporary COVID-19 facility and the total cost of building temporary facilities.\n\nThis example shows how a Facility Location mixed-integer programming (MIP) model can help healthcare providers make decisions about:\n\n* How to best utilize their capacity, \n* Whether to build temporary facilities for COVID-19 patients, and\n* How COVID-19 patients from a county should be allocated to various healthcare facilities in order to ensure that the facilities have the capacity to provide treatment for the patients.\n\nThis Jupyter Notebook is based on the paper written by Katherine Klise and Michael Bynum [1].\n\n## Model Formulation\n\n### Sets and Indices\n\n$e \\in E$: Index and set of existing healthcare facility locations.\n\n$t \\in T$: Index and set of temporary healthcare facility locations.\n\n$f \\in F = E \\cup T$: Index and set of all healthcare facility locations.\n\n$c \\in C$: Index and set of counties.\n\n### Parameters\n\n$Dist_{c,f} \\in \\mathbb{R}^+$: Distance between county $c$ and facility location $f$.\n\n$Dem_{c} \\in \\mathbb{R}^+$: Expected number of people in county $c$ who will need a COVID-19 facility.\n\n$Cap_{f} \\in \\mathbb{R}^+$: Number of people that can be served by a facility at location $f$.\n\n$\\text{dCost} = 5$: Cost of driving 10 miles.\n\n$\\text{tFCost} = 500,000$: Cost of building a temporary COVID-19 facility with a capacity of treating 100 COVID-19 patients.\n\n$bigM$: Penalty of adding extra capacity at temporary facilities in order to satisfy treatment of COVID-19 patients demand.\n\n### Decision Variables\n\n$y_{t} \\in \\{0, 1 \\}$: This variable is equal to 1 if we build a temporary facility at location $t$; and 0 otherwise.\n\n$ x_{c,f} \\in \\mathbb{R}^+$: Number of people from county $c$ served by a facility at location $f$.\n\n$z_{t} \\in \\mathbb{R}^+$: Extra capacity added at temporary facility location $t$.\n\n### Objective Function\n\n- **Cost**. We want to minimize the total cost of patients driving from a county to a healthcare facility and the total cost of building temporary COVID-19 treatment capacity. The last term with the big penalty coefficient ($bigM$), enables extra capacity to be added at a temporary facility to ensure that total demand is satisfied.\n\n\n\\begin{equation}\n\\text{Min} \\quad Z = \\sum_{c \\in C} \\sum_{f \\in F} \\text{dCost} *Dist_{c,f} * x_{c,f} + \n\\text{tFCost}*\\sum_{t \\in T} y_{t} + bigM*\\sum_{t \\in T} z_{t}\n\\tag{0}\n\\end{equation}\n\n### Constraints\n\n- **Demand**. Satisfy county demand of service from a COVID-19 facility.\n\n\\begin{equation}\n\\sum_{f \\in F} x_{c,f} = Dem_{c} \\quad \\forall c \\in C\n\\tag{1}\n\\end{equation}\n\n- **Existing facilities**. Capacity of an existing location of a facility cannot be exceeded.\n\n\\begin{equation}\n\\sum_{c \\in C} x_{c,e} \\leq Cap_{e} \\quad \\forall e \\in E\n\\tag{2}\n\\end{equation}\n\n- **Temporary facilities**. Capacity of a temporary location of a facility cannot be exceeded. Please observe that extra capacity can be added.\n\n\\begin{equation}\n\\sum_{c \\in C} x_{c,t} \\leq Cap_{t}*y_{t} + z_{t} \\quad \\forall t \\in T\n\\tag{3}\n\\end{equation}\n\n    Requirements:\n    - Use gurobipy (Model, GRB, addVar/addConstr, etc.)\n    - Make the script runnable as a standalone Python file if possible.\n    - Keep the code faithful to the example.\n"}, {"role": "assistant", "content": "from itertools import product\nfrom math import sqrt\n\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# tested with Gurobi v9.1.0 and Python 3.7.0\n\ndef compute_distance(loc1, loc2):\n    \n    # This function determines the Euclidean distance between a facility and a county centroid.\n    \n    dx = loc1[0] - loc2[0]\n    dy = loc1[1] - loc2[1]\n    return sqrt(dx*dx + dy*dy)\n\ndef solve_covid19_facility(c_coordinates, demand):\n    \n    #####################################################\n    #                    Data\n    #####################################################\n    \n    # Indices for the counties\n    counties = [*range(1,10)]\n    \n    # Indices for the facilities\n    facilities = [*range(1,24)]\n    \n    # Create a dictionary to capture the coordinates of an existing facility and capacity of treating COVID-19 patients\n    \n    existing, e_coordinates, e_capacity  = gp.multidict({\n        1: [(1, 2), 281],\n        2: [(2.5, 1), 187],\n        3: [(5, 1), 200],\n        4: [(6.5, 3.5), 223],\n        5: [(1, 5), 281],\n        6: [(3, 4), 281],\n        7: [(5, 4), 222],\n        8: [(6.5, 5.5), 200],\n        9: [(1, 8.5), 250], \n        10: [(1.5, 9.5), 125],\n        11: [(8.5, 6), 187],\n        12: [(5, 8), 300],\n        13: [(3, 9), 300],\n        14: [(6, 9), 243]\n    })\n    \n    # Create a dictionary to capture the coordinates of a temporary facility and capacity of treating COVID-19 patients\n    \n    temporary, t_coordinates, t_capacity  = gp.multidict({\n        15: [(1.5, 1), 100],\n        16: [(3.5, 1.5), 100],\n        17: [(5.5, 2.5), 100],\n        18: [(1.5, 3.5), 100],\n        19: [(3.5, 2.5), 100],\n        20: [(4.5, 4.5), 100],\n        21: [(1.5, 6.5), 100],\n        22: [(3.5, 6.5), 100],\n        23: [(5.5, 6.5), 100]\n    })\n    \n    # Cost of driving 10 miles\n    dcost = 5\n    \n    # Cost of building a temporary facility with capacity of 100 COVID-19\n    tfcost = 500000\n    \n    # Compute key parameters of MIP model formulation\n    f_coordinates = {}\n    for e in existing:\n        f_coordinates[e] = e_coordinates[e]\n    \n    for t in temporary:\n        f_coordinates[t] = t_coordinates[t]\n    \n    # Cartesian product of counties and facilities\n    cf = []\n    \n    for c in counties:\n        for f in facilities:\n            tp = c,f\n            cf.append(tp)\n        \n    # Compute distances between counties centroids and facility locations\n    distance = {(c,f): compute_distance(c_coordinates[c], f_coordinates[f]) for c, f in cf}\n    \n    #####################################################\n    #                    MIP Model Formulation\n    #####################################################\n    \n    m = gp.Model('covid19_temporary_facility_location')\n    \n    # Build temporary facility\n    y = m.addVars(temporary, vtype=GRB.BINARY, name='temporary')\n    \n    # Assign COVID-19 patients of county to facility\n    x = m.addVars(cf, vtype=GRB.CONTINUOUS, name='Assign')\n    \n    # Add capacity to temporary facilities\n    z = m.addVars(temporary, vtype=GRB.CONTINUOUS, name='addCap' )\n    \n    # Objective function: Minimize total distance to drive to a COVID-19 facility\n    \n    # Big penalty for adding capacity at a temporary facility\n    bigM = 1e9\n    \n    m.setObjective(gp.quicksum(dcost*distance[c,f]*x[c,f] for c,f in cf) \n                   + tfcost*y.sum()\n                   + bigM*z.sum(), GRB.MINIMIZE)\n    \n    # Counties demand constraints\n    demandConstrs = m.addConstrs((gp.quicksum(x[c,f] for f in facilities) == demand[c] for c in counties), \n                                 name='demandConstrs')\n    \n    # Existing facilities capacity constraints\n    existingCapConstrs = m.addConstrs((gp.quicksum(x[c,e]  for c in counties) <= e_capacity[e] for e in existing ), \n                                      name='existingCapConstrs')\n    \n    # temporary facilities capacity constraints\n    temporaryCapConstrs = m.addConstrs((gp.quicksum(x[c,t]  for c in counties) -z[t] \n                                        <= t_capacity[t]*y[t] for t in temporary ),\n                                       name='temporaryCapConstrs')\n    # Run optimization engine\n    m.optimize()\n    \n    #####################################################\n    #                    Output Reports\n    #####################################################\n    \n    # Total cost of building temporary facility locations\n    temporary_facility_cost = 0\n    \n    print(f\"\\n\\n_____________Optimal costs______________________\")\n    for t in temporary:\n        if (y[t].x > 0.5):\n            temporary_facility_cost += tfcost*round(y[t].x)\n        \n    patient_allocation_cost = 0\n    for c,f in cf:\n        if x[c,f].x > 1e-6:\n            patient_allocation_cost += dcost*round(distance[c,f]*x[c,f].x)\n            \n    print(f\"The total cost of building COVID-19 temporary healhtcare facilities is ${temporary_facility_cost:,}\") \n    print(f\"The total cost of allocating COVID-19 patients to healtcare facilities is ${patient_allocation_cost:,}\")  \n    \n    # Build temporary facility at location\n    \n    print(f\"\\n_____________Plan for temporary facilities______________________\")\n    for t in temporary:\n        if (y[t].x > 0.5):\n            print(f\"Build a temporary facility at location {t}\")\n            \n    # Extra capacity at temporary facilities\n    print(f\"\\n_____________Plan to increase Capacity at temporary Facilities______________________\")\n    for t in temporary:\n        if (z[t].x > 1e-6):\n            print(f\"Increase  temporary facility capacity at location {t} by {round(z[t].x)} beds\")\n\n    # Demand satisfied at each facility\n    f_demand = {}\n    \n    print(f\"\\n_____________Allocation of county patients to COVID-19 healthcare facility______________________\")\n    for f in facilities:\n        temp = 0\n        for c in counties:\n            allocation = round(x[c,f].x)\n            if allocation > 0:\n                print(f\"{allocation} COVID-19 patients from county {c} are treated at facility {f} \")\n            temp += allocation\n        f_demand[f] = temp\n        print(f\"{temp} is the total number of COVID-19 patients that are treated at facility {f}. \")\n        print(f\"\\n________________________________________________________________________________\")\n        \n    # Test total demand = total demand satisfied by facilities\n    total_demand = 0\n    \n    for c in counties:\n        total_demand += demand[c]\n        \n    demand_satisfied = 0\n    for f in facilities:\n        demand_satisfied += f_demand[f]\n        \n    print(f\"\\n_____________Test demand = supply______________________\")\n    print(f\"Total demand is: {total_demand:,} patients\")\n    print(f\"Total demand satisfied is: {demand_satisfied:,} beds\")\n\n# Create a dictionary to capture the coordinates of a county and the demand of COVID-19 treatment\n\ncounties, coordinates, forecast  = gp.multidict({\n    1: [(1, 1.5), 351],\n    2: [(3, 1), 230],\n    3: [(5.5, 1.5), 529],\n    4: [(1, 4.5 ), 339],\n    5: [(3, 3.5), 360],\n    6: [(5.5, 4.5), 527],\n    7: [(1, 8), 469],\n    8: [(3, 6), 234],\n    9: [(4.5, 8), 500]   \n})\n\n\n# find the optimal solution of the base scenario\nsolve_covid19_facility(coordinates, forecast)\n\n# Increase in demand by 20%.\n\nfor c in counties:\n    forecast[c] = round(1.2*forecast[c])\n    \n# find the optimal for scenario 1\nsolve_covid19_facility(coordinates, forecast)"}]}
{"meta": {"source_path": "/Users/sunyujun03/Desktop/ReLoop/gurobi-modeling-examples/pricing_competing_products/price_optimization_with_competing_products.ipynb", "kind": "ipynb", "title": "Price Optimization with Competing Products"}, "messages": [{"role": "system", "content": "You are an optimization engineer. Write correct and runnable Python code using gurobipy (Gurobi Python API). Be concise. Output only what is requested."}, {"role": "user", "content": "    Task: Reproduce the following Gurobi modeling example in Python using gurobipy.\n\n    Scenario description (from source):\n    Copyright © 2024 Gurobi Optimization, LLC\n\n# Price Optimization with Competing Products\nFinding the delicate balance between price and demand is a difficult problem to solve and one that is prevalent in a number of huge industries like retail, e-commerce, ticketing, and hospitality.\n\nIt just so happens that this is a problem that data scientists have recently been getting better and better at addressing. Still, a key piece is missing: How can I make the right pricing decision given all the other constraints and business rules that exist for this problem? That's where optimization comes in.\n\nIn this scenario, we have a product that has several categories, but we have a limited amount of \"space\" for our products. This could be shelf or warehouse space in retail, seats for events, or for airline ticketing, or rooms at a hotel.\n\nThis problem considers two similar products that are offered where it's our job to use the data available with some optimization know-how to determine the optimal mix of products to offer that maximize revenue while also adhering to a few other business rules. First, we'll create a predictive model to forecast sales based on the prices of each product. Then we'll build an optimization model to find this optimal mix. Finally, we’ll also use the Gurobi-sponsored open-source package Gurobi Machine Learning to seamlessly combine the features of a machine learning model with a decision of an optimization model.\n\nLet’s get started!\n\n## Load required packages\nIf you have a Gurobi license you can skip the installation of `gurobipy`, but always make sure you have the [latest version](https://www.gurobi.com/downloads/gurobi-software) available.\n\n## Start with some data analysis\n\nThis data contains prices and sales for two of our competing products and was generated using another script, which can be found [here](). Let's load the data and take a quick look.\n\n### What's in the data?\nThe data contains three columns:\n1. `p[1]` is the price (in dollars) of the first category (let's call it Category 1).\n2. `p[2]` is the price (in dollars) of the second category (Category 2).\n3. `n[1]` is the number of the items sold that are of Category 1.\n\nWe don't see a column for `n[2]`, which would be the number of items sold that are Category 2. Here is where we make a **pretty big assumption** that we will sell all of the items. This makes our decision to be how to divvy up the limited space we have in order to maximize our revenue.\nThe data was created to have a couple of key characteristics.\n1. As the price of Category 1 goes up, the number sold should decrease, so `p[1]` and `n[1]` have a negative correlation.\n2. As the price of Category 2 goes up, the number sold of Category 1 should increase, so `p[2]` and `n[1]` have a positive correlation.\n\nThe correlation plot of the columns of the data is below.\n\n    Requirements:\n    - Use gurobipy (Model, GRB, addVar/addConstr, etc.)\n    - Make the script runnable as a standalone Python file if possible.\n    - Keep the code faithful to the example.\n"}, {"role": "assistant", "content": "import gurobipy as gp\nfrom gurobipy import GRB\n\nimport numpy as np\nimport pandas as pd\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nimport warnings\nfrom sklearn.model_selection import train_test_split\nfrom sklearn import tree\n\nwarnings.filterwarnings(\"ignore\")\n\ndf = pd.read_csv('https://raw.githubusercontent.com/Gurobi/modeling-examples/master/pricing_competing_products/price_value_data.csv')\ndf\n\nfig, axes = plt.subplots(nrows=1, ncols=1, figsize=(15, 5))\nsns.heatmap(df[['p[1]','p[2]','n[1]']].corr(),annot=True, center=0,ax=axes)\n\naxes.set_title('Correlations')\nplt.show()\n\nfrom sklearn.compose import make_column_transformer\nfrom sklearn.linear_model import LinearRegression\nfrom sklearn.pipeline import make_pipeline\nfrom sklearn.metrics import r2_score\nfrom sklearn.model_selection import train_test_split      #importing scikit-learn's function for data splitting\nfrom sklearn.ensemble import GradientBoostingRegressor    #importing scikit-learn's gradient booster regressor function\nfrom sklearn.model_selection import cross_validate        #improting scikit-learn's cross validation function\n\nX = df[[\"p[1]\",\"p[2]\"]]\ny = df[\"n[1]\"]\n# Split the data for training and testing\nX_train, X_test, y_train, y_test = train_test_split(\n    X, y, train_size=0.75, random_state=1\n)\n\nlinear_regressor = make_pipeline(LinearRegression())\nlinear_regressor.fit(X_train, y_train)\nlinear_regression_validation = cross_validate(linear_regressor, X_train, y_train, cv=5, return_train_score=True, return_estimator=True)\n\nlinear_regression_validation['train_score'],linear_regression_validation['test_score']\n\nfrom sklearn.ensemble import GradientBoostingRegressor\nxgb_regressor = make_pipeline(GradientBoostingRegressor(n_estimators=10))\nxgb_regressor.fit(X_train, y_train)\nxgb_regressor_validation = cross_validate(xgb_regressor, X_train, y_train, cv=5, return_train_score=True, return_estimator=True)\n\nxgb_regressor_validation['train_score'], xgb_regressor_validation['test_score']\n\n#### Initialize the model\nm = gp.Model(\"price optimization\")\n\nproducts = [1,2]            #### Category 1 and Category 2\nN = 200                     #### limit on available space\nl = 0                       #### price control, we'll start this at 0\n\np = m.addVars(products, name=\"p\")            #### price decision variables\nn = m.addVars(products, name=\"n\")            #### decision variable for number of items in each category\n\nmin_items = {1:50,2:50}\nprice_bounds = {1:[300,400], 2:[100,300]}\nm.addConstrs(n[c] >= min_items[c] for c in products)        #### we could hardcode 50 instead of min_items, but this is more flexible\nm.addConstr(p[1] == [300,400])                              #### this is a shorthand way to code 300 <= p[1] <= 400\nm.addConstr(p[2] == [100,300]);\n\n#price_lb = {1:300, 2:100}\n#price_ub = {1:400, 2:300}\n#p = m.addVars(products, lb = price_lb, ub = price_ub, name=\"p\")     #### each price is now bounded\n#n = m.addVars(products, lb = min_items, name=\"n\")\n\nm.addConstr(n.sum() ==  N);     #### remember we set N = 200 earlier\n\nm.addConstr(p[1]-p[2] == [50,100]);\n\nrevenue = gp.quicksum(p[c]*n[c] for c in products)          #### you could also use the more simple p.prod(n)\npenalty = l*(p[1]**2+p[2]**2)                               #### we used l as the lambda parameter earlier\nm.setObjective(revenue - penalty, sense = GRB.MAXIMIZE)\n\n#### install the package and load the required function\nfrom gurobi_ml import add_predictor_constr\n\nm_feats = pd.DataFrame({\"p[1]\":[p[1]],\"p[2]\":[p[2]]})\n\npred_constr = add_predictor_constr(m, xgb_regressor, m_feats, n[1])\npred_constr.print_stats()\n\nm.Params.NonConvex = 2\nm.optimize()\n\nprint(\"\\nOptimal price for the two categories:\\n\",round(p[1].X,2),round(p[2].X,2))\nprint(\"\\nOptimal number of space assigned to the two categories:\\n\",round(n[1].X), round(n[2].X))\nprint(\"\\nTotal revenue:\\n\",round(revenue.getValue(),2))"}]}
{"meta": {"source_path": "/Users/sunyujun03/Desktop/ReLoop/gurobi-modeling-examples/economic_planning/economic_planning.ipynb", "kind": "ipynb", "title": "Economic Planning"}, "messages": [{"role": "system", "content": "You are an optimization engineer. Write correct and runnable Python code using gurobipy (Gurobi Python API). Be concise. Output only what is requested."}, {"role": "user", "content": "    Task: Reproduce the following Gurobi modeling example in Python using gurobipy.\n\n    Scenario description (from source):\n    # Economic Planning\n\n## Objective and Prerequisites\n\nIn this example, you’ll discover how mathematical optimization can be used to address a  macroeconomic planning problem that a country may face. We’ll show you how to model and solve an input-output problem encompassing the interrelationships between the different sectors of a country’s economy.\n\nThis model is example 9 from the fifth edition of Model Building in Mathematical Programming by H. Paul Williams on pages 263-264 and 316-317.\n\nThis modeling example is at the intermediate level, where we assume that you know Python and are familiar with the Gurobi Python API. In addition, you should have some knowledge about building mathematical optimization models.\n\n**Download the Repository** <br /> \nYou can download the repository containing this and other examples by clicking [here](https://github.com/Gurobi/modeling-examples/archive/master.zip). \n\n## Problem Description\n\nIn this problem, we assume that we have an economy with three types of industries:\n\n* Coal\n* Steel\n* Transport\n\nPart of the outputs from these industries are needed as inputs to others. For example, coal is needed to fire the blast furnaces that produce steel, steel is needed in the machinery for extracting coal, etc. We measure all units of production in monetary terms.  That is, each dollar of production by one of the industries requires inputs (in dollars) from possibly its own industry as well as other industries. The required inputs as well as the labor requirements (also measured in dollars) are shown in the following table. \n\n| input (t) / <br /> output (t+1) | Coal | Steel | Transport |\n| --- | --- | --- | --- | \n| Coal | 0.1 | 0.5 | 0.4 | \n| Steel | 0.1 | 0.1 | 0.2 |\n| Transport | 0.2 | 0.1 | 0.2 |\n| Labor | 0.6 | 0.3 | 0.2 | \n|**Total**  | **1** | **1** | **1**|\n\nThere is a time lag in the economy so that the output in year t +1 requires an input in year t.  For example, to produce one-dollar worth of coal requires 0.1 dollars of coal (to provide the necessary power), 0.1 dollars of steel (the steel ‘used up’ in the ‘wear and tear’ on the machinery) and 0.2 dollars of transport (for moving the coal from the mine). In addition, 0.6 dollars of manpower is required. Similarly, the other columns of the table give the inputs required (in dollars) for each dollar of steel and each dollar of transport (trucks, cars, trains, etc.). Notice that the value of each unit of output is exactly matched by the sum of the values of its inputs.\n\nOutput from an industry may also be used to build productive capacity for itself or other industries in future years. The inputs required to give unit increases (capacity in dollars’ worth of extra production) in productive capacity are given in the following table. Input from an industry in year t results in a (permanent) increase in productive capacity in year t +2.\n\n| input (t) / <br /> output (t+2) | Coal | Steel | Transport |\n| --- | --- | --- | --- | \n| Coal | 0.1 | 0.7 | 0.9 | \n| Steel | 0.1 | 0.1 | 0.2 |\n| Transport | 0.2 | 0.1 | 0.2 |\n| Labor | 0.4 | 0.2 | 0.1 | \n\nStocks of goods may be held from year to year. At present (the beginning of year 1), the stocks and productive capacities (per year) are given in the following table (in millions of dollars).\n\n| Present | Stocks | Productive Capacity |\n| --- | --- | --- | \n| Coal | 150 | 300 | \n| Steel | 80 | 350 | \n| Transport | 100 | 280 |  \n\nWe want to maximize the total manpower utilization i.e. employment, over the planning horizon while meeting an exogenous consumption requirement in every year:\n\n* 60 million dollars of coal. \n* 60 million dollars of steel.\n* 30 million dollars  of transport.\n\n## Model Formulation\nA widely used type of national economic model is the input–output model representing the interrelationships between the different sectors of a country’s economy. Such models are often referred to as dynamic Leontief models after their originator, who built such a model of the American economy. A similar model has been considered by Wagner (1957).\n\n### Sets and indices\n\n$i,j \\in \\text{Industries}=\\{\\text{coal}, \\text{steel}, \\text{transport}\\}$\n\n$ t \\in \\text{Horizon} = \\{\\text{year1}, \\text{year2}, \\text{year3}, \\text{year4}, \\text{year5}, \\text{year6} \\}$ \n\n$ t \\in \\text{fiveYears} = \\{\\text{year1}, \\text{year2}, \\text{year3}, \\text{year4}, \\text{year5} \\}$  \n\n$t \\in H_{2,4} = \\{year2, year3, year4 \\} $\n\n### Parameters\n\n$\\text{demand}_{j} \\in \\mathbb{R}^+$: Exogenous demand of goods in industry $j$.\n\n$\\text{initial_stock}_{j} \\in \\mathbb{R}^+$: Stocks of goods in industry $j$ available at the beginning of year 1.\n\n$\\text{in_out_prod}_{i,j} \\in \\mathbb{R}^+$: Input of good $i$ required to produce one unit of good $j$ in the following year.\n\n$\\text{in_out_cap}_{i,j} \\in \\mathbb{R}^+$: Input of good $i$ in current year results in a permanent increase in productive capacity of good $j$  two years later.\n\n$\\text{industry_cap}_{j} \\in \\mathbb{R}^+$: Industry $j$  productive capacity at the beginning of year 1.\n\n$\\text{labor_prod}_{j} \\in \\mathbb{R}^+$: Labor requirements for the production of goods in industry  $j$.\n\n$\\text{labor_extra_cap}_{j} \\in \\mathbb{R}^+$: Labor requirements to permanently increase capacity for goods in industry $j$.\n\n### Decision Variables\n\n$\\text{production}_{j,t} \\in \\mathbb{R}^+$: Production of goods in industry $j$ available at year $t$, in millions of dollars.\nNote: goods of industry j, in millions of dollars, available in year t but produced in previous year.\n\n$\\text{stock}_{j,t} \\in \\mathbb{R}^+$: Stock level of industry $j$ at the end of year $t$, in millions of dollars.\n\n$\\text{extra_cap}_{j,t} \\in \\mathbb{R}^+$: Extra capacity for industry   $j$ becoming effective at the beginning of year $t$, in millions of dollars.\n\nIn order to build a realistic model, we need to think beyond year 5. Therefore, we make the following assumptions:\n\n* External demand is constant up to year 5 and beyond.\n* Stock level remains constant at year 5 and beyond.\n* Capacity cannot be increased after year 5.\n\nConsequently, for year 6 and beyond, we can assume a static model of the economy. For this static model, the production of goods in each industry $i \\in \\text{Industries}$ can be computed as follows.\n\n\\begin{equation}\nx_{i} = \\text{demand}_{i} + \\sum_{j \\in \\text{Industries} } \\text{in_out_prod}_{i,j} * x_{j}\n\\end{equation}\n\nWhere $x_{i}$ is the production of goods in industry $i$.\n\nSolving this system of equations gives lower bounds for the production of goods in years beyond year 5. Then, the production of goods of  industry $j \\in \\text{Industries}$ in year 6 and beyond can be defined by the following constraints. \n\n$$\n\\text{production}_{j,t} \\geq x_{j} \\quad \\forall j \\in \\text{Industries}, \\; t=6. \n$$\n\n$$\n\\text{extra_cap}_{j,t} = 0 \\quad \\forall j \\in \\text{Industries}, \\; t=6.\n$$\n\n    Requirements:\n    - Use gurobipy (Model, GRB, addVar/addConstr, etc.)\n    - Make the script runnable as a standalone Python file if possible.\n    - Keep the code faithful to the example.\n"}, {"role": "assistant", "content": "import pandas as pd\nfrom itertools import product\n\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# tested with Python 3.7.0 & Gurobi 9.1.0\n\n# input-output matrix for the production of goods of each industry\n\narcs, inout_prod = gp.multidict({\n    ('coal', 'coal'): 0.1,\n    ('coal', 'steel'): 0.5,\n    ('coal', 'transport'): 0.4,\n    ('steel', 'coal'): 0.1,\n    ('steel', 'steel'): 0.1,\n    ('steel', 'transport'): 0.2,\n    ('transport', 'coal'): 0.2,\n    ('transport', 'steel'): 0.1,\n    ('transport', 'transport'): 0.2\n})\n\n# Labor requirements for the production of goods of each industry\nlabor_prod = dict({'coal': 0.6,\n                   'steel': 0.3,\n                   'transport': 0.2})\n\n# input-output matrix to create extra capacity for each industry\n\narcs, inout_cap = gp.multidict({\n    ('coal', 'coal'): 0.1,\n    ('coal', 'steel'): 0.7,\n    ('coal', 'transport'): 0.9,\n    ('steel', 'coal'): 0.1,\n    ('steel', 'steel'): 0.1,\n    ('steel', 'transport'): 0.2,\n    ('transport', 'coal'): 0.2,\n    ('transport', 'steel'): 0.1,\n    ('transport', 'transport'): 0.2\n})\n\n# Labor requirements to increase capacity for each industry\nlabor_extra_cap = dict({'coal': 0.4,\n                  'steel': 0.2,\n                  'transport': 0.1})\n\n# Initial stock, initial capacity, and demand of goods for each industry\n\nindustries, stock0, capacity0, demand = gp.multidict({\n    'coal': [250,300,60],\n    'steel': [180,350,60],\n    'transport': [200,280,30]\n})\n\n# Time Horizons\nhorizon = [1,2,3,4,5,6]\nfiveYears = [1,2,3,4,5]\nyears2_4 = [2,3,4]\n\n# Computed parameters\ni2h = set(product(industries, horizon))\ni2f = set(product(industries, fiveYears))\n\nstatic = gp.Model('StaticModel')\n\nstatic_prod = static.addVars(industries, name=\"static_prod\")\n\n# Static model balance equations\n\nstatic_balance = static.addConstrs(\n    (static_prod[i] - gp.quicksum(inout_prod[i,j]*static_prod[j] for j in industries) \n     == demand[i] for i in industries  ), name='static_balance' )\n\n# we define a constant objective function to solve the system of balance equations for the static model.\n\nstatic.setObjective(0)\n\n# Verify model formulation\n\nstatic.write(\"StaticModel.lp\")\n\n# Run optimization engine\n\nstatic.optimize()\n\n# Print solution of static model\n\nprint(\"\\n\\n_________________________________________________________________________________\")\nprint(f\"The production of goods by industry for the static model of the economy is:\")\nprint(\"_________________________________________________________________________________\")\nfor i in industries:\n    if (static_prod[i].x > 1e-6):\n        dollars_static_prod = '${:,.2f}'.format(static_prod[i].x)\n        print(f\"Generate {dollars_static_prod} million dollars of {i} \")\n\nmodel = gp.Model('EconomicPlanning')\n\n# Decision variables\nproduction = model.addVars(i2h, ub=capacity0, name=\"production\")\n\n# There is no production at year 1\nmodel.setAttr('ub', production.select('*',1), 0)    \n\nstock = model.addVars(i2f, name=\"stock\")\nextra_cap = model.addVars(i2h, name=\"extra_cap\")\n\n\n# No extra capacity can be generated at years 1 and 2\nfor j,t in i2h:\n    if t < 3:\n        extra_cap[j,t].ub = 0\n\n# Year 1 balance equations \n\nbalance1 = model.addConstrs( ( stock0[i] == gp.quicksum(inout_prod[i,j]*production[j,2] for j in industries)  \n                              + gp.quicksum(inout_cap[i,j]*extra_cap[j,3] for j in industries ) \n                              + demand[i] + stock[i,1] for i in industries ), name='balance1' )\n\n# Balance equations for years 2,3, and 4\n\nbalance_t = model.addConstrs(( production[i, year] + stock[i,year-1]  == \n                              gp.quicksum(inout_prod[i,j]*production[j, year + 1] for j in industries) \n                              + gp.quicksum(inout_cap[i,j]*extra_cap[j, year + 2] for j in industries ) \n                              + demand[i] + stock[i, year] for i in industries for year in years2_4 ), name='balance_t' )\n\n# Balance equations for year 5\n\nbalance5 = model.addConstrs( (production[i, 5] + stock[i,4]  == \n                              gp.quicksum(inout_prod[i,j]*production[j,6] for j in industries) \n                              + demand[i] + stock[i,5] for i in industries ), name='balance5' )\n\n# Steady state production for year 6 and beyond\n\nsteadyProduction = model.addConstrs((production[j,6] - static_prod[j].x >= 0 for j in industries ), name='steadyProduction')\n\n# Zero increased capacity for year 6 and beyond\nfor j,t in i2h:\n    if t == 6:\n        extra_cap[j,t].ub = 0\n\n# Productive capacity constraints\n\ncapacityConstr = model.addConstrs(\n    (production[industry, year] - gp.quicksum(extra_cap[industry,t] for t in fiveYears if t <= year) \n     <= capacity0[industry] for industry,year in i2f ), name='capacityConstr' )\n\n# Maximize employment\nmodel.setObjective(\n    (gp.quicksum(labor_prod[j]*production[j,t] for j in industries for t in fiveYears) \n     + gp.quicksum(labor_extra_cap[j]*extra_cap[j,t] for j in industries for t in fiveYears) ), GRB.MAXIMIZE)\n\n# Verify model formulation\n\nmodel.write('DynamicModel.lp')\n\n# Run optimization engine\n\nmodel.optimize()\n\n# Output reports\n\nprint(\"_______________________________________________________________________________________________\")\nprint(f\"The production of goods by industry and year for the dynamic Leontief model of the economy is:\")\nprint(\"_______________________________________________________________________________________________\")\n\ngoods = {}\n \nfor i in industries:\n    my_list = []\n    for t in fiveYears:\n        my_list.append('${:,.2f}'.format( production[i,t ].x ) )\n    goods[i] = my_list\n\ngoods_production = pd.DataFrame(goods, index=[\"Year1\", \"Year2\", \"Year3\", \"Year4\", \"Year5\"])\ngoods_production\n\nprint(\"_______________________________________________________________________________________________\")\nprint(f\"The productive capacity by industry and year for the dynamic Leontief model of the economy is:\")\nprint(\"_______________________________________________________________________________________________\")\n\n# Compute cummulative capacity\ntotalCap = {}\n \nfor i in industries:\n    amount = capacity0[i]\n    my_list = []\n    for t in fiveYears:\n        amount += extra_cap[i,t].x\n        my_list.append(round(amount))\n    totalCap[i] = my_list\n    \nextra_capacity = pd.DataFrame(totalCap, index=[\"Year1\", \"Year2\", \"Year3\", \"Year4\", \"Year5\"])\nextra_capacity\n\nprint(\"____________________________________________________________________________________\")\nprint(f\"Stock level by industry at the end of year for the dynamic Leontif model of the economy is:\")\nprint(\"____________________________________________________________________________________\")\n\ninv = {}\n \nfor i in industries:\n    my_list = []\n    for t in fiveYears:\n        my_list.append('${:,.2f}'.format( stock[i,t ].x ) )\n    inv[i] = my_list\n\nstock_level = pd.DataFrame(inv, index=[\"Year1\", \"Year2\", \"Year3\", \"Year4\", \"Year5\"])\nstock_level"}]}
{"meta": {"source_path": "/Users/sunyujun03/Desktop/ReLoop/gurobi-modeling-examples/fantasy_basketball/fantasy_basketball_part1.ipynb", "kind": "ipynb", "title": "fantasy_basketball_part1"}, "messages": [{"role": "system", "content": "You are an optimization engineer. Write correct and runnable Python code using gurobipy (Gurobi Python API). Be concise. Output only what is requested."}, {"role": "user", "content": "    Task: Reproduce the following Gurobi modeling example in Python using gurobipy.\n\n    Scenario description (from source):\n    <h1> Creating the Best Fantasy Basketball Lineup </h1>\n\n<h2> Introduction </h2>\n\nFantasy basketball, and fantasy sports in general, is an extremely popular game where participants compete against each other by virtually selecting players from real upcoming games to create a lineup. Typically, the goal is to assemble the best all-star team, meaning participants are allowed to select players from different professional teams that compete in the same league to play in each coach's virtual team.\n\nA basketball team typically consists of five players: a point guard (PG), a shooting guard (SG), a small forward (SF), a power forward (PF), and a center (C). Each player, assigned to these positions, can have different characteristics and objectives in the basketball game. A shooting guard might specialize in scoring, while a point guard's objective might be to run the game-plan and distribute the ball efficiently. To help compare players across different positions we need to find a common metric to assess each player's performance -- and we'll use fantasy points to do this. \n\nIn a follow-on example we will extend the optimization model to reflect actual fantasy basketball competitions found on major sites.\n\n<h2> Objective and Prerequisites </h2>\n\nIn this example, we'll take on the role of a basketball coach and learn how to find the optimal lineup of National Basketball Association (NBA) players in the context of fantasy basketball. The goal is to select the five players who are going to perform the best in the NBA games played on December 25, 2017, by simultaneously satisfying player and position eligibility and budget constraints.\n\nWe aim to demonstrate that machine learning and mathematical optimization are closely connected, and how they can be integrated to derive optimal decisions. Simply starting from a dataset, we will apply machine learning techniques to make predictions about the performance of basketball players. But when taking into account the problem constraints, directly utilizing these forecasts to make player selections isn't straightforward. This is where mathematical optimization and the Gurobi Optimizer thrive to prove what the best viable lineup is, by formulating and solving a mixed-integer programming (MIP) problem that will maximize the lineup's **total fantasy points**.\n\nThis example is for beginners in mathematical optimization who may have some experience in data handling and predictive modeling and experience using Python.\n\nThe presented problem requires the installation of the following Python packages:\n\n- **pandas** for data analysis and manipulation \n- **numpy** for calculations\n- **matplotlib** and **seaborn** for plotting and visualizing information\n- **scikit-learn** for accessing data science predictive tools\n- **gurobipy** for utilizing Gurobi to formulate and solve the optimization problem\n\n<h2> Problem Statement and Solution Approach</h2>\n\nGiven the regular season historical performances (box scores) of NBA players for the seasons 2016-2017 and 2017-2018, the eligible positions for each of the players, and a budget restriction on how much total salary we are allowed to spend for our team, select the five NBA players who are going to have the best performance on the NBA games played on Christmas day of the 2017-2018 season.\n\nAmong the eligible players that are going to play that day, we need to select a point guard, a shooting guard, a shooting forward, a power forward, and a center.\n\nThe solution to the problem consists of two components: 1) **fantasy points forecast** and 2) **lineup optimization**.\n\n    Requirements:\n    - Use gurobipy (Model, GRB, addVar/addConstr, etc.)\n    - Make the script runnable as a standalone Python file if possible.\n    - Keep the code faithful to the example.\n"}, {"role": "assistant", "content": "import pandas as pd                                       #importing pandas\nimport numpy as np                                        #importing numpy\nimport matplotlib.pyplot as plt                           #importing matplotlib \nimport seaborn as sns                                     #importing seaborn\nfrom sklearn.model_selection import train_test_split      #importing scikit-learn's function for data splitting\nfrom sklearn.linear_model import LinearRegression         #importing scikit-learn's linear regressor function\nfrom sklearn.neural_network import MLPRegressor           #importing scikit-learn's neural network function\nfrom sklearn.ensemble import GradientBoostingRegressor    #importing scikit-learn's gradient booster regressor function\nfrom sklearn.metrics import mean_squared_error            #importing scikit-learn's root mean squared error function for model evaluation\nfrom sklearn.model_selection import cross_validate        #improting scikit-learn's cross validation function\nimport gurobipy as gp                                     #importing Gurobi\n\nboxscores = pd.read_csv('https://raw.githubusercontent.com/Gurobi/modeling-examples/master/fantasy_basketball/boxscores_dataset.csv')     #load boxscores dataset\n# running locally\n# boxscores = pd.read_csv('boxscores_dataset.csv')     #load boxscores dataset\nboxscores = boxscores[(boxscores.playMin>=3) | (boxscores.playMin.isnull())]\n\nfig, (FGA, FGM, FTM, Min) = plt.subplots(1, 4, figsize=(14,5))\nfig.tight_layout()\n\nFGA.scatter(boxscores['playFGA'], boxscores['FantasyPoints'], c='blue', alpha = .2)\nFGM.scatter(boxscores['playFGM'], boxscores['FantasyPoints'], c='lightblue', alpha = .2)\nFTM.scatter(boxscores['playFTM'], boxscores['FantasyPoints'], c='coral', alpha = .2)\nMin.scatter(boxscores['playMin'], boxscores['FantasyPoints'], c='purple', alpha = .2)\n\nFGA.set_xlabel('Field Goal Attempts')\nFGM.set_xlabel('Field Goals Made')\nFTM.set_xlabel('Free Throws Made')\nMin.set_xlabel('Minutes Played')\n\nFGA.set_ylabel('Fantasy Points');\n\nhplot = sns.histplot(boxscores['FantasyPoints'], color=\"blue\", label=\"Fantasy Points\", kde=True, stat=\"density\", linewidth=0, bins=20)\nhplot.set_xlabel(\"Fantasy Points\", fontsize = 12)\nhplot.set_ylabel(\"Density\", fontsize = 12)\nsns.set(rc={\"figure.figsize\":(14, 5)})\n\nhorizon=3\n\nfor column_name in ['playPTS','playAST','playTO','playSTL','playBLK','playTRB','playFGA','playFTA','play2P%','play3P%','playFT%','playMin','teamDayOff','FantasyPoints']:\n    boxscores['moving' + column_name] = boxscores.groupby(['playDispNm'])[column_name].transform(lambda x: x.rolling(horizon, 1).mean().shift(1))                           #lagged moving average of numeric features\n\nboxscores.dropna(subset = [\"movingplayPTS\"], inplace=True)               #drop the first observation for each player\n\nsns.set(rc = {'figure.figsize':(15,8)})\nsns.heatmap(boxscores[['movingplayPTS', 'movingplayAST','movingplayTO','movingplaySTL','movingplayBLK','movingplayTRB','movingplayFGA','movingplayFTA','movingplay2P%','movingplay3P%','movingplayFT%','movingplayMin','movingteamDayOff','movingFantasyPoints']].corr(),annot=True)\nplt.show()\n\nboxscores['dummyTeamLoc'] = pd.get_dummies(data=boxscores['teamLoc'],drop_first=True)    #1 if the game is a home game, 0 if it is an away game\nboxscores['dummyplayStat'] = pd.get_dummies(data=boxscores['playStat'],drop_first=True)  #1 if the player starts, 0 if the player comes from the bench\n\nforecasting_data = boxscores[boxscores.gmDate != '2017-12-25']  #for model training, we exclude observation on December 25, 2017\n\nX = forecasting_data[['movingplayAST','movingplayTO','movingplaySTL','movingplayBLK','movingplayTRB','movingplayFTA','movingplayFT%','dummyplayStat']]  #select the features that will be used for model training\ny = forecasting_data['FantasyPoints']  #target set\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=4)      #dataset splitting\n\nlinear_regressor = LinearRegression()                                                         #load linear regressor\nlinear_regressor.fit(X_train, y_train)                                                        #train the linear regression model\nlinear_regression_validation = cross_validate(linear_regressor, X_train, y_train, cv=5, return_train_score=True, return_estimator=True)\n\nmlp = MLPRegressor(hidden_layer_sizes=(5,5), activation='relu')                               #load neural network\nmlp.fit(X_train,y_train)                                                                      #train the neural network with a ReLU function and two hidden layers with 5 nodes each\nmlp_validation = cross_validate(mlp, X_train, y_train, cv=5, return_train_score=True, return_estimator=True)\n\ngb = GradientBoostingRegressor()                                                              #load a gradient boosting regressor\ngb.fit(X_train, y_train)                                                                      #train a gradient boosting model\ngb_validation = cross_validate(gb, X_train, y_train, cv=5, return_train_score=True, return_estimator=True)\n\ngb_validation['test_score']                            #print CV test score across each fold\n\nlinear_regression_predictions = linear_regressor.predict(X_test)                              #make predictions based on the test set for the linear regression model\nmlp_predictions = mlp.predict(X_test)                                                         #make predictions based on the test set for the neural network model\ngb_predictions = gb.predict(X_test)                                                           #make predictions based on the test set for the gradient boosting model\n\nlinear_regression_mse = mean_squared_error(y_test, linear_regression_predictions)             #calculate the MSE for the linear regression model\nmlp_mse = mean_squared_error(y_test, mlp_predictions)                                         #calculate the MSE for the neural network model\ngb_mse = mean_squared_error(y_test, gb_predictions)                                           #calculate the MSE for the gradient boosting model\n\nresults = {'Linear Regression':[linear_regression_mse],'ReLU Neural Network':[mlp_mse],'Gradient Boosting Regressor':[gb_mse]}\nmodeling_results = pd.DataFrame(data=results,index=['MSE'])\n\nmodeling_results\n\nfig, (LR, FNN, GBR) = plt.subplots(1, 3,figsize=(15,5));\nfig.tight_layout()\n\nLR.scatter(x = linear_regression_predictions, y = y_test - linear_regression_predictions,color='red',alpha=0.06)\nFNN.scatter(x = mlp_predictions, y = y_test - mlp_predictions, color='green',alpha=0.06)\nGBR.scatter(x = gb_predictions, y = y_test - gb_predictions, color='blue',alpha=0.06)\n\nLR.set_xlabel('Linear Regression Predicted Fantasy Points')\nFNN.set_xlabel('Neural Network Predicted Fantasy Points')\nGBR.set_xlabel('Gradient Boosting Predicted Fantasy Points')\n\nLR.set_ylabel('Linear Regression Residual')\nFNN.set_ylabel('Neural Network Residual')\nGBR.set_ylabel('Gradient Boosting Residual')\n\ngb_final = GradientBoostingRegressor(random_state=4)                                                             \ngb_final.fit(X, y)   \n\noptimization_dataset = boxscores\noptimization_dataset['PredictedFantasyPoints'] = gb_final.predict(boxscores[['movingplayAST','movingplayTO','movingplaySTL','movingplayBLK','movingplayTRB','movingplayFTA','movingplayFT%','dummyplayStat']]) \n\nplayer_results = pd.read_csv('https://raw.githubusercontent.com/Gurobi/modeling-examples/master/fantasy_basketball/target_games.csv')\n# player_results = pd.read_csv('target_games.csv')\n\npredicted_fantasy_points = (\n    optimization_dataset.query(\"gmDate == '2017-12-25'\")\n    [[\"playDispNm\", \"PredictedFantasyPoints\"]]\n)\n\nplayer_results = pd.merge(\n    left = player_results,\n    right = predicted_fantasy_points,\n    left_on = \"Player\",\n    right_on = \"playDispNm\",\n)\n\npd.set_option('display.expand_frame_repr', False)\nplayer_results['Points/Salary Ratio'] = 1000*player_results['PredictedFantasyPoints']/player_results['Salary']    #we multiple the fantasy vs salary ratio by 1000 for better visualization\nplayer_results.sort_values(by='PredictedFantasyPoints',ascending=False).head(5)\n\nindices = player_results.Player\npoints = dict(zip(indices, player_results.PredictedFantasyPoints))\nsalaries = dict(zip(indices, player_results.Salary))\nS = 30000\n\nm = gp.Model();        # this defines the model that we'll add to as we finish the formulation\n\ny = m.addVars(player_results.Player, vtype=gp.GRB.BINARY, name=\"y\")\n\n# since we are maximizing points the last argument here is GRB.MAXIMIZE\nm.setObjective(gp.quicksum(points[i]*y[i] for i in indices), gp.GRB.MAXIMIZE)\n\nplayer_position_map = list(zip(player_results.Player, player_results.Pos))\nfor j in player_results.Pos:\n    m.addConstr(gp.quicksum([y[i] for i, pos in player_position_map if pos==j])==1)\n\nm.addConstr(gp.quicksum(salaries[i]*y[i] for i in indices) <= S, name=\"salary\");       \n#the budget for the selected team must not exceed 30,000\n\nm.optimize()  #we optimize our model\n\nvars = m.getVars()\n\nresults = (\n    player_results\n    .iloc[[v.index for v in vars if v.x > 1e-6]]\n    [['Player','Pos','PredictedFantasyPoints','Salary']]\n)\nfor i in results.index:\n    print(vars[i].varname, vars[i].x)\n\nprint('Total fantasy score: ', m.objVal)\n\nresults['True Fantasy Points'] = [53.5,17.25,28.5,15.5,29.25]\nresults\n\nm.dispose()\ngp.disposeDefaultEnv()"}]}
{"meta": {"source_path": "/Users/sunyujun03/Desktop/ReLoop/gurobi-modeling-examples/fantasy_basketball/fantasy_basketball_part2.ipynb", "kind": "ipynb", "title": "fantasy_basketball_part2"}, "messages": [{"role": "system", "content": "You are an optimization engineer. Write correct and runnable Python code using gurobipy (Gurobi Python API). Be concise. Output only what is requested."}, {"role": "user", "content": "    Task: Reproduce the following Gurobi modeling example in Python using gurobipy.\n\n    Scenario description (from source):\n    <h1>Fantasy Basketball Part Two </h1>\n\n<h2> Introduction </h2>\n\nIf you're familiar with fantasy basketball and worked through our **first example** you may have noticed that the lineup we solved for doesn't actually fit the criteria for many popular contests. It was meant as a ground-floor example into mathematical optimization, so make sure to dive into that one first for background on the problem. Additionally, we developed a predictive model to forecast each player's fantasy points, and we'll again use that forecast (without going through the modeling process again).\n\nIn this follow-up example, we will extend the optimization model to fulfill the requirements of a typical [DraftKings](https://www.draftkings.com/help/rules/nba) lineup. Specifically, we'll need to change the model to:\n- Allow some players to be selected for up to two positions (e.g. LeBron James can fill the PF or SF position)\n- Increase the roster from five to eight players\n- Ensure the three new roster slots consist of one guard (SG or PG), one forward (SF or PF), and one utility player (any position)\n\nA quick recap of what we saw in the prior example: When selecting a 5-player lineup, there were *a lot* of possibilities; staying under a salary cap wasn't all that easy; and implementing intuitive decision rules can lead to suboptimal lineups -- providing a glimpse into why mathematical optimization should be part of everyone's analytics toolkit. \n\n**The repository for this project can be accessed by following this link:**\n\n<h2> Objective and Prerequisites </h2>\n\nAs with the first example, the goal here is to build upon our findings of the previous example and select the optimal lineup of players of the National Basketball Association (NBA) that would produce the highest total of fantasy points, which are composed of a player's in-game stats. \n\nAs mentioned above, we will make a lineup that meets DraftKings contest rules. There were over 2 million possible lineups when selecting a 5-player team that contained one of each position. Can you figure out the number of possible lineups for this example? Here's a hint: It's a lot. Remember that there are 25 PGs, 23 SFs, 22 SGs, 19 PFs, and 9 Cs. The answer (approximately) will be given a bit later. \n\nAlso as mentioned, this example will use the same forecasting results as our fantasy basketball beginner's example, which used historical data from the 2016-2017 and 2017-2018 seasons to predict each player's fantasy points for games on 12/25/2017.\n\nThis example assumes you have experience using Python for data manipulation and requires the installation of the following packages:\n\n- **pandas**: for data analysis and manipulation \n- **math**: for mathematical manipulations\n- **gurobipy**: for utilizing Gurobi to formulate and solve the optimization problem\n\nWe'll also explore a few different ways to write summations and constraints in gurobipy, so you can find what works best for you. A quick note: Any output you see similar to <gurobi.Constr \\*Awaiting Model Update\\*> can be ignored and semi-colons have been added to cells to suppress that output. \n\n<h2> Problem Statement and Solution Approach</h2>\n\nBy formuating a model that allows some players to be assigned to more than one position and by also expanding the roster, we are making the model much more complex.  \n\nOur final lineup needs to include each of the following:\n- Point Guard (PG)\n- Shooting Guard (SG)\n- Shooting Forward (SF)\n- Power Forward (PF)\n- Center (C)\n- Guard (SG,PG)\n- Forward (SF,PF)\n- Utility (PG, SG, SF, PF, C)\n\nThe solution of the problem consists of two components: 1) **fantasy points forecast** and 2) **lineup optimization**.\n\nWe'll start by loading a dataset for the eligible players, showing their potential positions, salaries, as well as the forecasts for their upcoming performance. This information will act as an input to our optimization model which will guarantee that we satisfy the rules of the DraftKings contest while maximizing the total fantasy points of our team.\n\n    Requirements:\n    - Use gurobipy (Model, GRB, addVar/addConstr, etc.)\n    - Make the script runnable as a standalone Python file if possible.\n    - Keep the code faithful to the example.\n"}, {"role": "assistant", "content": "import pandas as pd                                       #importing pandas\nimport math                                               #importing math\nimport gurobipy as gp                                     #importing Gurobi\n\nplayer_predictions = pd.read_csv('https://raw.githubusercontent.com/Gurobi/modeling-examples/master/fantasy_basketball/results_target_advanced.csv')     #load processed dataset\n# player_predictions = pd.read_csv('results_target_advanced.csv')     #load processed dataset\nplayer_predictions.sort_values(by='PredictedFantasyPoints',ascending=False).head(20)\n\nplayers = player_predictions[\"Player\"].tolist()\npositions = player_predictions[\"MainPosition\"].unique().tolist()\nsalaries = player_predictions[\"Salary\"].tolist()\nfantasypoints = player_predictions[\"PredictedFantasyPoints\"].tolist()\nS = 50000\n\nsalary_dict = {players[i]: salaries[i] for i in range(len(players))}\npoints_dict = {players[i]: fantasypoints[i] for i in range(len(players))}\n\nm = gp.Model()\n\nmainposition = list(zip(player_predictions.Player, player_predictions.MainPosition))   \nalternativeposition = list(zip(player_predictions.Player, player_predictions.AlternativePosition))               \nindices = mainposition+alternativeposition\nplayer_pos_map = [t for t in indices if not any(isinstance(n, float) and math.isnan(n) for n in t)]\n\ny = m.addVars(player_pos_map, vtype=gp.GRB.BINARY, name=\"y\")\n\nm.setObjective(gp.quicksum(points_dict[i]*y[i,j] for i,j in player_pos_map), gp.GRB.MAXIMIZE)\n\n# option 1 for writing the above constraints\nfor j in positions:\n    m.addConstr(gp.quicksum(y[i,j] for i, pos in player_pos_map if pos==j)>=1, name = \"pos\" + j)\n\n# option 2, a slightly more compact way of adding the same set of constraints\nm.addConstrs((gp.quicksum(y[i,j] for i, pos in player_pos_map if pos==j)>=1 for j in positions), name = \"pos\");\n\nm.addConstr(gp.quicksum(y[i,j] for i, j in player_pos_map if (j=='PG' or j=='SG'))>=3)\nm.addConstr(gp.quicksum(y[i,j] for i, j in player_pos_map if (j=='SF' or j=='PF'))>=3);\n\nm.addConstrs((y.sum(i, \"*\") <= 1 for i in players), name=\"max_one\");\n\nm.addConstr(gp.quicksum(y[i,j] for i,j in player_pos_map) == 8, name=\"full_lineup\");\n\ncap = m.addConstr(gp.quicksum(salary_dict[i]*y[i,j] for i,j in player_pos_map) <= S, name=\"salary\")\n\nm.optimize()  # optimize our model\n\nplayer_selections = []\nfor v in m.getVars():\n    if (abs(v.x) > 1e-6):\n        player_selections.append(tuple(y)[v.index])\n        \ndf = pd.DataFrame(player_selections, columns = ['Player','Assigned Position'])\ndf = df.merge(pd.DataFrame(list(salary_dict.items()), columns=['Player', 'Salary']), left_on=['Player'], right_on=['Player'])\nlineup = df.merge(pd.DataFrame(list(points_dict.items()), columns=['Player', 'Predicted Points']), left_on=['Player'], right_on=['Player'])\n\nlineup.sort_values(by=['Assigned Position'])\n\nprint('Total fantasy score: ', round(m.objVal,2))\nprint('Remaining salary: ', cap.Slack)\n\nm.dispose()\ngp.disposeDefaultEnv()"}]}
{"meta": {"source_path": "/Users/sunyujun03/Desktop/ReLoop/gurobi-modeling-examples/factory_planning/factory_planning_2.ipynb", "kind": "ipynb", "title": "Factory Planning II"}, "messages": [{"role": "system", "content": "You are an optimization engineer. Write correct and runnable Python code using gurobipy (Gurobi Python API). Be concise. Output only what is requested."}, {"role": "user", "content": "    Task: Reproduce the following Gurobi modeling example in Python using gurobipy.\n\n    Scenario description (from source):\n    # Factory Planning II\n\n## Objective and Prerequisites\n\nAre you up for a major production planning challenge? Try this example where you will learn how to create an optimal production plan that will not only maximize profits, but also determine which month in which to perform maintenance operations on your machines.\n\nMore information on this type of model can be found in example #4 of the fifth edition of Modeling Building in Mathematical Programming by H. P. Williams on pages 256 and 302 – 303.\n\nThis modeling example is at the intermediate level, where we assume that you know Python and are familiar with the Gurobi Python API. In addition, you should have some knowledge about building mathematical optimization models.\n\n**Download the Repository** <br />\nYou can download the repository containing this and other examples by clicking [here](https://github.com/Gurobi/modeling-examples/archive/master.zip).\n\n---\n## Problem Description\n\nA factory makes seven products (Prod 1 to Prod 7) using a range of machines including:\n\n- Four grinders\n- Two vertical drills\n- Three horizontal drills\n- One borer\n- One planer\n\nEach product has a defined profit contribution per unit sold (defined as the sales price per unit minus the cost of raw materials). In addition, the manufacturing of each product requires a certain amount of time on each machine (in hours). The profit and manufacturing time value are shown below. A dash indicates that the manufacturing process for the given product does not require that machine.\n\n| <i></i> | PROD1 | PROD2 | PROD3 | PROD4 | PROD5 | PROD6 | PROD7 |\n| --- | --- | --- | --- | --- | --- | --- | --- |\n| Profit | 10 | 6 | 8 | 4 | 11 | 9 | 3 |\n| Grinding | 0.5 | 0.7 | - | - | 0.3 | 0.2 | 0.5 |\n| Vertical Drilling | 0.1 | 0.2 | - | 0.3 | - | 0.6 | - |\n| Horizontal Drilling | 0.2 | - | 0.8 | - | - | - | 0.6 |\n| Boring | 0.05 | 0.03 | - | 0.07 | 0.1 | - | 0.08 |\n| Planning | - | - | 0.01 | - | 0.05 | - | 0.05 |\n\nInstead of pre-defining a maintenance schedule for the machines, as was done in Factory Planning I, in this version of the model we will also optimize the maintenance schedule.\n\nThe maintenance requirements are as follows:\n\n- Each machine must be down for maintenance in one month of the six.\n- The exception to the above are the grinding machines as only two of them need to be down during the six months.\n\nThere are limitations on how many of each product can be sold in a given month. These limits are shown below:\n\n| Month | PROD1 | PROD2 | PROD3 | PROD4 | PROD5 | PROD6 | PROD7 |\n| --- | --- | --- | --- | --- | --- | --- | --- |\n| January | 500 | 1000 | 300 | 300 | 800 | 200 | 100 |\n| February | 600 | 500 | 200 | 0 | 400 | 300 | 150 |\n| March | 300 | 600 | 0 | 0 | 500 | 400 | 100 |\n| April | 200 | 300 | 400 | 500 | 200 | 0 | 100 |\n| May | 0 | 100 | 500 | 100 | 1000 | 300 | 0 |\n| June | 500 | 500 | 100 | 300 | 1100 | 500 | 60 |\n\nUp to 100 units of each product may be stored in inventory at a cost of $0.50 per unit per month. At the start of January, there is no product inventory. However, by the end of June, there should be 50 units of each product in inventory.\n\nThe factory produces products six days a week using two eight-hour shifts per day. It may be assumed that each month consists of 24 working days. Also, for the purposes of this model, there are no production sequencing issues that need to be taken into account.\n\nWhat should the production and maintenance plans look like? Also, is it possible to recommend any price increases and determine the value of acquiring any new machines?\n\nThis problem is based on a larger model built for the Cornish engineering company of Holman Brothers.\n\n---\n## Model Formulation\n\n### Sets and Indices\n\n$t \\in \\text{Months}=\\{\\text{Jan},\\text{Feb},\\text{Mar},\\text{Apr},\\text{May},\\text{Jun}\\}$: Set of months.\n\n$p \\in \\text{Products}=\\{1,2,\\dots,7\\}$: Set of products.\n\n$m \\in \\text{Machines}=\\{\\text{Grinder},\\text{VertDrill},\\text{horiDrill},\\text{Borer},\\text{Planer}\\}$: Set of machines.\n\n### Parameters\n\n$\\text{hours_per_month} \\in \\mathbb{R}^+$: Time (in hours/month) available at any machine on a monthly basis. It results from multiplying the number of working days (24 days) by the number of shifts per day (2) by the duration of a shift (8 hours).\n\n$\\text{max_inventory} \\in \\mathbb{N}$: Maximum number of units of a single product type that can be stored in inventory at any given month.\n\n$\\text{holding_cost} \\in \\mathbb{R}^+$: Monthly cost (in USD/unit/month) of keeping in inventory a unit of any product type.\n\n$\\text{store_target} \\in \\mathbb{N}$: Number of units of each product type to keep in inventory at the end of the planning horizon.\n\n$\\text{profit}_p \\in \\mathbb{R}^+$: Profit (in USD/unit) of product $p$.\n\n$\\text{installed}_m \\in \\mathbb{N}$: Number of machines of type $m$ installed in the factory.\n\n$\\text{down_req}_{m} \\in \\mathbb{N}$: Number of machines of type $m$ that should be scheduled for maintenance at some point in the planning horizon.\n\n$\\text{time_req}_{m,p} \\in \\mathbb{R}^+$: Time (in hours/unit) needed on machine $m$ to manufacture one unit of product $p$.\n\n$\\text{max_sales}_{t,p} \\in \\mathbb{N}$: Maximum number of units of product $p$ that can be sold at month $t$.\n\n### Decision Variables\n\n$\\text{make}_{t,p} \\in \\mathbb{R}^+$: Number of units of product $p$ to manufacture at month $t$.\n\n$\\text{store}_{t,p} \\in [0, \\text{max_inventory}] \\subset \\mathbb{R}^+$: Number of units of product $p$ to store at month $t$.\n\n$\\text{sell}_{t,p} \\in [0, \\text{max_sales}_{t,p}] \\subset \\mathbb{R}^+$: Number of units of product $p$ to sell at month $t$.\n\n$\\text{repair}_{t,m} \\in \\{0,1,\\dots, \\text{down_req}_m\\} \\subset \\mathbb{N}$: Number of machines of type $m$ scheduled for maintenance at month $t$.\n\n**Assumption:** We can produce fractional units.\n\n### Objective Function\n\n- **Profit:** Maximize the total profit (in USD) of the planning horizon.\n\n\\begin{equation}\n\\text{Maximize} \\quad Z = \\sum_{t \\in \\text{Months}}\\sum_{p \\in \\text{Products}}\n(\\text{profit}_p*\\text{make}_{t,p} - \\text{holding_cost}*\\text{store}_{t,p})\n\\tag{0}\n\\end{equation}\n\n### Constraints\n\n- **Initial Balance:** For each product $p$, the number of units produced should be equal to the number of units sold plus the number stored (in units of product).\n\n\\begin{equation}\n\\text{make}_{\\text{Jan},p} = \\text{sell}_{\\text{Jan},p} + \\text{store}_{\\text{Jan},p} \\quad \\forall p \\in \\text{Products}\n\\tag{1}\n\\end{equation}\n\n- **Balance:** For each product $p$, the number of units produced in month $t$ and previously stored should be equal to the number of units sold and stored in that month (in units of product).\n\n\\begin{equation}\n\\text{store}_{t-1,p} + \\text{make}_{t,p} = \\text{sell}_{t,p} + \\text{store}_{t,p} \\quad \\forall (t,p) \\in \\text{Months} \\setminus \\{\\text{Jan}\\} \\times \\text{Products}\n\\tag{2}\n\\end{equation}\n\n- **Inventory Target:** The number of units of product $p$ kept in inventory at the end of the planning horizon should hit the target (in units of product).\n\n\\begin{equation}\n\\text{store}_{\\text{Jun},p} = \\text{store_target} \\quad \\forall p \\in \\text{Products}\n\\tag{3}\n\\end{equation}\n\n- **Machine Capacity:** Total time used to manufacture any product at machine type $m$ cannot exceed its monthly capacity (in hours).\n\n\\begin{equation}\n\\sum_{p \\in \\text{Products}}\\text{time_req}_{m,p}*\\text{make}_{t,p} \\leq \\text{hours_per_month}*(\\text{installed}_m - \\text{repair}_{t,m}) \\quad \\forall (t,m) \\in \\text{Months} \\times \\text{Machines}\n\\tag{4}\n\\end{equation}\n\n- **Maintenance**: The number of machines of type $m$ scheduled for maintenance should meet the requirement.\n\n\\begin{equation}\n\\sum_{t \\in \\text{Months}}\\text{repair}_{t,m} = \\text{down_req}_m \\quad \\forall m \\in \\text{Machines}\n\\tag{5}\n\\end{equation}\n\n---\n## Python Implementation\n\nWe import the Gurobi Python Module and other Python libraries.\n\n## Input Data\nWe define all the input data of the model.\n\n## Model Deployment\nWe create a model and the variables. We set the UpdateMode parameter to 1 (which simplifies the code – see the documentation for more details). For each product (seven kinds of products) and each time period (month), we will create variables for the amount of which products will get manufactured, held, and sold. In each month, there is an upper limit on the amount of each product that can be sold. This is due to market limitations. For each type of machine and each month we create a variable d, which tells us how many machines are down in this month of this type.\n\nNext, we insert the constraints.\nThe balance constraints ensure that the amount of product that is in the storage in the prior month and the amount that gets manufactured equals the amount that is sold and held for each product in the current month. This ensures that all products in the model are manufactured in some month. The initial storage is empty.\n\n    Requirements:\n    - Use gurobipy (Model, GRB, addVar/addConstr, etc.)\n    - Make the script runnable as a standalone Python file if possible.\n    - Keep the code faithful to the example.\n"}, {"role": "assistant", "content": "import numpy as np\nimport pandas as pd\n\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# tested with Python 3.11 & Gurobi 11.0\n\n# Parameters\n\nproducts = [\"Prod1\", \"Prod2\", \"Prod3\", \"Prod4\", \"Prod5\", \"Prod6\", \"Prod7\"]\nmachines = [\"grinder\", \"vertDrill\", \"horiDrill\", \"borer\", \"planer\"]\nmonths = [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\"]\n\nprofit = {\"Prod1\":10, \"Prod2\":6, \"Prod3\":8, \"Prod4\":4, \"Prod5\":11, \"Prod6\":9, \"Prod7\":3}\n\ntime_req = {\n    \"grinder\": {    \"Prod1\": 0.5, \"Prod2\": 0.7, \"Prod5\": 0.3,\n                    \"Prod6\": 0.2, \"Prod7\": 0.5 },\n    \"vertDrill\": {  \"Prod1\": 0.1, \"Prod2\": 0.2, \"Prod4\": 0.3,\n                    \"Prod6\": 0.6 },\n    \"horiDrill\": {  \"Prod1\": 0.2, \"Prod3\": 0.8, \"Prod7\": 0.6 },\n    \"borer\": {      \"Prod1\": 0.05,\"Prod2\": 0.03,\"Prod4\": 0.07,\n                    \"Prod5\": 0.1, \"Prod7\": 0.08 },\n    \"planer\": {     \"Prod3\": 0.01,\"Prod5\": 0.05,\"Prod7\": 0.05 }\n}\n\n# number of each machine available\ninstalled = {\"grinder\":4, \"vertDrill\":2, \"horiDrill\":3, \"borer\":1, \"planer\":1} \n\n# number of machines that need to be under maintenance\ndown_req = {\"grinder\":2, \"vertDrill\":2, \"horiDrill\":3, \"borer\":1, \"planer\":1} \n\n# market limitation of sells\nmax_sales = {\n    (\"Jan\", \"Prod1\") : 500,\n    (\"Jan\", \"Prod2\") : 1000,\n    (\"Jan\", \"Prod3\") : 300,\n    (\"Jan\", \"Prod4\") : 300,\n    (\"Jan\", \"Prod5\") : 800,\n    (\"Jan\", \"Prod6\") : 200,\n    (\"Jan\", \"Prod7\") : 100,\n    (\"Feb\", \"Prod1\") : 600,\n    (\"Feb\", \"Prod2\") : 500,\n    (\"Feb\", \"Prod3\") : 200,\n    (\"Feb\", \"Prod4\") : 0,\n    (\"Feb\", \"Prod5\") : 400,\n    (\"Feb\", \"Prod6\") : 300,\n    (\"Feb\", \"Prod7\") : 150,\n    (\"Mar\", \"Prod1\") : 300,\n    (\"Mar\", \"Prod2\") : 600,\n    (\"Mar\", \"Prod3\") : 0,\n    (\"Mar\", \"Prod4\") : 0,\n    (\"Mar\", \"Prod5\") : 500,\n    (\"Mar\", \"Prod6\") : 400,\n    (\"Mar\", \"Prod7\") : 100,\n    (\"Apr\", \"Prod1\") : 200,\n    (\"Apr\", \"Prod2\") : 300,\n    (\"Apr\", \"Prod3\") : 400,\n    (\"Apr\", \"Prod4\") : 500,\n    (\"Apr\", \"Prod5\") : 200,\n    (\"Apr\", \"Prod6\") : 0,\n    (\"Apr\", \"Prod7\") : 100,\n    (\"May\", \"Prod1\") : 0,\n    (\"May\", \"Prod2\") : 100,\n    (\"May\", \"Prod3\") : 500,\n    (\"May\", \"Prod4\") : 100,\n    (\"May\", \"Prod5\") : 1000,\n    (\"May\", \"Prod6\") : 300,\n    (\"May\", \"Prod7\") : 0,\n    (\"Jun\", \"Prod1\") : 500,\n    (\"Jun\", \"Prod2\") : 500,\n    (\"Jun\", \"Prod3\") : 100,\n    (\"Jun\", \"Prod4\") : 300,\n    (\"Jun\", \"Prod5\") : 1100,\n    (\"Jun\", \"Prod6\") : 500,\n    (\"Jun\", \"Prod7\") : 60,\n}\n\nholding_cost = 0.5\nmax_inventory = 100\nstore_target = 50\nhours_per_month = 2*8*24\n\nfactory = gp.Model('Factory Planning II')\n\nmake = factory.addVars(months, products, name=\"Make\") # quantity manufactured\nstore = factory.addVars(months, products, ub=max_inventory, name=\"Store\") # quantity stored\nsell = factory.addVars(months, products, ub=max_sales, name=\"Sell\") # quantity sold\nrepair = factory.addVars(months, machines, vtype=GRB.INTEGER, ub=down_req, name=\"Repair\") # number of machines down\n\n#1. Initial Balance\nBalance0 = factory.addConstrs((make[months[0], product] == sell[months[0], product] \n                  + store[months[0], product] for product in products), name=\"Initial_Balance\")\n    \n#2. Balance\nBalance = factory.addConstrs((store[months[months.index(month) -1], product] + \n                make[month, product] == sell[month, product] + store[month, product] \n                for product in products for month in months \n                if month != months[0]), name=\"Balance\")\n\n#3. Inventory Target\nTargetInv = factory.addConstrs((store[months[-1], product] == store_target for product in products),  name=\"End_Balance\")\n\n#4. Machine Capacity\nMachineCap = factory.addConstrs((gp.quicksum(time_req[machine][product] * make[month, product]\n                             for product in time_req[machine])\n                    <= hours_per_month * (installed[machine] - repair[month, machine])\n                    for machine in machines for month in months),\n                   name = \"Capacity\")\n\n#5. Maintenance\n\nMaintenance = factory.addConstrs((repair.sum('*', machine) == down_req[machine] for machine in machines), \"Maintenance\")\n\n#0. Objective Function\nobj = gp.quicksum(profit[product] * sell[month, product] -  holding_cost * store[month, product]  \n               for month in months for product in products)\n\nfactory.setObjective(obj, GRB.MAXIMIZE)\n\nfactory.optimize()\n\nrows = months.copy()\ncolumns = products.copy()\nmake_plan = pd.DataFrame(columns=columns, index=rows, data=0.0)\n\nfor month, product in make.keys():\n    if (abs(make[month, product].x) > 1e-6):\n        make_plan.loc[month, product] = np.round(make[month, product].x, 1)\nmake_plan\n\nrows = months.copy()\ncolumns = products.copy()\nsell_plan = pd.DataFrame(columns=columns, index=rows, data=0.0)\n\nfor month, product in sell.keys():\n    if (abs(sell[month, product].x) > 1e-6):\n        sell_plan.loc[month, product] = np.round(sell[month, product].x, 1)\nsell_plan\n\nrows = months.copy()\ncolumns = products.copy()\nstore_plan = pd.DataFrame(columns=columns, index=rows, data=0.0)\n\nfor month, product in store.keys():\n    if (abs(store[month, product].x) > 1e-6):\n        store_plan.loc[month, product] = np.round(store[month, product].x, 1)\nstore_plan\n\nrows = months.copy()\ncolumns = machines.copy()\nrepair_plan = pd.DataFrame(columns=columns, index=rows, data=0.0)\n\nfor month, machine in repair.keys():\n    if (abs(repair[month, machine].x) > 1e-6):\n        repair_plan.loc[month, machine] = repair[month, machine].x\nrepair_plan"}]}
{"meta": {"source_path": "/Users/sunyujun03/Desktop/ReLoop/gurobi-modeling-examples/factory_planning/factory_planning_1.ipynb", "kind": "ipynb", "title": "Factory Planning I"}, "messages": [{"role": "system", "content": "You are an optimization engineer. Write correct and runnable Python code using gurobipy (Gurobi Python API). Be concise. Output only what is requested."}, {"role": "user", "content": "    Task: Reproduce the following Gurobi modeling example in Python using gurobipy.\n\n    Scenario description (from source):\n    # Factory Planning I\n\n## Objective and Prerequisites\n\nWant to learn how to create an optimal production plan that will maximize your profits? In this example, we’ll teach you how to solve this classic production planning problem.\n\nMore information on this type of model can be found in example # 3 of the fifth edition of Modeling Building in Mathematical Programming by H. P. Williams on pages 255 – 256 and 300 – 302.\n\nThis modeling example is at the intermediate level, where we assume that you know Python and are familiar with the Gurobi Python API. In addition, you should have some knowledge about building mathematical optimization models.\n\n**Download the Repository** <br />\nYou can download the repository containing this and other examples by clicking [here](https://github.com/Gurobi/modeling-examples/archive/master.zip). \n\n---\n## Problem Description\n\nA factory makes seven products (Prod 1 to Prod 7) using a range of machines including:\n\n- Four grinders\n- Two vertical drills\n- Three horizontal drills\n- One borer\n- One planer\n\nEach product has a defined profit contribution per unit sold (defined as the sales price per unit minus the cost of raw materials). In addition, the manufacturing of each product requires a certain amount of time on each machine (in hours). The contribution and manufacturing time value are shown below. A dash indicates that the manufacturing process for the given product does not require that machine.\n\n| <i></i> | PROD1 | PROD2 | PROD3 | PROD4 | PROD5 | PROD6 | PROD7 |\n| --- | --- | --- | --- | --- | --- | --- | --- |\n| Profit | 10 | 6 | 8 | 4 | 11 | 9 | 3 |\n| Grinding | 0.5 | 0.7 | - | - | 0.3 | 0.2 | 0.5 |\n| Vertical Drilling | 0.1 | 0.2 | - | 0.3 | - | 0.6 | - |\n| Horizontal Drilling | 0.2 | - | 0.8 | - | - | - | 0.6 |\n| Boring | 0.05 | 0.03 | - | 0.07 | 0.1 | - | 0.08 |\n| Planning | - | - | 0.01 | - | 0.05 | - | 0.05 |\n\nIn each of the six months covered by this model, one or more of the machines is scheduled to be down for maintenance and as a result will not be available to use for production that month. The maintenance schedule is as follows:\n\n| Month | Machine |\n| --- | --- |\n| January | One grinder |\n| February | Two horizontal drills |\n| March | One borer |\n| April | One vertical drill |\n| May | One grinder and one vertical drill |\n| June | One horizontal drill |\n\nThere are limitations on how many of each product can be sold in a given month. These limits are shown below:\n\n| Month | PROD1 | PROD2 | PROD3 | PROD4 | PROD5 | PROD6 | PROD7 |\n| --- | --- | --- | --- | --- | --- | --- | --- |\n| January | 500 | 1000 | 300 | 300 | 800 | 200 | 100 |\n| February | 600 | 500 | 200 | 0 | 400 | 300 | 150 |\n| March | 300 | 600 | 0 | 0 | 500 | 400 | 100 |\n| April | 200 | 300 | 400 | 500 | 200 | 0 | 100 |\n| May | 0 | 100 | 500 | 100 | 1000 | 300 | 0 |\n| June | 500 | 500 | 100 | 300 | 1100 | 500 | 60 |\n\nUp to 100 units of each product may be stored in inventory at a cost of $\\$0.50$ per unit per month. At the start of January, there is no product inventory. However, by the end of June, there should be 50 units of each product in inventory.\n\nThe factory produces products six days a week using two eight-hour shifts per day. It may be assumed that each month consists of 24 working days. Also, for the purposes of this model, there are no production sequencing issues that need to be taken into account.\n\nWhat should the production plan look like? Also, is it possible to recommend any price increases and determine the value of acquiring any new machines?\n\nThis problem is based on a larger model built for the Cornish engineering company of Holman Brothers.\n\n---\n## Model Formulation\n\n### Sets and Indices\n\n$t \\in \\text{Months}=\\{\\text{Jan},\\text{Feb},\\text{Mar},\\text{Apr},\\text{May},\\text{Jun}\\}$: Set of months.\n\n$p \\in \\text{Products}=\\{1,2,\\dots,7\\}$: Set of products.\n\n$m \\in \\text{Machines}=\\{\\text{Grinder},\\text{VertDrill},\\text{horiDrill},\\text{Borer},\\text{Planer}\\}$: Set of machines.\n\n### Parameters\n\n$\\text{hours_per_month} \\in \\mathbb{R}^+$: Time (in hours/month) available at any machine on a monthly basis. It results from multiplying the number of working days (24 days) by the number of shifts per day (2) by the duration of a shift (8 hours).\n\n$\\text{max_inventory} \\in \\mathbb{N}$: Maximum number of units of a single product type that can be stored in inventory at any given month.\n\n$\\text{holding_cost} \\in \\mathbb{R}^+$: Monthly cost (in USD/unit/month) of keeping in inventory a unit of any product type.\n\n$\\text{store_target} \\in \\mathbb{N}$: Number of units of each product type to keep in inventory at the end of the planning horizon.\n\n$\\text{profit}_p \\in \\mathbb{R}^+$: Profit (in USD/unit) of product $p$.\n\n$\\text{installed}_m \\in \\mathbb{N}$: Number of machines of type $m$ installed in the factory.\n\n$\\text{down}_{t,m} \\in \\mathbb{N}$: Number of machines of type $m$ scheduled for maintenance at month $t$.\n\n$\\text{time_req}_{m,p} \\in \\mathbb{R}^+$: Time (in hours/unit) needed on machine $m$ to manufacture one unit of product $p$.\n\n$\\text{max_sales}_{t,p} \\in \\mathbb{N}$: Maximum number of units of product $p$ that can be sold at month $t$.\n\n### Decision Variables\n\n$\\text{make}_{t,p} \\in \\mathbb{R}^+$: Number of units of product $p$ to manufacture at month $t$.\n\n$\\text{store}_{t,p} \\in [0, \\text{max_inventory}] \\subset \\mathbb{R}^+$: Number of units of product $p$ to store at month $t$.\n\n$\\text{sell}_{t,p} \\in [0, \\text{max_sales}_{t,p}] \\subset \\mathbb{R}^+$: Number of units of product $p$ to sell at month $t$.\n\n**Assumption:** We can produce fractional units.\n\n### Objective Function\n\n- **Profit:** Maximize the total profit (in USD) of the planning horizon.\n\n\\begin{equation}\n\\text{Maximize} \\quad Z = \\sum_{t \\in \\text{Months}}\\sum_{p \\in \\text{Products}}\n(\\text{profit}_p*\\text{make}_{t,p} - \\text{holding_cost}*\\text{store}_{t,p})\n\\tag{0}\n\\end{equation}\n\n### Constraints\n\n- **Initial Balance:** For each product $p$, the number of units produced should be equal to the number of units sold plus the number stored (in units of product).\n\n\\begin{equation}\n\\text{make}_{\\text{Jan},p} = \\text{sell}_{\\text{Jan},p} + \\text{store}_{\\text{Jan},p} \\quad \\forall p \\in \\text{Products}\n\\tag{1}\n\\end{equation}\n\n- **Balance:** For each product $p$, the number of units produced in month $t$ and the ones previously stored should be equal to the number of units sold and stored in that month (in units of product).\n\n\\begin{equation}\n\\text{store}_{t-1,p} + \\text{make}_{t,p} = \\text{sell}_{t,p} + \\text{store}_{t,p} \\quad \\forall (t,p) \\in \\text{Months} \\setminus \\{\\text{Jan}\\} \\times \\text{Products}\n\\tag{2}\n\\end{equation}\n\n- **Inventory Target:** The number of units of product $p$ kept in inventory at the end of the planning horizon should hit the target (in units of product).\n\n\\begin{equation}\n\\text{store}_{\\text{Jun},p} = \\text{store_target} \\quad \\forall p \\in \\text{Products}\n\\tag{3}\n\\end{equation}\n- **Machine Capacity:** Total time used to manufacture any product at machine type $m$ cannot exceed its monthly capacity (in hours).\n\n\\begin{equation}\n\\sum_{p \\in \\text{Products}}\\text{time_req}_{m,p}*\\text{make}_{t,p} \\leq \\text{hours_per_month}*(\\text{installed}_m - \\text{down}_{t,m}) \\quad \\forall (t,m) \\in \\text{Months} \\times \\text{Machines}\n\\tag{4}\n\\end{equation}\n\n---\n## Python Implementation\n\nWe import the Gurobi Python Module and other Python libraries.\n\n### Input Data\nWe define all the input data of the model.\n\n## Model Deployment\nWe create a model and the variables. For each product (seven kinds of products) and each time period (month), we will create variables for the amount of which products get manufactured, held, and sold. In each month, there is an upper limit on the amount of each product that can be sold. This is due to market limitations.\n\nNext, we insert the constraints. The balance constraints ensure that the amount of product that is in  storage in the prior month plus the amount that gets manufactured equals the amount that is sold and held for each product in the current month. This ensures that all products in the model are manufactured in some month. The initial storage is empty.\n\n    Requirements:\n    - Use gurobipy (Model, GRB, addVar/addConstr, etc.)\n    - Make the script runnable as a standalone Python file if possible.\n    - Keep the code faithful to the example.\n"}, {"role": "assistant", "content": "import numpy as np\nimport pandas as pd\n\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# tested with Python 3.11 & Gurobi 11.0\n\n# Parameters\n\nproducts = [\"Prod1\", \"Prod2\", \"Prod3\", \"Prod4\", \"Prod5\", \"Prod6\", \"Prod7\"]\nmachines = [\"grinder\", \"vertDrill\", \"horiDrill\", \"borer\", \"planer\"]\nmonths = [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\"]\n\nprofit = {\"Prod1\":10, \"Prod2\":6, \"Prod3\":8, \"Prod4\":4, \"Prod5\":11, \"Prod6\":9, \"Prod7\":3}\n\ntime_req = {\n    \"grinder\": {    \"Prod1\": 0.5, \"Prod2\": 0.7, \"Prod5\": 0.3,\n                    \"Prod6\": 0.2, \"Prod7\": 0.5 },\n    \"vertDrill\": {  \"Prod1\": 0.1, \"Prod2\": 0.2, \"Prod4\": 0.3,\n                    \"Prod6\": 0.6 },\n    \"horiDrill\": {  \"Prod1\": 0.2, \"Prod3\": 0.8, \"Prod7\": 0.6 },\n    \"borer\": {      \"Prod1\": 0.05,\"Prod2\": 0.03,\"Prod4\": 0.07,\n                    \"Prod5\": 0.1, \"Prod7\": 0.08 },\n    \"planer\": {     \"Prod3\": 0.01,\"Prod5\": 0.05,\"Prod7\": 0.05 }\n}\n\n\n# number of machines down\ndown = {(\"Jan\",\"grinder\"): 1, (\"Feb\", \"horiDrill\"): 2, (\"Mar\", \"borer\"): 1,\n        (\"Apr\", \"vertDrill\"): 1, (\"May\", \"grinder\"): 1, (\"May\", \"vertDrill\"): 1,\n        (\"Jun\", \"planer\"): 1, (\"Jun\", \"horiDrill\"): 1}\n\n# number of each machine available\ninstalled = {\"grinder\":4, \"vertDrill\":2, \"horiDrill\":3, \"borer\":1, \"planer\":1} \n\n# market limitation of sells\nmax_sales = {\n    (\"Jan\", \"Prod1\") : 500,\n    (\"Jan\", \"Prod2\") : 1000,\n    (\"Jan\", \"Prod3\") : 300,\n    (\"Jan\", \"Prod4\") : 300,\n    (\"Jan\", \"Prod5\") : 800,\n    (\"Jan\", \"Prod6\") : 200,\n    (\"Jan\", \"Prod7\") : 100,\n    (\"Feb\", \"Prod1\") : 600,\n    (\"Feb\", \"Prod2\") : 500,\n    (\"Feb\", \"Prod3\") : 200,\n    (\"Feb\", \"Prod4\") : 0,\n    (\"Feb\", \"Prod5\") : 400,\n    (\"Feb\", \"Prod6\") : 300,\n    (\"Feb\", \"Prod7\") : 150,\n    (\"Mar\", \"Prod1\") : 300,\n    (\"Mar\", \"Prod2\") : 600,\n    (\"Mar\", \"Prod3\") : 0,\n    (\"Mar\", \"Prod4\") : 0,\n    (\"Mar\", \"Prod5\") : 500,\n    (\"Mar\", \"Prod6\") : 400,\n    (\"Mar\", \"Prod7\") : 100,\n    (\"Apr\", \"Prod1\") : 200,\n    (\"Apr\", \"Prod2\") : 300,\n    (\"Apr\", \"Prod3\") : 400,\n    (\"Apr\", \"Prod4\") : 500,\n    (\"Apr\", \"Prod5\") : 200,\n    (\"Apr\", \"Prod6\") : 0,\n    (\"Apr\", \"Prod7\") : 100,\n    (\"May\", \"Prod1\") : 0,\n    (\"May\", \"Prod2\") : 100,\n    (\"May\", \"Prod3\") : 500,\n    (\"May\", \"Prod4\") : 100,\n    (\"May\", \"Prod5\") : 1000,\n    (\"May\", \"Prod6\") : 300,\n    (\"May\", \"Prod7\") : 0,\n    (\"Jun\", \"Prod1\") : 500,\n    (\"Jun\", \"Prod2\") : 500,\n    (\"Jun\", \"Prod3\") : 100,\n    (\"Jun\", \"Prod4\") : 300,\n    (\"Jun\", \"Prod5\") : 1100,\n    (\"Jun\", \"Prod6\") : 500,\n    (\"Jun\", \"Prod7\") : 60,\n}\n\nholding_cost = 0.5\nmax_inventory = 100\nstore_target = 50\nhours_per_month = 2*8*24\n\nfactory = gp.Model('Factory Planning I')\n\nmake = factory.addVars(months, products, name=\"Make\") # quantity manufactured\nstore = factory.addVars(months, products, ub=max_inventory, name=\"Store\") # quantity stored\nsell = factory.addVars(months, products, ub=max_sales, name=\"Sell\") # quantity sold\n\n#1. Initial Balance\nBalance0 = factory.addConstrs((make[months[0], product] == sell[months[0], product] \n                  + store[months[0], product] for product in products), name=\"Initial_Balance\")\n    \n#2. Balance\nBalance = factory.addConstrs((store[months[months.index(month) -1], product] + \n                make[month, product] == sell[month, product] + store[month, product] \n                for product in products for month in months \n                if month != months[0]), name=\"Balance\")\n\n#3. Inventory Target\nTargetInv = factory.addConstrs((store[months[-1], product] == store_target for product in products),  name=\"End_Balance\")\n\n#4. Machine Capacity\n\nMachineCap = factory.addConstrs((gp.quicksum(time_req[machine][product] * make[month, product]\n                             for product in time_req[machine])\n                    <= hours_per_month * (installed[machine] - down.get((month, machine), 0))\n                    for machine in machines for month in months),\n                   name = \"Capacity\")\n\n#0. Objective Function\nobj = gp.quicksum(profit[product] * sell[month, product] -  holding_cost * store[month, product]  \n               for month in months for product in products)\n\nfactory.setObjective(obj, GRB.MAXIMIZE)\n\nfactory.optimize()\n\nrows = months.copy()\ncolumns = products.copy()\nmake_plan = pd.DataFrame(columns=columns, index=rows, data=0.0)\n\nfor month, product in make.keys():\n    if (abs(make[month, product].x) > 1e-6):\n        make_plan.loc[month, product] = np.round(make[month, product].x, 1)\nmake_plan\n\nrows = months.copy()\ncolumns = products.copy()\nsell_plan = pd.DataFrame(columns=columns, index=rows, data=0.0)\n\nfor month, product in sell.keys():\n    if (abs(sell[month, product].x) > 1e-6):\n        sell_plan.loc[month, product] = np.round(sell[month, product].x, 1)\nsell_plan\n\nrows = months.copy()\ncolumns = products.copy()\nstore_plan = pd.DataFrame(columns=columns, index=rows, data=0.0)\n\nfor month, product in store.keys():\n    if (abs(store[month, product].x) > 1e-6):\n        store_plan.loc[month, product] = np.round(store[month, product].x, 1)\nstore_plan"}]}
{"meta": {"source_path": "/Users/sunyujun03/Desktop/ReLoop/gurobi-modeling-examples/milp_tutorial/introduction_to_modeling.ipynb", "kind": "ipynb", "title": "Introduction to Mathematical Optimization Modeling"}, "messages": [{"role": "system", "content": "You are an optimization engineer. Write correct and runnable Python code using gurobipy (Gurobi Python API). Be concise. Output only what is requested."}, {"role": "user", "content": "    Task: Reproduce the following Gurobi modeling example in Python using gurobipy.\n\n    Scenario description (from source):\n    # Introduction to Mathematical Optimization Modeling\n\n## Objective and Prerequisites\n\nAre you looking to learn the basics of mathematical optimization modeling? If so, then this is a great place to start. In this tutorial, we’ll walk you through the process of building a mathematical optimization model and solving a mathematical optimization problem. We’ll begin by giving you an overview of the key components of a simple mathematical optimization problem, then show you how to create a mathematical optimization model (or, to be more precise, a mixed-integer programming or MIP model) of the problem using using the Gurobi Python API, and then demonstrate how you can automatically generate an optimal solution using the Gurobi Optimizer.\n\nThis modeling tutorial is at the introductory level, where we assume that you know Python and that you have a background on a discipline that uses quantitative methods.\n\nYou may find it helpful to refer to the [documentation](https://www.gurobi.com/resources/?category-filter=documentation) \nof the Gurobi Python API. This notebook is explained in detail in our series of tutorial videos on mixed-integer linear programming. You can watch these videos by clicking\n[here](https://www.gurobi.com/resource/tutorial-mixed-integer-linear-programming/)\n\n**Download the Repository** <br />\nYou can download the repository containing this and other examples by clicking [here](https://github.com/Gurobi/modeling-examples/archive/master.zip). \n\n## Problem description\n\nConsider a consulting company that has three open positions: Tester, Java Developer, and Architect. The three top candidates (resources) for the positions are: Carlos, Joe, and Monika. The consulting company administered competency tests to each candidate in order to assess their ability to perform each of the jobs. The results of these tests are called *matching scores*. Assume that only one candidate can be assigned to a job, and at most one job can be assigned to a candidate.\n\nThe problem is to determine an assignment of resources and jobs such that each job is fulfilled, each resource is assigned to at most one job, and the total matching scores of the assignments is maximized.\n\n## Mathematical optimization \n\nMathematical optimization (which is also known as mathematical programming) is a declarative approach where the modeler formulates an  optimization problem that captures the key features of a complex decision problem. The Gurobi Optimizer solves the mathematical optimization problem using state-of-the-art mathematics and computer science.\n\nA mathematical optimization model has five components:\n\n* Sets\n* Parameters\n* Decision variables\n* Constraints\n* Objective function(s)\n\nThe following Python code imports the Gurobi callable library and imports the ``GRB`` class into the main namespace.\n\n## Resource Assignment Problem\n### Data\nThe list $R$ contains the names of the three resources: Carlos, Joe, and Monika.\n\nThe list $J$ contains the names of the job positions: Tester, Java Developer, and Architect.\n\n$r \\in R$: index and set of resources. The resource $r$ belongs to the set of resources $R$.\n\n$j \\in J$: index and set of jobs. The job $j$ belongs to the set of jobs $J$.\n\nThe ability of each resource to perform each of the jobs is listed in the following matching scores table:\n\n![scores](util/matching_score_data.PNG)\n\nFor each resource $r$ and job $j$, there is a corresponding matching score $s$. The matching score $s$ can only take values between 0 and 100. That is, $s_{r,j} \\in [0, 100]$ for all resources $r \\in R$ and jobs $j \\in J$. \n\nWe use the Gurobi Python ``multidict`` function to initialize one or more dictionaries with a single statement. The function takes a dictionary as its argument. The keys represent the possible combinations of resources and jobs.\n\n    Requirements:\n    - Use gurobipy (Model, GRB, addVar/addConstr, etc.)\n    - Make the script runnable as a standalone Python file if possible.\n    - Keep the code faithful to the example.\n"}, {"role": "assistant", "content": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Resource and job sets\nR = ['Carlos', 'Joe', 'Monika']\nJ = ['Tester', 'JavaDeveloper', 'Architect']\n\n# Matching score data\ncombinations, scores = gp.multidict({\n    ('Carlos', 'Tester'): 53,\n    ('Carlos', 'JavaDeveloper'): 27,\n    ('Carlos', 'Architect'): 13,\n    ('Joe', 'Tester'): 80,\n    ('Joe', 'JavaDeveloper'): 47,\n    ('Joe', 'Architect'): 67,\n    ('Monika', 'Tester'): 53,\n    ('Monika', 'JavaDeveloper'): 73,\n    ('Monika', 'Architect'): 47\n})\n\n# Declare and initialize model\nm = gp.Model('RAP')\n\n# Create decision variables for the RAP model\nx = m.addVars(combinations, name=\"assign\")\n\n# Create job constraints\njobs = m.addConstrs((x.sum('*',j) == 1 for j in J), name='job')\n\n# Create resource constraints\nresources = m.addConstrs((x.sum(r,'*') <= 1 for r in R), name='resource')\n\n# Objective: maximize total matching score of all assignments\nm.setObjective(x.prod(scores), GRB.MAXIMIZE)\n\n# Save model for inspection\nm.write('RAP.lp')\n\n# Run optimization engine\nm.optimize()\n\n# Display optimal values of decision variables\nfor v in m.getVars():\n    if v.x > 1e-6:\n        print(v.varName, v.x)\n\n# Display optimal total matching score\nprint('Total matching score: ', m.objVal)\n\n# Resource and job sets\nR = ['Carlos', 'Joe', 'Monika']\nJ = ['Tester', 'JavaDeveloper', 'Architect']\n\n# Matching score data\n# Cost is given in thousands of dollars\ncombinations, scores, costs = gp.multidict({\n    ('Carlos', 'Tester'): [53, 1],\n    ('Carlos', 'JavaDeveloper'): [27, 1],\n    ('Carlos', 'Architect'): [13,1],\n    ('Joe', 'Tester'): [80, 2],\n    ('Joe', 'JavaDeveloper'): [47, 2],\n    ('Joe', 'Architect'): [67, 2],\n    ('Monika', 'Tester'): [53, 3] ,\n    ('Monika', 'JavaDeveloper'): [73, 3],\n    ('Monika', 'Architect'): [47, 3]\n})\n\n# Available budget (thousands of dollars)\nbudget = 5\n\n# Declare and initialize model\nm = gp.Model('RAP2')\n\n# Create decision variables for the RAP model\nx = m.addVars(combinations, vtype=GRB.BINARY, name=\"assign\")\n\n# Create gap variables for the RAP model\ng = m.addVars(J, name=\"gap\")\n\n# Create job constraints\njobs = m.addConstrs((x.sum('*',j) + g[j]  == 1 for j in J), name='job')\n\n# Create resource constraints\nresources = m.addConstrs((x.sum(r,'*') <= 1 for r in R), name='resource')\n\nbudget = m.addConstr((x.prod(costs) <= budget), name='budget')\n\n# Penalty for not filling a job position\nM = 101\n\n# Objective: maximize total matching score of assignments\n# Unfilled jobs are heavily penalized\nm.setObjective(x.prod(scores) - M*g.sum(), GRB.MAXIMIZE)\n\n# Run optimization engine\nm.optimize()\n\n# Compute total matching score from assignment variables\ntotal_matching_score = 0\nfor r, j in combinations:\n    if x[r, j].x > 1e-6:\n        print(x[r, j].varName, x[r, j].x) \n        total_matching_score += scores[r, j]*x[r, j].x\n\nprint('Total matching score: ', total_matching_score)\n\nm.dispose()\ngp.disposeDefaultEnv()"}]}
{"meta": {"source_path": "/Users/sunyujun03/Desktop/ReLoop/gurobi-modeling-examples/milp_tutorial/milp_tutorial_RAP_problem_002.ipynb", "kind": "ipynb", "title": "Resource Assignment Problem formulation"}, "messages": [{"role": "system", "content": "You are an optimization engineer. Write correct and runnable Python code using gurobipy (Gurobi Python API). Be concise. Output only what is requested."}, {"role": "user", "content": "    Task: Reproduce the following Gurobi modeling example in Python using gurobipy.\n\n    Scenario description (from source):\n    # Resource Assignment Problem formulation\n\nConsider three job positions: Tester, Java-Developer, and Architect.\n\nConsider three resources: Carlos, Joe, and Monika.\n\n## Data \n\nThe ability to perform each of the jobs by each of the resources is illustrated by the following matching scores table:\n\n![Resource Allocation Problem Data Image](util/rap_data.png)\n\n**Assumption**: Only one resource can be assigned to a job, and only one job can be assigned to a resource.\n\n## Problem statement\n\nDetermine an assignment that ensures that each job is fulfilled and each resource is assigned to at most one job in order to maximize the total matching scores of the assignments.\n\n## Decision variables\n\nThe decision variable $x_{r,\\; j} = 1$ represents that resource r is assigned to job j, and 0 otherwise, for  r=1,2,3 and 𝑗=1,2,3.\n\n## Constraints\n\n### Jobs constraints\n\nFor each job 𝑗=1,2,3, exactly one resource from r=1,2,3 must be assigned.\n\nConstraint (Tester=1): $x_{1,\\; 1} + x_{2,\\; 1} + x_{3,\\; 1} = 1$\n\nConstraint (Java-Developer=2): $x_{1,\\; 2} + x_{2,\\; 2} + x_{3,\\; 2} = 1$\n\nConstraint (Architect=3): $x_{1,\\; 3} + x_{2,\\; 3} + x_{3,\\; 3} = 1$\n\n### Resources constraints\n\nFor each resource = r=1,2,3, at most one job from r=1,2,3 can be assigned.\n\nConstraint (Carlos=1): $x_{1,\\; 1} + x_{1,\\; 2} + x_{1,\\; 3}  \\leq 1$\n\nConstraint (Joe=2): $x_{2,\\; 1} + x_{2,\\; 2} + x_{2,\\; 3}  \\leq 1$\n\nConstraint (Monika=3): $x_{2,\\; 1} + x_{2,\\; 2} + x_{2,\\; 3}  \\leq 1$\n\n## Objective function\n\nThe objective function is to maximize the total matching score of the assignments while satisfying the jobs and resources constraints.\n\n$$\nMax \\; (53x_{1,\\; 1} + 80x_{2,\\; 1} + 53x_{3,\\; 1}) + (27x_{1,\\; 2} + 47x_{2,\\; 2} + 73x_{3,\\; 2})\n+ (13x_{1,\\; 3} + 67x_{2,\\; 3} + 47x_{3,\\; 3})\n$$\n\nFirst, let's install gurobipy as needed\n\n## Data\nThe list R contains the names of the three resources: Carlos, Joe, and Monika. \n\nThe list J contains the names of the job positions: tester, java-developer, and architect.\n\n**Math notation**\n\n$r \\in R$ means that a resource with index r is in the set (list) R.\n\n$j \\in J$ means that a job with index j is in the set (list) J.\n\nThe following “multidict” function describes the matching score associated with each possible combination of a resource and job.\n\n**Math notation**\n\nLet $ms_{r,\\;j}$ be the matching score of resource  $r \\in R$  with respect to job  $j \\in J$.\n\nLet $C_{r,\\;j}$ be the cost of assigning resource  $r \\in R$  to job  $j \\in J$.\n\nLet $B$ be the budget available.\n\n    Requirements:\n    - Use gurobipy (Model, GRB, addVar/addConstr, etc.)\n    - Make the script runnable as a standalone Python file if possible.\n    - Keep the code faithful to the example.\n"}, {"role": "assistant", "content": "# import gurobi library\nfrom gurobipy import *\n\n# resources and jobs sets\nR = ['Carlos', 'Joe', 'Monika']\nJ = ['Tester', 'JavaDeveloper', 'Architect']\n\n# matching score data\ncombinations, ms, C = multidict({\n    ('Carlos', 'Tester'): [53, 1],\n    ('Carlos', 'JavaDeveloper'): [27, 1],\n    ('Carlos', 'Architect'): [13,1],\n    ('Joe', 'Tester'): [80, 2],\n    ('Joe', 'JavaDeveloper'): [47, 2],\n    ('Joe', 'Architect'): [67, 2],\n    ('Monika', 'Tester'): [53, 3] ,\n    ('Monika', 'JavaDeveloper'): [73, 3],\n    ('Monika', 'Architect'): [47, 3]\n})\n\n# Budget available\n#B = 6\nB=5\n\n# Declare and initialize model\nm = Model('RAP')\n\n# Create decision variables for the RAP model\n#x = m.addVars(combinations, name=\"assign\")\nx = m.addVars(combinations, vtype=GRB.BINARY, name=\"assign\")\n\n# Create gap variables for the RAP model\ng = m.addVars(J, name=\"gap\")\n\n# create jobs  constraints\njobs = m.addConstrs((x.sum('*',j) + g[j]  == 1 for j in J), 'job')\n\n# create resources constraints\nresources = m.addConstrs((x.sum(r,'*') <= 1 for r in R), 'resource')\n\nbudget = m.addConstr((x.prod(C) <= B), 'budget')\n\n# Penalty for not filling a job position\nBIGM =101\n\n# The objective is to maximize total matching score of the assignments\nm.setObjective(x.prod(ms) -BIGM*g.sum(), GRB.MAXIMIZE)\n\n# save model for inspection\nm.write('RAP3.lp')\n\n# run optimization engine\nm.optimize()\n\n# display optimal values of decision variables\nfor v in m.getVars():\n\tif (abs(v.x) > 1e-6):\n\t\tprint(v.varName, v.x)\n\n# display optimal total matching score\nprint('Optimal objective function value', m.objVal)   \n\n# Compute total matching score from assignment  variables\ntotal_matching_score = 0\nfor [r, j] in combinations:\n    if (abs(x[r, j].x) > 1e-6):\n        total_matching_score = total_matching_score + ms[r, j]*x[r, j].x\n\nprint('Total matching score: ', total_matching_score)"}]}
{"meta": {"source_path": "/Users/sunyujun03/Desktop/ReLoop/gurobi-modeling-examples/milp_tutorial/milp_tutorial_RAP_problem_003.ipynb", "kind": "ipynb", "title": "Resource Assignment Problem formulation"}, "messages": [{"role": "system", "content": "You are an optimization engineer. Write correct and runnable Python code using gurobipy (Gurobi Python API). Be concise. Output only what is requested."}, {"role": "user", "content": "    Task: Reproduce the following Gurobi modeling example in Python using gurobipy.\n\n    Scenario description (from source):\n    # Resource Assignment Problem formulation\n\nConsider three job positions: Tester, Java-Developer, and Architect.\n\nConsider three resources: Carlos, Joe, and Monika.\n\n## Data \n\nThe ability to perform each of the jobs by each of the resources is illustrated by the following matching scores table:\n\n![Resource Allocation Problem Data Image](util/rap_data.png)\n\n**Assumption**: Only one resource can be assigned to a job, and only one job can be assigned to a resource.\n\n## Problem statement\n\nDetermine an assignment that ensures that each job is fulfilled and each resource is assigned to at most one job in order to maximize the total matching scores of the assignments.\n\n## Decision variables\n\nThe decision variable $x_{r,\\; j} = 1$ represents that resource r is assigned to job j, and 0 otherwise, for  r=1,2,3 and 𝑗=1,2,3.\n\n## Constraints\n\n### Jobs constraints\n\nFor each job 𝑗=1,2,3, exactly one resource from r=1,2,3 must be assigned.\n\nConstraint (Tester=1): $x_{1,\\; 1} + x_{2,\\; 1} + x_{3,\\; 1} = 1$\n\nConstraint (Java-Developer=2): $x_{1,\\; 2} + x_{2,\\; 2} + x_{3,\\; 2} = 1$\n\nConstraint (Architect=3): $x_{1,\\; 3} + x_{2,\\; 3} + x_{3,\\; 3} = 1$\n\n### Resources constraints\n\nFor each resource = r=1,2,3, at most one job from r=1,2,3 can be assigned.\n\nConstraint (Carlos=1): $x_{1,\\; 1} + x_{1,\\; 2} + x_{1,\\; 3}  \\leq 1$\n\nConstraint (Joe=2): $x_{2,\\; 1} + x_{2,\\; 2} + x_{2,\\; 3}  \\leq 1$\n\nConstraint (Monika=3): $x_{2,\\; 1} + x_{2,\\; 2} + x_{2,\\; 3}  \\leq 1$\n\n## Objective function\n\nThe objective function is to maximize the total matching score of the assignments while satisfying the jobs and resources constraints.\n\n$$\nMax \\; (53x_{1,\\; 1} + 80x_{2,\\; 1} + 53x_{3,\\; 1}) + (27x_{1,\\; 2} + 47x_{2,\\; 2} + 73x_{3,\\; 2})\n+ (13x_{1,\\; 3} + 67x_{2,\\; 3} + 47x_{3,\\; 3})\n$$\n\nFirst, let's install a few packages as needed\n\n## Data\nThe list R contains the names of the three resources: Carlos, Joe, and Monika. \n\nThe list J contains the names of the job positions: tester, java-developer, and architect.\n\n**Math notation**\n\n$r \\in R$ means that a resource with index r is in the set (list) R.\n\n$j \\in J$ means that a job with index j is in the set (list) J.\n\nThe following “multidict” function describes the matching score associated with each possible combination of a resource and job.\n\n**Math notation**\n\nLet $ms_{r,\\;j}$ be the matching score of resource  $r \\in R$  with respect to job  $j \\in J$.\n\nLet $C_{r,\\;j}$ be the cost of assigning resource  $r \\in R$  to job  $j \\in J$.\n\nLet $B$ be the budget available.\n\n    Requirements:\n    - Use gurobipy (Model, GRB, addVar/addConstr, etc.)\n    - Make the script runnable as a standalone Python file if possible.\n    - Keep the code faithful to the example.\n"}, {"role": "assistant", "content": "# import gurobi library\nfrom gurobipy import *\n\n# resources and jobs sets\nR = ['Carlos', 'Joe', 'Monika']\nJ = ['Tester', 'JavaDeveloper', 'Architect']\n\n# matching score data\ncombinations, ms, C = multidict({\n    ('Carlos', 'Tester'): [53, 1],\n    ('Carlos', 'JavaDeveloper'): [27, 1],\n    ('Carlos', 'Architect'): [13,1],\n    ('Joe', 'Tester'): [80, 2],\n    ('Joe', 'JavaDeveloper'): [47, 2],\n    ('Joe', 'Architect'): [67, 2],\n    ('Monika', 'Tester'): [53, 3] ,\n    ('Monika', 'JavaDeveloper'): [73, 3],\n    ('Monika', 'Architect'): [47, 3]\n})\n\n# Budget available\n#B = 6\nB=5\n\n# Declare and initialize model\nm = Model('RAP')\n\n# Create decision variables for the RAP model\n#x = m.addVars(combinations, name=\"assign\")\nx = m.addVars(combinations, vtype=GRB.BINARY, name=\"assign\")\n\n# Create gap variables for the RAP model\ng = m.addVars(J, name=\"gap\")\n\n# create jobs  constraints\njobs = m.addConstrs((x.sum('*',j) + g[j]  == 1 for j in J), 'job')\n\n# create resources constraints\nresources = m.addConstrs((x.sum(r,'*') <= 1 for r in R), 'resource')\n\nbudget = m.addConstr((x.prod(C) <= B), 'budget')\n\n# Penalty for not filling a job position\nBIGM =101\n\n# The objective is to maximize total matching score of the assignments\nm.setObjective(x.prod(ms) -BIGM*g.sum(), GRB.MAXIMIZE)\n\n# save model for inspection\nm.write('RAP3.lp')\n\n# run optimization engine\nm.optimize()\n\n# display optimal values of decision variables\nfor v in m.getVars():\n\tif (abs(v.x) > 1e-6):\n\t\tprint(v.varName, v.x)\n\n# display optimal total matching score\nprint('Optimal objective function value', m.objVal)   \n\n# Compute total matching score from assignment  variables\ntotal_matching_score = 0\nfor [r, j] in combinations:\n    if (abs(x[r, j].x) > 1e-6):\n        total_matching_score = total_matching_score + ms[r, j]*x[r, j].x\n\nprint('Total matching score: ', total_matching_score)\n\nimport names\nimport random\nimport numpy as np\nfrom gurobipy import *\nfrom itertools import product\n\ndef generate_scenario(num_resources=200, num_jobs=200, roles=None,\n                      score_mu=50, score_sigma=15, seed=10101):\n    random.seed(seed)\n    np.random.seed(seed)\n    if roles is None:\n        roles = {\"Architect\", \"BackEndEngineer\", \"FrontEndEngineer\",\n                     \"Tester\", \"DataScientist\", \"DataEngineer\"}\n    # P.D.F. of resource costs follows Benford's law, having support {1,2,...,9}\n    benford = [np.log10((i+1)/i) for i in range(1,10)]\n    # Sample resource names\n    resources = {names.get_full_name() for i in range(num_resources)}\n    # Sample job requirements, given that all roles are equally likely to be selected\n    req = np.random.multinomial(num_jobs, [1/len(roles)]*len(roles), size=1)[0]\n    jobs = set()\n    # Assign ID to each job position\n    for i, role in enumerate(roles):\n        jobs = jobs.union(set(map(''.join, zip([role]*req[i], [str(x).zfill(int(np.log10(num_jobs))+1) for x in range(1,req[i]+1)]))))\n    scores = {}\n    costs = {}\n    # Sample matching score and cost for each potential assignment\n    for pair in product(resources, jobs):\n        scores[pair] = int(np.clip(np.random.normal(score_mu, score_sigma), 0, 100))\n        costs[pair] = random.choices(list(range(1,10)), weights=benford, k=1)[0]\n    return resources, jobs, scores, costs\n\nres, job, ms, cst = generate_scenario(seed=11111)\nbudget = 200\n\ndef greedy_solve(resources, jobs, scores, costs, budget):\n    assign = set()\n    total_score = 0\n    remaining_budget = budget\n    while remaining_budget > 0 and len(scores.keys()) > 0:\n        selection = max(scores, key=scores.get)\n        assign.add(selection)\n        total_score += scores[selection]\n        remaining_budget -= costs[selection]\n        # Remove potential assignments related to the resource/job of new selection\n        res_filter = list(filter(lambda x: x[0] == selection[0], scores))\n        job_filter = list(filter(lambda x: x[1] == selection[1], scores))\n        blacklist = res_filter + job_filter\n        scores = {key: val for key,val in scores.items()\n                  if key not in blacklist\n                  and costs[key] <= remaining_budget}\n    print(\"Number of assignments: {0}\".format(len(assign)))\n    print(\"Total matching score: {0}\".format(total_score))\n    print(\"Budget consumed: {0}\".format(budget - remaining_budget))\n    \n    kpi = {}\n    kpi[\"n_assign\"] = len(assign)\n    kpi[\"total_ms\"] = total_score\n    kpi[\"budget_used\"] = budget - remaining_budget\n    return assign, kpi\n\ngreedy_sol, kpi = greedy_solve(res, job, ms, cst, budget)\n\n# Greedy heuristic KPI's \nGreedy_assign = kpi[\"n_assign\"]\nGreedy_ms = kpi[\"total_ms\"]\n\n#print('Greedy number assignments: ', Greedy_assign)\n#print('Greedy total matching score: ',Greedy_ms)\n\nm = Model(\"RAP\")\nassign = m.addVars(ms.keys(), vtype=GRB.BINARY, name=\"assign\")\ng = m.addVars(job, name=\"gap\")\nm.addConstrs((assign.sum(\"*\", j) + g[j]  == 1 for j in job), name=\"demand\")\nm.addConstrs((assign.sum(r, \"*\") <= 1 for r in res), name=\"supply\")\nm.addConstr(assign.prod(cst) <= budget, name=\"Budget\")\nm.setObjective(assign.prod(ms) -BIGM*g.sum(), GRB.MAXIMIZE)\nm.optimize()\n\ndef print_solution(model):\n    i = 1\n    total_ms = 0\n    for var in model.getVars():\n        if abs(var.x) > 1e-6:\n            print(\"{0}) {1}: {2}\".format(i, var.varName, var.x))\n            i += 1\n            if \"assign\" in var.varName:\n                total_ms += var.Obj\n    print('Total matching score: {0}'.format(total_ms))\n    print('Optimal objective function value: {0}'.format(model.objVal))\n    return None\n\n# display optimal values of decision variables\nprint_solution(m)\n\n# comparing KPI's of greedy heuristic and Gurobi Optimizer\nGurobi_assign = 0\nGurobi_ms = 0\nfor [r,j] in ms.keys():\n    if (abs(assign[r, j].x) > 1e-6):\n        Gurobi_assign = Gurobi_assign + assign[r, j].x\n        Gurobi_ms = Gurobi_ms + ms[r, j]*assign[r, j].x\n        \n#print('Gurobi total assignments: ', Gurobi_assign)\n#print('Gurobi total matching score: ', Gurobi_ms)\n\n#Ratio of Greedy assignments respect to Gurobi assignments\nassign_ratio = 100*Greedy_assign/Gurobi_assign\nms_ratio = 100*Greedy_ms/Gurobi_ms\n\nprint('Assignment ratio: ',\"%.2f\" % assign_ratio, '%')\nprint('Matching score ratio: ',\"%.2f\" % ms_ratio, '%')"}]}
{"meta": {"source_path": "/Users/sunyujun03/Desktop/ReLoop/gurobi-modeling-examples/milp_tutorial/milp_tutorial_RAP_problem_001.ipynb", "kind": "ipynb", "title": "Resource Assignment Problem formulation"}, "messages": [{"role": "system", "content": "You are an optimization engineer. Write correct and runnable Python code using gurobipy (Gurobi Python API). Be concise. Output only what is requested."}, {"role": "user", "content": "    Task: Reproduce the following Gurobi modeling example in Python using gurobipy.\n\n    Scenario description (from source):\n    # Resource Assignment Problem formulation\n\nConsider three job positions: Tester, Java-Developer, and Architect.\n\nConsider three resources: Carlos, Joe, and Monika.\n\n## Data \n\nThe ability to perform each of the jobs by each of the resources is illustrated by the following matching scores table:\n\n![Resource Allocation Problem Data Image](util/rap_data.png)\n\n**Assumption**: Only one resource can be assigned to a job, and at most one job can be assigned to a resource.\n\n## Problem statement\n\nDetermine an assignment that ensures that each job is fulfilled and each resource is assigned to at most one job in order to maximize the total matching scores of the assignments.\n\n## Decision variables\n\nThe decision variable $x_{r,\\; j} = 1$ represents that resource r is assigned to job j, and 0 otherwise, for  r=1,2,3 and 𝑗=1,2,3.\n\n## Constraints\n\n### Jobs constraints\n\nFor each job 𝑗=1,2,3, exactly one resource from r=1,2,3 must be assigned.\n\nConstraint (Tester=1): $x_{1,\\; 1} + x_{2,\\; 1} + x_{3,\\; 1} = 1$\n\nConstraint (Java-Developer=2): $x_{1,\\; 2} + x_{2,\\; 2} + x_{3,\\; 2} = 1$\n\nConstraint (Architect=3): $x_{1,\\; 3} + x_{2,\\; 3} + x_{3,\\; 3} = 1$\n\n### Resources constraints\n\nFor each resource = r=1,2,3, at most one job from r=1,2,3 can be assigned.\n\nConstraint (Carlos=1): $x_{1,\\; 1} + x_{1,\\; 2} + x_{1,\\; 3}  \\leq 1$\n\nConstraint (Joe=2): $x_{2,\\; 1} + x_{2,\\; 2} + x_{2,\\; 3}  \\leq 1$\n\nConstraint (Monika=3): $x_{2,\\; 1} + x_{2,\\; 2} + x_{2,\\; 3}  \\leq 1$\n\n## Objective function\n\nThe objective function is to maximize the total matching score of the assignments while satisfying the jobs and resources constraints.\n\n$$\nMax \\; (53x_{1,\\; 1} + 80x_{2,\\; 1} + 53x_{3,\\; 1}) + (27x_{1,\\; 2} + 47x_{2,\\; 2} + 73x_{3,\\; 2})\n+ (13x_{1,\\; 3} + 67x_{2,\\; 3} + 47x_{3,\\; 3})\n$$\n\nFirst, let's install gurobipy as needed\n\n## Data\nThe list R contains the names of the three resources: Carlos, Joe, and Monika. \n\nThe list J contains the names of the job positions: tester, java-developer, and architect\n\n$r \\in R$ index and set of resources.\n\n$j \\in J$ index and set of Jobs.\n\n    Requirements:\n    - Use gurobipy (Model, GRB, addVar/addConstr, etc.)\n    - Make the script runnable as a standalone Python file if possible.\n    - Keep the code faithful to the example.\n"}, {"role": "assistant", "content": "# import gurobi library\nfrom gurobipy import *\n\n# resources and jobs sets\nR = ['Carlos', 'Joe', 'Monika']\nJ = ['Tester', 'JavaDeveloper', 'Architect']\n\n# matching score data\ncombinations, ms = multidict({\n    ('Carlos', 'Tester'): 53,\n    ('Carlos', 'JavaDeveloper'): 27,\n    ('Carlos', 'Architect'): 13,\n    ('Joe', 'Tester'): 80,\n    ('Joe', 'JavaDeveloper'): 47,\n    ('Joe', 'Architect'): 67,\n    ('Monika', 'Tester'): 53,\n    ('Monika', 'JavaDeveloper'): 73,\n    ('Monika', 'Architect'): 47\n})\n\n# Declare and initialize model\nm = Model('RAP')\n\n# Create decision variables for the RAP model\nx = m.addVars(combinations, name=\"assign\")\n\n# create jobs  constraints\njob = m.addConstrs((x.sum('*',j) == 1 for j in J), 'job')\n\n# create resources constraints\nresource = m.addConstrs((x.sum(r,'*') <= 1 for r in R), 'resource')\n\n# The objective is to maximize total matching score of the assignments\nm.setObjective(x.prod(ms), GRB.MAXIMIZE)\n\n# save model for inspection\nm.write('RAP.lp')\n\n# run optimization engine\nm.optimize()\n\ndef print_solution(model):\n    for var in model.getVars():\n        if abs(var.x) > 1e-6:\n            print(\"{0}: {1}\".format(var.varName, var.x))\n    print('Total matching score: {0}'.format(model.objVal))\n    return None\n\n# display optimal values of decision variables\nprint_solution(m)\n\nnew_scores = {('Ada','Tester'):100, ('Ada','JavaDeveloper'):100, ('Ada','Architect'):100}\n\nfor key, val in new_scores.items():\n    r, j = key\n    x[key] = m.addVar(obj=val,\n                           name='assign[{0},{1}]'.format(r,j),\n                           column=Column([1], [m.getConstrByName('job[{0}]'.format(j))]))\nm.addConstr(x.sum('Ada','*') <= 1, name=\"resources[Ada]\")\n\n# reoptimize\nm.optimize()\n# display optimal values of decision variables\nprint_solution(m)"}]}
{"meta": {"source_path": "/Users/sunyujun03/Desktop/ReLoop/gurobi-modeling-examples/yield_management/yield_management.ipynb", "kind": "ipynb", "title": "Yield Management"}, "messages": [{"role": "system", "content": "You are an optimization engineer. Write correct and runnable Python code using gurobipy (Gurobi Python API). Be concise. Output only what is requested."}, {"role": "user", "content": "    Task: Reproduce the following Gurobi modeling example in Python using gurobipy.\n\n    Scenario description (from source):\n    # Yield Management \n\n## Objective and Prerequisites\n\nSee how mathematical optimization can make your revenues and profits soar in this example, where we’ll show you how an airline can use the AI technology to devise an optimal seat pricing strategy. You’ll learn how to formulate this Yield Management Problem as a three-period stochastic programming problem using the Gurobi Python API and solve it with the Gurobi Optimizer.\n\nThis model is example 24 from the fifth edition of Model Building in Mathematical Programming by H. Paul Williams on pages 282-284 and 337-340.\n\nThis modeling example is at the advanced level, where we assume that you know Python and the Gurobi Python API and that you have advanced knowledge of building mathematical optimization models. Typically, the objective function and/or constraints of these examples are complex or require advanced features of the Gurobi Python API.\n\n**Download the Repository** <br /> \nYou can download the repository containing this and other examples by clicking [here](https://github.com/Gurobi/modeling-examples/archive/master.zip). \n\n**Gurobi License** <br /> \nIn order to run this Jupyter Notebook properly, you must have a Gurobi license. If you do not have one, you can request an [evaluation license](https://www.gurobi.com/downloads/request-an-evaluation-license/) as a *commercial user*, or download a [free license](https://www.gurobi.com/academia/academic-program-and-licenses/) as an *academic user*.\n\n## Problem Description\n\nAn airline is selling tickets for flights to a particular destination. The flights will depart in three weeks and require up to six planes, each costing £50 000 to hire. Each plane has the following:\n\n* 37 First Class seats\n* 38 Business Class seats\n* 47 Economy Class seats.\n\nThe airline needs to decide on an initial price for each of these seats, and will then have the opportunity to update the price after one week and two weeks. Once a customer has purchased a ticket, there is no cancellation option. For administrative simplicity, three price level options are possible in each class (one of which must be chosen). The same option need not be chosen for each class. These are given in the following table for the current period (period 1) and two future periods.\n\n![optionsClass](optionsClass.PNG)\n\nDemand is uncertain but will be affected by price. Demand forecasts have been made according to a probability distribution that divides the demand levels into three scenarios for each period. The probabilities of the three scenarios\nin each period are as follows:\n\n![scenariosProb](scenariosProb.PNG)\n\nThe forecasted demand levels are shown in the following table:\n\n![forecastDemand](forecastDemand.PNG)\n\nThe goal is to determine the price levels for the current period, how many seats to sell in each class, the provisional number of planes to book and provisional price levels and seats to sell in future periods in order to maximize\nexpected yield. We should be able to meet commitments under all possible combinations of scenarios. With hindsight (i.e. not known until the beginning of the next period), it turned out that demand in each period (depending on the price level you chose) was as shown in following table.\n\n![actualDemand](actualDemand.PNG)\n\nWe use the actual demand that resulted from the prices we set in period 1 to rerun the model at the beginning of period 2 to set price levels for period 2 and provisional price levels for period 3. We repeat this procedure with a rerun at the beginning of period 3.\n\n---\n## Model Formulation\n\nThe Yield Management problem is formulated as a three-period stochastic programming problem. Solving this model for the first time gives recommendations for price levels and sales of week 1 and recommends price levels and sales for subsequent weeks under all possible scenarios. The probabilities of these scenarios will be taken into account in order to maximize expected yield. A week later the model will be rerun, taking into account the committed sales and revenue in the first week, to redetermine recommended prices and sales for the second week (i.e. with ‘recourse’) and the third week under all possible scenarios. The procedure will be repeated again a week later.\n\n### Sets and indices\n\n$i,j,k \\in \\text{Scenarios}$: Indices and set of scenarios.\n\n$h \\in \\text{Options}$: Index and set of price options.\n\n$c \\in \\text{Class}$: Index and set of seats categories.\n\n### Parameters\n\n$\\text{price1}_{c,h} \\in \\mathbb{R}^+$: Price of option $h$ chosen for class $c$ in week 1.\n\n$\\text{price2}_{i,c,h} \\in \\mathbb{R}^+$: Price of option $h$ chosen for class $c$ in week 2 as a result of scenario $i$ in week 1.\n\n$\\text{price3}_{i,j,c,h} \\in \\mathbb{R}^+$: Price of option $h$ chosen for class $c$ in week 3 as a result of scenario $i$ in week 1, and scenario $j$ in week 2.\n\n$\\text{forecast1}_{i,c,h} \\in \\mathbb{R}^+$: Forecast demand in week 1 for class $c$ under price option $h$ and scenario $i$.\n\n$\\text{forecast2}_{i,j,c,h} \\in \\mathbb{R}^+$: Forecast demand in week 2 for class $c$ under price option $h$ if scenario $i$ holds in week 1, and scenario $j$ in week 2.\n\n$\\text{forecast3}_{i,j,k,c,h} \\in \\mathbb{R}^+$: Forecast demand in week 3 for class $c$ under price option $h$ if  scenario $i$ holds in week 1, scenario $j$ in week 2, and scenario $k$ in week 3.\n\n$\\text{prob}_i \\in [0,1]$: Probability of scenario $i$.\n\n$\\text{cap}_c \\in \\mathbb{N}$: Capacity per plane for class $c$.\n\n$\\text{cost} \\in \\mathbb{R}^+$: Cost to hire a plane.\n\n### Decision Variables\n\n$p1_{c,h} \\in \\{0, 1\\}$: This binary variable is equal to one if price of option $h$ is chosen for class $c$ in week 1.\n\n$p2_{i,c,h} \\in \\{0, 1\\}$: This binary variable is equal to one if price of option $h$ is chosen for class $c$ in week 2 as a result of scenario $i$ in week 1.\n\n$p3_{i,j,c,h} \\in \\{0, 1\\}$: This binary variable is equal to one if price of option $h$ is chosen for class $c$ in week 3 as a result of scenario $i$ in week 1 and scenario $j$ in week 2.\n\n$s1_{i,c,h} \\in \\mathbb{R}^+$: Number of tickets to be sold in week 1 for class $c$ under price option $h$ and scenario $i$.\n\n$s2_{i,j,c,h} \\in \\mathbb{R}^+$: Number of tickets to be sold in week 2 for class $c$ under price option $h$ if scenario $i$ holds in week 1, and scenario $j$ in week 2.\n\n$s3_{i,j,k,c,h} \\in \\mathbb{R}^+$: Number of tickets to be sold in week 3 for class $c$ under price option $h$ if  scenario $i$ in week 1, scenario $j$ in week 2, and scenario $k$ in week 3.\n\n$n \\in \\mathbb{N}$: Number of planes to fly.\n\n### Objective function\n\n**Profit**: Maximize expected profit.\n\n$$\n\\text{Maximize} \\quad \\text{profit} = (\n\\sum_{i \\in \\text{Scenarios}} \\sum_{c \\in \\text{Class}} \n\\sum_{h \\in \\text{Options}}{\\text{prob}_i * \\text{price1}_{c,h} * p1_{c,h} * s1_{i,c,h}  }  +\n$$\n\n$$\n\\sum_{i \\in \\text{Scenarios}} \\sum_{j \\in \\text{Scenarios}} \\sum_{c \\in \\text{Class}} \\sum_{h \\in \\text{Options}}\n{\\text{prob}_i *\\text{prob}_j * \\text{price2}_{c,h} * p2_{i,c,h} * s2_{i,j,c,h} } +\n$$\n\n$$\n\\sum_{i \\in \\text{Scenarios}} \\sum_{j \\in \\text{Scenarios}} \\sum_{k \\in \\text{Scenarios}} \n\\sum_{c \\in \\text{Class}} \\sum_{h \\in \\text{Options}}\n{\\text{prob}_i * \\text{prob}_j * \\text{prob}_k * \\text{price3}_{c,h} * p2_{i,j,c,h} * s3_{i,j,k,c,h}} )\n- \\text{cost} * n\n$$\n\n### Constraints\n\n**Price option week 1**: Only one price option must be chosen in each class in week 1.\n\n$$\n\\sum_{h \\in \\text{Options}} p1_{c,h} = 1 \\quad \\forall c \\in \\text{Class}\n$$\n\n**Sales week 1**: Sales cannot exceed forecasted demand in week 1.\n\n$$\ns1_{i,c,h} \\leq \\text{forecast1}_{i,c,h} * p1_{c,h},\n\\quad \\forall i \\in \\text{Scenarios}, \\; c \\in \\text{Class}, \\; h \\in \\text{Options}\n$$\n\n**Price option week 2**: Only one price option must be chosen in each class in week 2 for each scenario in week 1.\n\n$$\n\\sum_{h \\in \\text{Options}} p2_{i,c,h} = 1 \\quad \\forall c \\in \\text{Class}, \\; i \\in \\text{Scenarios}\n$$\n\n**Sales week 2**: Sales cannot exceed forecasted demand in week 2.\n\n$$\ns2_{i,j,c,h} \\leq \\text{forecast2}_{j,c,h} * p2_{i,c,h},\n\\quad \\forall i,j \\in \\text{Scenarios}, \\; c \\in \\text{Class}, \\; h \\in \\text{Options}\n$$\n\n**Price option week 3**: Only one price option must be chosen in each class in week 3 for each scenario in week 1 and week 2.\n\n$$\n\\sum_{h \\in \\text{Options}} p3_{i,j,c,h} = 1 \\quad \\forall c \\in \\text{Class}, \\; i,j \\in \\text{Scenarios}\n$$\n\n**Sales week 3**: Sales cannot exceed forecasted demand in week 3.\n$$\ns3_{i,j,k,c,h} \\leq \\text{forecast3}_{k,c,h} * p3_{i,j,c,h},\n\\quad \\forall i,j,k \\in \\text{Scenarios}, \\; c \\in \\text{Class}, \\; h \\in \\text{Options}\n$$\n\n**Class capacity**: Capacity constraint for each class.\n\n$$\n\\sum_{h \\in \\text{Options}} s1_{i,c,h} +\n\\sum_{h \\in \\text{Options}} s2_{i,j,c,h} + \n\\sum_{h \\in \\text{Options}} s3_{i,j,k,c,h} \\leq \\text{cap}_c * n\n\\quad \\forall i,j,k \\in \\text{Scenarios}, \\; c \\in \\text{Class}\n$$\n\n**Planes** Up to six planes can be hired.\n\n$$\nn \\leq 6\n$$\n\n---\n## Python Implementation\n\nWe import the Gurobi Python Module and other Python libraries.\n\n    Requirements:\n    - Use gurobipy (Model, GRB, addVar/addConstr, etc.)\n    - Make the script runnable as a standalone Python file if possible.\n    - Keep the code faithful to the example.\n"}, {"role": "assistant", "content": "# Note, the restricted license is not sufficient to run this notebook, a full license is needed\n\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# tested with Python 3.7.0 & Gurobi 9.1.0\n\n# Lists of classes, price options, and scenarios.\n\nclasses = ['First', 'Business', 'Economy']\n\noptions = ['option1', 'option2', 'option3']\n\nscenarios = ['sce1', 'sce2', 'sce3']\n\n#  Classes, price options, and prices value for week 1, 2, and 3.\n\nch, price1, price2, price3  = gp.multidict({\n    ('First', 'option1'): [1200, 1400, 1500],\n    ('Business', 'option1'): [900, 1100, 820],\n    ('Economy', 'option1'): [500, 700, 480],\n    ('First', 'option2'): [1000, 1300, 900],\n    ('Business', 'option2'): [800, 900, 800],\n    ('Economy', 'option2'): [300, 400, 470],\n    ('First', 'option3'): [950, 1150, 850],\n    ('Business', 'option3'): [600, 750, 500],\n    ('Economy', 'option3'): [200, 350, 450]\n})\n\n# Probablity of each scenario\n\nprob ={'sce1': 0.1, 'sce2': 0.7, 'sce3': 0.2}\n\n# Forecasted demand for each class, price option, and scenario at week 1\n\nich, fcst1, fcst2, fcst3 = gp.multidict({\n    ('sce1', 'First', 'option1'): [10, 20, 30],\n    ('sce1', 'Business', 'option1'): [20, 42, 40],\n    ('sce1', 'Economy', 'option1'): [45, 50, 50],\n    ('sce1', 'First', 'option2'): [15, 25, 35],\n    ('sce1', 'Business', 'option2'): [25, 45, 50],\n    ('sce1', 'Economy', 'option2'): [55, 52, 60],\n    ('sce1', 'First', 'option3'): [20, 35, 40],\n    ('sce1', 'Business', 'option3'): [35, 46, 55],\n    ('sce1', 'Economy', 'option3'): [60, 60, 80],\n    ('sce2', 'First', 'option1'): [20, 10, 30],\n    ('sce2', 'Business', 'option1'): [40, 50, 10],\n    ('sce2', 'Economy', 'option1'): [50, 60, 50],\n    ('sce2', 'First', 'option2'): [25, 40, 40],\n    ('sce2', 'Business', 'option2'): [42, 60, 40],\n    ('sce2', 'Economy', 'option2'): [52, 65, 60],\n    ('sce2', 'First', 'option3'): [35, 50, 60],\n    ('sce2', 'Business', 'option3'): [45, 80, 45],\n    ('sce2', 'Economy', 'option3'): [63, 90, 70],\n    ('sce3', 'First', 'option1'): [45, 50, 50],\n    ('sce3', 'Business', 'option1'): [45, 20, 40],\n    ('sce3', 'Economy', 'option1'): [55, 10, 60],\n    ('sce3', 'First', 'option2'): [50, 55, 70],\n    ('sce3', 'Business', 'option2'): [46, 30, 45],\n    ('sce3', 'Economy', 'option2'): [56, 40, 65],\n    ('sce3', 'First', 'option3'): [60, 80, 80],\n    ('sce3', 'Business', 'option3'): [47, 50, 60],\n    ('sce3', 'Economy', 'option3'): [64, 60, 70]    \n})\n\n#  Actual demand at weeks 1, 2, and 3.\n\nch, demand1, demand2, demand3  = gp.multidict({\n    ('First', 'option1'): [25, 22, 45],\n    ('Business', 'option1'): [50, 45, 20],\n    ('Economy', 'option1'): [50, 50, 55],\n    ('First', 'option2'): [30, 45, 60],\n    ('Business', 'option2'): [40, 55, 40],\n    ('Economy', 'option2'): [53, 60, 60],\n    ('First', 'option3'): [40, 50, 75],\n    ('Business', 'option3'): [45, 75, 50],\n    ('Economy', 'option3'): [65, 80, 75]\n})\n\n# Class capacity\n\ncap ={'First': 37, 'Business': 38, 'Economy': 47}\n\n# cost per plane\n\ncost = 50000\n\n# Preprocessing\n\n# week 1 data structures\nlist_ch = []\n\nfor c in classes:\n    for h in options:\n        tp = c,h\n        list_ch.append(tp)\n\nch = gp.tuplelist(list_ch)\n\nlist_ich = []\n\nfor i in scenarios:\n    for c in classes:\n        for h in options:\n            tp = i,c,h\n            list_ich.append(tp)\n\nich = gp.tuplelist(list_ich)\n\n# week 2 data structure\n\nlist_ijch = []\n\nfor i in scenarios:\n    for j in scenarios:\n        for c in classes:\n            for h in options:\n                tp = i,j,c,h\n                list_ijch.append(tp)\n\nijch = gp.tuplelist(list_ijch)\n\n# week 3 data structure\n\nlist_ijkch = []\n\nfor i in scenarios:\n    for j in scenarios:\n        for k in scenarios:\n            for c in classes:\n                for h in options:\n                    tp = i,j,k,c,h\n                    list_ijkch.append(tp)\n\nijkch = gp.tuplelist(list_ijkch)\n\n# scenarios data structure\n\nlist_ijk = []\n\nfor i in scenarios:\n    for j in scenarios:\n        for k in scenarios:\n            tp = i,j,k,\n            list_ijk.append(tp)\n\nijk = gp.tuplelist(list_ijk)\n\n# capacity constraints data structure\n\nlist_ijkc = []\n\nfor i in scenarios:\n    for j in scenarios:\n        for k in scenarios:\n            for c in classes:\n                tp = i,j,k,c\n                list_ijkc.append(tp)\n\nijkc = gp.tuplelist(list_ijkc)\n\nmodel = gp.Model('YieldManagement')\n\n# Set global parameters. \nmodel.params.nonConvex = 2\n\n# Decision variables\n\n# price option binary variables at each week\np1ch = model.addVars(ch, vtype=GRB.BINARY, name=\"p1ch\")\np2ich = model.addVars(ich, vtype=GRB.BINARY, name=\"p2ich\")\np3ijch = model.addVars(ijch, vtype=GRB.BINARY, name=\"p3ijch\")\n\n# tickets to be sold at each week\ns1ich = model.addVars(ich, name=\"s1ich\")\ns2ijch = model.addVars(ijch, name=\"s2ijch\")\ns3ijkch = model.addVars(ijkch, name=\"s3ijkch\")\n\n# number of planes to fly\nn = model.addVar(ub=6, vtype=GRB.INTEGER, name=\"planes\")\n\n# Price option constraints for week 1\n\npriceOption1 = model.addConstrs( (gp.quicksum(p1ch[c,h] for h in options ) == 1 for c in classes ), name='priceOption1' )\n\n# sales constraints for week 1\n\nsales1 = model.addConstrs( (s1ich[i,c,h] <= fcst1[i,c,h]*p1ch[c,h] for i,c,h in ich ), name='sales1' )\n\n# Price option constraints for week 2\n\npriceOption2 = model.addConstrs( (gp.quicksum(p2ich[i,c,h] for h in options ) \n                                  == 1 for i in scenarios for c in classes ), name='priceOption2' )\n\n# sales constraints for week 2\n\nsales2 = model.addConstrs( (s2ijch[i,j,c,h] <= fcst2[j,c,h]*p2ich[i,c,h] for i,j,c,h in ijch ), name='sales2' )\n\n# Price option constraints for week 3\n\npriceOption3 = model.addConstrs( (gp.quicksum(p3ijch[i,j,c,h] for h in options ) \n                                  == 1 for i in scenarios for j in scenarios for c in classes ), name='priceOption3' )\n\n# sales constraints for week 3\n\nsales3 = model.addConstrs( (s3ijkch[i,j,k,c,h] <= fcst3[k,c,h]*p3ijch[i,j,c,h] for i,j,k,c,h in ijkch ), name='sales3' )\n\n# Class capacity constraints\n\nclassCap = model.addConstrs( (gp.quicksum(s1ich[i,c,h] for h in options)  \n                              + gp.quicksum(s2ijch[i,j,c,h] for h in options) \n                              + gp.quicksum(s3ijkch[i,j,k,c,h] for h in options)  \n                              <= cap[c]*n for i,j,k,c in ijkc ) , name='classCap')\n\n# Objective function\nobj = gp.quicksum(prob[i]*price1[c,h]*p1ch[c,h]*s1ich[i,c,h] for i,c,h in ich ) \\\n+ gp.quicksum(prob[i]*prob[j]*price2[c,h]*p2ich[i,c,h]*s2ijch[i,j,c,h] for i,j,c,h in ijch ) \\\n+ gp.quicksum(prob[i]*prob[j]*prob[k]*price3[c,h]*p3ijch[i,j,c,h]*s3ijkch[i,j,k,c,h] for i,j,k,c,h in ijkch) - cost*n\n\nmodel.setObjective( obj, GRB.MAXIMIZE)\n\n# Verify model formulation\n\nmodel.write('YieldManagement.lp')\n\n# Run optimization engine\n\nmodel.optimize()\n\n#############################################################\n#            Print results of model for week 1\n#############################################################\n\nprint(\"\\n\\n\\n____________________Week 1 solution___________________________\")\n\nprint(f\"The expected total profit is: £{round(model.objVal,2): ,}\") \nprint(f\"Number of planes to book: {n.x}\")\n\n# Week 1 prices for seat class\n\n# optimal values of option prices at week 1\nopt_p1ch = {}\n\nprint(\"\\n____________________Week 1 prices_______________________________\")\nfor c,h in ch:\n    opt_p1ch[c,h] = 0\n    if p1ch[c,h].x > 0.5:\n        opt_p1ch[c,h] = round(p1ch[c,h].x)\n        price_ch = opt_p1ch[c,h]*price1[c,h]\n        print(f\"({c},{h}) = £{price_ch: ,}\")\n#\n\n# Week 2 provisional prices\n\nprint(\"\\n_____________Week 2 provisional prices____________________________\")\nfor i,c,h in ich:\n    if p2ich[i,c,h].x > 0.5:\n        price_ch = round(p2ich[i,c,h].x)*price2[c,h]\n        print(f\"({i}, {c}, {h}) = £{price_ch: ,}\")\n\n# Week 3 provisional prices\n\nprint(\"\\n_____________Week 3 provisional prices____________________________\")\nfor i,j,c,h in ijch:\n    if p3ijch[i,j,c,h].x > 0.5:\n        price_ch = round(p3ijch[i,j,c,h].x)*price3[c,h]\n        print(f\"({i}, {j}, {c}, {h}) = £{price_ch: ,}\")\n\nmodel2 = gp.Model('YieldManagement2')\n\n# Set global parameters \nmodel2.params.nonConvex = 2\n\n# Decision variables\n\n# price option binary variables at each week\np1ch = model2.addVars(ch, vtype=GRB.BINARY, name=\"p1ch\")\n\n# Fix price options of week 1\nfor c,h in ch:\n    p1ch[c,h].lb = opt_p1ch[c,h]\n\np2ich = model2.addVars(ich, vtype=GRB.BINARY, name=\"p2ich\")\np3ijch = model2.addVars(ijch, vtype=GRB.BINARY, name=\"p3ijch\")\n\n# tickets to be sold at each week\ns1ich = model2.addVars(ich, name=\"s1ich\")\n\n# use hindsight demand of week 1\nfor i,c,h in ich:\n    fcst1[i,c,h] = 0\n    fcst1[i,c,h] = demand1[c,h]*opt_p1ch[c,h] \n\ns2ijch = model2.addVars(ijch, name=\"s2ijch\")\ns3ijkch = model2.addVars(ijkch, name=\"s3ijkch\")\n\n# number of planes to fly\nn = model2.addVar(ub=6, vtype=GRB.INTEGER, name=\"planes\")\n\n# Price option constraints for week 1\n\npriceOption1 = model2.addConstrs( (gp.quicksum(p1ch[c,h] for h in options ) == 1 for c in classes ), name='priceOption1' )\n\n# sales constraints for week 1\n\nsales1 = model2.addConstrs( (s1ich[i,c,h] <= fcst1[i,c,h]*p1ch[c,h] for i,c,h in ich ), name='sales1' )\n\n# Price option constraints for week 2\n\npriceOption2 = model2.addConstrs( (gp.quicksum(p2ich[i,c,h] for h in options ) \n                                  == 1 for i in scenarios for c in classes ), name='priceOption2' )\n\n# sales constraints for week 2\n\nsales2 = model2.addConstrs( (s2ijch[i,j,c,h] <= fcst2[j,c,h]*p2ich[i,c,h] for i,j,c,h in ijch ), name='sales2' )\n\n# Price option constraints for week 3\n\npriceOption3 = model2.addConstrs( (gp.quicksum(p3ijch[i,j,c,h] for h in options ) \n                                  == 1 for i in scenarios for j in scenarios for c in classes ), name='priceOption3' )\n\n# sales constraints for week 3\n\nsales3 = model2.addConstrs( (s3ijkch[i,j,k,c,h] <= fcst3[k,c,h]*p3ijch[i,j,c,h] for i,j,k,c,h in ijkch ), name='sales3' )\n\n# Class capacity constraints.\n\nclassCap = model2.addConstrs( (gp.quicksum(s1ich[i,c,h] for h in options)  \n                              + gp.quicksum(s2ijch[i,j,c,h] for h in options) \n                              + gp.quicksum(s3ijkch[i,j,k,c,h] for h in options)  \n                              <= cap[c]*n for i,j,k,c in ijkc ) , name='classCap')\n\n# Objective function\nobj = gp.quicksum(prob[i]*price1[c,h]*p1ch[c,h]*s1ich[i,c,h] for i,c,h in ich ) \\\n+ gp.quicksum(prob[i]*prob[j]*price2[c,h]*p2ich[i,c,h]*s2ijch[i,j,c,h] for i,j,c,h in ijch ) \\\n+ gp.quicksum(prob[i]*prob[j]*prob[k]*price3[c,h]*p3ijch[i,j,c,h]*s3ijkch[i,j,k,c,h] for i,j,k,c,h in ijkch) - cost*n\n\nmodel2.setObjective( obj, GRB.MAXIMIZE)\n\n# Verify model formulation\n\nmodel2.write('YieldManagement2.lp')\n\n# Run optimization engine\n\nmodel2.optimize()\n\n#############################################################\n#            Print results of model for week 2\n#############################################################\n\nprint(\"\\n\\n\\n____________________Week 2 solution___________________________\")\n\nprint(f\"The expected total profit at the beginning of week 2 is: £ {round(model2.objVal,2):,}\") \nprint(f\"Number of planes to book: {n.x}\")\n\n# Week 2 prices\n\n# optimal values of option prices at week 1\nopt_p2ich = {}\n\nprint(\"\\n_____________Week 2 prices____________________________\")\nfor i,c,h in ich:\n    opt_p2ich[i,c,h] = 0\n    if p2ich[i,c,h].x > 0.5:\n        opt_p2ich[i,c,h] = round(p2ich[i,c,h].x)\n        price_ch = opt_p2ich[i,c,h]*price2[c,h]\n        #print(f\"({i},{c},{h}) = £ {price_ch}\")\n        if i == 'sce1':\n            print(f\"({c},{h}) = £{price_ch: ,}\")\n#\n\n# Week 3 provisional prices\n\nprint(\"\\n_____________Week 3 provisional prices____________________________\")\nfor i,j,c,h in ijch:\n    if p3ijch[i,j,c,h].x > 0.5:\n        price_ch = round(p3ijch[i,j,c,h].x)*price3[c,h]\n        print(f\"({i}, {j}, {c}, {h}) = £ {price_ch}\")\n\nmodel3 = gp.Model('YieldManagement3')\n\n# Set global parameters. \nmodel3.params.nonConvex = 2\n\n# Decision variables\n\n# price option binary variables at each week\np1ch = model3.addVars(ch, vtype=GRB.BINARY, name=\"p1ch\")\n\n# Fix price options of week 1\n\nfor c,h in ch:\n    p1ch[c,h].lb = opt_p1ch[c,h]\n\np2ich = model3.addVars(ich, vtype=GRB.BINARY, name=\"p2ich\")\n\n# Fix price options of week 2\n\nfor i,c,h in ich:\n    p2ich[i,c,h].lb = opt_p2ich[i,c,h]\n\np3ijch = model3.addVars(ijch, vtype=GRB.BINARY, name=\"p3ijch\")\n\n# tickets to be sold at each week\ns1ich = model3.addVars(ich, name=\"s1ich\")\n\n# use hindsight demand of week 1\nfor i,c,h in ich:\n    fcst1[i,c,h] = 0\n    fcst1[i,c,h] = demand1[c,h]*opt_p1ch[c,h]\n\ns2ijch = model3.addVars(ijch, name=\"s2ijch\")\n\n# use hindsight demand of week 2\nfor j,c,h in ich:\n    fcst2[j,c,h] = 0\n    fcst2[j,c,h] = demand2[c,h]*opt_p2ich[j,c,h]\n\ns3ijkch = model3.addVars(ijkch, name=\"s3ijkch\")\n\n# number of planes to fly\nn = model3.addVar(ub=6, vtype=GRB.INTEGER, name=\"planes\")\n\n# Price option constraints for week 1\n\npriceOption1 = model3.addConstrs( (gp.quicksum(p1ch[c,h] for h in options ) == 1 for c in classes ), name='priceOption1' )\n\n# sales constraints for week 1\n\nsales1 = model3.addConstrs( (s1ich[i,c,h] <= fcst1[i,c,h]*p1ch[c,h] for i,c,h in ich ), name='sales1' )\n\n# Price option constraints for week 2\n\npriceOption2 = model3.addConstrs( (gp.quicksum(p2ich[i,c,h] for h in options ) \n                                  == 1 for i in scenarios for c in classes ), name='priceOption2' )\n\n# sales constraints for week 2\n\nsales2 = model3.addConstrs( (s2ijch[i,j,c,h] <= fcst2[j,c,h]*p2ich[i,c,h] for i,j,c,h in ijch ), name='sales2' )\n\n# Price option constraints for week 3\n\npriceOption3 = model3.addConstrs( (gp.quicksum(p3ijch[i,j,c,h] for h in options ) \n                                  == 1 for i in scenarios for j in scenarios for c in classes ), name='priceOption3' )\n\n# sales constraints for week 3\n\nsales3 = model3.addConstrs( (s3ijkch[i,j,k,c,h] <= fcst3[k,c,h]*p3ijch[i,j,c,h] for i,j,k,c,h in ijkch ), name='sales3' )\n\n# Class capacity constraints.\n\nclassCap = model3.addConstrs( (gp.quicksum(s1ich[i,c,h] for h in options)  \n                              + gp.quicksum(s2ijch[i,j,c,h] for h in options) \n                              + gp.quicksum(s3ijkch[i,j,k,c,h] for h in options)  \n                              <= cap[c]*n for i,j,k,c in ijkc ) , name='classCap')\n\n# Objective function\nobj = gp.quicksum(prob[i]*price1[c,h]*p1ch[c,h]*s1ich[i,c,h] for i,c,h in ich ) \\\n+ gp.quicksum(prob[i]*prob[j]*price2[c,h]*p2ich[i,c,h]*s2ijch[i,j,c,h] for i,j,c,h in ijch ) \\\n+ gp.quicksum(prob[i]*prob[j]*prob[k]*price3[c,h]*p3ijch[i,j,c,h]*s3ijkch[i,j,k,c,h] for i,j,k,c,h in ijkch) - cost*n\n\nmodel3.setObjective( obj, GRB.MAXIMIZE)\n\n# Verify model formulation\n\nmodel3.write('YieldManagement3.lp')\n\n# Run optimization engine\n\nmodel3.optimize()\n\n#############################################################\n#            Print results of model for week 3\n#############################################################\n\n\nprint(\"\\n\\n\\n____________________Week 3 solution___________________________\")\n\nprint(f\"The expected total profit is: £ {round(model3.objVal,2):,}\") \nprint(f\"Number of planes to book: {n.x}\")\n\n# Week 3  prices\n\n# optimal values of option prices at week 3\nopt_p3ijch = {}\n\n\nprint(\"\\n_____________Week 3 prices____________________________\")\nfor i,j,c,h in ijch:\n    opt_p3ijch[i,j,c,h] = 0\n    if p3ijch[i,j,c,h].x > 0.5:\n        opt_p3ijch[i,j,c,h] = round(p3ijch[i,j,c,h].x)\n        price_ch = opt_p3ijch[i,j,c,h]*price3[c,h]\n        if i == 'sce1' and j == 'sce1':\n            print(f\"({c}, {h}) = £{price_ch: ,}\")\n\nmodel4 = gp.Model('YieldManagement4')\n\n# Set global parameters \nmodel4.params.nonConvex = 2\n\n# Decision variables\n\n# price option binary variables at each week\np1ch = model4.addVars(ch, vtype=GRB.BINARY, name=\"p1ch\")\n\n# Fix price options of week 1\n\nfor c,h in ch:\n    p1ch[c,h].lb = opt_p1ch[c,h]\n\np2ich = model4.addVars(ich, vtype=GRB.BINARY, name=\"p2ich\")\n\n# Fix price options of week 2\n\nfor i,c,h in ich:\n    p2ich[i,c,h].lb = opt_p2ich[i,c,h]\n\np3ijch = model4.addVars(ijch, vtype=GRB.BINARY, name=\"p3ijch\")\n\n# Capture one scenario where opt_p3ijch[i,j,c,h] = 1\nopt_p3kch = {}\n\nfor i,j,c,h in ijch:\n    p3ijch[i,j,c,h].lb = opt_p3ijch[i,j,c,h]\n    opt_p3kch[j,c,h] = 0\n    if opt_p3ijch[i,j,c,h] == 1:\n        opt_p3kch[j,c,h] = opt_p3ijch[i,j,c,h] \n\n# tickets to be sold at each week\ns1ich = model4.addVars(ich, name=\"s1ich\")\n\n# use hindsight demand of week 1\nfor i,c,h in ich:\n    fcst1[i,c,h] = 0\n    fcst1[i,c,h] = demand1[c,h]*opt_p1ch[c,h] \n\ns2ijch = model4.addVars(ijch, name=\"s2ijch\")\n\n# use hindsight demand of week 2\nfor j,c,h in ich:\n    fcst2[j,c,h] = 0\n    fcst2[j,c,h] = demand2[c,h]*opt_p2ich[j,c,h]\n\n\ns3ijkch = model4.addVars(ijkch, name=\"s3ijkch\")\n\n# use hindsight demand of week 3\nfor k,c,h in ich:\n    fcst3[k,c,h] = 0\n    fcst3[k,c,h] = demand3[c,h]*opt_p3kch[k,c,h]\n\n    \n# number of planes to fly\nn = model4.addVar(ub=6, vtype=GRB.INTEGER, name=\"planes\")\n\n# Price option constraints for week 1\n\npriceOption1 = model4.addConstrs( (gp.quicksum(p1ch[c,h] for h in options ) == 1 for c in classes ), name='priceOption1' )\n\n# sales constraints for week 1\n\nsales1 = model4.addConstrs( (s1ich[i,c,h] <= fcst1[i,c,h]*p1ch[c,h] for i,c,h in ich ), name='sales1' )\n\n# Price option constraints for week 2\n\npriceOption2 = model4.addConstrs( (gp.quicksum(p2ich[i,c,h] for h in options ) \n                                  == 1 for i in scenarios for c in classes ), name='priceOption2' )\n\n# sales constraints for week 2\n\nsales2 = model4.addConstrs( (s2ijch[i,j,c,h] <= fcst2[j,c,h]*p2ich[i,c,h] for i,j,c,h in ijch ), name='sales2' )\n\n# Price option constraints for week 3\n\npriceOption3 = model4.addConstrs( (gp.quicksum(p3ijch[i,j,c,h] for h in options ) \n                                  == 1 for i in scenarios for j in scenarios for c in classes ), name='priceOption3' )\n\n# sales constraints for week 3\n\nsales3 = model4.addConstrs( (s3ijkch[i,j,k,c,h] <= fcst3[k,c,h]*p3ijch[i,j,c,h] for i,j,k,c,h in ijkch ), name='sales3' )\n\n# Class capacity constraints.\n\nclassCap = model4.addConstrs( (gp.quicksum(s1ich[i,c,h] for h in options)  \n                              + gp.quicksum(s2ijch[i,j,c,h] for h in options) \n                              + gp.quicksum(s3ijkch[i,j,k,c,h] for h in options)  \n                              <= cap[c]*n for i,j,k,c in ijkc ) , name='classCap')\n\n# Objective function\nobj = gp.quicksum(prob[i]*price1[c,h]*p1ch[c,h]*s1ich[i,c,h] for i,c,h in ich ) \\\n+ gp.quicksum(prob[i]*prob[j]*price2[c,h]*p2ich[i,c,h]*s2ijch[i,j,c,h] for i,j,c,h in ijch ) \\\n+ gp.quicksum(prob[i]*prob[j]*prob[k]*price3[c,h]*p3ijch[i,j,c,h]*s3ijkch[i,j,k,c,h] for i,j,k,c,h in ijkch) - cost*n\n\nmodel4.setObjective( obj, GRB.MAXIMIZE)\n\n# Verify model formulation\n\nmodel4.write('YieldManagement4.lp')\n\n# Run optimization engine\n\nmodel4.optimize()\n\n#############################################################\n#            Print results of model for week 4\n#############################################################\n\n\nprint(\"\\n\\n\\n____________________Take off solution___________________________\")\n\nprint(f\"The actual total profit is: £{round(model4.objVal,2):,}\") \nprint(f\"Number of planes used: {n.x}\")\n\n\n# Sales week 1\n\nprint(\"\\n___________Week 1 seats sold and revenue__________________________\")\nfor i,c,h in ich:\n    if i == 'sce1':\n        if s1ich[i,c,h].x > 1e-6:\n            tickets = round(s1ich[i,c,h].x)\n            price = price1[c,h]*round(p1ch[c,h].x)\n            revenue = price*tickets\n            print(f\"{c} class: {tickets} seats sold at £{price:,}: revenue £{revenue:,}  \")\n            \n# Sales week 2\n\nprint(\"___________Period 2 seats sold and revenue__________________________\")\nfor i,j,c,h in ijch:\n    if i == 'sce1' and j == 'sce1':\n        if s2ijch[i,j,c,h].x > 1e-6:\n            tickets = round(s2ijch[i,j,c,h].x)\n            price = price2[c,h]*round(p2ich[i,c,h].x)\n            revenue = price*tickets\n            print(f\"{c} class: {tickets} seats sold at £{price:,}: revenue £{revenue:,}  \")\n            \n# Sales week 3\n\nprint(\"___________Period 3 seats sold and revenue__________________________\")\nfor i,j,k,c,h in ijkch:\n    if i == 'sce1' and j == 'sce1' and k == 'sce1':\n        if s3ijkch[i,j,k,c,h].x > 1e-6:\n            tickets = round(s3ijkch[i,j,k,c,h].x )\n            price = price3[c,h]*round(p3ijch[i,j,c,h].x)\n            revenue = price*tickets\n            print(f\"{c} class: {tickets} seats sold at £{price:,}: revenue £{revenue:,}  \")"}]}
{"meta": {"source_path": "/Users/sunyujun03/Desktop/ReLoop/gurobi-modeling-examples/refinery/refinery.ipynb", "kind": "ipynb", "title": "Refinery"}, "messages": [{"role": "system", "content": "You are an optimization engineer. Write correct and runnable Python code using gurobipy (Gurobi Python API). Be concise. Output only what is requested."}, {"role": "user", "content": "    Task: Reproduce the following Gurobi modeling example in Python using gurobipy.\n\n    Scenario description (from source):\n    # Refinery\n\n## Objective and Prerequisites\n\nIn this example, we’ll demonstrate how you can use mathematical optimization to optimize the output of a refinery. You’ll learn how to generate an optimal production plan that maximizes total profit, while taking into account production capacity and other restrictions.\n\nMore information on this type of model can be found in example # 6 of the fifth edition of Modeling Building in Mathematical Programming by H. P. Williams on pages 258 and 306 – 310.\n\nThis modeling example is at the intermediate level, where we assume that you know Python and are familiar with the Gurobi Python API. In addition, you should have some knowledge about building mathematical optimization models.\n\n**Download the Repository** <br />\nYou can download the repository containing this and other examples by clicking [here](https://github.com/Gurobi/modeling-examples/archive/master.zip). \n\n---\n## Problem Description\n\nAn oil refinery purchases two types of crude oil (Crude 1 and Crude 2) and refines them through a four-step process (distillation, reforming, cracking, and blending) to produce gas and fuels that are sold.\n\n### Step One: Distillation\n\nThe distillation process separates each crude oil into six fractions according to their boiling points. These fractions are: light naphtha, medium naphtha, heavy naphtha, light oil, heavy oil, and residuum. The octane numbers for the light, medium and heavy naphthas are, respectively, 90, 80, and 70.\n\nOne barrel of crude separates into following fractions:\n\n| <i></i> | Light Naphta | Medium Naphta | Heavy Naphta | Light Oil | Heavy Oil | Residuum |\n| --- | --- | --- | --- | --- | --- | --- |\n| Crude 1 | 0.1 | 0.2 | 0.2 | 0.12 | 0.2 | 0.13 |\n| Crude 2 | 0.15 | 0.25 | 0.18 | 0.08 | 0.19 | 0.12 |\n\nThere is a small amount of waste in distillation (5% and 3% for Crude 1 and 2, respectively).\n\n### Step Two: Reforming\n\nAfter distillation, the resulting naphthas can be blended into different grades of gas, or they can go through a process called reforming. The output of the reforming process is a product known as reformed gasoline with an octane number of 115.\n\nThe yields of reformed gasoline from each barrel of the different naphthas are given as follows:\n\n- One barrel of light naphtha yields 0.6 barrels of reformed gasoline.\n- One barrel of medium naphtha yields 0.52 barrels of reformed gasoline.\n- One barrel of heavy naphtha yields 0.45 barrels of reformed gasoline.\n\n### Step Three: Cracking\n\nLight and heavy oils can be blended into jet fuel or be put through a process known as catalytic cracking. The catalytic cracker produces cracked oil and cracked gasoline.\n\nCracked gasoline has an octane number of 105 with the following yields:\n\n- One barrel of light oil yields 0.68 barrels of cracked oil and 0.28 barrels of cracked gasoline.\n- One barrel of heavy oil yields 0.75 barrels of cracked oil and 0.2 barrels of cracked gasoline.\n\nCracked oil is used for blending fuel oil and jet fuel; cracked gasoline is used for blending gasoline. Residuum can be used for either producing lube-oil or blending into jet fuel and fuel oil:\n\n- One barrel of residuum yields 0.5 barrels of lube-oil.\n\n### Step Four: Blending\n\n#### Gasoline\n\nThere are two kinds of gasoline — regular and premium — made by blending naphtha, reformed gasoline, and cracked gasoline. The only requirement is that regular gasoline must have an octane of at least 84 and premium gasoline must have an octane number of at least 94. It is assumed that octane numbers blend linearly by volume.\n\n#### Jet Fuel\n\nJet fuel must have a vapor pressure that does not exceed $1.0 \\frac{\\text{kg}}{\\text{cm}^2}$. The vapor pressures for light, heavy, cracked oils and residuum are, respectively, 1.0, 0.6, 1.5 and 0.05 $\\frac{\\text{kg}}{\\text{cm}^2}$. It is assumed that vapor pressures blend linearly by volume.\n\n#### Fuel Oil\n\nTo produce fuel oil, you must blend light oil, cracked oil, heavy oil and residuum in the ratio of 10:4:3:1. \n\nThe availability and capacity limitations are as follows:\n\n- The daily availability of crude 1 is 20 000 barrels.\n- The daily availability of crude 2 is 30 000 barrels.\n- At most 45 000 barrels of crude can be distilled per day.\n- At most 10 000 barrels of naphtha can be reformed per day.\n- At most 8000 barrels of oil can be cracked per day.\n- The daily production of lube oil must be between 500 and 1000 barrels.\n- Premium gasoline production must be at least 40% of regular gasoline production.\n\nEach final product has the following profit contribution per barrel (pennies per barrel):\n\n| <i></i> | Profit Contribution |\n| --- | --- |\n| Premium Gasoline | 700 |\n| Regular Gasoline | 600 |\n| Jet Fuel | 400 |\n| Fuel Oil | 350 |\n| Lube Oil | 150 |\n\nThe key question is: How should the operations of the refinery be planned in order to maximize total profit?\n\n---\n## Model Formulation\n\n### Sets and Indices\n\n$i \\in \\text{Crudes}=\\{1,2\\}$: Set of crude oils.\n\n### Parameters\n\n$\\text{buy_limit}_i \\in \\mathbb{N}$: Maximum number of barrels of crude $i$ to buy.\n\n$\\text{distill_cap} \\in \\mathbb{N}$: Maximum number of barrels of crude oil to distill. \n\n$\\text{reform_cap} \\in \\mathbb{N}$: Maximum number of barrels of naphtha to reform. \n\n$\\text{crack_cap} \\in \\mathbb{N}$ Maximum number of barrels of oil to crack.\n\n$\\text{LBO_min}, \\text{LBO_max} \\in \\mathbb{N}$ Minimum and Maximum number of barrels of lube oil to produce.\n\n### Decision Variables\n\n$\\text{CR}_i \\in [0,\\text{buy_limit}_i] \\subset \\mathbb{R}^+$: Number of barrels of crude $i$ to buy.\n\n$\\text{LN} \\in \\mathbb{R}^+$: Number of barrels of light naphtha to distill.\n\n$\\text{MN} \\in \\mathbb{R}^+$: Number of barrels of medium naphtha to distill.\n\n$\\text{HN} \\in \\mathbb{R}^+$: Number of barrels of heavy naphtha to distill.\n\n$\\text{LO} \\in \\mathbb{R}^+$: Number of barrels of light oil to distill.\n\n$\\text{HO} \\in \\mathbb{R}^+$: Number of barrels of heavy oil to distill.\n\n$\\text{R} \\in \\mathbb{R}^+$: Number of barrels of residuum to distill.\n\n$\\text{LNRG} \\in \\mathbb{R}^+$: Number of barrels of light naphtha used to produce reformed gasoline.\n\n$\\text{MNRG} \\in \\mathbb{R}^+$: Number of barrels of medium naphtha used to produce reformed gasoline.\n\n$\\text{HNRG} \\in \\mathbb{R}^+$: Number of barrels of heavy naphtha used to produce reformed gasoline.\n\n$\\text{RG} \\in \\mathbb{R}^+$: Number of barrels of reformed gasoline to produce.\n\n$\\text{LOCGO} \\in \\mathbb{R}^+$: Number of barrels of light oil used to produce cracked gasoline and cracked oil.\n\n$\\text{HOCGO} \\in \\mathbb{R}^+$: Number of barrels of heavy oil used to produce cracked gasoline and cracked oil.\n\n$\\text{CG} \\in \\mathbb{R}^+$: Number of barrels of cracked gasoline to produce.\n\n$\\text{CO} \\in \\mathbb{R}^+$: Number of barrels of cracked oil to produce.\n\n$\\text{LNPMF} \\in \\mathbb{R}^+$: Number of barrels of light naphtha used to produce premium motor fuel.\n\n$\\text{LNRMF} \\in \\mathbb{R}^+$: Number of barrels of light naphtha used to produce regular motor fuel.\n\n$\\text{MNPMF} \\in \\mathbb{R}^+$: Number of barrels of medium naphtha used to produce premium motor fuel.\n\n$\\text{MNRMF} \\in \\mathbb{R}^+$: Number of barrels of medium naphtha used to produce regular motor fuel.\n\n$\\text{HNPMF} \\in \\mathbb{R}^+$: Number of barrels of heavy naphtha used to produce premium motor fuel.\n\n$\\text{HNRMF} \\in \\mathbb{R}^+$: Number of barrels of heavy naphtha used to produce regular motor fuel.\n\n$\\text{RGPMF} \\in \\mathbb{R}^+$: Number of barrels of reformed gasoline used to produce premium motor fuel.\n\n$\\text{RGRMF} \\in \\mathbb{R}^+$: Number of barrels of reformed gasoline used to produce regular motor fuel.\n\n$\\text{CGPMF} \\in \\mathbb{R}^+$: Number of barrels of cracked gasoline used to produce premium motor fuel.\n\n$\\text{CGRMF} \\in \\mathbb{R}^+$: Number of barrels of cracked gasoline used to produce regular motor fuel.\n\n$\\text{LOJF} \\in \\mathbb{R}^+$: Number of barrels of light oil used to produce jet fuel.\n\n$\\text{HOJF} \\in \\mathbb{R}^+$: Number of barrels of heavy oil used to produce jet fuel.\n\n$\\text{RJF} \\in \\mathbb{R}^+$: Number of barrels of residuum used to produce jet fuel.\n\n$\\text{COJF} \\in \\mathbb{R}^+$: Number of barrels of cracked oil used to produce jet fuel.\n\n$\\text{RLBO} \\in \\mathbb{R}^+$: Number of barrels of residuum used to produce lube oil.\n\n$\\text{PMF} \\in \\mathbb{R}^+$: Number of barrels of premium motor fuel to produce.\n\n$\\text{RMF} \\in \\mathbb{R}^+$: Number of barrels of regular motor fuel to produce.\n\n$\\text{JF} \\in \\mathbb{R}^+$: Number of barrels of jet fuel to produce.\n\n$\\text{FO} \\in \\mathbb{R}^+$: Number of barrels of fuel oil to produce.\n\n$\\text{LBO} \\in [\\text{LBO_min}, \\text{LBO_max}] \\subset \\mathbb{R}^+$: Number of barrels of lube oil to produce.\n\n### Objective Function\n\n- **Profit:** Maximize the total profit (in hundreds of USD).\n\n\\begin{equation}\n\\text{Max} \\quad Z = 7*\\text{PMF} + 6*\\text{RMF} + 4*\\text{JF} + 3.5*\\text{FO} + 1.5*\\text{LBO}\n\\tag{0}\n\\end{equation}\n\n### Constraints\n\n- **Distillation Capacity**: The number of barrels of crude oil to distill cannot exceed the capacity.\n\n\\begin{equation}\n\\sum_{i \\in \\text{Crudes}}{\\text{CR}_i} \\leq \\text{distill_cap}\n\\tag{1}\n\\end{equation}\n\n- **Reforming Capacity**: The number of barrels of naphtha to reform cannot exceed the capacity.\n\n\\begin{equation}\n\\text{LNRG} + \\text{MNRG} + \\text{HNRG} \\leq \\text{reform_cap}\n\\tag{2}\n\\end{equation}\n\n- **Cracking Capacity**: The number of barrels of oil to crack cannot exceed the capacity.\n\n\\begin{equation}\n\\text{LOCGO} + \\text{HOCGO} \\leq \\text{crack_cap}\n\\tag{3}\n\\end{equation}\n\n- **Yield**: The number of barrels produced depends on the quantities of inputs used, as well as their corresponding yields.\n\n\\begin{equation}\n0.10*\\text{CR}_1 + 0.15*\\text{CR}_2 = \\text{LN}\n\\tag{4.1}\n\\end{equation}\n\n\\begin{equation}\n0.20*\\text{CR}_1 + 0.25*\\text{CR}_2 = \\text{MN}\n\\tag{4.2}\n\\end{equation}\n\n\\begin{equation}\n0.20*\\text{CR}_1 + 0.18*\\text{CR}_2 = \\text{HN}\n\\tag{4.3}\n\\end{equation}\n\n\\begin{equation}\n0.12*\\text{CR}_1 + 0.08*\\text{CR}_2 = \\text{LO}\n\\tag{4.4}\n\\end{equation}\n\n\\begin{equation}\n0.20*\\text{CR}_1 + 0.19*\\text{CR}_2 = \\text{HO}\n\\tag{4.5}\n\\end{equation}\n\n\\begin{equation}\n0.13*\\text{CR}_1 + 0.12*\\text{CR}_2 = \\text{R}\n\\tag{4.6}\n\\end{equation}\n\n\\begin{equation}\n0.60*\\text{LNRG} + 0.52*\\text{MNRG} + 0.45*\\text{HNRG} = \\text{RG}\n\\tag{4.7}\n\\end{equation}\n\n\\begin{equation}\n0.68*\\text{LOCGO} + 0.75*\\text{HOCGO} = \\text{CO}\n\\tag{4.8}\n\\end{equation}\n\n\\begin{equation}\n0.28*\\text{LOCGO} + 0.20*\\text{HOCGO} = \\text{CG}\n\\tag{4.9}\n\\end{equation}\n\n\\begin{equation}\n0.50*\\text{RLBO} = \\text{LBO}\n\\tag{4.10}\n\\end{equation}\n\n\\begin{equation}\n\\text{LNPMF} + \\text{MNPMF} + \\text{HNPMF} + \\text{RGPMF} + \\text{CGPMF} = \\text{PMF}\n\\tag{4.11}\n\\end{equation}\n\n\\begin{equation}\n\\text{LNRMF} + \\text{MNRMF} + \\text{HNRMF} + \\text{RGRMF} + \\text{CGRMF} = \\text{RMF}\n\\tag{4.12}\n\\end{equation}\n\n\\begin{equation}\n\\text{LOJF} + \\text{HOJF} + \\text{COJF} + \\text{RJF} = \\text{JF}\n\\tag{4.13}\n\\end{equation}\n\n- **Mass Conservation:** The number of barrels used must be equal to the number of barrels available.\n\n\\begin{equation}\n\\text{LNRG} + \\text{LNPMF} + \\text{LNRMF} = \\text{LN}\n\\tag{5.1}\n\\end{equation}\n\n\\begin{equation}\n\\text{MNRG} + \\text{MNPMF} + \\text{MNRMF} = \\text{MN}\n\\tag{5.2}\n\\end{equation}\n\n\\begin{equation}\n\\text{HNRG} + \\text{HNPMF} + \\text{HNRMF} = \\text{HN}\n\\tag{5.3}\n\\end{equation}\n\n\\begin{equation}\n\\text{LOCGO} + \\text{LOJF} + 0.55*\\text{FO} = \\text{LO}\n\\tag{5.4}\n\\end{equation}\n\n\\begin{equation}\n\\text{HOCGO} + \\text{HOJF} + 0.17*\\text{FO} = \\text{HO}\n\\tag{5.5}\n\\end{equation}\n\n\\begin{equation}\n\\text{COJF} + 0.22*\\text{FO} = \\text{CO}\n\\tag{5.6}\n\\end{equation}\n\n\\begin{equation}\n\\text{RLBO} + \\text{RJF} + 0.0555*\\text{FO} = \\text{R}\n\\tag{5.7}\n\\end{equation}\n\n\\begin{equation}\n\\text{CGPMF} + \\text{CGRMF} = \\text{CG}\n\\tag{5.8}\n\\end{equation}\n\n\\begin{equation}\n\\text{RGPMF} + \\text{RGRMF} = \\text{RG}\n\\tag{5.9}\n\\end{equation}\n\n- **Premium-to-Regular Proportion:** The production ratio between premium and regular gasoline must satisfy the minimum requirement.\n\n\\begin{equation}\n\\text{PMF} \\geq 0.40*\\text{RMF}\n\\tag{6}\n\\end{equation}\n\n- **Octane Tolerance:** The octane rating of each type of gasoline cannot drop below the lower tolerance.\n\n\\begin{equation}\n90*\\text{LNPMF} + 80*\\text{MNPMF} + 70*\\text{HNPMF} + 115*\\text{RGPMF} + 105*\\text{CGPMF} \\geq 94*\\text{PMF}\n\\tag{7.1}\n\\end{equation}\n\n\\begin{equation}\n90*\\text{LNRMF} + 80*\\text{MNRMF} + 70*\\text{HNRMF} + 115*\\text{RGRMF} + 105*\\text{CGRMF} \\geq 84*\\text{PMF}\n\\tag{7.2}\n\\end{equation}\n\n- **Vapor-Pressure Tolerance:** The vapor pressure of jet fuel cannot drop below the lower tolerance.\n\n\\begin{equation}\n1.0*\\text{LOJF} + 0.6*\\text{HOJF} + 1.5*\\text{COJF} + 0.05*\\text{RJF} \\leq 1.0*\\text{JF}\n\\tag{8}\n\\end{equation}\n\n---\n## Python Implementation\n\nWe import the Gurobi Python Module and other Python libraries.\n\n## Input Data\nWe define all the input data of the model.\n\n## Model Deployment\nWe create a model and the variables.\n\nNext, we insert the constraints.\n\nThe distillation capacity constraint is:\n\n    Requirements:\n    - Use gurobipy (Model, GRB, addVar/addConstr, etc.)\n    - Make the script runnable as a standalone Python file if possible.\n    - Keep the code faithful to the example.\n"}, {"role": "assistant", "content": "import numpy as np\n\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# tested with Python 3.11 & Gurobi 11.0\n\n# Parameters\n\ncrude_numbers = range(1,2+1)\npetrols = [\"Premium_fuel\", \"Regular_fuel\"]\nend_product_names = [\"Premium_fuel\", \"Regular_fuel\", \"Jet_fuel\", \"Fuel_oil\", \"Lube_oil\"]\ndistillation_products_names = [\"Light_naphtha\", \"Medium_naphtha\", \"Heavy_naphtha\",\n                               \"Light_oil\", \"Heavy_oil\", \"Residuum\"]\nnaphthas = [\"Light_naphtha\", \"Medium_naphtha\", \"Heavy_naphtha\"]\nintermediate_oils = [\"Light_oil\", \"Heavy_oil\"]\ncracking_products_names = [\"Cracked_gasoline\", \"Cracked_oil\"]\nused_for_motor_fuel_names = [\"Light_naphtha\", \"Medium_naphtha\", \"Heavy_naphtha\",\n                             \"Reformed_gasoline\", \"Cracked_gasoline\"]\nused_for_jet_fuel_names = [\"Light_oil\", \"Heavy_oil\", \"Residuum\", \"Cracked_oil\"]\n\nbuy_limit = {1:20000, 2:30000}\nlbo_min = 500\nlbo_max = 1000\n\ndistill_cap = 45000\nreform_cap = 10000\ncrack_cap = 8000\n\ndistillation_splitting_coefficients = {\"Light_naphtha\": (0.1, 0.15),\n                          \"Medium_naphtha\": (0.2, 0.25),\n                         \"Heavy_naphtha\": (0.2, 0.18),\n                         \"Light_oil\": (0.12, 0.08),\n                         \"Heavy_oil\": (0.2, 0.19),\n                         \"Residuum\": (0.13, 0.12)}\n\ncracking_splitting_coefficients = {(\"Light_oil\",\"Cracked_oil\"): 0.68,\n                                   (\"Heavy_oil\",\"Cracked_oil\"): 0.75,\n                                   (\"Light_oil\",\"Cracked_gasoline\"): 0.28,\n                                   (\"Heavy_oil\",\"Cracked_gasoline\"): 0.2}\n\nreforming_splitting_coefficients = {\"Light_naphtha\": 0.6, \"Medium_naphtha\":0.52, \"Heavy_naphtha\":0.45}\nend_product_profit = {\"Premium_fuel\":7, \"Regular_fuel\":6, \"Jet_fuel\":4, \"Fuel_oil\":3.5, \"Lube_oil\":1.5}\nblending_coefficients = {\"Light_oil\": 0.55, \"Heavy_oil\": 0.17, \"Cracked_oil\": 0.22, \"Residuum\": 0.055}\n\nlube_oil_factor = 0.5\npmf_rmf_ratio = 0.4\n\noctance_number_coefficients = {\n    \"Light_naphtha\":90,\n    \"Medium_naphtha\":80,\n    \"Heavy_naphtha\":70,\n    \"Reformed_gasoline\":115,\n    \"Cracked_gasoline\":105,\n}\noctance_number_fuel = {\"Premium_fuel\": 94,\"Regular_fuel\": 84}\n\nvapor_pressure_constants = [0.6, 1.5, 0.05]\n\nrefinery = gp.Model('Refinery_Optimization')\n\n# Variables\ncrudes = refinery.addVars(crude_numbers, ub=buy_limit, name=\"cr\")    \nend_products = refinery.addVars(end_product_names, name=\"end_prod\")\nend_products[\"Lube_oil\"].lb= lbo_min\nend_products[\"Lube_oil\"].ub= lbo_max\ndistillation_products = refinery.addVars(distillation_products_names, name=\"dist_prod\")\nreform_usage = refinery.addVars(naphthas, name=\"napthas_to_reformed_gasoline\")\nreformed_gasoline = refinery.addVar(name=\"reformed_gasoline\")\ncracking_usage = refinery.addVars(intermediate_oils,name=\"intermediate_oils_to_cracked_gasoline\")\ncracking_products = refinery.addVars(cracking_products_names,  name=\"cracking_prods\")\nused_for_regular_motor_fuel = refinery.addVars(used_for_motor_fuel_names, name=\"motor_fuel_to_regular_motor_fuel\")\nused_for_premium_motor_fuel = refinery.addVars(used_for_motor_fuel_names, name=\"motot_fuel_to_premium_motor_fuel\")\nused_for_jet_fuel = refinery.addVars(used_for_jet_fuel_names, name=\"jet_fuel\")\nused_for_lube_oil = refinery.addVar(vtype=GRB.CONTINUOUS,name=\"residuum_used_for_lube_oil\")\n\n# 1. Distillation capacity\nDistillationCap = refinery.addConstr(crudes.sum() <= distill_cap, \"Distill_cap\")\n\n# 2. Reforming capacity\nReformingCap = refinery.addConstr(reform_usage.sum() <= reform_cap, \"Reform_cap\")\n\n# 3. Cracking capacity\nCrackingCap = refinery.addConstr(cracking_usage.sum() <= crack_cap, \"Crack_cap\")\n\n# 4.1-4.6 Yield (Crude oil products)\nYieldCrudeOil = refinery.addConstrs((gp.quicksum(distillation_splitting_coefficients[dpn][crude-1]*crudes[crude] for crude in crudes)\n                  == distillation_products[dpn] for dpn in distillation_products_names), \"Splitting_distillation\")\n\n# 4.7 Yield (Reforming of Naphthas)\nYieldNaphthas = refinery.addConstr(reform_usage.prod(reforming_splitting_coefficients) == reformed_gasoline, \"Splitting_reforming\")\n\n# 4.8-4.9 Yield (Cracking of oils)\nYieldCrackingOil = refinery.addConstrs((gp.quicksum(cracking_splitting_coefficients[oil, crack_prod]*cracking_usage[oil]\n                           for oil in intermediate_oils) == cracking_products[crack_prod]\n                  for crack_prod in cracking_products_names),\n                 name=\"Splitting_cracking\")\n\n# 4.10 Yield (Lube oil)\nYieldLubeOil = refinery.addConstr(lube_oil_factor*used_for_lube_oil == end_products[\"Lube_oil\"],\n                \"Splitting_lube_oil\")\n\n# 4.11 Yield (Premium gasoline)\nYieldPremium = refinery.addConstr(used_for_premium_motor_fuel.sum() == end_products[\"Premium_fuel\"], \"Blending_premium_fuel\")\n\n# 4.12 Yield (Regular gasoline)\nYieldRegular = refinery.addConstr(used_for_regular_motor_fuel.sum() == end_products[\"Regular_fuel\"], \"Blending_regular_fuel\")\n\n# 4.13 Yield (Jet fuel)\nYieldJetFuel = refinery.addConstr(used_for_jet_fuel.sum() == end_products[\"Jet_fuel\"], \"Continuity_jet_fuel\")\n\n# 5.1-5.3 Mass conservation (Naphthas)\nMassBalNaphthas = refinery.addConstrs((reform_usage[naphtha] +\n                    used_for_regular_motor_fuel[naphtha] +\n                    used_for_premium_motor_fuel[naphtha] ==\n                    distillation_products[naphtha] for naphtha in naphthas), \"Continuity_napththa\")\n\n# 5.4 Mass Conservation (Light oil)\nMassBalLightOil = refinery.addConstr(cracking_usage[\"Light_oil\"]+\n                used_for_jet_fuel[\"Light_oil\"]+\n                blending_coefficients[\"Light_oil\"]*end_products[\"Fuel_oil\"] ==\n                distillation_products[\"Light_oil\"], \"Fixed_proportion_light_oil_for_blending\")\n\n# 5.5 Mass Conservation (Heavy oil)\nMassBalHeavyOil = refinery.addConstr(cracking_usage[\"Heavy_oil\"]+\n                used_for_jet_fuel[\"Heavy_oil\"]+\n                blending_coefficients[\"Heavy_oil\"]*end_products[\"Fuel_oil\"] ==\n                distillation_products[\"Heavy_oil\"], \"Fixed_proportion_heavy_oil_for_blending\")\n\n# 5.6 Mass Conservation (Cracked oil)\nMassBalCrackedOil = refinery.addConstr(used_for_jet_fuel[\"Cracked_oil\"]+\n                blending_coefficients[\"Cracked_oil\"]*end_products[\"Fuel_oil\"] ==\n                cracking_products[\"Cracked_oil\"], \"Fixed_proportion_cracked_oil_for_blending\")\n\n# 5.7 Mass Conservation (Residuum)\nMassBalResiduum = refinery.addConstr(used_for_lube_oil +\n                used_for_jet_fuel[\"Residuum\"]+\n                blending_coefficients[\"Residuum\"]*end_products[\"Fuel_oil\"] ==\n                distillation_products[\"Residuum\"], \"Fixed_proportion_residuum_for_blending\")\n\n# 5.8 Mass conservation (Cracked gasoline)\nMassBalCrackedGas = refinery.addConstr(used_for_regular_motor_fuel[\"Cracked_gasoline\"] +\n                used_for_premium_motor_fuel[\"Cracked_gasoline\"] ==\n                cracking_products[\"Cracked_gasoline\"], \"Continuity_cracked_gasoline\")\n\n# 5.9 Mass conservation (Reformed gasoline)\nMassBalReformedGas = refinery.addConstr(used_for_regular_motor_fuel[\"Reformed_gasoline\"] +\n                used_for_premium_motor_fuel[\"Reformed_gasoline\"] ==\n                reformed_gasoline, \"Continuity_reformed_gasoline\")\n\n# 7. Premium-to-regular proportion\nPremium2Regular = refinery.addConstr(end_products[\"Premium_fuel\"] >= pmf_rmf_ratio*end_products[\"Regular_fuel\"],\n                \"Prem2reg_prop\")\n\n# 8.1-8.2 Octane tolerance\nOctaneRegular = refinery.addConstr(used_for_regular_motor_fuel.prod(octance_number_coefficients) >=\n                octance_number_fuel[\"Regular_fuel\"] * end_products[\"Regular_fuel\"],\n                \"Octane_tol_regular_fuel\")\n\nOctanePremium = refinery.addConstr(used_for_premium_motor_fuel.prod(octance_number_coefficients) >=\n                octance_number_fuel[\"Premium_fuel\"] * end_products[\"Premium_fuel\"],\n                \"Octane_tol_premium_fuel\")\n\n# 9. Vapor-pressure tolerance\nVaporPressure = refinery.addConstr(used_for_jet_fuel[\"Light_oil\"] +\n                vapor_pressure_constants[0]*used_for_jet_fuel[\"Heavy_oil\"] +\n                vapor_pressure_constants[1]*used_for_jet_fuel[\"Cracked_oil\"] +\n                vapor_pressure_constants[2]*used_for_jet_fuel[\"Residuum\"] <= end_products[\"Jet_fuel\"],\n                \"Vapor_pressure_tol\")\n\n# 0. Profit\nrefinery.setObjective(end_products.prod(end_product_profit), GRB.MAXIMIZE)\n\nrefinery.optimize()\n\nfor var in refinery.getVars():\n    if abs(var.x) > 1e-6:\n        print(\"{0} = {1}\".format(var.varName, np.round(var.x, 2)))"}]}
{"meta": {"source_path": "/Users/sunyujun03/Desktop/ReLoop/gurobi-modeling-examples/logical_design/logical_design.ipynb", "kind": "ipynb", "title": "Logical Design"}, "messages": [{"role": "system", "content": "You are an optimization engineer. Write correct and runnable Python code using gurobipy (Gurobi Python API). Be concise. Output only what is requested."}, {"role": "user", "content": "    Task: Reproduce the following Gurobi modeling example in Python using gurobipy.\n\n    Scenario description (from source):\n    # Logical Design\n\n## Objective and Prerequisites\n\nIn this example, you’ll learn how to solve a logical design problem, which involves constructing a circuit using the minimum number of NOR gates (devices with two inputs and  one output) that will perform the logical function specified by a truth table. We’ll show you how to formulate this problem as a binary optimization problem using the Gurobi Python API and then use Gurobi Optimizer to automatically find the optimal solution.\n\nThis model is example 12 from the fifth edition of Model Building in Mathematical Programming by H. Paul Williams on pages 266-267 and 320-321.\n\nThis example is at the intermediate level, where we assume that you know Python and the Gurobi Python API and that you have some knowledge of building mathematical optimization models.\n\n**Download the Repository** <br /> \nYou can download the repository containing this and other examples by clicking [here](https://github.com/Gurobi/modeling-examples/archive/master.zip). \n\n## Problem Description\n\nLogical circuits have a given number of inputs and one output. Impulses may be applied to the inputs of a given logical circuit, and it will respond by giving either an output (signal 1) or no output (signal 0). The input impulses are of the\nsame kind as the outputs - 1 (positive input) or 0 (no input).\n\nIn this example, a logical circuit is to be built up of NOR gates. A NOR gate is a device with two inputs and one output. It has the property that there is positive output (signal 1) if and only if neither input is positive, that is, both inputs have the value 0. By connecting such gates together with outputs from one gate possibly being inputs into another gate, it is possible to construct a circuit to perform any desired logical function. For example, the circuit illustrated in the following figure will respond to the inputs A and B in the way indicated by the truth table.\n![circuit](circuit.PNG)\n\nThe objective is to construct a circuit using the minimum number of NOR gates that will perform the logical function specified by the following  truth table.\n\n| A | B | Output |\n| --- | --- | --- | \n| 0 | 0 | 0 |\n| 0 | 1 | 1 |\n| 1 | 0 | 1 |\n| 1 | 1 | 0 |\n\n‘Fan-in’ and ‘fan-out’ are not permitted. That is, more than one output from a NOR gate cannot lead into one input nor can one output lead into more than one input. It may be assumed throughout that the optimal design is a ‘subnet’ of the ‘maximal’ net shown in the following figure.\n![subnet](subnet.PNG)\n\n## Model Formulation\n\n### Sets and Indices\n\n$i \\in \\text{Gates}=\\{1,...,7\\}$\n\n$i \\in \\text{G47}=\\{4,...,7\\}$\n\n$r \\in \\text{Rows}=\\{1,...,4\\}$\n\n### Parameters\n\n$\\text{valueA}_{i,r} \\in \\{0,1 \\}$: Value of the external input A in row  $r$ of the truth table for gate $i$.\n\n$\\text{valueB}_{i,r} \\in \\{0,1 \\}$: Value of the external input B in row  $r$ of the truth table for gate $i$.\n\n### Decision Variables\n\n$\\text{NOR}_{i} \\in \\{0,1 \\}$: This binary variable is equal to 1, if NOR gate $i$  is selected, 0 otherwise.\n\n$\\text{inputA}_{i} \\in \\{0,1 \\}$: This binary variable is equal to 1, if external input A is an input to NOR gate $i$ , and 0 otherwise.\n\n$\\text{inputB}_{i} \\in \\{0,1 \\}$: This binary variable is equal to 1, if external input B is an input to NOR gate $i$ , and 0 otherwise.\n\n$\\text{output}_{i,r} \\in \\{0,1 \\}$: This binary variable is the output from gate $i$ for the combination of external input signals specified  in row $r$  of the truth table.\n\n### Constraints\n\n**External input**: A NOR gate can only have an external input if it exists.\n\n\\begin{equation}\n\\text{NOR}_{i} \\geq \\text{inputA}_{i}  \\quad \\forall i \\in \\text{Gates}\n\\end{equation}\n\n\\begin{equation}\n\\text{NOR}_{i} \\geq \\text{inputB}_{i}  \\quad \\forall i \\in \\text{Gates}\n\\end{equation}\n\n**NOR gates**:If a NOR gate has one (or two) external inputs leading into it, only one (or no) NOR gates can feed into it. \n\n\\begin{equation}\n\\text{NOR}_{2} + \\text{NOR}_{3} + \\text{inputA}_{1} + \\text{inputB}_{1} \\leq 2\n\\end{equation}\n\n\\begin{equation}\n\\text{NOR}_{4} + \\text{NOR}_{5} + \\text{inputA}_{2} + \\text{inputB}_{2} \\leq 2\n\\end{equation}\n\n\\begin{equation}\n\\text{NOR}_{6} + \\text{NOR}_{7} + \\text{inputA}_{3} + \\text{inputB}_{3} \\leq 2\n\\end{equation}\n\nThese constraints are based on the circuit shown in the figure of the ‘maximal’ net. \n\n**Output signals**: The output signal from NOR gate $i$ must be the correct logical function (NOR) of the input signals into gate $i$, if gate $i$ exists. \n\n\\begin{equation}\n\\text{output}_{2,r} + \\text{output}_{1,r} \\leq 1 \\quad \\forall r \\in \\text{Rows}\n\\end{equation}\n\n\\begin{equation}\n\\text{output}_{3,r} + \\text{output}_{1,r} \\leq 1 \\quad \\forall r \\in \\text{Rows}\n\\end{equation}\n\n\\begin{equation}\n\\text{valueA}_{i,r}*\\text{inputA}_{i} + \\text{output}_{i,r} \\leq 1 \\quad \\forall i \\in \\text{Gates}, r \\in \\text{Rows}\n\\end{equation}\n\n\\begin{equation}\n\\text{valueB}_{i,r}*\\text{inputB}_{i} + \\text{output}_{i,r} \\leq 1 \\quad \\forall i \\in \\text{Gates}, r \\in \\text{Rows}\n\\end{equation}\n\n\\begin{equation}\n\\text{valueA}_{i,r}*\\text{inputA}_{i} + \\text{valueB}_{i,r}*\\text{inputB}_{i} + \n\\text{output}_{i,r} - \\text{NOR}_{i}  \\geq 0 \\quad \\forall i \\in \\text{G47}, r \\in \\text{Rows}\n\\end{equation}\n\n\\begin{equation}\n\\text{valueA}_{1,r}*\\text{inputA}_{1} + \\text{valueB}_{1,r}*\\text{inputB}_{1} + \n\\text{output}_{2,r} + \\text{output}_{3,r} + \\text{output}_{1,r} - \\text{NOR}_{1}  \\geq 0 \n\\quad \\forall r \\in \\text{Rows}\n\\end{equation}\n\n\\begin{equation}\n\\text{valueA}_{2,r}*\\text{inputA}_{2} + \\text{valueB}_{2,r}*\\text{inputB}_{2} + \n\\text{output}_{4,r} + \\text{output}_{5,r} + \\text{output}_{2,r} - \\text{NOR}_{2}  \\geq 0 \n\\quad \\forall r \\in \\text{Rows}\n\\end{equation}\n\n\\begin{equation}\n\\text{valueA}_{3,r}*\\text{inputA}_{3} + \\text{valueB}_{3,r}*\\text{inputB}_{3} + \n\\text{output}_{6,r} + \\text{output}_{7,r} + \\text{output}_{3,r} - \\text{NOR}_{3}  \\geq 0 \n\\quad \\forall r \\in \\text{Rows}\n\\end{equation}\n\n**Gate 1**: For NOR gate 1, the output variables are fixed at the values specified in the truth table. \n\n\\begin{equation}\n\\text{output}_{1,1} = 0, \\text{output}_{1,2} = 1, \\text{output}_{1,3} = 1,  \\text{output}_{1,4} = 0   \n\\end{equation}\n\nTo avoid a trivial solution containing no NOR gates, it is necessary to impose a constraint that selects NOR gate 1.\n\n\\begin{equation}\n\\text{NOR}_{1} \\geq 1  \n\\end{equation}\n\n**Gates and output**: If there is an output signal of 1 from a particular NOR gate for any combination of the input signals, then that gate must exist.\n\n\\begin{equation}\n\\text{NOR}_{i} - \\text{output}_{i,r} \\geq 0 \\quad \\forall i \\in \\text{Gates}, r \\in \\text{Rows}\n\\end{equation}\n\n### Objective Function\n\n**Number of gates**: The objective is to minimize the number of NOR gates selected.\n\n\\begin{equation}\n\\text{Minimize} \\quad  \\sum_{i \\in \\text{Gates}} \\text{NOR}_{i}\n\\end{equation}\n\n## Python Implementation\n\nWe import the Gurobi Python Module.\n\n    Requirements:\n    - Use gurobipy (Model, GRB, addVar/addConstr, etc.)\n    - Make the script runnable as a standalone Python file if possible.\n    - Keep the code faithful to the example.\n"}, {"role": "assistant", "content": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# tested with Python 3.11 & Gurobi 11.0\n\n# List of NOR gates 1 to 7.\n\ngates = ['1','2','3','4','5','6','7']\n\n# List of NOR gates 4 to 7.\n\ngates47 = ['4','5','6','7']\n\n# List of rows of the truth-table in the range 1 to 4.\n\nrows = ['1','2','3','4']\n\n# Create a dictionary to capture the value of the external input A and B in the r row of the truth table, for each \n# NOR gate i.\n\ngatesRows, valueA, valueB = gp.multidict({\n    ('1','1'): [0,0],\n    ('1','2'): [0,1],\n    ('1','3'): [1,0],\n    ('1','4'): [1,1],\n    ('2','1'): [0,0],\n    ('2','2'): [0,1],\n    ('2','3'): [1,0],\n    ('2','4'): [1,1],\n    ('3','1'): [0,0],\n    ('3','2'): [0,1],\n    ('3','3'): [1,0],\n    ('3','4'): [1,1],\n    ('4','1'): [0,0],\n    ('4','2'): [0,1],\n    ('4','3'): [1,0],\n    ('4','4'): [1,1],\n    ('5','1'): [0,0],\n    ('5','2'): [0,1],\n    ('5','3'): [1,0],\n    ('5','4'): [1,1],\n    ('6','1'): [0,0],\n    ('6','2'): [0,1],\n    ('6','3'): [1,0],\n    ('6','4'): [1,1],\n    ('7','1'): [0,0],\n    ('7','2'): [0,1],\n    ('7','3'): [1,0],\n    ('7','4'): [1,1]\n})\n\nmodel = gp.Model('logicalDesign')\n\n# Decision variables to select NOR gate i.\nNOR = model.addVars(gates, vtype=GRB.BINARY, name=\"NORgate\" )\n\n# In order to avoid a trivial solution containing no NOR gates, it is necessary to impose a constraint \n# that selects NOR gate 1.\n\nNOR['1'].lb = 1\n\n# Variables to decide if external input A is an input to NOR gate i.\ninputA = model.addVars(gates, vtype=GRB.BINARY, name=\"inputA\")\n\n# Variables to decide if external input B is an input to NOR gate i.\ninputB = model.addVars(gates, vtype=GRB.BINARY, name=\"inputB\")\n\n# Output decision variables.\noutput = model.addVars(gatesRows, vtype=GRB.BINARY, name=\"output\")\n\n# For NOR gate 1, the output variables are fixed at the values specified in the truth table.\n\noutput['1','1'].ub = 0\noutput['1','2'].lb = 1\noutput['1','3'].lb = 1\noutput['1','4'].ub = 0\n\n# External inputs constraints\n\nexternalInputsA = model.addConstrs( ( NOR[i] >= inputA[i]  for i in gates), name='externalInputsA')\n\nexternalInputsB = model.addConstrs( ( NOR[i] >= inputB[i]  for i in gates), name='externalInputsB')\n\n# NOR gates constraints\n\nNORgate1 = model.addConstr(NOR['2'] + NOR['3'] + inputA['1'] + inputB['1'] <= 2, name='NORgate1')\n\nNORgate2 = model.addConstr(NOR['4'] + NOR['5'] + inputA['2'] + inputB['2'] <= 2, name='NORgate2')\n\nNORgate3 = model.addConstr(NOR['6'] + NOR['7'] + inputA['3'] + inputB['3'] <= 2, name='NORgate3')\n\n# Output signal constraint.\n\noutputSignals1_1 = model.addConstrs( (output['2',r] + output['1',r] <= 1 for r in rows), name='outputSignals1_1' )\n\noutputSignals1_2 = model.addConstrs( (output['3',r] + output['1',r] <= 1 for r in rows), name='outputSignals1_2' )\n\noutputSignals2_1 = model.addConstrs( (output['4',r] + output['2',r] <= 1 for r in rows), name='outputSignals2_1' )\n\noutputSignals2_2 = model.addConstrs( (output['5',r] + output['2',r] <= 1 for r in rows), name='outputSignals2_2' )\n\noutputSignals3_1 = model.addConstrs( (output['6',r] + output['3',r] <= 1 for r in rows), name='outputSignals3_1' )\n\noutputSignals3_2 = model.addConstrs( (output['7',r] + output['3',r] <= 1 for r in rows), name='outputSignals3_2' )\n\n\noutputSignals4 = model.addConstrs( (valueA[i,r]*inputA[i] + output[i,r] <= 1 for i,r in gatesRows), name='outputSignals4')\n\noutputSignals5 = model.addConstrs( (valueB[i,r]*inputB[i] + output[i,r] <= 1 for i,r in gatesRows), name='outputSignals5')\n\noutputSignals6 = model.addConstrs( (valueA[i,r]*inputA[i] + valueB[i,r]*inputB[i] + output[i,r] - NOR[i] >= 0 \n                                    for i,r in gatesRows if i in gates47), name='outputSignals6')\n\noutputSignals7 = model.addConstrs( (valueA['1',r]*inputA['1'] + valueB['1',r]*inputB['1'] \n                                    + output['2',r] + output['3',r] + output['1',r] - NOR['1'] >= 0\n                                    for i,r in gatesRows), name='outputSignals7')\n\noutputSignals8 = model.addConstrs( (valueA['2',r]*inputA['2'] + valueB['2',r]*inputB['2'] \n                                    + output['4',r] + output['5',r] + output['2',r] - NOR['2'] >= 0\n                                    for i,r in gatesRows), name='outputSignals8')\n\noutputSignals9 = model.addConstrs( (valueA['3',r]*inputA['3'] + valueB['3',r]*inputB['3'] \n                                    + output['6',r] + output['7',r] + output['3',r] - NOR['3'] >= 0\n                                    for i,r in gatesRows), name='outputSignals9')\n\n# Gate and output signals constraints\n\ngateOutput = model.addConstrs( (NOR[i] - output[i,r] >= 0 for i,r in gatesRows) , name='gateOutput')\n\n# Objective function.\n\nmodel.setObjective(NOR.sum(), GRB.MINIMIZE)\n\n# Verify model formulation\n\nmodel.write('logicalDesign.lp')\n\n# Run optimization engine\n\nmodel.optimize()\n\n# Output reports\n\nprint(\"\\n\\n_________________________________________________________________________________\")\nprint(f\"The optimal circuit design:\")\nprint(\"_________________________________________________________________________________\")\nfor i in gates:\n    if (NOR[i].x > 0.5):\n        if (inputA[i].x + inputB[i].x > 0.5):\n            print(f\"NOR gate {i} is active, with external inputs A and B values of {inputA[i].x} and  {inputB[i].x}.\")\n        else:\n            print(f\"NOR gate {i} is active.\")"}]}
{"meta": {"source_path": "/Users/sunyujun03/Desktop/ReLoop/gurobi-modeling-examples/music_recommendation/music_recommendation.ipynb", "kind": "ipynb", "title": "A Music Recommendation System With Mathematical Optimization"}, "messages": [{"role": "system", "content": "You are an optimization engineer. Write correct and runnable Python code using gurobipy (Gurobi Python API). Be concise. Output only what is requested."}, {"role": "user", "content": "    Task: Reproduce the following Gurobi modeling example in Python using gurobipy.\n\n    Scenario description (from source):\n    <div class=\"alert alert-block alert-danger\">\nNote: This notebook uses the python package lightfm which is not supported with Python 3.12!\nTo run this notebook, use Python 3.11.\n</div>\n\nCopyright © 2022 Gurobi Optimization, LLC\n\n# A Music Recommendation System With Mathematical Optimization \n\nA good song never gets old, except when it does. \nMusic streaming services like Spotify periodically provide their millions of users with curated music recommendations to keep them wanting to come back for more. It is important that these recommendations truly resonate with their users, while also introducing them to novelty that keeps their curiosity alive.\n\nIn this notebook, we will walk-through how to create a music recommendation system using a mixture of predictive and prescriptive analytics.\nThe predictive component foresees what users might be into based on their past music preferences, while the prescriptive component uses these predictions to  create an optimally diverse recommendation list.\n\n**Goal**: Recommend new artists to users such that the artists are likeable and diverse.\n\nThe datasets used in this notebook are pre-processed from two Kaggle datasets: \n- [Encrypted user data (Pichl, Zangerle and Specht, 2015)](https://www.kaggle.com/datasets/andrewmvd/spotify-playlists) with playlists created by [Spotify](https://open.spotify.com/) users, and \n- [Artist data](https://www.kaggle.com/datasets/pieca111/music-artists-popularity) with musician demographics collected from [Musicbrainz](https://musicbrainz.org/) and [Last.fm](last.fm).\n\nPichl, Martin; Zangerle, Eva; Specht, Günther: \"Towards a Context-Aware Music Recommendation Approach: What is Hidden in the Playlist Name?\" in 15th IEEE International Conference on Data Mining Workshops (ICDM 2015), pp. 1360-1365, IEEE, Atlantic City, 2015.\n\n## Load the data\n\nTo start, let's load the following packages for analyzing and visualizing the datasets.\n\nWe will first load the dataset with artist information. This dataset has 8,465 artists along with information on their  country of origin and the number of listeners they have on [Last.fm](https://www.last.fm/). Each artist is given an id from 0 through 8,465.\n\n    Requirements:\n    - Use gurobipy (Model, GRB, addVar/addConstr, etc.)\n    - Make the script runnable as a standalone Python file if possible.\n    - Keep the code faithful to the example.\n"}, {"role": "assistant", "content": "import numpy as np \nimport pandas as pd \nimport warnings \nwarnings.filterwarnings(\"ignore\")\nfrom matplotlib import pyplot as plt \nimport seaborn as sns\n\ndf_artist = pd.read_csv('https://raw.githubusercontent.com/Gurobi/modeling-examples/master/music_recommendation/artist_data.csv')\nprint(len(df_artist),\"artists\")\ndf_artist.head()\n\ndf_artist.set_index('artist')['listeners'].head(2000).plot(rot=40) \nplt.xlabel('Artist')\nplt.ylabel('Number of listeners (millions)') \nplt.show()\n\ndf_country = df_artist.groupby('country')['country'].count().sort_values(ascending = False).reset_index(name=\"count\")\ndf_country.set_index('country')['count'].plot(rot=40) #Select countries with at least 100 artists from there\nplt.xlabel('Country')\nplt.ylabel('Number of artists originating from the country') \nplt.show() \ndf_country\n\ndf_playlist = pd.read_csv('https://raw.githubusercontent.com/Gurobi/modeling-examples/master/music_recommendation/user_playlist_data.csv')\nprint(df_playlist['user_id'].nunique(),\"users\") \ndf_playlist.head(50)\n\nimport lightfm \nfrom lightfm import LightFM, cross_validation\nfrom lightfm.evaluation import auc_score\n\n# Dataframe that stores the frequency of artists as they appear in users' playlists\ndf_freq = df_playlist.groupby(['user_id', 'artist']).agg('size').reset_index().rename(columns={0:'freq'})[['user_id', 'artist', 'freq']].sort_values(['freq'], ascending=False)\ndf_freq = df_freq.merge(df_artist[['artist_id','artist']], left_on='artist', right_on='artist') \n\n# Input matrix \ninput_matrix = df_freq.groupby(['user_id', 'artist_id'])['freq'].sum().unstack().reset_index().fillna(0).set_index('user_id')\n\n# Dictionary to track the artist id for each artist name\nartists_dict ={(df_artist.loc[i,'artist_id']): df_artist.loc[i,'artist'] for i in range(df_artist.shape[0])} \ndf_freq.head()\n\n### Train-Test split\nfrom scipy import sparse\nx = sparse.csr_matrix(input_matrix.values)  \ntrain, test = lightfm.cross_validation.random_train_test_split(x, test_percentage=0.2, random_state=None)\n\n### Train the Matrix Factorization Model  \nmodel = LightFM(no_components=50, loss='warp')\nmodel.fit(x, epochs=30, num_threads = 4)\n \ntrain_auc = auc_score(model, train, num_threads=4).mean()  \ntest_auc = auc_score(model, test, train_interactions=train, num_threads=4).mean()\nprint('Train AUC: %f, test AUC: %f'%(train_auc,test_auc))\n\nfrom __future__ import print_function\nimport ipywidgets as widgets\nfrom ipywidgets import interact, interactive, fixed, interact_manual\n  \ndef get_user_preference(x):  \n    # Create a dictionary that stores the preference for each artist as a number between 0 and 1\n    global preference, df_pref\n    preference = pd.Series(model.predict(x, np.arange(input_matrix.shape[1]))).to_dict()\n    lower_score = min(preference.values())\n    highest_score = max(preference.values())\n    preference = {artists_dict[i]:(preference[i]-lower_score)/(highest_score-lower_score) for i in preference}  \n     \n    # Print the known likes of the user\n    known_items = list(pd.Series(input_matrix.loc[x,:][input_matrix.loc[x,:] > 0].index).sort_values(ascending=False))\n    known_items = list(pd.Series(known_items).apply(lambda x: artists_dict[x])) \n    print(\"Top 20 artists this user already likes:\\n\",known_items[:20]) \n     \n    # Print the predicted preference scores of the user\n    df_pref = pd.DataFrame.from_records([(k, v) for k, v in preference.items()], columns =['artist', 'preference']) \n    df_pref = df_artist.merge(df_pref,left_on='artist',right_on='artist').sort_values(by = 'preference',ascending=False)\n    print(\"\\nPredicted preferences:\") \n\nn_users = df_playlist['user_id'].nunique()\nprint(\"Select a user id from 0 through %i.\"%(n_users-1))\ninteract(get_user_preference, x=list(range(n_users)))\ndf_pref.head(30)\n\nprint(\"The top 30 artists have %i listeners on average.\"% int(df_pref[['listeners']].head(30).sum()/30))\n\nimport gurobipy as gp \nfrom gurobipy import GRB\n\nartists = sorted(preference.keys(),reverse=True,key=lambda x : preference[x])[:1000]  # Set of the most preferred 1000 artists\npopularity = df_artist.groupby('artist')['listeners'].apply(float).to_dict() # Popularity of each artist\nP_max = 500000\nN = 30\n\nm = gp.Model(\"Recommend artists\") # this defines the model that we'll add to as we finish the formulation\n\nx = {}\nfor a in artists:\n    x[a] = m.addVar(vtype=GRB.BINARY)  \n# x = m.addVars(artists,vtype=GRB.BINARY)\n\nm.setObjective(sum(x[a]*preference[a] for a in artists), GRB.MAXIMIZE)\nm.ModelSense = GRB.MAXIMIZE\n\npopularity_constraints = m.addConstr(sum(x[a]*popularity[a] for a in artists) <= P_max*N)\n\nn_artists_constraints = m.addConstr(sum(x[a] for a in artists) == N)\n\nm.optimize()\n\nchosen_artists = [a for a in artists if x[a].X > .99]  \ndict_artist_country = dict(zip(df_artist.artist, df_artist.country))\n\ndf_chosen_artists = pd.DataFrame({'artists':chosen_artists, 'popularity':[popularity[i] for i in chosen_artists], 'preference':[preference[i] for i in chosen_artists], 'country':[dict_artist_country[i] for i in chosen_artists]})\nprint(\"Artists chosen:\"%(chosen_artists))\ndf_chosen_artists\n\nartists_in_country = df_artist[df_artist['artist'].isin(artists)].groupby('country')['artist'].apply(list).to_dict() # the set of artists from each country\ncountries = artists_in_country.keys() # The set of all countries\nC_min = 20 # A number between 0 and N\n\ny = m.addVars(countries, vtype=GRB.BINARY)\n\ncountry_defining_constraints = m.addConstrs((y[c] <= sum(x[a] for a in artists_in_country[c])) for c in countries)\n\ncountry_limit_constraints = m.addConstr(sum(y[c] for c in artists_in_country) >= C_min) \nm.optimize()\n\nchosen_artists = [a for a in artists if x[a].X > .99]\nchosen_countries = [c for c in artists_in_country if y[c].x > 0.99]\nprint(\"%i artists in %i countries chosen.\"%(len(chosen_artists),len(chosen_countries)))\nprint(\"Represented countries:\",chosen_countries)\n\ndf_chosen_artists = pd.DataFrame({'artists':chosen_artists, 'popularity':[popularity[i] for i in chosen_artists], 'preference':[preference[i] for i in chosen_artists], 'country':[dict_artist_country[i] for i in chosen_artists]})\nsns.scatterplot(data=df_chosen_artists, x=\"preference\", y=\"popularity\", hue=\"country\", legend = False)\nplt.xlim(0, 1)\nplt.ylim(0, 500000)\nplt.show()\ndf_chosen_artists\n\ndef solve(x):\n    # Input parameters for artist selection\n    P_max = x # maximumum limit on the average popularity\n    N = 30 # number of chosen artists \n    C_min = 30 # minimum limit on the number of countries to be represented\n    \n    #Initiate the model \n    m = gp.Model(\"Playlisting\")  \n    \n    # Define the variables\n    x = m.addVars(artists,vtype=GRB.BINARY) \n    y = m.addVars(countries, vtype=GRB.BINARY) \n    \n    # Define the objective \n    m.setObjective(sum(x[a]*preference[a] for a in artists), GRB.MAXIMIZE)\n    m.ModelSense = GRB.MAXIMIZE\n    \n    # Add the constraitns \n    m.addConstr(sum(x[a]*popularity[a] for a in artists) <= P_max*N) # Sets a maximum limit on the average popularity\n    m.addConstr(sum(x[a] for a in artists) == N) # Selects exactly N artists \n      \n    m.addConstrs((y[c] <= sum(x[a] for a in artists_in_country[c])) for c in countries) # Selects a country only if an artist from that country is chosen\n    m.addConstr(sum(y[c] for c in artists_in_country) >= C_min) # Sets a minimum limit on the number of countries represented\n    \n    m.setParam('OutputFlag', 0) # Suppress the output\n    m.optimize() # Run the optimization of the model\n    \n    if m.status != 2:\n        print(\"\\n The problem is infeasible. There is no solution that satisfies all the constraints.\")\n        print(\"Try increasing the maximum popularity limit, or decreasing the minimum number of countries to be represented.\")\n        return\n \n    chosen_artists = [a for a in artists if x[a].X > .99] # Chosen set of artists \n    chosen_countries = [c for c in artists_in_country if y[c].x > 0.99] # Chosen set of countries \n    print(\"%i artists in %i countries chosen.\"%(len(chosen_artists),len(chosen_countries)))\n    print(\"Represented countries:\",chosen_countries)\n\n    # Create a dataframe for the visualization\n    df_chosen_artists = pd.DataFrame({'artists':chosen_artists, 'popularity':[popularity[i] for i in chosen_artists], 'preference':[preference[i] for i in chosen_artists], 'country':[dict_artist_country[i] for i in chosen_artists]})\n    sns.scatterplot(data=df_chosen_artists, x=\"preference\", y=\"popularity\", hue=\"country\", legend = False)\n    plt.xlim(0.6, 1)\n    plt.ylim(0, 5000000)\n    plt.show()\n    print(df_chosen_artists)\n     \nprint(\"Select a maximum limit on the average popularity:\\n\")\ninteract(solve, x=(200000,2000000,200000))"}]}
{"meta": {"source_path": "/Users/sunyujun03/Desktop/ReLoop/gurobi-modeling-examples/optimization201/Modeling_Session_2/completed_exercise_set2.ipynb", "kind": "ipynb", "title": "Exercise Set 2"}, "messages": [{"role": "system", "content": "You are an optimization engineer. Write correct and runnable Python code using gurobipy (Gurobi Python API). Be concise. Output only what is requested."}, {"role": "user", "content": "    Task: Reproduce the following Gurobi modeling example in Python using gurobipy.\n\n    Scenario description (from source):\n    # Exercise Set 2\n**Q1.** Re-write the **Charge/discharge:** constraints using indicator constraints. Remember to consider what happens when $z_{b,t} = 1$ and when $z_{b,t} = 0$\n\nDefine $z_{b,t} \\in \\{0,1\\}, t \\in T$.\n$$\n\\begin{align*}\nf^{in}_{b,t} &\\leq 20*z_{b,t} &\\forall b \\in B, t \\in T \\\\\nf^{out}_{b,t} &\\leq 20*(1-z_{b,t}) &\\forall b \\in B, t \\in T\n\\end{align*}\n$$\n\nThe multiple scenarios API is restricted. For example, it is not possible to explicitly\n- Add/remove variables or constraints\n- Change the variable types\n- Change the sense of constraints\n\nHowever, we can get around some of the restrictions using some tricks.\n\nAssume `ScenarioNumber` and `ScenNName` parameters are already set for each of the below.\n______\nTo remove a variable, set its bounds to zero.\n\n**Q2.** Write a `for` loop and `gurobipy` code to remove the flow in and flow out for `Battery0` in time periods 0 to 49.\n______\nTo add a variable to a scenario, add it to the base model with bounds set to zero and then change the bounds accordingly.\n\n**Q3.** Write `gurobipy` code to add a continuous variable $w_t, t\\in T$ to the base model `m` such that it's \"not in\" this model as described above. Then write a `for` loop to add it to a scenario with an *upper bound* of 100.\n______\n\nTo remove a constraint, change its RHS values to GRB.INFINITY/-GRB.INFINITY.\n\n**Q4.** We defined $v_{b,t} = 1$ when battery $b$ is below a depth of discharge α (say 0.3) and 0 otherwise. Supposed we had a hard constraint on the number of times both batteries together could go below their depth, with that limit to be 15. And say we stored (set the constraint equal to) this constraint as `depth_limit`.\n\n$$\n\\begin{equation}\n\\sum_{b,t} v_{b,t} \\le C\n\\end{equation}\n$$\n\nAdd a constraint to the base model `m` for the number of times either battery could go below its depth. Write the `gurobipy` code to remove this constraint.\n______\n\n    Requirements:\n    - Use gurobipy (Model, GRB, addVar/addConstr, etc.)\n    - Make the script runnable as a standalone Python file if possible.\n    - Keep the code faithful to the example.\n"}, {"role": "assistant", "content": "m.addConstrs((((z[b,t] == 0) >> (flow_in[b,t] == 0)) for b in batteries for t in time_periods), name = \"zis0\")\nm.addConstrs((((z[b,t] == 1) >> (flow_out[b,t] == 0)) for b in batteries for t in time_periods), name = \"zis1\")\n\n#Q2.\nfor t in range(50):\n  flow_in['Battery0',t].ScenNUB = 0\n  flow_out['Battery0',t].ScenNUB = 0\n\n#Q3.\nw = m.addVars(time_periods, lb = 0, ub = 0, name = 'w')\n#....\nfor t in time_periods:\n  w[t].ScenNUB = 100\n\n#Q4.\nv = m.addVars(time_periods, vtype=GRB.BINARY, name = 'v')\n# define a linear expression for total depth count\ntotal_depth_count = v.sum() # this is optional!\ndepth_limit = m.addConstr(total_depth_count <= 15, name = 'depth_limit')\n\n# remove the constraint by setting the RHS to infinity\ndepth_limit.ScenNRhs = GRB.INFINITY"}]}
{"meta": {"source_path": "/Users/sunyujun03/Desktop/ReLoop/gurobi-modeling-examples/optimization201/Modeling_Session_2/exercise_set2.ipynb", "kind": "ipynb", "title": "Exercise Set 2"}, "messages": [{"role": "system", "content": "You are an optimization engineer. Write correct and runnable Python code using gurobipy (Gurobi Python API). Be concise. Output only what is requested."}, {"role": "user", "content": "    Task: Reproduce the following Gurobi modeling example in Python using gurobipy.\n\n    Scenario description (from source):\n    # Exercise Set 2\n**Q1.** Re-write the **Charge/discharge:** constraints using indicator constraints. Remember to consider what happens when $z_{b,t} = 1$ and when $z_{b,t} = 0$\n\nDefine $z_t \\in \\{0,1\\}, t \\in T$.\n$$\n\\begin{align*}\nf^{in}_{b,t} &\\leq 20*z_{b,t} &\\forall b \\in B, t \\in T \\\\\nf^{out}_{b,t} &\\leq 20*(1-z_{b,t}) &\\forall b \\in B, t \\in T\n\\end{align*}\n$$\n\nThe multiple scenarios API is restricted. For example, it is not possible to explicitly\n- Add/remove variables or constraints\n- Change the variable types\n- Change the sense of constraints\n\nHowever, we can get around some of the restrictions using some tricks.\n\nAssume `ScenarioNumber` and `ScenNName` parameters are already set for each of the below.\n______\nTo remove a variable, set its bounds to zero.\n\n**Q2.** Write a `for` loop and `gurobipy` code to remove the flow in and flow out for `Battery0` in time periods 0 to 49.\n______\nTo add a variable to a scenario, add it to the base model with bounds set to zero and then change the bounds accordingly.\n\n**Q3.** Write `gurobipy` code to add a continuous variable $w_t, t\\in T$ to the base model `m` such that it's \"not in\" this model as described above. Then write a `for` loop to add it to a scenario with an *upper bound* of 100.\n______\n\nTo remove a constraint, change its RHS values to GRB.INFINITY/-GRB.INFINITY.\n\n**Q4.** We defined $v_{b,t} = 1$ when battery $b$ is below a depth of discharge α (say 0.3) and 0 otherwise. Supposed we had a hard constraint on the number of times both batteries together could go below their depth, with that limit to be 15. And say we stored (set the constraint equal to) this constraint as `depth_limit`.\n\n$$\n\\begin{equation}\n\\sum_{b,t} v_{b,t} \\le C\n\\end{equation}\n$$\n\nAdd a constraint to the base model `m` for the number of times either battery could go below its depth. Write the `gurobipy` code to remove this constraint.\n______\n\n    Requirements:\n    - Use gurobipy (Model, GRB, addVar/addConstr, etc.)\n    - Make the script runnable as a standalone Python file if possible.\n    - Keep the code faithful to the example.\n"}, {"role": "assistant", "content": "m.addConstrs((       ???????????         ), name = \"zis0\")\nm.addConstrs((       ???????????         ), name = \"zis1\")\n\n#Q2.\n\n\n\n#Q3.\n\n\n\n#Q4.\nv = m.addVars(time_periods, vtype=GRB.BINARY, name = 'v')"}]}
{"meta": {"source_path": "/Users/sunyujun03/Desktop/ReLoop/gurobi-modeling-examples/optimization201/Modeling_Session_2/completed_modeling2.ipynb", "kind": "ipynb", "title": "Intermediate Modeling - Part 2: Back for More Sun"}, "messages": [{"role": "system", "content": "You are an optimization engineer. Write correct and runnable Python code using gurobipy (Gurobi Python API). Be concise. Output only what is requested."}, {"role": "user", "content": "    Task: Reproduce the following Gurobi modeling example in Python using gurobipy.\n\n    Scenario description (from source):\n    # Intermediate Modeling - Part 2: Back for More Sun\nJust as we expanded on the first modeling example from Opti 101 for the first example of Opti 201, we'll do the same here. This example is motivated by [IEEE's Predict+Optimize Technical Challenge](https://ieee-dataport.org/competitions/ieee-cis-technical-challenge-predictoptimize-renewable-energy-scheduling) in 2021.\n\nIn this example we are trying to minimize the amount of electricity purchased from the grid to supply a building with electricity over a 6-day period while meeting predicted demand. The building is outfitted with solar panels and two batteries to store and provide energy when appropriate. Decisions made at each 30-minute interval are:\n1. Buy electricity from the grid\n2. Charge/discharge the one battery\n3. Charge/discharge the other battery\n\nThe output of the optimization model is a charge/discharge schedule for the batteries as well as the time periods where electricity will be purchased. The demand is forecasted using [Prophet](https://facebook.github.io/prophet/). The notebook for this part of the problem can be found [here](https://colab.research.google.com/github/Gurobi/modeling-examples/blob/master/optimization101/Modeling_Session_2/energy_storage_ML.ipynb) If you want to have the first notebook handy, you can find it [here](https://colab.research.google.com/github/Gurobi/modeling-examples/blob/master/optimization101/Modeling_Session_2/completed_modeling2.ipynb).\n\nThis model is a lot more complicated that the first from Opti 101, so we can copy the formulation and code in a concise way and highlight the parts relevant to the features discussed in the second modeling session video.\n\nIn subsequent sections we'll see how to adapt this model to incorporate\n- Multi-objective models,\n- Multi-scenario models, and\n- Solutions pools\n\n## Opti 101 Model\n\n### Formulation\n\n#### Sets and Input Parameters\n\nBatteries: $b \\in B = \\{\\texttt{Battery0, Battery1}\\}$\n\nTime periods: $t \\in T = \\{0,1,...,179\\}$ for the first Monday through Saturday of October, 2020\n\n$c_{b}$: capacity of battery $b \\in B \\quad\\quad \\texttt{capacity[b]}$\n\n$p_{b}$: loss of energy (as a percentage) during transfer into battery $b\\in B \\quad\\quad \\texttt{p}\\_\\texttt{loss[b]}$\n\n$q_{b}$: quantity of initial energy in battery $b \\in B \\quad\\quad \\texttt{initial[b]}$\n\n$solar_{t}$: solar power generation of the panel for time period $t \\in T \\quad\\quad \\texttt{solar}\\_\\texttt{values[b]}$\n\n$d_{t}$: total building and class energy demand for time period $t\\in T \\quad\\quad \\texttt{total}\\_\\texttt{deamnd[t]}$\n\n    Requirements:\n    - Use gurobipy (Model, GRB, addVar/addConstr, etc.)\n    - Make the script runnable as a standalone Python file if possible.\n    - Keep the code faithful to the example.\n"}, {"role": "assistant", "content": "# install/import packages\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# read in solar forecast data\npath = 'https://raw.githubusercontent.com/Gurobi/modeling-examples/master/optimization101/Modeling_Session_2/'\nsolar_values_read = pd.read_csv(path+'pred_solar_values.csv')\nsolar_values = round(solar_values_read.yhat,3)\nsolar_values.reset_index(drop = True, inplace = True)\n\n# read in demaind data, where total demand is a fixed building demand and\n# an estimated demand based on a proposed schedule for the building\nschedule = pd.read_csv(path+'schedule_demand.csv')\navg_building = pd.read_csv(path+'building_demand.csv')\ntotal_demand = schedule.sched_demand + avg_building.build_demand\nprint(f\"Total Solar Generation: {solar_values.sum()} \\nTotal Demand: {total_demand.sum()}\")\n\n# create data for batteries, including capity, efficency and initial charges\n# also define time periods,\nbatteries = [\"Battery0\", \"Battery1\"]\ncapacity = {\"Battery0\": 60, \"Battery1\": 80} # in Kw\np_loss = {\"Battery0\": 0.95, \"Battery1\": 0.9} # proportion\ninitial = {\"Battery0\": 0, \"Battery1\": 0} # in kW\ntime_periods = range(len(solar_values_read))\n\nm = gp.Model() #this defines the model that we'll add to as we finish the formulation\n\nflow_in = m.addVars(batteries, time_periods, name=\"flow_in\")\nflow_out = m.addVars(batteries, time_periods, name=\"flow_out\")\n\ngrid = m.addVars(time_periods, name=\"grid\")\nstate = m.addVars(batteries, time_periods, ub = [capacity[b] for b in batteries for t in time_periods], name=\"state\")\ngen = m.addVars(time_periods, name=\"gen\")\n\nzwitch = m.addVars(batteries, time_periods, vtype=GRB.BINARY, name=\"zwitch\")\n\n# Power balance\nm.addConstrs((gp.quicksum(flow_out[b,t] - p_loss[b]*flow_in[b,t] for b in batteries) + gen[t] + grid[t] == total_demand[t]\n                  for t in time_periods), name=\"power_balance\");\n# Battery state\nm.addConstrs((state[b,0] == initial[b] + p_loss[b]*flow_in[b,0] - flow_out[b,0] for b in batteries), name=\"initial_state\")\nm.addConstrs((state[b,t] == state[b,t-1] + p_loss[b]*flow_in[b,t] - flow_out[b,t] for b in batteries for t in time_periods if t >= 1), name=\"subsequent_states\");\n\n#Solar availability\nm.addConstrs((flow_in['Battery0',t] + flow_in['Battery1',t] + gen[t] <= solar_values[t] for t in time_periods), name = \"solar_avail\");\n\n#Charge/discharge\nm.addConstrs((flow_in[b,t] <= 20*zwitch[b,t] for b in batteries for t in time_periods), name = \"to_charge\")\nm.addConstrs((flow_out[b,t] <= 20*(1-zwitch[b,t]) for b in batteries for t in time_periods), name = \"or_not_to_charge\");\n\n# read in estimated price of electricity for each time period\navg_price = pd.read_csv(path+'expected_price.csv')\nprice = avg_price.price\n\n# define a linear expression for total energy purchased from the grid\ntotal_grid = grid.sum()\n# define a linear expression for total cost\ntotal_cost = gp.quicksum(avg_price.price[t]*grid[t] for t in time_periods)\n\n# set the objective to the original of min grid purchase\nm.setObjective(total_grid, GRB.MINIMIZE)\n\nm.optimize()\n\nresults = pd.DataFrame([[round(v,2) for v in [total_cost.getValue(),total_grid.getValue()]]],\n                       columns = ['Cost','GridAmount']\n                       )\n\nresults\n\nm.setObjective(total_cost, GRB.MINIMIZE)\nm.optimize()\n\nresults = pd.concat([results,\n                     pd.DataFrame([[round(v,2) for v in [total_cost.getValue(),total_grid.getValue()]]], columns = ['Cost','GridAmount'])\n                     ],\n                    ignore_index=True\n                    )\n\nresults\n#create a copy for later\nmp = m.copy()\n\nm.setObjectiveN(total_cost, index=0, weight = 1, name=\"cost\")\nm.setObjectiveN(total_grid, index=1, weight = 10, name= \"grid\")\n\nm.ModelSense = GRB.MINIMIZE\nm.optimize()\n\nresults = pd.concat([results,\n                     pd.DataFrame([[round(v,2) for v in [total_cost.getValue(),total_grid.getValue()]]], columns = ['Cost','GridAmount'])\n                    ],\n                    ignore_index=True\n                    )\n\nresults\n\n# Reminder that s_{b,t} is defined by state[b,t] in the code\nv = m.addVars(time_periods, vtype=GRB.BINARY, name = 'v')\n\n# define a linear expression for total depth count\ntotal_depth_count = v.sum()\n# remember to implement this constraint for battery 0 only\nm.addConstrs((((v[t] == 0) >> (state['Battery0',t] >= 0.3*capacity['Battery0'])) for b in batteries for t in time_periods), name = \"discharge_depth\")\nm.update()\n\n#the higher priority number is used first as an objective\nm.setObjectiveN(total_cost, index=0, priority=2, reltol = 0.05, name=\"cost\")\nm.setObjectiveN(total_depth_count, index=1,  priority=1, reltol = 0.2, name= \"depth\")\nm.setObjectiveN(total_grid, index=2, priority=0, name= \"grid\")\n\nm.optimize()\n\nfor o in range(m.NumObj):\n  # set which objective we will query\n  m.params.ObjNumber = o\n  # query the o-th objective value\n  print(' ',round(m.ObjNVal,2), end='')\n\nmm = gp.Model('mulit_scen') #this defines the model that we'll add to as we finish the formulation\nflow_in = mm.addVars(batteries, time_periods, name=\"flow_in\")\nflow_out = mm.addVars(batteries, time_periods, name=\"flow_out\")\ngrid = mm.addVars(time_periods, name=\"grid\")\nstate = mm.addVars(batteries, time_periods, ub = [capacity[b] for b in batteries for t in time_periods], name=\"state\")\ngen = mm.addVars(time_periods, name=\"gen\")\nzwitch = mm.addVars(batteries, time_periods, vtype=GRB.BINARY, name=\"zwitch\")\n\n# define a linear expression for total energy purchased from the grid\ntotal_grid = grid.sum()\n# define a linear expression for total cost\ntotal_cost = gp.quicksum(avg_price.price[t]*grid[t] for t in time_periods)\n\npower_balance = mm.addConstrs((gp.quicksum(flow_out[b,t] - p_loss[b]*flow_in[b,t] for b in batteries) + gen[t] + grid[t] == total_demand[t]\n                  for t in time_periods), name=\"power_balance\")\ninitial_state = mm.addConstrs((state[b,0] == initial[b] + p_loss[b]*flow_in[b,0] - flow_out[b,0] for b in batteries), name=\"initial_state\")\nsubsequent_states = mm.addConstrs((state[b,t] == state[b,t-1] + p_loss[b]*flow_in[b,t] - flow_out[b,t] for b in batteries for t in time_periods if t >= 1), name=\"subsequent_states\")\nsolar_avail = mm.addConstrs((flow_in['Battery0',t] + flow_in['Battery1',t] + gen[t] <= solar_values[t] for t in time_periods), name = \"solar_avail\")\nto_charge = mm.addConstrs((flow_in[b,t] <= 20*zwitch[b,t] for b in batteries for t in time_periods), name = \"to_charge\")\nor_not_to_charge = mm.addConstrs((flow_out[b,t] <= 20*(1-zwitch[b,t]) for b in batteries for t in time_periods), name = \"or_not_to_charge\")\n\nmm.setObjective(total_cost, GRB.MINIMIZE)\nmm.update()\n\nmm.NumScenarios=4\nmm.Params.ScenarioNumber = 0\nmm.ScenNName = 'Base model'\n\nprice2 = avg_price.price2\n# change obj\nmm.Params.ScenarioNumber = 1\nmm.ScenNName = 'Increased price'\nfor t in time_periods:\n  grid[t].ScenNObj = price2[t]\n\ncapacity2 = {'Battery0': 48, 'Battery1': 64}\n# change variable bound\nmm.Params.ScenarioNumber = 2\nmm.ScenNName = 'Low Battery'\nfor b in batteries:\n  for t in time_periods:\n    state[b,t].ScenNUB = capacity2[b]\n\nsolar_values2 = round(0.1*solar_values_read.yhat_lower +\n                      0.6*solar_values_read.yhat +\n                      0.3*solar_values_read.yhat_upper,3)\n# just in case any forecasted value is negative, set it to 0\nsolar_values2[solar_values2 < 0] = 0\n\n# change constraint RHS\nmm.Params.ScenarioNumber = 3\nmm.ScenNName = 'High Solar'\nfor t in time_periods:\n    solar_avail[t].ScenNRhs = solar_values2[t]\n\nmm.write('ms.lp')\nmm.optimize()\n\n#print obj value from each scenario\nfor s in range(mm.NumScenarios):\n    # Set the scenario number to query the information for this scenario\n    mm.Params.ScenarioNumber = s\n    print('\\nTotal cost for '+mm.ScenNName+' is '+'$'+str(round(mm.ScenNObjVal,2)))\n\n# Limit how many solutions to collect\nmp.setParam(GRB.Param.PoolSolutions, 250)\n# Limit the search space by setting a gap for the worst possible solution that will be accepted\nmp.setParam(GRB.Param.PoolGap, 0.05)\n# do a systematic search for the k-best solutions\nmp.setParam(GRB.Param.PoolSearchMode, 2)\n\nmp.optimize()\n\nflow_250 = pd.DataFrame()\nfor i in range(250):\n  mp.setParam(GRB.Param.SolutionNumber, i)\n  tmp = pd.DataFrame([[b, t, flow_in[b,t].Xn, flow_out[b,t].Xn, i] for b in batteries for t in time_periods], columns=['battery', 'time_period', 'out','in','Scen'])\n  flow_250 = pd.concat([flow_250, tmp], axis = 0, ignore_index=True)\nflow_250"}]}
{"meta": {"source_path": "/Users/sunyujun03/Desktop/ReLoop/gurobi-modeling-examples/optimization201/Modeling_Session_2/modeling2.ipynb", "kind": "ipynb", "title": "Intermediate Modeling - Part 2: Back for More Sun"}, "messages": [{"role": "system", "content": "You are an optimization engineer. Write correct and runnable Python code using gurobipy (Gurobi Python API). Be concise. Output only what is requested."}, {"role": "user", "content": "    Task: Reproduce the following Gurobi modeling example in Python using gurobipy.\n\n    Scenario description (from source):\n    # Intermediate Modeling - Part 2: Back for More Sun\nJust as we expanded on the first modeling example from Opti 101 for the first example of Opti 201, we'll do the same here. This example is motivated by [IEEE's Predict+Optimize Technical Challenge](https://ieee-dataport.org/competitions/ieee-cis-technical-challenge-predictoptimize-renewable-energy-scheduling) in 2021.\n\nIn this example we are trying to minimize the amount of electricity purchased from the grid to supply a building with electricity over a 6-day period while meeting predicted demand. The building is outfitted with solar panels and two batteries to store and provide energy when appropriate. Decisions made at each 30-minute interval are:\n1. Buy electricity from the grid\n2. Charge/discharge the one battery\n3. Charge/discharge the other battery\n\nThe output of the optimization model is a charge/discharge schedule for the batteries as well as the time periods where electricity will be purchased. The demand is forecasted using [Prophet](https://facebook.github.io/prophet/). The notebook for this part of the problem can be found [here](https://colab.research.google.com/github/Gurobi/modeling-examples/blob/master/optimization101/Modeling_Session_2/energy_storage_ML.ipynb) If you want to have the first notebook handy, you can find it [here](https://colab.research.google.com/github/Gurobi/modeling-examples/blob/master/optimization101/Modeling_Session_2/completed_modeling2.ipynb).\n\nThis model is a lot more complicated that the first from Opti 101, so we can copy the formulation and code in a concise way and highlight the parts relevant to the features discussed in the second modeling session video.\n\nIn subsequent sections we'll see how to adapt this model to incorporate\n- Multi-objective models,\n- Multi-scenario models, and\n- Solutions pools\n\n## Opti 101 Model\n\n### Formulation\n\n#### Sets and Input Parameters\n\nBatteries: $b \\in B = \\{\\texttt{Battery0, Battery1}\\}$\n\nTime periods: $t \\in T = \\{0,1,...,179\\}$ for the first Monday through Saturday of October, 2020\n\n$c_{b}$: capacity of battery $b \\in B \\quad\\quad \\texttt{capacity[b]}$\n\n$p_{b}$: loss of energy (as a percentage) during transfer into battery $b\\in B \\quad\\quad \\texttt{p}\\_\\texttt{loss[b]}$\n\n$q_{b}$: quantity of initial energy in battery $b \\in B \\quad\\quad \\texttt{initial[b]}$\n\n$solar_{t}$: solar power generation of the panel for time period $t \\in T \\quad\\quad \\texttt{solar}\\_\\texttt{values[b]}$\n\n$d_{t}$: total building and class energy demand for time period $t\\in T \\quad\\quad \\texttt{total}\\_\\texttt{deamnd[t]}$\n\n    Requirements:\n    - Use gurobipy (Model, GRB, addVar/addConstr, etc.)\n    - Make the script runnable as a standalone Python file if possible.\n    - Keep the code faithful to the example.\n"}, {"role": "assistant", "content": "# install/import packages\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# read in solar forecast data\npath = 'https://raw.githubusercontent.com/Gurobi/modeling-examples/master/optimization101/Modeling_Session_2/'\nsolar_values_read = pd.read_csv(path+'pred_solar_values.csv')\nsolar_values = round(solar_values_read.yhat,3)\nsolar_values.reset_index(drop = True, inplace = True)\n\n# read in demaind data, where total demand is a fixed building demand and\n# an estimated demand based on a proposed schedule for the building\nschedule = pd.read_csv(path+'schedule_demand.csv')\navg_building = pd.read_csv(path+'building_demand.csv')\ntotal_demand = schedule.sched_demand + avg_building.build_demand\nprint(f\"Total Solar Generation: {solar_values.sum()} \\nTotal Demand: {total_demand.sum()}\")\n\n# create data for batteries, including capity, efficency and initial charges\n# also define time periods,\nbatteries = [\"Battery0\", \"Battery1\"]\ncapacity = {\"Battery0\": 60, \"Battery1\": 80} # in Kw\np_loss = {\"Battery0\": 0.95, \"Battery1\": 0.9} # proportion\ninitial = {\"Battery0\": 0, \"Battery1\": 0} # in kW\ntime_periods = range(len(solar_values_read))\n\nm = gp.Model() #this defines the model that we'll add to as we finish the formulation\n\nflow_in = m.addVars(batteries, time_periods, name=\"flow_in\")\nflow_out = m.addVars(batteries, time_periods, name=\"flow_out\")\n\ngrid = m.addVars(time_periods, name=\"grid\")\nstate = m.addVars(batteries, time_periods, ub = [capacity[b] for b in batteries for t in time_periods], name=\"state\")\ngen = m.addVars(time_periods, name=\"gen\")\n\nzwitch = m.addVars(batteries, time_periods, vtype=GRB.BINARY, name=\"zwitch\")\n\n# Power balance\nm.addConstrs((gp.quicksum(flow_out[b,t] - p_loss[b]*flow_in[b,t] for b in batteries) + gen[t] + grid[t] == total_demand[t]\n                  for t in time_periods), name=\"power_balance\");\n# Battery state\nm.addConstrs((state[b,0] == initial[b] + p_loss[b]*flow_in[b,0] - flow_out[b,0] for b in batteries), name=\"initial_state\")\nm.addConstrs((state[b,t] == state[b,t-1] + p_loss[b]*flow_in[b,t] - flow_out[b,t] for b in batteries for t in time_periods if t >= 1), name=\"subsequent_states\");\n\n#Solar availability\nm.addConstrs((flow_in['Battery0',t] + flow_in['Battery1',t] + gen[t] <= solar_values[t] for t in time_periods), name = \"solar_avail\");\n\n#Charge/discharge\nm.addConstrs((flow_in[b,t] <= 20*zwitch[b,t] for b in batteries for t in time_periods), name = \"to_charge\")\nm.addConstrs((flow_out[b,t] <= 20*(1-zwitch[b,t]) for b in batteries for t in time_periods), name = \"or_not_to_charge\");\n\n# read in estimated price of electricity for each time period\navg_price = pd.read_csv(path+'expected_price.csv')\nprice = avg_price.price\n\n# define a linear expression for total energy purchased from the grid\ntotal_grid = grid.sum()\n# define a linear expression for total cost\ntotal_cost = gp.quicksum(avg_price.price[t]*grid[t] for t in time_periods)\n\n# set the objective to the original of min grid purchase\nm.setObjective(total_grid, GRB.MINIMIZE)\n\nm.optimize()\n\nresults = pd.DataFrame([[round(v,2) for v in [total_cost.getValue(),total_grid.getValue()]]],\n                       columns = ['Cost','GridAmount']\n                       )\n\nresults\n\nm.setObjective(total_cost, GRB.MINIMIZE)\nm.optimize()\n\nresults = pd.concat([results,\n                     pd.DataFrame([[round(v,2) for v in [total_cost.getValue(),total_grid.getValue()]]], columns = ['Cost','GridAmount'])\n                     ],\n                    ignore_index=True\n                    )\n\nresults\n#create a copy for later\nmp = m.copy()\n\nm.setObjectiveN(total_cost, index=0, weight = 1, name=\"cost\")\nm.setObjectiveN(total_grid, index=1, weight = 10, name= \"grid\")\n\nm.ModelSense = GRB.MINIMIZE\nm.optimize()\n\nresults = pd.concat([results,\n                     pd.DataFrame([[round(v,2) for v in [total_cost.getValue(),total_grid.getValue()]]], columns = ['Cost','GridAmount'])\n                    ],\n                    ignore_index=True\n                    )\n\nresults\n\n# Reminder that s_{b,t} is defined by state[b,t] in the code\nv = m.addVars(time_periods, vtype=GRB.BINARY, name = 'v')\n\n# define a linear expression for total depth count\ntotal_depth_count = v.sum()\n# remember to implement this constraint for battery 0 only\nm.addConstrs(((    ??????     >>    ??????     ) for t in time_periods), name = \"discharge_depth\")\nm.update()\n\n#the higher priority number is used first as an objective\nm.setObjectiveN(total_cost, index=0, priority=  ???  , reltol = 0.05, name=\"cost\")\nm.setObjectiveN(total_depth_count, index=1,  priority= ???, reltol = 0.2, name= \"depth\")\nm.setObjectiveN(total_grid, index=2, priority=  ???  , name= \"grid\")\n\nm.optimize()\n\nfor o in range(m.NumObj):\n  # set which objective we will query\n  m.params.ObjNumber = o\n  # query the o-th objective value\n  print(' ',round(m.ObjNVal,2), end='')\n\nmm = gp.Model('mulit_scen') #this defines the model that we'll add to as we finish the formulation\nflow_in = mm.addVars(batteries, time_periods, name=\"flow_in\")\nflow_out = mm.addVars(batteries, time_periods, name=\"flow_out\")\ngrid = mm.addVars(time_periods, name=\"grid\")\nstate = mm.addVars(batteries, time_periods, ub = [capacity[b] for b in batteries for t in time_periods], name=\"state\")\ngen = mm.addVars(time_periods, name=\"gen\")\nzwitch = mm.addVars(batteries, time_periods, vtype=GRB.BINARY, name=\"zwitch\")\n\n# define a linear expression for total energy purchased from the grid\ntotal_grid = grid.sum()\n# define a linear expression for total cost\ntotal_cost = gp.quicksum(avg_price.price[t]*grid[t] for t in time_periods)\n\npower_balance = mm.addConstrs((gp.quicksum(flow_out[b,t] - p_loss[b]*flow_in[b,t] for b in batteries) + gen[t] + grid[t] == total_demand[t]\n                  for t in time_periods), name=\"power_balance\")\ninitial_state = mm.addConstrs((state[b,0] == initial[b] + p_loss[b]*flow_in[b,0] - flow_out[b,0] for b in batteries), name=\"initial_state\")\nsubsequent_states = mm.addConstrs((state[b,t] == state[b,t-1] + p_loss[b]*flow_in[b,t] - flow_out[b,t] for b in batteries for t in time_periods if t >= 1), name=\"subsequent_states\")\nsolar_avail = mm.addConstrs((flow_in['Battery0',t] + flow_in['Battery1',t] + gen[t] <= solar_values[t] for t in time_periods), name = \"solar_avail\")\nto_charge = mm.addConstrs((flow_in[b,t] <= 20*zwitch[b,t] for b in batteries for t in time_periods), name = \"to_charge\")\nor_not_to_charge = mm.addConstrs((flow_out[b,t] <= 20*(1-zwitch[b,t]) for b in batteries for t in time_periods), name = \"or_not_to_charge\")\n\nmm.setObjective(total_cost, GRB.MINIMIZE)\nmm.update()\n\nmm.NumScenarios=4\nmm.Params.ScenarioNumber = 0\nmm.ScenNName = 'Base model'\n\nprice2 = avg_price.price2\n# change obj\nmm.Params.ScenarioNumber = 1\nmm.ScenNName = 'Increased price'\nfor t in time_periods:\n  grid[t].ScenNObj = price2[t]\n\ncapacity2 = {'Battery0': 48, 'Battery1': 64}\n# change variable bound\nmm.Params.ScenarioNumber = 2\nmm.ScenNName = 'Low Battery'\nfor b in batteries:\n  for t in time_periods:\n    state[b,t].ScenNUB = capacity2[b]\n\nsolar_values2 = round(0.1*solar_values_read.yhat_lower +\n                      0.6*solar_values_read.yhat +\n                      0.3*solar_values_read.yhat_upper,3)\n# just in case any forecasted value is negative, set it to 0\nsolar_values2[solar_values2 < 0] = 0\n\n# change constraint RHS\nmm.Params.ScenarioNumber = 3\nmm.ScenNName = 'High Solar'\nfor t in time_periods:\n    solar_avail[t].ScenNRhs = solar_values2[t]\n\nmm.write('ms.lp')\nmm.optimize()\n\n#print obj value from each scenario\nfor s in range(mm.NumScenarios):\n    # Set the scenario number to query the information for this scenario\n    mm.Params.ScenarioNumber = s\n    print('\\nTotal cost for '+mm.ScenNName+' is '+'$'+str(round(mm.ScenNObjVal,2)))\n\n# Limit how many solutions to collect\nmp.setParam(GRB.Param.PoolSolutions, 250)\n# Limit the search space by setting a gap for the worst possible solution that will be accepted\nmp.setParam(GRB.Param.PoolGap, 0.05)\n# do a systematic search for the k-best solutions\nmp.setParam(GRB.Param.PoolSearchMode, 2)\n\nmp.optimize()\n\nflow_250 = pd.DataFrame()\nfor i in range(250):\n  mp.setParam(GRB.Param.SolutionNumber, i)\n  tmp = pd.DataFrame([[b, t, flow_in[b,t].Xn, flow_out[b,t].Xn, i] for b in batteries for t in time_periods], columns=['battery', 'time_period', 'out','in','Scen'])\n  flow_250 = pd.concat([flow_250, tmp], axis = 0, ignore_index=True)\nflow_250"}]}
{"meta": {"source_path": "/Users/sunyujun03/Desktop/ReLoop/gurobi-modeling-examples/optimization201/technician_assignment/resource_assignment.ipynb", "kind": "ipynb", "title": "Resource Assignment: Optimizing Service Vehicle Allocation"}, "messages": [{"role": "system", "content": "You are an optimization engineer. Write correct and runnable Python code using gurobipy (Gurobi Python API). Be concise. Output only what is requested."}, {"role": "user", "content": "    Task: Reproduce the following Gurobi modeling example in Python using gurobipy.\n\n    Scenario description (from source):\n    # Resource Assignment: Optimizing Service Vehicle Allocation\n\n## Motivation\n\nPicture Uber Eats, DoorDash, or Grubhub, but also local mom-and-pop restaurants with their own delivery.   \nOr consider home service providers that have skilled workers like landscapers, plumbers, or electricians.  \nOr how about home healthcare providers that send licensed professionals like nurses to patients' homes.\n\nWhat do they all have in common?\n\nThey all involve delivering goods or services. In these businesses, customers place orders and receive a delivery window from the provider (like when Amazon tells you that your overnight package will arrive between 7 am and 10 am). For service-based businesses, like needing a technician to fix something, customers might also provide an availability window (like, \"Can you come tomorrow afternoon, between 1 pm and 4 pm?\").\n\nIn these diverse businesses, managing limited resources is the name of the game. Whether it's delivery vans, skilled workers, or even time itself, the challenge lies in allocating these limited resources optimally to achieve business goals.\n\n## Problem Description\n\nLet's delve into a specific scenario: You are consulting for a telecom company that dispatches technicians to perform various tasks for customers, ranging from equipment installations and setups to repairs. Each technician requires a service vehicle to travel to the job site. Here's what you're dealing with:\n\n- The company offers various services, and not all technicians can perform all of them, so matching the right technician to the right job is crucial.\n- Service times (also known as process times) can vary for different jobs.\n- Customers provide windows of availability, and each customer is assigned to at most one technician (due to resource constraints).\n- Technicians have their own working hours. Not all of them work an 8-hour shift, and the job can't surpass these hours (no overtime allowed).\n- Technicians leave the service centers, complete their assigned jobs, and return to the center.\n- There are a limited number of vans at the service centers, equipped with the necessary tools. These vans are in shorter supply compared to technicians, and each technician needs a van to reach customers.\n\nCurrently, basic rule-of-thumb approaches are used for scheduling customers one after another and assigning them to the technicians. Each technician is dispatched with a van as soon as their schedule is known. When a technician returns, the van is up for grabs.\n\nNow, let's explore how mathematical optimization can help with the allocation of these limited resources.\n\n## Solution Approach\n\nWe solve this problem in two steps:\n\n### 1. Technician Routing\nThis is a variation of the well-known vehicle routing problem (VRP) with time windows. The goal is to decide which technicians are assigned to which customers and in what sequence. This is modeled and solved in the [`technician_routing`](https://github.com/decision-spot/technician_assignment/blob/main/technician_routing.ipynb) notebook.\n\nThis model yields two outputs: \n- `routes` provides some information about each technician's feasible departure window from the service center and their total occupied time.\n- `orders` provides which customers (or orders) are assigned to which technicians and in what sequence (or in what order). A bit of fun with the file name!\n\n_Note:_ The `technician_routing` notebook is almost identical to Gurobi's [`technician_routing_scheduling`](https://colab.research.google.com/github/Gurobi/modeling-examples/blob/master/technician_routing_scheduling/technician_routing_scheduling.ipynb). Since an additional post processing step was required to export the results into csv files, and also some slight modifications in the constraints and objective functions needed to be made, a slightly different file name is used to differentiate between the two. \n\n### 2. Resource Allocation\nNow that we know which technicians serve which customers, we can assign them to the available vans. This is the focus of this notebook.\n\nHere, we optimize the allocation of limited resources, ensuring each technician has access to a van equipped with necessary tools to reach customers in time. We're looking at the big picture, reshuffling routes as needed, and making the most of our vans. If a technician can efficiently serve multiple customers, and a service van can be used multiple times per day, we're all in.\n\nLet's roll up our sleeves and optimize! 🚚🔧\n\n    Requirements:\n    - Use gurobipy (Model, GRB, addVar/addConstr, etc.)\n    - Make the script runnable as a standalone Python file if possible.\n    - Keep the code faithful to the example.\n"}, {"role": "assistant", "content": "import gurobipy as gp\nimport pandas as pd\nfrom gurobipy import GRB\n\nroutes = pd.read_csv('https://raw.githubusercontent.com/decision-spot/technician_assignment/main/routes.csv')\nroutes\n\nimport matplotlib.pyplot as plt\n\nfig, ax = plt.subplots(figsize=(10, 6))\nrow_height = 0.3\nrow_space = 0.2\n\nfor _, row in routes.iterrows():\n    route_id = row[\"Route ID\"]\n    earliest_start = row[\"Earliest Start Time\"]\n    earliest_end = row[\"Earliest End Time\"]\n    latest_start = row[\"Latest Start Time\"]\n    latest_end = row[\"Latest End Time\"]\n\n    # Plot the bars for earliest start to earliest end\n    ax.barh(route_id - row_space / 2 - row_height, earliest_end - earliest_start, \n            left=earliest_start, height=row_height, color=\"yellowgreen\")\n\n    # Plot the bars for latest start to latest end on a separate line\n    ax.barh(route_id + row_space / 2, latest_end - latest_start, \n            left=latest_start, height=row_height, color=\"lightcoral\")\n\n# Labels\nax.set_xlabel(\"Time\")\nax.set_ylabel(\"Route ID\")\nax.set_title(\"Routes Earliest and Latest Windows\")\nax.invert_yaxis()  # Invert the y-axis to have Route ID 1 at the top\n# Set y-ticks to ensure integer values\nax.set_yticks(range(1, len(routes) + 1))\n# Create a single legend entry \nearliest_legend = plt.Line2D([0], [0], color=\"yellowgreen\", lw=4, label=\"Earliest\")\nlatest_legend = plt.Line2D([0], [0], color=\"lightcoral\", lw=4, label=\"Latest\")\nax.legend(handles=[earliest_legend, latest_legend], loc=\"upper left\", bbox_to_anchor=(1, 1))\n\nplt.show()\n\norder_routes = pd.read_csv('https://raw.githubusercontent.com/decision-spot/technician_assignment/main/orders.csv')\norder_routes\n\nearliest_time = 0  # this is the reference for start time. Assume 7:00 AM is minute 0\nlatest_time = 600  # 10 hours later, 5:00 PM is minute 600\nresource_limit = 3  # number of available resources\n\norder_route_dict = dict(zip(order_routes['Customer Name'], order_routes['Route ID']))  # a(o,r)\nroutes_dict = routes.set_index('Route ID').to_dict(orient='index')  # this will help us in creating the constraints\nr_set = routes_dict.keys()  # R\nv_set = set(range(resource_limit))  # V\nrv_set = {(r, v) for r in r_set for v in range(resource_limit)}  # pair of (r,v) index\n\nmdl = gp.Model('resource_assignment')\n\n# Variables\nu = mdl.addVars(order_route_dict.keys(), vtype=GRB.BINARY, name='u')  # tracks whether order o is covered\nx = mdl.addVars(r_set, vtype=GRB.BINARY, name='x')  # tracks whether route r is used\ny = mdl.addVars(rv_set, vtype=GRB.BINARY, name='y')  # tracks whether route r is assigned to van v\nz = mdl.addVars(v_set, vtype=GRB.BINARY, name='z')  # tracks whether van v is used\ns = mdl.addVars(r_set, lb=earliest_time, ub=latest_time, vtype=GRB.CONTINUOUS, name='s')  # tracks start time of route r\ne = mdl.addVars(r_set, lb=earliest_time, ub=latest_time, vtype=GRB.CONTINUOUS, name='e')  # tracks end time of route r\n\n# Relation between x and u\n... # ???\n\n# Relation between y and x\n... # ???\n\n# LB relation between y and z\n... # ???\n\n# UB relation between y and z\n... # ???\n\n# Logical constraints for the route's start and end time\n... # ???\n\nrh_set = set((r1, r2) for r1 in r_set for r2 in r_set if r1 != r2)  # pair of (r,h) index\n\ndelta = mdl.addVars(rh_set, vtype=GRB.BINARY, name='d')\n\n# Relation between any pair of routes assigned to a van\n... # ???\n\nmdl.ModelSense = GRB.MINIMIZE\n# weight=1: minimize, -1: maximize\nmdl.setObjectiveN(u.sum(), index=0, priority=2, name='order_coverage', weight=-1)\nmdl.setObjectiveN(z.sum(), index=1, priority=1, name='resource_usage', weight=1)\n\nmdl.optimize()\n\nres_df = pd.DataFrame()\nstatus = mdl.status\nif status == GRB.OPTIMAL:\n    res_list = []\n    for k, val in y.items():\n        if val.x > 0.5:\n            rid, n = k  # route id, resource number\n            r = routes_dict[rid]\n            st = s[rid].x  # start time\n            rows = {'Resource Number': n, 'Route Number': rid, 'Start Time': st}\n            rows.update(r)\n            res_list.append(rows)\n    res_df = pd.DataFrame(res_list)\n    res_df = res_df.sort_values(by=['Resource Number', 'Start Time', 'Route Number'])\n    uncovered_orders = {o for o in order_route_dict if u[o].x < 0.5}\n    print(f'Number of uncovered orders:\\n {len(uncovered_orders)}')\nelif status in (GRB.INF_OR_UNBD, GRB.INFEASIBLE):\n    print('Model is either infeasible or unbounded.')\nelse:\n    print(f'Status is {status} which is unexpected.')\nres_df"}]}
{"meta": {"source_path": "/Users/sunyujun03/Desktop/ReLoop/gurobi-modeling-examples/optimization201/technician_assignment/resource_assignment_complete.ipynb", "kind": "ipynb", "title": "Resource Assignment: Optimizing Service Vehicle Allocation"}, "messages": [{"role": "system", "content": "You are an optimization engineer. Write correct and runnable Python code using gurobipy (Gurobi Python API). Be concise. Output only what is requested."}, {"role": "user", "content": "    Task: Reproduce the following Gurobi modeling example in Python using gurobipy.\n\n    Scenario description (from source):\n    # Resource Assignment: Optimizing Service Vehicle Allocation\n\n## Motivation\n\nPicture Uber Eats, DoorDash, or Grubhub, but also local mom-and-pop restaurants with their own delivery.   \nOr consider home service providers that have skilled workers like landscapers, plumbers, or electricians.  \nOr how about home healthcare providers that send licensed professionals like nurses to patients' homes.\n\nWhat do they all have in common?\n\nThey all involve delivering goods or services. In these businesses, customers place orders and receive a delivery window from the provider (like when Amazon tells you that your overnight package will arrive between 7 am and 10 am). For service-based businesses, like needing a technician to fix something, customers might also provide an availability window (like, \"Can you come tomorrow afternoon, between 1 pm and 4 pm?\").\n\nIn these diverse businesses, managing limited resources is the name of the game. Whether it's delivery vans, skilled workers, or even time itself, the challenge lies in allocating these limited resources optimally to achieve business goals.\n\n## Problem Description\n\nLet's delve into a specific scenario: You are consulting for a telecom company that dispatches technicians to perform various tasks for customers, ranging from equipment installations and setups to repairs. Each technician requires a service vehicle to travel to the job site. Here's what you're dealing with:\n\n- The company offers various services, and not all technicians can perform all of them, so matching the right technician to the right job is crucial.\n- Service times (also known as process times) can vary for different jobs.\n- Customers provide windows of availability, and each customer is assigned to at most one technician (due to resource constraints).\n- Technicians have their own working hours. Not all of them work an 8-hour shift, and the job can't surpass these hours (no overtime allowed).\n- Technicians leave the service centers, complete their assigned jobs, and return to the center.\n- There are a limited number of vans at the service centers, equipped with the necessary tools. These vans are in shorter supply compared to technicians, and each technician needs a van to reach customers.\n\nCurrently, basic rule-of-thumb approaches are used for scheduling customers one after another and assigning them to the technicians. Each technician is dispatched with a van as soon as their schedule is known. When a technician returns, the van is up for grabs.\n\nNow, let's explore how mathematical optimization can help with the allocation of these limited resources.\n\n## Solution Approach\n\nWe solve this problem in two steps:\n\n### 1. Technician Routing\nThis is a variation of the well-known vehicle routing problem (VRP) with time windows. The goal is to decide which technicians are assigned to which customers and in what sequence. This is modeled and solved in the [`technician_routing`](https://github.com/decision-spot/technician_assignment/blob/main/technician_routing.ipynb) notebook.\n\nThis model yields two outputs: \n- `routes` provides some information about each technician's feasible departure window from the service center and their total occupied time.\n- `orders` provides which customers (or orders) are assigned to which technicians and in what sequence (or in what order). A bit of fun with the file name!\n\n_Note:_ The `technician_routing` notebook is almost identical to Gurobi's [`technician_routing_scheduling`](https://colab.research.google.com/github/Gurobi/modeling-examples/blob/master/technician_routing_scheduling/technician_routing_scheduling.ipynb). Since an additional post processing step was required to export the results into csv files, and also some slight modifications in the constraints and objective functions needed to be made, a slightly different file name is used to differentiate between the two. \n\n### 2. Resource Allocation\nNow that we know which technicians serve which customers, we can assign them to the available vans. This is the focus of this notebook.\n\nHere, we optimize the allocation of limited resources, ensuring each technician has access to a van equipped with necessary tools to reach customers in time. We're looking at the big picture, reshuffling routes as needed, and making the most of our vans. If a technician can efficiently serve multiple customers, and a service van can be used multiple times per day, we're all in.\n\nLet's roll up our sleeves and optimize! 🚚🔧\n\n    Requirements:\n    - Use gurobipy (Model, GRB, addVar/addConstr, etc.)\n    - Make the script runnable as a standalone Python file if possible.\n    - Keep the code faithful to the example.\n"}, {"role": "assistant", "content": "import gurobipy as gp\nimport pandas as pd\nfrom gurobipy import GRB\n\nroutes = pd.read_csv('https://raw.githubusercontent.com/decision-spot/technician_assignment/main/routes.csv')\nroutes\n\nimport matplotlib.pyplot as plt\n\nfig, ax = plt.subplots(figsize=(10, 6))\nrow_height = 0.3\nrow_space = 0.2\n\nfor _, row in routes.iterrows():\n    route_id = row[\"Route ID\"]\n    earliest_start = row[\"Earliest Start Time\"]\n    earliest_end = row[\"Earliest End Time\"]\n    latest_start = row[\"Latest Start Time\"]\n    latest_end = row[\"Latest End Time\"]\n\n    # Plot the bars for earliest start to earliest end\n    ax.barh(route_id - row_space / 2 - row_height, earliest_end - earliest_start, \n            left=earliest_start, height=row_height, color=\"yellowgreen\")\n\n    # Plot the bars for latest start to latest end on a separate line\n    ax.barh(route_id + row_space / 2, latest_end - latest_start, \n            left=latest_start, height=row_height, color=\"lightcoral\")\n\n# Labels\nax.set_xlabel(\"Time\")\nax.set_ylabel(\"Route ID\")\nax.set_title(\"Routes Earliest and Latest Windows\")\nax.invert_yaxis()  # Invert the y-axis to have Route ID 1 at the top\n# Set y-ticks to ensure integer values\nax.set_yticks(range(1, len(routes) + 1))\n# Create a single legend entry \nearliest_legend = plt.Line2D([0], [0], color=\"yellowgreen\", lw=4, label=\"Earliest\")\nlatest_legend = plt.Line2D([0], [0], color=\"lightcoral\", lw=4, label=\"Latest\")\nax.legend(handles=[earliest_legend, latest_legend], loc=\"upper left\", bbox_to_anchor=(1, 1))\n\nplt.show()\n\norder_routes = pd.read_csv('https://raw.githubusercontent.com/decision-spot/technician_assignment/main/orders.csv')\norder_routes\n\nearliest_time = 0  # this is the reference for start time. Assume 7:00 AM is minute 0\nlatest_time = 600  # 10 hours later, 5:00 PM is minute 600\nresource_limit = 3  # number of available resources\n\norder_route_dict = dict(zip(order_routes['Customer Name'], order_routes['Route ID']))  # a(o,r)\nroutes_dict = routes.set_index('Route ID').to_dict(orient='index')  # this will help us in creating the constraints\nr_set = routes_dict.keys()  # R\nv_set = set(range(resource_limit))  # V\nrv_set = {(r, v) for r in r_set for v in range(resource_limit)}  # pair of (r,v) index\n\nmdl = gp.Model('resource_assignment')\n\n# Variables\nu = mdl.addVars(order_route_dict.keys(), vtype=GRB.BINARY, name='u')  # tracks whether order o is covered\nx = mdl.addVars(r_set, vtype=GRB.BINARY, name='x')  # tracks whether route r is used\ny = mdl.addVars(rv_set, vtype=GRB.BINARY, name='y')  # tracks whether route r is assigned to van v\nz = mdl.addVars(v_set, vtype=GRB.BINARY, name='z')  # tracks whether van v is used\ns = mdl.addVars(r_set, lb=earliest_time, ub=latest_time, vtype=GRB.CONTINUOUS, name='s')  # tracks start time of route r\ne = mdl.addVars(r_set, lb=earliest_time, ub=latest_time, vtype=GRB.CONTINUOUS, name='e')  # tracks end time of route r\n\n# Relation between x and u\nfor o, r in order_route_dict.items():\n    mdl.addConstr(x[r] == u[o], f'order_cov_{o}'); # add \";\" here to stop the cell to print the constraints\n\n# # More generalizable version for cases when an order can be in multiple routes\n# for o, routes in order_route_dict.items():  # in this case, order_route_dict has a signature of {order: list of routes}\n#     mdl.addConstr(gp.quicksum(x[r] for r in routes) == u[o], f'order_cov_{o}')\n\n# Relation between y and x\nmdl.addConstrs((y.sum(r, '*') == x[r] for r in routes_dict), 'route_cov');\n\n# LB relation between y and z\nmdl.addConstrs((y[r, v] <= z[v] for (r, v) in rv_set), 'lb_y_z')\n\n# UB relation between y and z\nmdl.addConstrs((y.sum('*', v) >= z[v] for v in v_set), 'ub_y_z');\n\n# LB of s\nmdl.addConstrs((s[r] >= routes_dict[r]['Earliest Start Time'] for r in r_set), 'lb_s')\n\n# UB of s\nmdl.addConstrs((s[r] <= routes_dict[r]['Latest Start Time']  for r in r_set), 'ub_s')\n\n# LB of e\nmdl.addConstrs((e[r] >= routes_dict[r]['Earliest End Time'] for r in r_set), 'lb_e')\n\n# UB of e\nmdl.addConstrs((e[r] <= routes_dict[r]['Latest End Time'] for r in r_set), 'ub_e')\n\n# relation between s and e\nmdl.addConstrs((s[r] + routes_dict[r]['Total Time'] == e[r]  for r in r_set), 'rel_s_e');\n\nrh_set = set((r1, r2) for r1 in r_set for r2 in r_set if r1 != r2)  # pair of (r,h) index\n\ndelta = mdl.addVars(rh_set, vtype=GRB.BINARY, name='d')\n\n# Relation between any pair of routes assigned to a van\nbig_m = latest_time\nfor (r, h) in rh_set:\n    if r < h:\n        mdl.addConstr(s[h] >= e[r] - big_m * (1 - delta[r, h]), f'rbh_{r}_{h}')  # r before h\n        mdl.addConstr(s[r] >= e[h] - big_m * (1 - delta[h, r]), f'hbr_{r}_{h}')  # h before r\n        \n        for v in v_set:\n            mdl.addConstr(y[r, v] + y[h, v] - 1 <= delta[r, h] + delta[h, r], f'rel_d_y_{r}_{h}_{v}')\n\nfor (r, h) in rh_set:\n    if r < h:\n        mdl.addConstr((delta[r,h] == 1) >> (s[h] >= e[r]), f'rbh_{r}_{h}')  # r before h\n        mdl.addConstr((delta[h,r] == 1) >> (s[r] >= e[h]), f'hbr_{r}_{h}')  # h before r\n        # only repeating the constraint below, in case you want to try the model by running this cell instead of the one above\n        for v in v_set:\n            mdl.addConstr(y[r, v] + y[h, v] - 1 <= delta[r, h] + delta[h, r], f'rel_d_y_{r}_{h}_{v}')\n\nmdl.ModelSense = GRB.MINIMIZE\n# weight=1: minimize, -1: maximize\nmdl.setObjectiveN(u.sum(), index=0, priority=2, name='order_coverage', weight=-1)\nmdl.setObjectiveN(z.sum(), index=1, priority=1, name='resource_usage', weight=1)\n\n# mdl.write('ra.lp')\nmdl.optimize()\n\nres_df = pd.DataFrame()\nstatus = mdl.status\nif status == GRB.OPTIMAL:\n    res_list = []\n    for k, val in y.items():\n        if val.x > 0.5:\n            rid, n = k  # route id, resource number\n            r = routes_dict[rid]\n            st = s[rid].x  # start time\n            rows = {'Resource Number': n, 'Route Number': rid, 'Start Time': st}\n            rows.update(r)\n            res_list.append(rows)\n    res_df = pd.DataFrame(res_list)\n    res_df = res_df.sort_values(by=['Resource Number', 'Start Time', 'Route Number'])\n    uncovered_orders = {o for o in order_route_dict if u[o].x < 0.5}\n    print(f'Uncovered orders: {uncovered_orders}') if uncovered_orders else print('All Covered!')\nelif status in (GRB.INF_OR_UNBD, GRB.INFEASIBLE):\n    print('Model is either infeasible or unbounded.')\nelse:\n    print(f'Status is {status} which is unexpected.')\nres_df\n\ndef resource_assignment(routes, order_routes, resource_limit):\n    order_route_dict = dict(zip(order_routes['Customer Name'], order_routes['Route ID']))  # a(o,r)\n    routes_dict = routes.set_index('Route ID').to_dict(orient='index')  # this will help us in creating the constraints\n    r_set = routes_dict.keys()  # R\n    v_set = set(range(resource_limit))  # V\n    rv_set = {(r, v) for r in r_set for v in range(resource_limit)}  # pair of (r,v) index\n    rh_set = set((r1, r2) for r1 in r_set for r2 in r_set if r1 != r2)  # pair of (r,h) index\n\n    mdl = gp.Model('resource_assignment')\n\n    # Variables\n    u = mdl.addVars(order_route_dict.keys(), vtype=GRB.BINARY, name='u')\n    x = mdl.addVars(routes_dict.keys(), vtype=GRB.BINARY, name='x')\n    y = mdl.addVars(rv_set, vtype=GRB.BINARY, name='y')\n    z = mdl.addVars(v_set, vtype=GRB.BINARY, name='z')\n    s = mdl.addVars(r_set, lb=earliest_time, ub=latest_time, vtype=GRB.CONTINUOUS, name='s')\n    e = mdl.addVars(r_set, lb=earliest_time, ub=latest_time, vtype=GRB.CONTINUOUS, name='e')\n    delta = mdl.addVars(rh_set, vtype=GRB.BINARY, name='d')\n    \n    # Constraints\n    # Relation between x and u\n    for o, r in order_route_dict.items():\n        mdl.addConstr(x[r] == u[o], f'order_cov_{o}')\n        \n    # Relation between y and x\n    mdl.addConstrs((y.sum(r, '*') == x[r] for r in routes_dict), 'route_cov')\n    \n    # LB relation between y and z\n    mdl.addConstrs((y[r, v] <= z[v] for (r, v) in rv_set), 'lb_y_z')\n\n    # UB relation between y and z\n    mdl.addConstrs((y.sum('*', v) >= z[v] for v in v_set), 'ub_y_z')\n    \n    # LB of s\n    mdl.addConstrs((s[r] >= routes_dict[r]['Earliest Start Time'] for r in r_set), 'lb_s')\n\n    # UB of s\n    mdl.addConstrs((s[r] <= routes_dict[r]['Latest Start Time']  for r in r_set), 'ub_s')\n\n    # LB of e\n    mdl.addConstrs((e[r] >= routes_dict[r]['Earliest End Time'] for r in r_set), 'lb_e')\n\n    # UB of e\n    mdl.addConstrs((e[r] <= routes_dict[r]['Latest End Time'] for r in r_set), 'ub_e')\n\n    # relation between s and e\n    mdl.addConstrs((s[r] + routes_dict[r]['Total Time'] == e[r]  for r in r_set), 'rel_s_e')\n    \n    # Relation between any pair of routes assigned to a van\n    for (r, h) in rh_set:\n        if r < h:\n            mdl.addConstr((delta[r,h] == 1) >> (s[h] >= e[r]), f'rbh_{r}_{h}')  # r before h\n            mdl.addConstr((delta[h,r] == 1) >> (s[r] >= e[h]), f'hbr_{r}_{h}')  # h before r\n            for v in v_set:\n                mdl.addConstr(y[r, v] + y[h, v] - 1 <= delta[r, h] + delta[h, r], f'rel_d_y_{r}_{h}_{v}')\n\n    # Objectives\n    mdl.ModelSense = GRB.MINIMIZE\n    # weight=1: minimize, -1: maximize\n    mdl.setObjectiveN(u.sum(), index=0, priority=2, name='order_coverage', weight=-1)\n    mdl.setObjectiveN(z.sum(), index=1, priority=1, name='resource_usage', weight=1)\n    mdl.setParam(GRB.Param.OutputFlag, 0)  # disable printing the logs\n    mdl.optimize()\n\n    # create output\n    res_df = pd.DataFrame()\n    status = mdl.status\n    if status == GRB.OPTIMAL:\n        res_list = []\n        for k, val in y.items():\n            if val.x > 0.5:\n                rid, n = k  # route id, resource number\n                r = routes_dict[rid]\n                st = s[rid].x  # start time\n                rows = {'Resource Number': n, 'Route Number': rid, 'Start Time': st}\n                rows.update(r)\n                res_list.append(rows)\n        res_df = pd.DataFrame(res_list)\n        res_df = res_df.sort_values(by=['Resource Number', 'Start Time', 'Route Number'])\n        uncovered_orders = {o for o in order_route_dict if u[o].x < 0.5}\n        print(f'Uncovered orders: {uncovered_orders}') if uncovered_orders else print('All Covered!')\n    elif status in (GRB.INF_OR_UNBD, GRB.INFEASIBLE):\n        print('Model is either infeasible or unbounded.')\n    else:\n        print(f'Status is {status} which is unexpected.')\n    return res_df\n\n# run the model with different resource limits\nall_outputs = []\nfor limit in range(1,5):\n    print(f'**************\\nRunning the model with {limit} vans\\n**************')\n    res = resource_assignment(routes, order_routes, limit)\n    res['Resource Limit'] = limit\n    all_outputs.append(res)\noutput_df = pd.concat(all_outputs)\noutput_df = output_df[[\"Resource Limit\"] + [col for col in output_df.columns if col != \"Resource Limit\"]]\n\noutput_df"}]}
{"meta": {"source_path": "/Users/sunyujun03/Desktop/ReLoop/gurobi-modeling-examples/optimization201/technician_assignment/technician_routing.ipynb", "kind": "ipynb", "title": "Technician Routing and Scheduling Problem"}, "messages": [{"role": "system", "content": "You are an optimization engineer. Write correct and runnable Python code using gurobipy (Gurobi Python API). Be concise. Output only what is requested."}, {"role": "user", "content": "    Task: Reproduce the following Gurobi modeling example in Python using gurobipy.\n\n    Scenario description (from source):\n    # Technician Routing and Scheduling Problem\n\n**Note**:\n\nThis notebook, originally created for opti201 optimization training, is almost identical to Gurobi's [`technician_routing_scheduling`](\nhttps://colab.research.google.com/github/Gurobi/modeling-examples/blob/master/technician_routing_scheduling/technician_routing_scheduling.ipynb).\nSince an additional post processing step was required to export the results into csv files, and also some slight modifications in the constraints and objective functions needed to be made, a slightly different file name is used to differentiate between the two.\n\nTo stay true to the original notebook, the changes are only made were absolutely necessary.\n\n## Objective and Prerequisites\n\nTry this modeling example to discover how mathematical optimization can help telecommunications firms automate and improve their technician assignment, scheduling, and routing decisions in order to ensure the highest levels of customer satisfaction.\n\nThis modeling example is at the intermediate level, where we assume that you know Python and are familiar with the Gurobi Python API. In addition, you have some knowledge about building mathematical optimization models. To fully understand the content of this notebook, you should be familiar with object-oriented-programming.\n\n**Download the Repository** <br /> \nYou can download the repository containing this and other examples by clicking [here](https://github.com/Gurobi/modeling-examples/archive/master.zip). \n\n**Gurobi License** <br /> \nIn order to run this Jupyter Notebook properly, you must have a Gurobi license. If you do not have one, you can request an [evaluation license](https://www.gurobi.com/downloads/request-an-evaluation-license/?utm_source=3PW&utm_medium=OT&utm_campaign=WW-MU-TRA-OR-O_LEA-PR_NO-Q3_FY20_WW_JPME_technician-routing-sche-problem_COM_EVAL_GITHUB_&utm_term=technician-routing-scheduling-problem&utm_content=C_JPM) as a *commercial user*, or download a [free license](https://www.gurobi.com/academia/academic-program-and-licenses/?utm_source=3PW&utm_medium=OT&utm_campaign=WW-MU-TRA-OR-O_LEA-PR_NO-Q3_FY20_WW_JPME_technician-routing-sch-problem_ACADEMIC_EVAL_GITHUB_&utm_term=technician-routing-scheduling-problem&utm_content=C_JPM) as an *academic user*.\n\n## Motivation\nThe Technician Routing and Scheduling (TRS) is a common problem faced by telecommunication firms, which must be able to provide services for a large number of customers. With its limited resources, these firms must try to deliver timely, affordable and reliable services to maximize customer satisfaction. The TRS problem involves assignment, scheduling, and routing of multi-skilled technicians to serve customers with unique priorities, service time windows, processing times, skills requirements, and geographical locations. \nIn the current practice, these decisions are often being made by operators via heuristics, sometimes manually -and this method\ncan not only be time-consuming, \nbut may also deviate from optima significantly. \nUsing mathematical optimization to solve the\nTRS problem  will\nenable \ntelecom operators and dispatchers to automate and improve their assignment, scheduling, and routing decisions, while achieving high customer satisfaction.\n\n    Requirements:\n    - Use gurobipy (Model, GRB, addVar/addConstr, etc.)\n    - Make the script runnable as a standalone Python file if possible.\n    - Keep the code faithful to the example.\n"}, {"role": "assistant", "content": "import sys\nimport gurobipy as gp\nfrom gurobipy import GRB\nimport pandas as pd\n\n# tested with Gurobi v10.0.3\n\nclass Technician():\n    def __init__(self, name, cap, depot):\n        self.name = name\n        self.cap = cap\n        self.depot = depot\n\n    def __str__(self):\n        return f\"Technician: {self.name}\\n  Capacity: {self.cap}\\n  Depot: {self.depot}\"\n\nclass Job():\n    def __init__(self, name, priority, duration, coveredBy):\n        self.name = name\n        self.priority = priority\n        self.duration = duration\n        self.coveredBy = coveredBy\n\n    def __str__(self):\n        about = f\"Job: {self.name}\\n  Priority: {self.priority}\\n  Duration: {self.duration}\\n  Covered by: \"\n        about += \", \".join([t.name for t in self.coveredBy])\n        return about\n\nclass Customer():\n    def __init__(self, name, loc, job, tStart, tEnd, tDue):\n        self.name = name\n        self.loc = loc\n        self.job = job\n        self.tStart = tStart\n        self.tEnd = tEnd\n        self.tDue = tDue\n\n    def __str__(self):\n        coveredBy = \", \".join([t.name for t in self.job.coveredBy])\n        return f\"Customer: {self.name}\\n  Location: {self.loc}\\n  Job: {self.job.name}\\n  Priority: {self.job.priority}\\n  Duration: {self.job.duration}\\n  Covered by: {coveredBy}\\n  Start time: {self.tStart}\\n  End time: {self.tEnd}\\n  Due time: {self.tDue}\"\n\n# Read Excel workbook\nexcel_file = 'https://raw.githubusercontent.com/decision-spot/technician_assignment/main/data-Sce0.xlsx'\ndf = pd.read_excel(excel_file, sheet_name='Technicians')\ndf = df.rename(columns={df.columns[0]: \"name\", df.columns[1]: \"cap\", df.columns[2]: \"depot\"})\n\ndf1 = df.drop(df.columns[3:], axis=1).drop(df.index[[0,1]])\n# Create Technician objects\ntechnicians = [Technician(*row) for row in df1.itertuples(index=False, name=None)]\n# print(df1)\n\n# Read job data\njobs=[]\nfor j in range(3, len(df.columns)):\n    coveredBy = [t for i, t in enumerate(technicians) if df.iloc[2+i,j]==1]\n    thisJob = Job(df.iloc[2:,j].name, df.iloc[0,j], df.iloc[1,j], coveredBy)\n    jobs.append(thisJob)\n\n# Read location data\ndf_locations = pd.read_excel(excel_file, sheet_name='Locations', index_col=0) #, skiprows=1, index_col=0)\n\n# Extract locations and initialize distance dictionary\nlocations = df_locations.index\ndist = {(l, l): 0 for l in locations}\n\n# Populate distance dictionary\nfor i, l1 in enumerate(locations):\n    for j, l2 in enumerate(locations):\n        if i < j:\n            dist[l1, l2] = df_locations.iloc[i, j]\n            dist[l2, l1] = dist[l1, l2]\n\n# Read customer data\ndf_customers = pd.read_excel(excel_file, sheet_name='Customers')\n\ncustomers = []\nfor i, c in enumerate(df_customers.iloc[:, 0]):\n    job_name = df_customers.iloc[i, 2]\n\n    # Find the corresponding Job object\n    matching_job = next((job for job in jobs if job.name == job_name), None)\n\n    if matching_job is not None:\n        # Create Customer object using corresponding Job object\n        this_customer = Customer(c, df_customers.iloc[i, 1], matching_job, *df_customers.iloc[i, 3:])\n        customers.append(this_customer)\n\ndef get_latest_times(customers, technician):\n    latest = dict()\n    d = dist[customers[-1].loc, technician.depot]   # distance back to the depot\n    prev_latest = min(customers[-1].tEnd, 600 - d - customers[-1].job.duration)\n    latest[customers[-1].loc] = prev_latest\n    for i in range(len(customers) - 2, -1, -1):\n        d = dist[customers[i].loc, customers[i + 1].loc]\n        latest_end = min(prev_latest - d - customers[i].job.duration, customers[i].tEnd)\n        latest[customers[i].loc] = latest_end\n        prev_latest = latest_end\n    return latest\n\ndef solve_trs0(technicians, customers, dist):\n    # Build useful data structures\n    K = [k.name for k in technicians]\n    C = [j.name for j in customers]\n    J = [j.loc for j in customers]\n    L = list(set([l[0] for l in dist.keys()]))\n    D = list(set([t.depot for t in technicians]))\n    cap = {k.name: k.cap for k in technicians}\n    loc = {j.name: j.loc for j in customers}\n    depot = {k.name: k.depot for k in technicians}\n    canCover = {j.name: [k.name for k in j.job.coveredBy] for j in customers}\n    dur = {j.name: j.job.duration for j in customers}\n    tStart = {j.name: j.tStart for j in customers}\n    tEnd = {j.name: j.tEnd for j in customers}\n    priority = {j.name: j.job.priority for j in customers}\n\n    ### Create model\n    m = gp.Model(\"trs0\")\n\n    ### Decision variables\n    # Customer-technician assignment\n    x = m.addVars(C, K, vtype=GRB.BINARY, name=\"x\")\n\n    # Technician assignment\n    u = m.addVars(K, vtype=GRB.BINARY, name=\"u\")\n\n    # Edge-route assignment to technician\n    y = m.addVars(L, L, K, vtype=GRB.BINARY, name=\"y\")\n\n    # Technician cannot leave or return to a depot that is not its base\n    for k in technicians:\n        for d in D:\n            if k.depot != d:\n                for i in L:\n                    y[i, d, k.name].ub = 0\n                    y[d, i, k.name].ub = 0\n\n    # Start time of service\n    t = m.addVars(L, ub=600, name=\"t\")\n\n    # Unfilled jobs\n    g = m.addVars(C, vtype=GRB.BINARY, name=\"g\")\n\n    ### Constraints\n\n    # A technician must be assigned to a job, or a gap is declared (1)\n    m.addConstrs((gp.quicksum(x[j, k] for k in canCover[j]) + g[j] == 1 for j in C), name=\"assignToJob\")\n\n    # At most one technician can be assigned to a job (2)\n    m.addConstrs((x.sum(j, '*') <= 1 for j in C), name=\"assignOne\")\n\n    # Technician capacity constraints (3)\n    capLHS = {k: gp.quicksum(dur[j] * x[j, k] for j in C) + \\\n                 gp.quicksum(dist[i, j] * y[i, j, k] for i in L for j in L) for k in K}\n    m.addConstrs((capLHS[k] <= cap[k] * u[k] for k in K), name=\"techCapacity\")\n\n    # Technician tour constraints (4 and 5)\n    m.addConstrs((y.sum('*', loc[j], k) == x[j, k] for k in K for j in C), \\\n                 name=\"techTour1\")\n    m.addConstrs((y.sum(loc[j], '*', k) == x[j, k] for k in K for j in C), \\\n                 name=\"techTour2\")\n\n    # Same depot constraints (6 and 7)\n    m.addConstrs((gp.quicksum(y[j, depot[k], k] for j in J) == u[k] for k in K), \\\n                 name=\"sameDepot1\")\n    m.addConstrs((gp.quicksum(y[depot[k], j, k] for j in J) == u[k] for k in K), \\\n                 name=\"sameDepot2\")\n\n    # Temporal constraints (8) for customer locations\n    M = {(i, j): 600 + dur[i] + dist[loc[i], loc[j]] for i in C for j in C}\n    m.addConstrs((t[loc[j]] >= t[loc[i]] + dur[i] + dist[loc[i], loc[j]] \\\n                  - M[i, j] * (1 - gp.quicksum(y[loc[i], loc[j], k] for k in K)) \\\n                  for i in C for j in C), name=\"tempoCustomer\")\n\n    # Temporal constraints (8) for depot locations\n    M = {(i, j): 600 + dist[i, loc[j]] for i in D for j in C}\n    m.addConstrs((t[loc[j]] >= t[i] + dist[i, loc[j]] \\\n                  - M[i, j] * (1 - y.sum(i, loc[j], '*')) for i in D for j in C), \\\n                 name=\"tempoDepot\")\n\n    # Time window constraints (9 and 10)\n    m.addConstrs((t[loc[j]] >= tStart[j] for j in C), name=\"timeWinA\")\n    m.addConstrs((t[loc[j]] <= tEnd[j] for j in C), name=\"timeWinB\")\n\n    ### Objective function\n    M = 6100\n\n    m.setObjective(gp.quicksum(M * priority[j] * g[j] for j in C) + gp.quicksum(0.01 * M * t[k] for k in L),\n                   GRB.MINIMIZE)\n\n    m.write(\"TRS0.lp\")\n    m.optimize()\n\n    status = m.Status\n    if status in [GRB.INF_OR_UNBD, GRB.INFEASIBLE, GRB.UNBOUNDED]:\n        print(\"Model is either infeasible or unbounded.\")\n        sys.exit(0)\n    elif status != GRB.OPTIMAL:\n        print(\"Optimization terminated with status {}\".format(status))\n        sys.exit(0)\n\n    ### Print results\n    # Assignments\n    print(\"\")\n    for j in customers:\n        if g[j.name].X > 0.5:\n            jobStr = \"Nobody assigned to {} ({}) in {}\".format(j.name,j.job.name,j.loc)\n        else:\n            for k in K:\n                if x[j.name, k].X > 0.5:\n                    jobStr = f\"{k} assigned to {j.name} ({j.job.name}) in {j.loc}. Start at t={t[j.loc].X:.2f}.\"\n        print(jobStr)\n\n    # Technicians\n    print(\"\")\n    for k in technicians:\n        if u[k.name].X > 0.5:\n            cur = k.depot\n            route = k.depot\n            while True:\n                for j in customers:\n                    if y[cur,j.loc,k.name].X > 0.5:\n                        route += (f\" -> {j.loc} (dist={dist[cur, j.loc]}, t={t[j.loc].X:.2f},\"\n                                  f\" proc={j.job.duration}, a={tStart[j.name]}, b={tEnd[j.name]})\")\n                        cur = j.loc\n                for i in D:\n                    if y[cur,i,k.name].X > 0.5:\n                        route += \" -> {} (dist={})\".format(i,dist[cur, i])\n                        cur = i\n                        break\n                if cur == k.depot:\n                    break\n            print(\"{}'s route: {}\".format(k.name, route))\n        else:\n            print(\"{} is not used\".format(k.name))\n\n            \n    # Utilization\n    print(\"\")\n    for k in K:\n        used = capLHS[k].getValue()\n        total = cap[k]\n        util = used / cap[k] if cap[k] > 0 else 0\n        print(\"{}'s utilization is {:.2%} ({:.2f}/{:.2f})\".format(k, util, used, cap[k]))\n    totUsed = sum(capLHS[k].getValue() for k in K)\n    totCap = sum(cap[k] for k in K)\n    totUtil = totUsed / totCap if totCap > 0 else 0\n    print(\"Total technician utilization is {:.2%} ({:.2f}/{:.2f})\".format(totUtil, totUsed, totCap))\n    \n    def create_excel_output():\n        routes_cols = ['Route ID', 'Technician Name', 'Origin Location', 'Total Travel Time', 'Total Processing Time',\n                       'Total Time', 'Earliest Start Time', 'Latest Start Time', 'Earliest End Time',\n                       'Latest End Time', 'Num Jobs']\n        routes_list = []\n        orders_cols = ['Route ID', 'Stop Number', 'Customer Name', 'Technician Name', 'Location Name', 'Job type',\n                       'Processing Time', 'Customer Time Window Start', 'Customer Time Window End',\n                       'Earliest Start', 'Latest Start', 'Earliest End', 'Latest End', ]\n        route_id = 0\n        orders_list = []\n        for k in technicians:\n            if u[k.name].X > 0.5:\n                customers_list = []\n                route_id += 1\n                total_distance, total_travel_time, total_processing_time = 0, 0, 0\n                cur = k.depot\n                while True:\n                    for j in customers:\n                        if y[cur, j.loc, k.name].X > 0.5:\n                            total_travel_time += dist[cur, j.loc]\n                            total_distance += dist[cur, j.loc]\n                            total_processing_time += j.job.duration\n                            customers_list.append(j)\n                            cur = j.loc\n                    for i in D:\n                        if y[cur, i, k.name].X > 0.5:\n                            total_travel_time += dist[cur, i]\n                            total_distance += dist[cur, i]\n                            cur = i\n                            break\n                    if cur == k.depot:\n                        break\n                latest = get_latest_times(customers_list, k)\n\n                # append customers to the list of orders\n                for i, j in enumerate(customers_list):\n                    orders_list.append([route_id, i + 1, j.name, k.name, j.loc, j.job.name,\n                                        j.job.duration, tStart[j.name], tEnd[j.name],\n                                        t[j.loc].X, latest[j.loc],\n                                        t[j.loc].X + j.job.duration, latest[j.loc] + j.job.duration])\n\n                # append route to routes list\n                earliest_start_route = t[customers_list[0].loc].X - dist[k.depot, customers_list[0].loc]\n                latest_start_route = latest[customers_list[0].loc] - dist[k.depot, customers_list[0].loc]\n                earliest_end_route = t[customers_list[-1].loc].X + customers_list[-1].job.duration + \\\n                                     dist[customers_list[-1].loc, k.depot]\n                latest_end_route = latest[customers_list[-1].loc] + customers_list[-1].job.duration + \\\n                                   dist[customers_list[-1].loc, k.depot]\n\n                routes_list.append([route_id, k.name, k.depot, total_travel_time, total_processing_time,\n                                    earliest_end_route - earliest_start_route, earliest_start_route,\n                                    latest_start_route, earliest_end_route, latest_end_route, len(customers_list)])\n        # Convert to dataframe and write to excel\n        routes_df = pd.DataFrame.from_records(routes_list, columns=routes_cols)\n        routes_df.to_csv('routes.csv', index=False)\n        orders_df = pd.DataFrame.from_records(orders_list, columns=orders_cols)\n        orders_df.to_csv('orders.csv', index=False)\n    \n    # create output files\n    create_excel_output()\n    \n    m.dispose()\n    gp.disposeDefaultEnv()\n\ndef printScen(scenStr):\n    sLen = len(scenStr)\n    print(\"\\n\" + \"*\"*sLen + \"\\n\" + scenStr + \"\\n\" + \"*\"*sLen + \"\\n\")\n\nif __name__ == \"__main__\":\n    # Base model\n    printScen(\"Solving base scenario model\")\n    solve_trs0(technicians, customers, dist)"}]}
{"meta": {"source_path": "/Users/sunyujun03/Desktop/ReLoop/gurobi-modeling-examples/optimization201/Modeling_Session_1/completed_exercise_set1.ipynb", "kind": "ipynb", "title": "Exercise Set 1"}, "messages": [{"role": "system", "content": "You are an optimization engineer. Write correct and runnable Python code using gurobipy (Gurobi Python API). Be concise. Output only what is requested."}, {"role": "user", "content": "    Task: Reproduce the following Gurobi modeling example in Python using gurobipy.\n\n    Scenario description (from source):\n    # Exercise Set 1\n\n## Multiple choice\n\nCorrect answers are `marked like this`.\n\n**Q1.** All projects that can utilize mathematical optimization identify this well in advance.\n> TRUE\n\n> `FALSE`\n\n**Q2.** The core value of machine learning lies in the _________ used to fit models. In mathematical optimization, the _________ carries most of the value.\n>a. platform, GPU\n\n>b. `data, algorithms`\n\n>c. algorithms, industry\n\n>d. parallelization, data\n\n**Q3.** Heuristics often have a way to know how far a current solution may be from the optimal solution.\n> TRUE\n\n> `FALSE`\n\n**Q4.** While it is good to note the size of a mathematical optimization problem in terms of the number of variables and constraints, it is far from a reliable way to measure how long it will take to solve.\n> `TRUE`\n\n> FALSE\n\n## Free Responses\n````\nI suggest getting some paper and pencil here for some of these\n````\n**Q5.** Apply `DeMorgan's laws` to the following statements. Final answers should only use the $=$, $\\le$, $\\ge$, $<$, and $>$ comparison symbols, where applicable.\n>a. Not (Python or R).\n>>not Python and not R\n\n>b. It's not the case that both $x$ is equal to 0 and $y$ is positive. Simplify this statement so all \"*not*\" are removed.\n\n$$\n\\begin{align*}\n&not \\space (x = 0 \\space or \\space y > 0)\\\\\n&not \\space x = 0 \\space and \\space not \\space y > 0\\\\\n&x > 0  \\space or \\space x < 0\\space and \\space y \\le 0\n\\end{align*}\n$$\n\n**Q6.** Let $a$ be the amount of snow that falls overnight and $b$ is a binary variable indicating if school is open ($b=1$) or closed ($b=0$). Use this, and the `IF-THEN` to an `OR` statement equivalence to rewrite this statement: \"If it snows more than 8 inches overnight, then school will be closed tomorrow.\"\n>> If $a > 8$ then $b = 0$\n\n>> $a \\le 8$ or $b=0$\n\n**Q7.** Write the `contrapositive` of \"If Duke is late for a meeting, that's because he was out surfing.\"\n\n>> If Duke wasn't out surfing, then he won't be late for a meeting.\n\n**Q8.** In the **Using Big M Constraints** section of last session's notebook, we used the following inequality $x + M_2 \\times z \\ge C$.\n>a. Simplify this inequality replacing $𝑀_2$ with $C$.\n$$\n\\begin{align*}\nx + M_2 \\times z \\ge C\\\\\nx + C \\times z \\ge C\\\\\nx  \\ge C - C \\times z\\\\\nx \\ge C×(1-z)\n\\end{align*}\n$$\n\n>b. The other clause of this `OR` statement was $x \\le M_1\\times(1-z)$. Write out what these two inequalities reduce to when $z = 1$ and $z = 0$.\n\n> Let $z = 1$\n$$\n\\begin{align*}\nx \\ge C×(1-z) \\quad\\quad & \\space\\quad\\quad x \\le M_1\\times(1-z)\\\\\nx \\ge C×(1-1) \\quad\\quad & \\space\\quad\\quad x \\le M_1\\times(1-1)\\\\\nx \\ge C×0 \\quad\\quad & \\space\\quad\\quad x \\le M_1\\times0\\\\\nx \\ge 0 \\quad\\quad & \\space\\quad\\quad x \\le 0\\\\\nx & = 0\n\\end{align*}\n$$\n> Let $z = 0$\n$$\n\\begin{align*}\nx \\ge C×(1-z) \\quad\\quad & \\space\\quad\\quad x \\le M_1\\times(1-z)\\\\\nx \\ge C×(1-0) \\quad\\quad & \\space\\quad\\quad x \\le M_1\\times(1-0)\\\\\nx \\ge C×1 \\quad\\quad & \\space\\quad\\quad x \\le M_1\\times1\\\\\nx \\ge C \\quad\\quad & \\space\\quad\\quad x \\le M_1\\\\\nC \\le x & \\le M_1\n\\end{align*}\n$$\n\n## Formulation and Coding\n**Q9.** In the **Constraining production facilities** section of the Modeling Example 1 notebook, when adding the $y$ decision variables for opening production facilities, assume there are fixed costs given by the list `[180, 150, 120, 155, 175]` for activating each respective production facility. Write `gurobipy` code that will add these costs to the original objective function.\n\n    Requirements:\n    - Use gurobipy (Model, GRB, addVar/addConstr, etc.)\n    - Make the script runnable as a standalone Python file if possible.\n    - Keep the code faithful to the example.\n"}, {"role": "assistant", "content": "# the quickest way is to incorporate this when defining the variable.\ny = m.addVars(production, obj = [180, 150, 120, 155, 175], vtype=GRB.BINARY)\n\n# part a.\nm.addConstrs(((y[p] == 0) >> (x[p,d] == 0)) for p in production for d in distribution)\n\n# part b.\nz = m.addVar(vtype = GRB.BINARY, name = 'z')\n\n# take the contrapositive\n# if charleston is open then NOT (cleveland and baltimore open)\n# cleveland and baltimore both open means y_cle + y_bal = 2. \n# not that means y_cle + y_bal <= 1\nm.addConstr((y['Charleston'] == 1) >> (y['Cleveland'] + y['Baltimore'] <= 1))"}]}
{"meta": {"source_path": "/Users/sunyujun03/Desktop/ReLoop/gurobi-modeling-examples/optimization201/Modeling_Session_1/completed_modeling1.ipynb", "kind": "ipynb", "title": "Intermediate Modeling: Return of the Widgets"}, "messages": [{"role": "system", "content": "You are an optimization engineer. Write correct and runnable Python code using gurobipy (Gurobi Python API). Be concise. Output only what is requested."}, {"role": "user", "content": "    Task: Reproduce the following Gurobi modeling example in Python using gurobipy.\n\n    Scenario description (from source):\n    # Intermediate Modeling: Return of the Widgets\n\nIn Opti101 we first learned about mathematical optimzation through a fictitious problem about producing and distributing widgets. If you would like to have the first notebook using this example from the previous training handy, you can find it [here](https://colab.research.google.com/github/Gurobi/modeling-examples/blob/master/optimization101/Modeling_Session_1/completed_modeling1.ipynb).\n\nWe are going to expand on this problem, so let's do a quick recap. We make widgets. They are produced in one of **five production facilities** and are then sent to one of **six distribution hubs** to be sold locally. Each distribution center has a demand forecast and each production facility has a min and max number of widgets it can make during this period.\n\nOur production and distribution `sets` are:\n- $P = \\{\\texttt{'Baltimore', 'Cleveland', 'Little Rock', 'Birmingham', 'Charleston'}\\}$ $\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\space\\space \\texttt{production}$\n- $D = \\{\\texttt{'Columbia', 'Indianapolis', 'Lexington', 'Nashville', 'Richmond', 'St. Louis'}\\} \\quad\\quad\\quad \\texttt{distribution}$\n\nModel `parameters`:\n- $c_{p,d}$: cost to ship a widget from $p$ to $d$, $\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\texttt{transp_cost[p,d]}$\n- $m_p$: maximum a production facility $p$ can produce, $\\quad\\quad\\quad\\quad\\quad\\quad\\space\\texttt{max_prod[p]}$\n- $n_d$: demand at distribution hub $d$, $\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\texttt{n_demand[d]}$\n\nIf you are running this in Colab or don't have a Gurobi license, quickly installing `gurobipy` will install a limited license.\n\n### The First Model\n\n- Our **decision variables** are the amount produced at facility $p$ and shipped to distribution center $d$, denoted $x_{p,d}$\n- We have **constraints** to ensure:\n  - Min and max production\n  - Demand is met\n- The **objective** is to meet demand at **minimal cost**.\n\nAs a reminder, here is the original *formulation*:\n\n\\begin{align*}\n{\\rm min} &\\sum_{p,d}c_{p,d}x_{p,d}\\\\\n{\\rm s.t.}\\\\\n&\\sum_{d}x_{p,d} \\le m_p, &\\forall p \\in P \\quad &\\texttt{can}\\_\\texttt{produce[p]}\\\\\n&\\sum_{d}x_{p,d} \\ge a*m_p,&\\forall p \\in P \\quad &\\texttt{must}\\_\\texttt{produce[p]}\\\\\n&\\sum_{p}x_{p,d} \\ge n_d, &\\forall d \\in D \\quad &\\texttt{meet}\\_\\texttt{demand[d]}\\\\\n&x_{p,d} \\ge 0,  &\\forall p \\in P, d \\in D\\quad &\\texttt{non-negativity}\\\\\n\\end{align*}\n\nSolve the optimization problem, and look at the results.\n\n### Fixing the very small shipment value\nIn the Intermediate Modeling recorded presentation, we saw a decision that may not be actually doable in an optimal solution.\n\n$x_{Cleveland,Nashville} = 2$, meaning we have a shipment of only two units. It's *possible* that this is something we may need to avoid for various reasons, say for instance the transportation cost per unit is only valid for a minimum amount.\n\n    Requirements:\n    - Use gurobipy (Model, GRB, addVar/addConstr, etc.)\n    - Make the script runnable as a standalone Python file if possible.\n    - Keep the code faithful to the example.\n"}, {"role": "assistant", "content": "# Import packages\nimport pandas as pd\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# read in transportation cost data\npath = 'https://raw.githubusercontent.com/Gurobi/modeling-examples/master/optimization101/Modeling_Session_1/'\ntransp_cost = pd.read_csv(path + 'cost.csv')\n\n# get production and distribution locations from data frame\nproduction = list(transp_cost['production'].unique())\ndistribution = list(transp_cost['distribution'].unique())\ntransp_cost = transp_cost.set_index(['production','distribution']).squeeze()\n\nmax_prod = pd.Series([180,200,140,80,180], index = production, name = \"max_production\")\nn_demand = pd.Series([89,95,121,101,116,181], index = distribution, name = \"demand\")\n# the min prodcution is a fraction of the max\nfrac = 0.75\n\n# gurobipy code for thie above formulation\nm = gp.Model('widgets')\n\n# decision vars\nx = m.addVars(production, distribution, name = 'prod_ship')\n\n# constraints\ncan_produce = m.addConstrs((gp.quicksum(x[p,d] for d in distribution) <= max_prod[p] for p in production), name = 'can_produce')\nmust_produce = m.addConstrs((gp.quicksum(x[p,d] for d in distribution) >= frac*max_prod[p] for p in production), name = 'must_produce')\nmeet_demand = m.addConstrs(x.sum('*', d) >= n_demand[d] for d in distribution)\n\n#objective\nm.setObjective(gp.quicksum(transp_cost[p,d]*x[p,d] for p in production for d in distribution), GRB.MINIMIZE)\n\nm.optimize()\n\nx_values = pd.Series(m.getAttr('X', x), name = \"shipment\", index = transp_cost.index)\nsol = pd.concat([transp_cost, x_values], axis=1)\nobj0 = m.getObjective()\nobj0_value = obj0.getValue()\n\nprint(f\"The original model had a total cost of {round(obj0_value,2)}\")\nsol[sol.shipment > 0]\n\nz = m.addVars(production, distribution, vtype=GRB.BINARY, name = 'min_distribution')\n\nmin_ship1 = m.addConstrs(x[p,d] <= max_prod[p]*(1-z[p,d]) for p in production for d in distribution)\nm.update()\n\nC = 30\nmin_ship2 = m.addConstrs(x[p,d] + C*z[p,d] >= C for p in production for d in distribution)\nm.update()\n\nm.optimize()\n\nx_values = pd.Series(m.getAttr('X', x), name = \"shipment\", index = transp_cost.index)\nsol = pd.concat([transp_cost, x_values], axis=1)\nobj1 = m.getObjective()\nobj1_value = obj1.getValue()\nsol[sol.shipment > 0]\n\nprint(f\"The updated model had a total cost of {round(obj1_value,2)}.\")\nprint(f\"The additional cost is {round(obj1_value - obj0_value,2)}.\")\n\n# remove the big M constraints and variable\nm.remove([min_ship1, min_ship2])\nC = 30\n# overloaded form\nzis1 = m.addConstrs((((z[p,d] == 1) >> (x[p,d] >= C)) for p in production for d in distribution), name = \"zis1\")\nzis0 = m.addConstrs((((z[p,d] == 0) >> (x[p,d] <= 0)) for p in production for d in distribution), name = \"zis0\")\nm.update()\n\nm.optimize()\n\nx_values = pd.Series(m.getAttr('X', x), name = \"shipment\", index = transp_cost.index)\nsol = pd.concat([transp_cost, x_values], axis=1)\nsol[sol.shipment > 0]\n\nm.remove([zis1, zis0])\n\n# decision vars\nm = gp.Model('widgets')\n\n# decision vars\nx = m.addVars(production, distribution, vtype=GRB.SEMICONT, lb = C, name = 'prod_ship')\n\n# constraints\ncan_produce = m.addConstrs((gp.quicksum(x[p,d] for d in distribution) <= max_prod[p] for p in production), name = 'can_produce')\nmust_produce = m.addConstrs((gp.quicksum(x[p,d] for d in distribution) >= frac*max_prod[p] for p in production), name = 'must_produce')\nmeet_demand = m.addConstrs(x.sum('*', d) >= n_demand[d] for d in distribution)\n\n# objective\nm.setObjective(gp.quicksum(transp_cost[p,d]*x[p,d] for p in production for d in distribution), GRB.MINIMIZE)\nm.optimize()\n\n# extract and show solution\nx_values = pd.Series(m.getAttr('X', x), name = \"shipment\", index = transp_cost.index)\nsol = pd.concat([transp_cost, x_values], axis=1)\nsol[sol.shipment > 0]\n\nmax_prod2 = pd.Series([210,225,140,130,220], index = production, name = \"max_production\")\n\nm2 = gp.Model('widgets2')\n\n# decision vars\nx = m2.addVars(production, distribution, name = 'prod_ship')\n\n# constraints\ncan_produce = m2.addConstrs((gp.quicksum(x[p,d] for d in distribution) <= max_prod2[p] for p in production), name = 'can_produce')\nmeet_demand = m2.addConstrs(x.sum('*', d) >= n_demand[d] for d in distribution)\n\n# define total cost for quick access later\ntotal_cost = gp.quicksum(transp_cost[p,d]*x[p,d] for p in production for d in distribution)\n\n# objective\nm2.setObjective(total_cost, GRB.MINIMIZE)\n\nm2.optimize()\nx_values = pd.Series(m2.getAttr('X', x), name = \"shipment\", index = transp_cost.index)\nsol2 = pd.concat([transp_cost, x_values], axis=1)\nsol2[sol2.shipment > 0]\n\ny = m2.addVars(production, vtype=GRB.BINARY, name = 'prod_on')\n\nm2.addConstrs((x[p,d] <= max_prod2[p]*y[p] for p in production for d in distribution), name = 'xy_link')\nm2.update()\n\n# regionality conditions\nreg_cond = m2.addConstr((y['Charleston']==1) >> (y['Cleveland'] + y['Baltimore'] == 0))\nm2.write('reg_cond.lp')\n\nm2.optimize()\nx_values = pd.Series(m2.getAttr('X', x), name = \"shipment\", index = transp_cost.index)\nsol2 = pd.concat([transp_cost, x_values], axis=1)\nsol2[sol2.shipment > 0]\n\n# remove the regional condition constraint from the model\nm2.remove(reg_cond)\n\nm2.setObjective(y.sum())\nm2.optimize()\n\n# (new objective value) - (previous objecive value)\ntotal_cost.getValue() - sum(sol2.cost*sol2.shipment)\n\nonly_four = m2.addConstr(y.sum() <= 4)\nm2.setObjective(total_cost, GRB.MINIMIZE)\nm2.optimize()\n\nround(total_cost.getValue() - sum(sol2.cost*sol2.shipment),2)\n\n#remove the contraing limiting to four facilities\nm2.remove(only_four)\n\n# overloaded forms\nr = m2.addVar(vtype=GRB.INTEGER, name = 'r')\n#minconstr = m2.addConstr(r == min_([x[p,d] for p in production for d in distribution]), name=\"minconstr\")\nminconstr = m2.addGenConstrMin(r, [x[p,d] for p in production for d in distribution],name= \"minconstr\")\nm2.setObjective(r, GRB.MAXIMIZE)\nm2.optimize()\n\nm2.remove(minconstr)\n\nm2.addConstrs(r <= x[p,d] for p in production for d in distribution)\nm2.optimize()"}]}
{"meta": {"source_path": "/Users/sunyujun03/Desktop/ReLoop/gurobi-modeling-examples/optimization201/Modeling_Session_1/modeling1.ipynb", "kind": "ipynb", "title": "Intermediate Modeling: Return of the Widgets"}, "messages": [{"role": "system", "content": "You are an optimization engineer. Write correct and runnable Python code using gurobipy (Gurobi Python API). Be concise. Output only what is requested."}, {"role": "user", "content": "    Task: Reproduce the following Gurobi modeling example in Python using gurobipy.\n\n    Scenario description (from source):\n    # Intermediate Modeling: Return of the Widgets\n\nIn Opti101 we first learned about mathematical optimization through a fictitious problem about producing and distributing widgets. If you would like to have the first notebook using this example from the previous training handy, you can find it [here](https://colab.research.google.com/github/Gurobi/modeling-examples/blob/master/optimization101/Modeling_Session_1/completed_modeling1.ipynb).\n\nWe are going to expand on this problem, so let's do a quick recap. We make widgets. They are produced in one of **five production facilities** and are then sent to one of **six distribution hubs** to be sold locally. Each distribution center has a demand forecast and each production facility has a min and max number of widgets it can make during this period.\n\nOur production and distribution `sets` are:\n- $P = \\{\\texttt{'Baltimore', 'Cleveland', 'Little Rock', 'Birmingham', 'Charleston'}\\}$ $\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\space\\space \\texttt{production}$\n- $D = \\{\\texttt{'Columbia', 'Indianapolis', 'Lexington', 'Nashville', 'Richmond', 'St. Louis'}\\} \\quad\\quad\\quad \\texttt{distribution}$\n\nModel `parameters`:\n- $c_{p,d}$: cost to ship a widget from $p$ to $d$, $\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\texttt{transp_cost[p,d]}$\n- $m_p$: maximum a production facility $p$ can produce, $\\quad\\quad\\quad\\quad\\quad\\quad\\space\\texttt{max_prod[p]}$\n- $n_d$: demand at distribution hub $d$, $\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\texttt{n_demand[d]}$\n\nIf you are running this in Colab or don't have a Gurobi license, quickly installing `gurobipy` will install a limited license.\n\n### The First Model\n\n- Our **decision variables** are the amount produced at facility $p$ and shipped to distribution center $d$, denoted $x_{p,d}$\n- We have **constraints** to ensure:\n  - Min and max production\n  - Demand is met\n- The **objective** is to meet demand at **minimal cost**.\n\nAs a reminder, here is the original *formulation*:\n\n\\begin{align*}\n{\\rm min} &\\sum_{p,d}c_{p,d}x_{p,d}\\\\\n{\\rm s.t.}\\\\\n&\\sum_{d}x_{p,d} \\le m_p, &\\forall p \\in P \\quad &\\texttt{can}\\_\\texttt{produce[p]}\\\\\n&\\sum_{d}x_{p,d} \\ge a*m_p,&\\forall p \\in P \\quad &\\texttt{must}\\_\\texttt{produce[p]}\\\\\n&\\sum_{p}x_{p,d} \\ge n_d, &\\forall d \\in D \\quad &\\texttt{meet}\\_\\texttt{demand[d]}\\\\\n&x_{p,d} \\ge 0,  &\\forall p \\in P, d \\in D\\quad &\\texttt{non-negativity}\\\\\n\\end{align*}\n\nSolve the optimization problem, and look at the results.\n\n### Fixing the very small shipment value\nIn the Intermediate Modeling recorded presentation, we saw a decision that may not be actually doable in an optimal solution.\n\n$x_{Cleveland,Nashville} = 2$, meaning we have a shipment of only two units. It's *possible* that this is something we may need to avoid for various reasons, say for instance the transportation cost per unit is only valid for a minimum amount.\n\n    Requirements:\n    - Use gurobipy (Model, GRB, addVar/addConstr, etc.)\n    - Make the script runnable as a standalone Python file if possible.\n    - Keep the code faithful to the example.\n"}, {"role": "assistant", "content": "# Import packages\nimport pandas as pd\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# read in transportation cost data\npath = 'https://raw.githubusercontent.com/Gurobi/modeling-examples/master/optimization101/Modeling_Session_1/'\ntransp_cost = pd.read_csv(path + 'cost.csv')\n\n# get production and distribution locations from data frame\nproduction = list(transp_cost['production'].unique())\ndistribution = list(transp_cost['distribution'].unique())\ntransp_cost = transp_cost.set_index(['production','distribution']).squeeze()\n\nmax_prod = pd.Series([180,200,140,80,180], index = production, name = \"max_production\")\nn_demand = pd.Series([89,95,121,101,116,181], index = distribution, name = \"demand\")\n# the min prodcution is a fraction of the max\nfrac = 0.75\n\n# gurobipy code for thie above formulation\nm = gp.Model('widgets')\n\n# decision vars\nx = m.addVars(production, distribution, name = 'prod_ship')\n\n# constraints\ncan_produce = m.addConstrs((gp.quicksum(x[p,d] for d in distribution) <= max_prod[p] for p in production), name = 'can_produce')\nmust_produce = m.addConstrs((gp.quicksum(x[p,d] for d in distribution) >= frac*max_prod[p] for p in production), name = 'must_produce')\nmeet_demand = m.addConstrs(x.sum('*', d) >= n_demand[d] for d in distribution)\n\n#objective\nm.setObjective(gp.quicksum(transp_cost[p,d]*x[p,d] for p in production for d in distribution), GRB.MINIMIZE)\n\nm.optimize()\n\nx_values = pd.Series(m.getAttr('X', x), name = \"shipment\", index = transp_cost.index)\nsol = pd.concat([transp_cost, x_values], axis=1)\nobj0 = m.getObjective()\nobj0_value = obj0.getValue()\n\nprint(f\"The original model had a total cost of {round(obj0_value,2)}\")\nsol[sol.shipment > 0]\n\nz = m.addVars(production, distribution, vtype=GRB.BINARY, name = 'min_distribution')\n\nmin_ship1 = m.addConstrs(    ?????????     for p in production for d in distribution)\nm.update()\n\nC = 30\nmin_ship2 = m.addConstrs(    ?????????   for p in production for d in distribution)\nm.update()\n\nm.optimize()\n\nx_values = pd.Series(m.getAttr('X', x), name = \"shipment\", index = transp_cost.index)\nsol = pd.concat([transp_cost, x_values], axis=1)\nobj1 = m.getObjective()\nobj1_value = obj1.getValue()\nsol[sol.shipment > 0]\n\nprint(f\"The updated model had a total cost of {round(obj1_value,2)}.\")\nprint(f\"The additional cost is {round(obj1_value - obj0_value,2)}.\")\n\n# remove the big M constraints and variable\nm.remove([min_ship1, min_ship2])\nC = 30\n# overloaded form\nzis1 = m.addConstrs((((z[p,d] == 1 ) >> (  ?????  )) for p in production for d in distribution), name = \"zis1\")\nzis0 = m.addConstrs((((   ??????   ) >> (  ?????  )) for p in production for d in distribution), name = \"zis0\")\nm.update()\n\nm.optimize()\n\nx_values = pd.Series(m.getAttr('X', x), name = \"shipment\", index = transp_cost.index)\nsol = pd.concat([transp_cost, x_values], axis=1)\nsol[sol.shipment > 0]\n\nm.remove([zis1, zis0])\n\n# decision vars\nm = gp.Model('widgets')\n\n# decision vars\nx = m.addVars(production, distribution, vtype=GRB.SEMICONT, lb = C, name = 'prod_ship')\n\n# constraints\ncan_produce = m.addConstrs((gp.quicksum(x[p,d] for d in distribution) <= max_prod[p] for p in production), name = 'can_produce')\nmust_produce = m.addConstrs((gp.quicksum(x[p,d] for d in distribution) >= frac*max_prod[p] for p in production), name = 'must_produce')\nmeet_demand = m.addConstrs(x.sum('*', d) >= n_demand[d] for d in distribution)\n\n# objective\nm.setObjective(gp.quicksum(transp_cost[p,d]*x[p,d] for p in production for d in distribution), GRB.MINIMIZE)\nm.optimize()\n\n# extract and show solution\nx_values = pd.Series(m.getAttr('X', x), name = \"shipment\", index = transp_cost.index)\nsol = pd.concat([transp_cost, x_values], axis=1)\nsol[sol.shipment > 0]\n\nmax_prod2 = pd.Series([210,225,140,130,220], index = production, name = \"max_production\")\n\nm2 = gp.Model('widgets2')\n\n# decision vars\nx = m2.addVars(production, distribution, name = 'prod_ship')\n\n# constraints\ncan_produce = m2.addConstrs((gp.quicksum(x[p,d] for d in distribution) <= max_prod2[p] for p in production), name = 'can_produce')\nmeet_demand = m2.addConstrs(x.sum('*', d) >= n_demand[d] for d in distribution)\n\n# define total cost for quick access later\ntotal_cost = gp.quicksum(transp_cost[p,d]*x[p,d] for p in production for d in distribution)\n\n# objective\nm2.setObjective(total_cost, GRB.MINIMIZE)\n\nm2.optimize()\nx_values = pd.Series(m2.getAttr('X', x), name = \"shipment\", index = transp_cost.index)\nsol2 = pd.concat([transp_cost, x_values], axis=1)\nsol2[sol2.shipment > 0]\n\ny = m2.addVars(production, vtype= ?????, name = 'prod_on')\n\nm2.addConstrs((        ?????????         ), name = 'xy_link')\nm2.update()\n\n# regionality conditions\nreg_cond = m2.addConstr(         ?????????????               )\nm2.write('reg_cond.lp')\n\nm2.optimize()\nx_values = pd.Series(m2.getAttr('X', x), name = \"shipment\", index = transp_cost.index)\nsol2 = pd.concat([transp_cost, x_values], axis=1)\nsol2[sol2.shipment > 0]\n\n# remove the regional condition constraint from the model\nm2.remove(reg_cond)\n\nm2.setObjective(y.sum())\nm2.optimize()\n\n# (new objective value) - (previous objecive value)\ntotal_cost.getValue() - sum(sol2.cost*sol2.shipment)\n\nonly_four = m2.??????????\nm2.setObjective(total_cost, GRB.MINIMIZE)\nm2.optimize()\n\nround(total_cost.getValue() - sum(sol2.cost*sol2.shipment),2)\n\n#remove the contraing limiting to four facilities\nm2.remove(only_four)\n\nr = m2.addVar(vtype=GRB.INTEGER, name = 'r')\n#minconstr = m2.addConstr(r == gp.min_([x[p,d] for p in production for d in distribution]), name=\"minconstr\")\nminconstr = m2.addGenConstrMin(r, [x[p,d] for p in production for d in distribution],name= \"minconstr\")\nm2.setObjective(r, GRB.MAXIMIZE)\nm2.optimize()\n\nm2.remove(minconstr)\n\nm2.addConstrs(r <= x[p,d] for p in production for d in distribution)\nm2.optimize()"}]}
{"meta": {"source_path": "/Users/sunyujun03/Desktop/ReLoop/gurobi-modeling-examples/opencast_mining/opencast_mining.ipynb", "kind": "ipynb", "title": "Opencast Mining"}, "messages": [{"role": "system", "content": "You are an optimization engineer. Write correct and runnable Python code using gurobipy (Gurobi Python API). Be concise. Output only what is requested."}, {"role": "user", "content": "    Task: Reproduce the following Gurobi modeling example in Python using gurobipy.\n\n    Scenario description (from source):\n    # Opencast Mining\n\n## Objective and Prerequisites\n\nHow can a mining company use mathematical optimization to identify which excavation locations to choose in order to maximize the gross margins of extracting ore? Try this modeling example to find out!\n\nThis model is example 14 from the fifth edition of Model Building in Mathematical Programming by H. Paul Williams on pages 269-270 and 324-325.\n\nThis example is at the intermediate level where we assume that you know Python and the Gurobi Python API and that you have some knowledge of building mathematical optimization models.\n\n**Download the Repository** <br /> \nYou can download the repository containing this and other examples by clicking [here](https://github.com/Gurobi/modeling-examples/archive/master.zip). \n\n## Problem Description\n\nA company has obtained permission to conduct opencast mining within a square plot 200 ft $\\times$ 200 ft. The angle of slip of the soil is such that it is not possible for the sides of the excavation to be steeper than 45 degrees. The company has obtained estimates for the value of the ore in various places at various depths. Bearing in mind the restrictions imposed by the angle of slip, the company decides to consider the problem as one of the extracting of rectangular blocks. Each block has horizontal dimensions 50 ft $\\times$ 50 ft and a vertical dimension of 25 ft. If the blocks are chosen to lie above one another then it is only possible to excavate blocks forming an upturned pyramid. \nThe three dimensional representation below shows four levels of excavation. We have numbered, in black, each block at each level, and the number in red represents the block underneath the four blocks of the level. For example, block 17 of level 2 lies underneath the blocks 1,2,5,and 6 of level 1.\n![pyramid](extractionPyramid.PNG)\n\nThe profit for the extraction of ore at each block has been estimated. The goal is to find an ore extraction plan that maximizes total profit.\n\n## Model Formulation\n\n### Sets and Indices\n\n$b,b2 \\in \\text{Blocks}=\\{1,...,30 \\}$.\n\n### Parameters\n\n$\\text{profit}_{b} \\in \\mathbb{R}^+$: Profit from extracting ore from block $b$.\n\n$(b,b2) \\in Arcs = Blocks \\times Blocks$: This parameter represent the arcs in the series-parallel graph describing the rules of extraction. The arc $(b,b2)$ in the adjacency matrix of this series-parallel graph has a value of 1 if block b2 is one of the four blocks above block b, and 0 otherwise. For example, arc $(29,24)$ represents that block 24 is one of the four blocks above block 29.\n\n### Decision Variables\n\n$\\text{extract}_{b} \\in \\{0,1\\}$: This binary variable is equal 1, if block $b$ is selected, and 0 otherwise.\n\n### Constraints\n\n**Extraction**: If a block is extracted, then the four blocks above it must also be extracted..\n\n\\begin{equation}\n\\text{extract}_{b2} \\geq \\text{extract}_{b} \\quad \\forall (b,b2) \\in \\text{Arcs}\n\\end{equation}\n\n### Objective Function\n\n**Profits**: Maximize profits from the extraction of ore.\n\n\\begin{equation}\n\\text{Maximize} \\quad \\sum_{b \\in Blocks} \\text{profit}_{b}*\\text{extract}_{b}\n\\end{equation}\n\n## Python Implementation\n\nWe import the Gurobi Python Module.\n\n    Requirements:\n    - Use gurobipy (Model, GRB, addVar/addConstr, etc.)\n    - Make the script runnable as a standalone Python file if possible.\n    - Keep the code faithful to the example.\n"}, {"role": "assistant", "content": "import numpy as np\nimport pandas as pd\n\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# tested with Python 3.11 & Gurobi 11.0\n\n# Create a dictionary to capture the profit of the extracting of ore at each block.\n\nblocks, profit = gp.multidict({\n    ('1'): 0,\n    ('2'): 0,\n    ('3'): 0,\n    ('4'): -1500,\n    ('5'): 0,\n    ('6'): 1000,\n    ('7'): 0,\n    ('8'): -1500,\n    ('9'): -1000,\n    ('10'): -1000,\n    ('11'): -1500,\n    ('12'): -2000,\n    ('13'): -1500,\n    ('14'): -1500,\n    ('15'): -2000,\n    ('16'): -2500,\n    ('17'): 2000,\n    ('18'): 2000,\n    ('19'): -2000,\n    ('20'): 0,\n    ('21'): 0,\n    ('22'): -4000,\n    ('23'): -2000,\n    ('24'): -2000,\n    ('25'): -5000,\n    ('26'): 16000,\n    ('27'): 4000,\n    ('28'): 2000,\n    ('29'): 0,\n    ('30'): 2000\n})\n\n# Create a dictionary for the adjacency matrix of the series-parallel graph.\n\narcs, value = gp.multidict({\n    ('30','26'): 1,\n    ('30','27'): 1,\n    ('30','28'): 1,\n    ('30','29'): 1,\n    ('29','21'): 1,\n    ('29','22'): 1,\n    ('29','24'): 1,\n    ('29','25'): 1,\n    ('28','20'): 1,\n    ('28','21'): 1,\n    ('28','23'): 1,\n    ('28','24'): 1,\n    ('27','18'): 1,\n    ('27','19'): 1,\n    ('27','21'): 1,\n    ('27','22'): 1,\n    ('26','17'): 1,\n    ('26','18'): 1,\n    ('26','20'): 1,\n    ('26','21'): 1,\n    ('25','11'): 1,\n    ('25','12'): 1,\n    ('25','15'): 1,\n    ('25','16'): 1,\n    ('24','10'): 1,\n    ('24','11'): 1,\n    ('24','14'): 1,\n    ('24','15'): 1,\n    ('23','9'): 1,\n    ('23','10'): 1,\n    ('23','13'): 1,\n    ('23','14'): 1,\n    ('22','7'): 1,\n    ('22','8'): 1,\n    ('22','11'): 1,\n    ('22','12'): 1,\n    ('21','6'): 1,\n    ('21','7'): 1,\n    ('21','10'): 1,\n    ('21','11'): 1,\n    ('20','5'): 1,\n    ('20','6'): 1,\n    ('20','9'): 1,\n    ('20','10'): 1,\n    ('19','3'): 1,\n    ('19','4'): 1,\n    ('19','7'): 1,\n    ('19','8'): 1,\n    ('18','2'): 1,\n    ('18','3'): 1,\n    ('18','6'): 1,\n    ('18','7'): 1,\n    ('17','1'): 1,\n    ('17','2'): 1,\n    ('17','5'): 1,\n    ('17','6'): 1\n})\n\nmodel = gp.Model('opencastMining')\n\n# Decision variable to extract ore from block\nextract = model.addVars(blocks, ub=1, vtype=GRB.CONTINUOUS, name=\"extract\" )\n\n# Extraction constraints\n\nextractionConstrs = model.addConstrs( (extract[b] <= extract[b2]  for b,b2 in arcs), name='extractionConstrs')\n\n# Objective function\n\nextractionProfit = gp.quicksum(profit[b]*extract[b] for b in blocks )\n\nmodel.setObjective(extractionProfit, GRB.MAXIMIZE)\n\n# Verify model formulation\n\nmodel.write('opencastMining.lp')\n\n# Run optimization engine\n\nmodel.optimize()\n\n# Output reports\n\nextraction_plan = pd.DataFrame(\n    [(b, f\"${profit[b]*round(extract[b].x):,.2f}\") for b in blocks if (extract[b].x > 0.5)],\n    columns = [\"Block\", \"Profit/Loss\"],\n)\nextraction_plan.index=[''] * len(extraction_plan)\nextraction_plan"}]}
{"meta": {"source_path": "/Users/sunyujun03/Desktop/ReLoop/gurobi-modeling-examples/agricultural_pricing/agricultural_pricing.ipynb", "kind": "ipynb", "title": "Agricultural Pricing"}, "messages": [{"role": "system", "content": "You are an optimization engineer. Write correct and runnable Python code using gurobipy (Gurobi Python API). Be concise. Output only what is requested."}, {"role": "user", "content": "    Task: Reproduce the following Gurobi modeling example in Python using gurobipy.\n\n    Scenario description (from source):\n    # Agricultural Pricing\n\n## Objective and Prerequisites\n\nTry this example to learn how to use mathematical optimization to tackle a common, but critical agricultural pricing problem:  Determining the prices and demand for a country’s dairy products in order to maximize total revenue derived from the sales of those products. You will learn how to model this problem as a quadratic optimization problem using the Gurobi Python API and solve it using the Gurobi Optimizer.\n\nThis model is example 21 from the fifth edition of Model Building in Mathematical Programming, by H. Paul Williams on pages 276-278 and 333-335.\n\nThis modeling example is at the intermediate level, where we assume that you know Python and are familiar with the Gurobi Python API. In addition, you should have some knowledge about building mathematical optimization models.\n\n**Download the Repository** <br /> \nYou can download the repository containing this and other examples by clicking [here](https://github.com/Gurobi/modeling-examples/archive/master.zip). \n\n## Problem Description\n\nThe government of a country wants to decide what prices should be charged for its dairy products: milk, butter, and cheese. All these products \nare produced \n(directly or indirectly) from the country’s raw milk production operations. This raw milk is divided into two main components: fat and dry matter. After subtracting the quantities of fat and dry matter, which are used for making products for export or consumption on the farms, there is a total yearly availability of 600,000 tons of fat and 750,000 tons of dry matter. This is all available for producing milk, butter and two kinds of cheese for domestic consumption. The percentage composition of the products are given in the following table:\n\n| Composition | Fat (%) | Dry matter (%) |\n| --- | --- | --- |\n| Milk | 4 | 9 |\n| Butter | 80 | 2 |\n| Cheese 1 | 35 | 30 |\n| Cheese 2 | 25 | 40 |\n\nThe table below shows last year's domestic consumption (demand) and prices for the dairy products:\n\n| Dairy <br /> products | Milk | Butter | Cheese 1 | Cheese 2 |\n| --- | --- | --- | --- | --- |\n| Demand (1000 tons) | 4.82 | 0.32 |  0.21 | 0.07 |\n| Price (dollars/ton) | 297 | 720 | 1050 | 815 |\n\nThe elasticities and cross-elasticities are given in the table below:\n\n| Milk | Butter | Cheese 1 | Cheese 2 | Cheese 1 to  <br /> Cheese 2 |  Cheese 2 to  <br /> Cheese 1 |\n| --- | --- | --- | --- | --- |  --- |\n| 0.4 | 2.7 | 1.1 |  0.4 | 0.1 |  0.4 |\n\nThe price index cannot be raised higher than last year.This constraint establishes that the new prices must be such that the total cost of last year’s consumption would not be increased. \nLast year's price index is 1.939 (measured in thousand dollars).\n\nThe goal is to determine what prices and demand  maximizes the total revenue.\n\n## Model Formulation\n\n### Sets and Indices\n\n$d \\in \\text{Dairy}=\\{\\text{milk}, \\text{butter}, \\text{cheese1}, \\text{cheese2} \\}$\n\n$c \\in \\text{Components}=\\{\\text{fat}, \\text{dry_matter} \\}$\n\n### Parameters\n\n$\\text{capacity}_{c} \\in \\mathbb{R}^+$: Yearly availability of component $c$ (1000 tons).\n\n$\\text{qtyper}_{c,d} \\in [0,1]$: Percentage of component $c$ in dairy product $d$.\n\n$\\text{consumption}_{d} \\in \\mathbb{R}^+$: Last year domestic consumption of dairy product  $d$ (1000 tons).\n\n$\\text{price}_{d} \\in \\mathbb{R}^+$: Last year price of dairy product $d$ (dollars/1000 tons).\n\n$\\text{elasticity}_{d} \\in \\mathbb{R}^+$: Last year price elasticity of domestic consumption of dairy product $d$.\n\n$\\text{elasticity12} \\in \\mathbb{R}^+$: Last year price cross-elasticity of domestic consumption of cheese 1 and cheese 2.\n\n$\\text{elasticity21} \\in \\mathbb{R}^+$: Last year price cross-elasticity of domestic consumption of cheese 2 and cheese 1.\n\n$\\text{prcIndex} \\in \\mathbb{R}^+$: Price index reflecting last year total consumption cost.\n\n### Decision Variables\n\n$\\text{p}_{d} \\in \\mathbb{R}^+$: Price of dairy product $d$ (dollars/1000 tons).\n\n$\\text{q}_{d} \\in \\mathbb{R}^+$: Demand of dairy product $d$ (1000 tons).\n\n### Constraints\n\n**Capacity**: The limited availabilities of fat and dry matter are enforced by the following constraints.\n\n\\begin{equation}\n\\sum_{d \\in \\text{Dairy}}{\\text{qtyper}_{c,d}*\\text{q}_{d} } \\leq \\text{capacity}_{c} \\quad \\forall c \\in \\text{Components}\n\\end{equation}\n\n**Price index**: This constraint establishes that the new prices must be such that the total cost of last year’s consumption would not be increased.\n\n\\begin{equation}\n\\sum_{d \\in \\text{Dairy}}{\\text{consumption}_{d}*\\text{p}_{d} } \\leq \\text{prcIndex}\n\\end{equation}\n\n**Elasticities**: The demand variables $q_{d}$ are related to the price variables $p_{d}$  through the price elasticities relationships. We approximate the elasticities with linear relationships.\n\nMilk elasticity.\n$$\n(\\text{q}_{milk} - \\text{consumption}_{milk})/\\text{consumption}_{milk}) = -\\text{elasticity}_{milk}*(\\text{p}_{milk} - \\text{price}_{milk})/\\text{price}_{milk})\n$$\n\nButter elasticity.\n$$\n(\\text{q}_{butter} - \\text{consumption}_{butter})/\\text{consumption}_{butter}) = -\\text{elasticity}_{butter}*(\\text{p}_{butter} - \\text{price}_{butter})/\\text{price}_{butter})\n$$\n\nCheese 1 elasticity.\n$$\n(\\text{q}_{cheese1} - \\text{consumption}_{cheese1})/\\text{consumption}_{cheese1}) = -\\text{elasticity}_{cheese1}*(\\text{p}_{cheese1} - \\text{price}_{cheese1})/\\text{price}_{cheese1}) \n$$\n\n$$\n+ elasticity12*(\\text{p}_{cheese2} - \\text{price}_{cheese2})/\\text{price}_{cheese2})\n$$\n\nCheese 2 elasticity.\n$$\n(\\text{q}_{cheese2} - \\text{consumption}_{cheese2})/\\text{consumption}_{cheese2}) = -\\text{elasticity}_{cheese2}*(\\text{p}_{cheese2} - \\text{price}_{cheese2})/\\text{price}_{cheese2}) \n$$\n\n$$\n+ elasticity21*(\\text{p}_{cheese1} - \\text{price}_{cheese1})/\\text{price}_{cheese1}) \n$$\n\n### Objective Function\n\n**Revenue**: The objective is to maximize total revenue.\n\n\\begin{equation}\n\\text{Maximize} \\quad \\sum_{d \\in \\text{Dairy}}{\\text{q}_{d}*\\text{p}_{d} }\n\\end{equation}\n\n---\n## Python Implementation\n\nWe import the Gurobi Python Module and other Python libraries.\n\n## Input data\n\nWe define all the input data for the model.\n\n    Requirements:\n    - Use gurobipy (Model, GRB, addVar/addConstr, etc.)\n    - Make the script runnable as a standalone Python file if possible.\n    - Keep the code faithful to the example.\n"}, {"role": "assistant", "content": "import pandas as pd\n\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# tested with Python 3.11 & Gurobi 11.0\n\n# List of dairy products.\n\ndairy = ['milk', 'butter', 'cheese1', 'cheese2']\n\ncomponents = ['fat', 'dryMatter']\n\n\n# Create a dictionary to capture the percentage composition of the products.\n\ncd, qtyper = gp.multidict({\n    ('fat','milk'): 0.04,\n    ('fat','butter'): 0.8,\n    ('fat','cheese1'): 0.35,\n    ('fat','cheese2'): 0.25,\n    ('dryMatter','milk'): 0.09,\n    ('dryMatter','butter'): 0.02,\n    ('dryMatter','cheese1'): 0.3,\n    ('dryMatter','cheese2'): 0.4\n})\n\n# Create a dictionary to capture the yearly availability of components (1000 tons).\n\ncomponents, capacity = gp.multidict({\n    ('fat'): 600,\n    ('dryMatter'): 750\n})\n\n# Create a dictionary to capture last year's domestic consumption and prices\n\ndairy, consumption, price, elasticity = gp.multidict({\n    ('milk'): [4.82, 0.297, 0.4],\n    ('butter'): [0.32, 0.72, 2.7],\n    ('cheese1'): [0.21, 1.05, 1.1],\n    ('cheese2'): [0.07, 0.815, 0.4]\n})\n\nelasticity12 = 0.1\nelasticity21 = 0.4\n\npriceIndex = 1.939\n\nmodel = gp.Model('AgriculturalPricing')\n\n# Set global parameters. \nmodel.params.nonConvex = 2\n\n# Quantity of dairy products.\nqvar = model.addVars(dairy, name=\"qvar\")\n\n# Price of dairy products.\npvar = model.addVars(dairy, name=\"pvar\")\n\n# Capacity constraint.\n\nfatCap = model.addConstrs( (gp.quicksum(qtyper[c,d]*qvar[d] for d in dairy) <= capacity[c] for c in components  ), \n                          name='fatCap')\n\n# Price index constraint.\n\npriceIndex = model.addConstr( (gp.quicksum(consumption[d]*pvar[d] for d in dairy) <= priceIndex ), name='priceIndex')\n\n# Elasticity constraints\n\nelasMilk = model.addConstr( (qvar['milk']-consumption['milk'])/consumption['milk']  \n                           == -elasticity['milk']*(pvar['milk']-price['milk'])/price['milk'], name='elasMilk')\n\nelasButter = model.addConstr( (qvar['butter']-consumption['butter'])/consumption['butter']  \n                           == -elasticity['butter']*(pvar['butter']-price['butter'])/price['butter'], name='elasButter')\n\nelasCheese1 = model.addConstr( (qvar['cheese1']-consumption['cheese1'])/consumption['cheese1']  \n                           == -elasticity['cheese1']*(pvar['cheese1']-price['cheese1'])/price['cheese1']\n                              +elasticity12*(pvar['cheese2']-price['cheese2'])/price['cheese2'] , name='elasCheese1')\n\nelasCheese2 = model.addConstr( (qvar['cheese2']-consumption['cheese2'])/consumption['cheese2']  \n                           == -elasticity['cheese2']*(pvar['cheese2']-price['cheese2'])/price['cheese2']\n                              +elasticity21*(pvar['cheese1']-price['cheese1'])/price['cheese1'] , name='elasCheese2')\n\n# Quadratic objective function.\n\nobj = gp.quicksum(qvar[d]*pvar[d] for d in dairy)\n\nmodel.setObjective(obj, GRB.MAXIMIZE)\n\n# Verify model formulation\n\nmodel.write('AgriculturalPricing.lp')\n\n# Run optimization engine\n\nmodel.optimize()\n\n# Output Report\nprice_demand = pd.DataFrame(\n    {\n        \"Products\": dairy,\n        \"Price\": [f\"{round(1000*pvar[d].x):.2f}\" for d in dairy],\n        \"Demand\" : [f\"{round(1e6*qvar[d].x):.2f}\" for d in dairy],\n    },\n)\nprice_demand.index=[''] * len(price_demand)\nprice_demand"}]}
{"meta": {"source_path": "/Users/sunyujun03/Desktop/ReLoop/gurobi-modeling-examples/power_generation/optimize_power_schedule.ipynb", "kind": "ipynb", "title": "Optimizing a power generation schedule"}, "messages": [{"role": "system", "content": "You are an optimization engineer. Write correct and runnable Python code using gurobipy (Gurobi Python API). Be concise. Output only what is requested."}, {"role": "user", "content": "    Task: Reproduce the following Gurobi modeling example in Python using gurobipy.\n\n    Scenario description (from source):\n    # Optimizing a power generation schedule\n\nThe electricity grid powers nearly every aspect of modern life — be it charging a phone, powering a factory, or mining Bitcoin.\nEnergy sector decision-makers must ensure a smooth and adequate power supply that caters to the growing power needs of modern life.\nAfter all, with great power comes great responsibility.\n\nManaging the supply and demand of electricity can be a complex and challenging task. Suppose that we are in charge of generating power for the U.S. State of Georgia. Assume that we know the set of all available power plants and the demand for power for each hour of a day. Can we create a schedule to decide how much power each plant should generate, and when to switch the plants \"on\" and \"off\"? How can we do so while minimizing the overall costs?\n\nIn this notebook, we model this decision-making problem using **mathematical optimization**. The first part of the notebook describes the datasets used. We use real data from the State of Georgia with a population of 10.8 million people. The data includes historical demand for power as well as specific information about the power plants.\n\nThe second part of the notebook introduces the three components of a mathematical optimization model: the objective function to be optimized, the decision variables, and the constraints. In our power generation problem, the **objective** is to minimize the overall costs. The **decision variables** model the power generation schedule. The **constraints** capture basic requirements such as ensuring that the power supply meets the demand, as well as practical limitations such as the minimum and maximum production levels for each power plant. By finding the optimally cost-efficient schedule, this model helps power plant operators get the best output from their facilities while minimizing the overall costs.\n\nLet's get started.\n\n## The data\n\nFirst, let us load the following packages needed to process and visualize the data.\n\n    Requirements:\n    - Use gurobipy (Model, GRB, addVar/addConstr, etc.)\n    - Make the script runnable as a standalone Python file if possible.\n    - Keep the code faithful to the example.\n"}, {"role": "assistant", "content": "from PIL import Image\nimport requests\nfrom io import BytesIO\n \nprint('Nuclear power plants. Source: Daniel Prudek / Shutterstock).')  \nimg = Image.open(BytesIO(requests.get('https://github.com/Gurobi/modeling-examples/blob/master/power_generation/image_powerplant.png?raw=true').content))\nimg \n# Image('image_powerplant.png')\n\nimport pandas as pd   \nimport matplotlib.pyplot as plt  \nimport seaborn as sns  \nimport warnings\nwarnings.filterwarnings(\"ignore\")\n\ndf_load_curves = pd.read_csv('https://github.com/Gurobi/modeling-examples/blob/master/power_generation/demand.csv?raw=true') \n# df_load_curves = pd.read_csv('demand.csv')\n\n# select the demand for the chosen day (July 1st, 2011)\ndf_subset = df_load_curves[(df_load_curves['YEAR']==2011)&(df_load_curves['MONTH']==7)&(df_load_curves['DAY']==1)] \n\n# store the demand to a dicionary\nd = df_subset.set_index(['HOUR']).LOAD.to_dict() \n\nH = set(d.keys()) # set of hours in a day (1 through 24)\n\nfig, ax = plt.subplots(figsize=(15,6)) \ndemand_plot = sns.barplot(x=list(range(1,25)), y=[d[h] for h in range(1,25)])\ndemand_plot.set_xticklabels(demand_plot.get_xticklabels());\ndemand_plot.set(xlabel='Hour', ylabel='Demand (MWh)');\nplt.show()\n\ndf_plant_info = pd.read_csv('https://github.com/Gurobi/modeling-examples/blob/master/power_generation/small_plant_data/plant_capacities.csv?raw=true') # replace \"small_plant_data\" with \"large_plant_data\" to use the full dataset\n# df_plant_info = pd.read_csv('small_plant_data/plant_capacities.csv')\n\nP = set(df_plant_info['Plant'].unique())                          # set of all power plants\n\nplant_type = df_plant_info.set_index('Plant').PlantType.to_dict() # plant type for each plant\n\nP_N = set([i for i in P if plant_type[i]=='NUCLEAR'])             # set of all nuclear plants  \n\nfuel_type = df_plant_info.set_index('Plant').FuelType.to_dict()   # fuel type for each plant\n\ndf_plant_info['capacity'] = df_plant_info['Capacity']\nc = df_plant_info.set_index('Plant').capacity.to_dict() # generation capacity   \n\ncapacity_plot = sns.barplot(x=list(c.keys()), y=[c[k] for k in c])\ncapacity_plot.set_xticklabels(capacity_plot.get_xticklabels(), rotation=40);\ncapacity_plot.set(xlabel='Plant', ylabel='Capacity (MWh)');\nplt.show()\n\nm = {i: 0.8 if i in P_N else 0.01 for i in P} # min % generation when on\n\nr = {i: 1 if i in ['BIOMASS','GAS','HYDRO','OIL'] else .2 if i in P_N else .25 for i in P}  # ramp up/down speed (plant)\n\ndf_fuel_costs = pd.read_csv('https://github.com/Gurobi/modeling-examples/blob/master/power_generation/small_plant_data/fuel_costs.csv?raw=true') \n# df_fuel_costs = pd.read_csv('small_plant_data/fuel_costs.csv') \n\n# read the fuel costs and transform it from fuel-type to plant-name\nf = {i: df_fuel_costs[df_fuel_costs['year']==2011].T.to_dict()[9][fuel_type[i]] for i in fuel_type} # dictionary of fuel cost for each plant\n\n# plot the fuel costs\nfuelcost_plot = sns.barplot(x=list(f.keys()), y=[f[k] for k in f])\nfuelcost_plot.set_xticklabels(fuelcost_plot.get_xticklabels(), rotation=40);\nfuelcost_plot.set(xlabel='Plant', ylabel='Fuel cost per MWh ($)');\nplt.show()\n\ndf_oper_costs = pd.read_csv('https://github.com/Gurobi/modeling-examples/blob/master/power_generation/small_plant_data/operating_costs.csv?raw=true')  \n# df_oper_costs = pd.read_csv('small_plant_data/operating_costs.csv')\no = {i: df_oper_costs[df_oper_costs['year']==2011].T.to_dict()[9][fuel_type[i]] for i in fuel_type} # operating cost/MWh (plant)\n\ndf_startup_costs = pd.read_csv('https://github.com/Gurobi/modeling-examples/blob/master/power_generation/small_plant_data/startup_costs.csv?raw=true')  \n# df_startup_costs = pd.read_csv('small_plant_data/startup_costs.csv')\ns = {i: df_startup_costs[df_startup_costs['year']==2011].T.to_dict()[9][fuel_type[i]] for i in fuel_type} # operating cost/MWh (plant)\n \nt = s.copy() # assume that the cost of shuting down = starting up\n\ndf_health_costs = pd.read_csv('https://github.com/Gurobi/modeling-examples/blob/master/power_generation/small_plant_data/health_costs.csv?raw=true')  \n# df_health_costs = pd.read_csv('small_plant_data/health_costs.csv')\na = df_health_costs[(df_health_costs['Year']==2007)&(df_health_costs['Day']==1)].set_index(['Plant','Hour']).to_dict()['Cost'] # operating cost/MWh (plant)\na.update({(i,h): 0 for i in P for h in H if i not in ['Bowen','Jack McDonough','Scherer']})  \n\nfig, ax = plt.subplots(figsize=(15,6)) \nhealthcost_plot = sns.barplot(x=list(range(1,25)), y=[a['Bowen',h] for h in range(1,25)])\nhealthcost_plot.set_xticklabels(healthcost_plot.get_xticklabels());\nhealthcost_plot.set(xlabel='Hour', ylabel='Health costs in Bowen ($)');\nplt.show()\n\nimport gurobipy as gp\nfrom gurobipy import GRB\nmodel = gp.Model(\"powergeneration\")\n\nz = model.addVars(P, H, name=\"z\", lb=0)             # power generated in each plant for each hour\n\nu = model.addVars(P, H, name=\"u\", vtype=GRB.BINARY) # is the plant on? for each plant and hour\n\nv = model.addVars(P, H, name=\"v\", vtype=GRB.BINARY) # start up the plant? for each plant and hour\n\nw = model.addVars(P, H, name=\"w\", vtype=GRB.BINARY) # shut down the plant? for each plant and hour \n\nprint(\"This model has\",len(z)+len(u)+len(v)+len(w),\"decision variables.\")\n\nmodel.update()\n\nobjective = gp.quicksum(f[i]*z[i,h] for i in P for h in H) # fuel cost\nobjective += gp.quicksum(a[i,h]*z[i,h] for i in P for h in H) # health cost\nobjective += gp.quicksum(o[i]*u[i,h] for i in P for h in H) # operating cost\nobjective += gp.quicksum(s[i]*v[i,h] for i in P for h in H) # startup cost\nobjective += gp.quicksum(t[i]*w[i,h] for i in P for h in H) # shutdown cost\nmodel.setObjective(objective, sense=GRB.MINIMIZE)\n\nmodel.addConstrs((gp.quicksum(z[i,h] for i in P) == d[h]) for h in H)  \n\nmodel.update()\n\nmodel.addConstrs((z[i,h] <= c[i]*u[i,h]) for i in P for h in H)  \n\nmodel.addConstrs((z[i,h] >= m[i]*c[i]*u[i,h]) for i in P for h in H)  \n\nmodel.update()\n\nmodel.addConstrs((z[i,h] >= m[i]*c[i]) for i in P_N for h in H)   \n\nmodel.update()\n\nmodel.addConstrs((z[i,h]-z[i,h-1] >= -r[i]*c[i]) for i in P for h in H if h>1)  \n\nmodel.addConstrs((z[i,h]-z[i,h-1] <= r[i]*c[i]) for i in P for h in H if h>1)  \n\nmodel.update()\n\nmodel.addConstrs((v[i,h] <= u[i,h]) for i in P for h in H)  \n\nmodel.addConstrs((w[i,h] <= 1-u[i,h]) for i in P for h in H)    \n\nmodel.update()\n\nmodel.addConstrs((v[i,h] - w[i,h] == u[i,h] - u[i,h-1]) for i in P for h in H if h > 1) \n\nmodel.update()\n\nmodel.optimize()\n\nsolution = pd.DataFrame() \nsolution = pd.DataFrame(columns=['Hour', 'Power (MWh)', 'Plant']) \nplant_hour_pairs = [(h,i) for i in P for h in H  if z[i,h].X > 0] \n            \nsolution['Hour'] = [pair[0] for pair in plant_hour_pairs]\nsolution['Plant'] = [pair[1] for pair in plant_hour_pairs]\nsolution['Power generated (MWh)'] = [z[pair[1],pair[0]].X for pair in plant_hour_pairs]\n            \nprint(\"Power supply:\")\nfig, ax = plt.subplots(figsize=(15,6)) \nsns.pointplot(data=solution,x='Hour', y='Power generated (MWh)', hue='Plant')\nsns.move_legend(ax, \"upper left\", bbox_to_anchor=(1, 1))\nplt.show()\n\nprint(\"Power demand:\")\nfig, ax = plt.subplots(figsize=(15,6)) \ndemand = pd.DataFrame(columns=['Hour', 'Demand (MWh)']) \ndemand['Hour'] = list(H)\ndemand['Demand (MWh)'] = [d[h] for h in H]\nsns.pointplot(data=demand,x='Hour', y='Demand (MWh)')\nplt.show()\n\nprint(\"Fuel costs: $\",round(sum(f[i]*z[i,h].X for i in P for h in H)*10**(-6),2),\"million\")\nprint(\"Health costs: $\",round(sum(a[i,h]*z[i,h].X for i in P for h in H)*10**(-6),2),\"million\")\nprint(\"Operating costs: $\",round(sum(o[i]*u[i,h].X for i in P for h in H),2))\nprint(\"Start-up costs: $\",round(sum(s[i]*v[i,h].X for i in P for h in H),2))\nprint(\"Start-up costs: $\",round(sum(s[i]*w[i,h].X for i in P for h in H),2))\n\nsol = pd.DataFrame()\nplant = 'OTHER COAL'\nsol['hour'] = [h for h in H]\nsol['v[i,h]'] = [v[plant,h].X for h in H]\nsol['w[i,h]'] = [w[plant,h].X for h in H]\nsol['u[i,h]'] = [u[plant,h].X for h in H] \nsol['z[i,h]'] = [z[plant,h].X for h in H] \nsol\n\nimport gurobipy as gp\nfrom gurobipy import GRB\nmodel = gp.Model(\"powergeneration\")\n\n# Define the variables\nz = model.addVars(P,H,name=\"z\", lb=0) # power generated in each plant for each hour \nu = model.addVars(P,H,name=\"u\", vtype=GRB.BINARY, lb=0) # is the plant on? for each plant and hour\nv = model.addVars(P,H,name=\"v\", vtype=GRB.BINARY) # start up the plant? for each plant and hour\nw = model.addVars(P,H,name=\"w\", vtype=GRB.BINARY) # shut down the plant? for each plant and hour \n\n# Set the objective function by adding all the costs \nobjective = gp.quicksum(f[i]*z[i,h] for i in P for h in H) # fuel cost\nobjective += gp.quicksum(a[i,h]*z[i,h] for i in P for h in H) # health cost\nobjective += gp.quicksum(o[i]*u[i,h] for i in P for h in H) # operating cost\nobjective += gp.quicksum(s[i]*v[i,h] for i in P for h in H) # startup cost\nobjective += gp.quicksum(t[i]*w[i,h] for i in P for h in H) # shutdown cost\nmodel.setObjective(objective,sense=GRB.MINIMIZE)\n\n# Set the constraint to meet the demand\nmodel.addConstrs((gp.quicksum(z[i,h] for i in P) == d[h]) for h in H)  \n\n# Set the constraint to set the minimum and maximum generation limits\nmodel.addConstrs((z[i,h] >= m[i]*c[i]*u[i,h]) for i in P for h in H)  \nmodel.addConstrs((z[i,h] <= c[i]*u[i,h]) for i in P for h in H)  \n\n# Set the constraint to always keep the nuclear power plants on\nmodel.addConstrs((z[i,h] >= m[i]*c[i]) for i in P_N for h in H)   \n\n# Set the constraint to ensure that the ramp-up and ramp-down speeds are within limits\nmodel.addConstrs((z[i,h]-z[i,h-1]  >= -r[i]*c[i]) for i in P for h in H if h>1)  \nmodel.addConstrs((z[i,h]-z[i,h-1]  <= r[i]*c[i]) for i in P for h in H if h>1)  \n\n# Set the constraint to ensure that if the plant is turned on, the plant should be on\nmodel.addConstrs((v[i,h] <= u[i,h]) for i in P for h in H)  \n\n# Set the constraint to ensure that if the plant is turned off, the plant should be off\nmodel.addConstrs((w[i,h] <= 1-u[i,h]) for i in P for h in H)  \n\n# Set the constraint to link the startup/shutdown variables (v,w) to the on/off variables (u)\nmodel.addConstrs((v[i,h] - w[i,h] == u[i,h] - u[i,h-1]) for i in P for h in H if h > 1) \n\n# Solve the model\nmodel.optimize()"}]}
{"meta": {"source_path": "/Users/sunyujun03/Desktop/ReLoop/gurobi-modeling-examples/lost_luggage_distribution/lost_luggage_distribution.ipynb", "kind": "ipynb", "title": "Lost Luggage Distribution  Problem"}, "messages": [{"role": "system", "content": "You are an optimization engineer. Write correct and runnable Python code using gurobipy (Gurobi Python API). Be concise. Output only what is requested."}, {"role": "user", "content": "    Task: Reproduce the following Gurobi modeling example in Python using gurobipy.\n\n    Scenario description (from source):\n    # Lost Luggage Distribution  Problem\n\n## Objective and Prerequisites\n\nIn this example, you’ll learn how to use mathematical optimization to solve a vehicle routing problem with time windows, which involves helping a company figure out the minimum number of vans required to deliver pieces of lost or delayed baggage to their rightful owners and determining the optimal assignment of vans to customers.\n\nThis model is example 27 from the fifth edition of Model Building in Mathematical Programming by H. Paul Williams on pages 287-289 and 343-344.\n\nThis modeling example is at the advanced level, where we assume that you know Python and the Gurobi Python API and that you have advanced knowledge of building mathematical optimization models. Typically, the objective function and/or constraints of these examples are complex or require advanced features of the Gurobi Python API.\n\n**Download the Repository** <br /> \nYou can download the repository containing this and other examples by clicking [here](https://github.com/Gurobi/modeling-examples/archive/master.zip).\n\n## Problem Description\n\nA small company with six vans has a contract with a number of airlines to pick up lost or delayed baggage, belonging to customers in the London area, from Heathrow airport at 6 p.m. each evening. The contract stipulates that each customer must have their baggage delivered by 8 p.m. The company requires a model to advise them what is the minimum number of vans they need to use and to which customers each van should deliver and in what order. There is no practical capacity limitation on each van. Each van can hold all baggage that needs to be delivered in a two-hour period. To solve this problem, we can formulate an optimization model that minimizes the number of vans that need to be used.\n\n##  Model Formulation\n\n### Sets and Indices\n\n$i,j \\in \\text{Locations} \\equiv L=\\{0,1..(n-1)\\}$: Set of locations where $0$ is the index for the single depot -Heathrow airport, and $n$ is the number of locations.\n\n$k \\in \\text{Vans} \\equiv  V=\\{0..K-1\\}$: Index and set of vans, where $K$ is the number of vans.\n\n$S_k \\in S  $: Tour of van $k$, i.e. subset of locations visited by the van.\n\n### Parameters\n\n$t_{i,j} \\in \\mathbb{R}^+$: Travel time from location $i$  to location $j$.\n\n### Decision Variables\n\n$x_{i,j,k} \\in \\{0,1 \\}$: This binary variable is equal 1, if van $k$ visits and goes directly from location $i$ to location $j$, and zero otherwise.\n\n$y_{i,k} \\in \\{0,1 \\}$: This binary variable is equal 1, if van $k$ visits location $i$, and zero otherwise.\n\n$z_{k} \\in \\{0,1 \\}$: This binary variable is equal 1, if van $k \\in \\{1,2..K\\}$ is used, and zero otherwise.\n\n### Objective Function\n\n**Number of vans**: Minimize number of vans used.\n\n\\begin{equation}\n\\text{Minimize} \\quad \\sum_{k = 1}^{K} z_k\n\\end{equation}\n\n### Constraints\n\n**Van utilization**: For all locations different from the depot, i.e. $i > 0$, if the location is visited by van $k$, then it is used.\n\n\\begin{equation}\ny_{i,k} \\leq z_{k} \\quad \\forall i \\in L \\setminus \\{0\\}, \\; k \\in V\n\\end{equation}\n\n**Travel time**: No van travels for more than 120 min. Note that we do not consider the travel time to return to the depot.\n\n\\begin{equation}\n\\sum_{i \\in L} \\sum_{j \\in L \\setminus \\{0\\}} t_{i,j} \\cdot x_{i,j,k} \\leq 120 \\quad \\forall k \\in  V\n\\end{equation}\n\n**Visit all customers**:  Each customer location is visited by exactly one van.\n\n\\begin{equation}\n\\sum_{k \\in V}  y_{i,k} = 1 \\quad \\forall i \\in L \\setminus \\{0\\}\n\\end{equation}\n\n**Depot**: Heathrow is visited by every van used. (Note: to improve performance, we diverge from the book by disaggregating this constraint).\n\n\\begin{equation}\ny_{0,k} = z_k \\quad \\forall k \\in V\n\\end{equation}\n\n**Arriving at a location**: If location $j$ is visited by van $k$, then the van is coming from another location $i$.\n\n\\begin{equation}\n\\sum_{i \\in L}  x_{i,j,k} =  y_{j,k}  \\quad \\forall j \\in L, \\; k \\in V\n\\end{equation}\n\n**Leaving a location**: If van $k$ leaves location $j$, then the van is going to another location $i$.\n\n\\begin{equation}\n\\sum_{i \\in L}  x_{j,i,k} = y_{j,k}  \\quad \\forall j \\in L, \\; k \\in V\n\\end{equation}\n\n**Breaking symmetry**: \n\n\\begin{equation}\n\\sum_{i \\in L}  y_{i,k} \\geq \\sum_{i \\in L}  y_{i,k+1} \\quad \\forall k \\in  \\{0..K-1\\}\n\\end{equation}\n\n**Subtour elimination**: These constraints ensure that for each van route, there is no cycle. \n\n\\begin{equation}\n\\sum_{(i,j) \\in S_k}x_{i,j,k} \\leq |S_k|-1 \\quad \\forall  k \\in K, \\;   S_k \\subseteq L\n\\end{equation}\n\n## Python Implementation\n\nWe import the Gurobi Python Module and other Python libraries.\n\n    Requirements:\n    - Use gurobipy (Model, GRB, addVar/addConstr, etc.)\n    - Make the script runnable as a standalone Python file if possible.\n    - Keep the code faithful to the example.\n"}, {"role": "assistant", "content": "import sys\nimport math\nimport random\nfrom itertools import permutations\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# tested with Python 3.7.0 & Gurobi 9.1.0\n\n# number of locations, including the depot. The index of the depot is 0\nn = 17\nlocations = [*range(n)]\n\n# number of vans\nK = 6\nvans = [*range(K)]\n\n# Create n random points\n# Depot is located at (0,0) coordinates\nrandom.seed(1)\npoints = [(0, 0)]\npoints += [(random.randint(0, 50), random.randint(0, 50)) for i in range(n-1)]\n\n# Dictionary of Euclidean distance between each pair of points\n# Assume a speed of 60 km/hr, which is 1 km/min. Hence travel time = distance\ntime = {(i, j):\n        math.sqrt(sum((points[i][k]-points[j][k])**2 for k in range(2)))\n        for i in locations for j in locations if i != j}\n\nm = gp.Model('lost_luggage_distribution')\n\n# Create variables: \n\n# x =1, if van  k  visits and goes directly from location  i  to location  j \nx = m.addVars(time.keys(), vans, vtype=GRB.BINARY, name='FromToBy')\n\n# y = 1, if customer i is visited by van k\ny = m.addVars(locations, vans, vtype=GRB.BINARY, name='visitBy')\n\n# Number of vans used is a decision variable\nz = m.addVars(vans, vtype=GRB.BINARY, name='used')\n\n# Travel time per van\nt = m.addVars(vans, ub=120, name='travelTime')\n\n# Maximum travel time\ns = m.addVar(name='maxTravelTime')\n\n# Van utilization constraint\n\nvisitCustomer = m.addConstrs((y[i,k] <= z[k]  for k in vans for i in locations if i > 0), name='visitCustomer' )\n\n# Travel time constraint\n# Exclude the time to return to the depot\n\ntravelTime = m.addConstrs((gp.quicksum(time[i,j]*x[i,j,k] for i,j in time.keys() if j > 0) == t[k] for k in vans), \n                          name='travelTimeConstr' )\n\n# Visit all customers\nvisitAll = m.addConstrs((y.sum(i,'*') == 1 for i in locations if i > 0), name='visitAll' )\n\n# Depot constraint\ndepotConstr = m.addConstrs((y[0, k] == z[k] for k in vans), name='depotConstr' )\n\n# Arriving at a customer location constraint\nArriveConstr = m.addConstrs((x.sum('*',j,k) == y[j,k] for j,k in y.keys()), name='ArriveConstr' )\n\n# Leaving a customer location constraint\nLeaveConstr = m.addConstrs((x.sum(j,'*',k) == y[j,k] for j,k in y.keys()), name='LeaveConstr' )\n\nbreakSymm = m.addConstrs((y.sum('*',k-1) >= y.sum('*',k) for k in vans if k>0), name='breakSymm' )\n\nmaxTravelTime = m.addConstrs((t[k] <= s for k in vans), name='maxTravelTimeConstr')\n\n# Alternately, as a general constraint:\n# maxTravelTime = m.addConstr(s == gp.max_(t), name='maxTravelTimeConstr')\n\nm.ModelSense = GRB.MINIMIZE\nm.setObjectiveN(z.sum(), 0, priority=1, name=\"Number of vans\")\nm.setObjectiveN(s, 1, priority=0, name=\"Travel time\")\n\n# Callback - use lazy constraints to eliminate sub-tours\ndef subtourelim(model, where):\n    if where == GRB.Callback.MIPSOL:\n        # make a list of edges selected in the solution\n        vals = model.cbGetSolution(model._x)\n        selected = gp.tuplelist((i,j) for i, j, k in model._x.keys()\n                                if vals[i, j, k] > 0.5)\n        # find the shortest cycle in the selected edge list\n        tour = subtour(selected)\n        if len(tour) < n: \n            for k in vans:\n                model.cbLazy(gp.quicksum(model._x[i, j, k]\n                                         for i, j in permutations(tour, 2))\n                             <= len(tour)-1)\n\n\n# Given a tuplelist of edges, find the shortest subtour not containing depot (0)\ndef subtour(edges):\n    unvisited = list(range(1, n))\n    cycle = range(n+1)  # initial length has 1 more city\n    while unvisited:\n        thiscycle = []\n        neighbors = unvisited\n        while neighbors:\n            current = neighbors[0]\n            thiscycle.append(current)\n            if current != 0:\n                unvisited.remove(current)\n            neighbors = [j for i, j in edges.select(current, '*')\n                         if j == 0 or j in unvisited]\n        if 0 not in thiscycle and len(cycle) > len(thiscycle):\n            cycle = thiscycle\n    return cycle\n\n# Verify model formulation\n\nm.write('lost_luggage_distribution.lp')\n\n# Run optimization engine\nm._x = x\nm.Params.LazyConstraints = 1\nm.optimize(subtourelim)\n\n# Print optimal routes\nfor k in vans:\n    route = gp.tuplelist((i,j) for i,j in time.keys() if x[i,j,k].X > 0.5)\n    if route:\n        i = 0\n        print(f\"Route for van {k}: {i}\", end='')\n        while True:\n            i = route.select(i, '*')[0][1]\n            print(f\" -> {i}\", end='')\n            if i == 0:\n                break\n        print(f\". Travel time: {round(t[k].X,2)} min\")\n\nprint(f\"Max travel time: {round(s.X,2)}\")"}]}
{"meta": {"source_path": "/Users/sunyujun03/Desktop/ReLoop/gurobi-modeling-examples/aviation_planning/airlineplanning.ipynb", "kind": "ipynb", "title": "Airline planning after flight disruption"}, "messages": [{"role": "system", "content": "You are an optimization engineer. Write correct and runnable Python code using gurobipy (Gurobi Python API). Be concise. Output only what is requested."}, {"role": "user", "content": "    Task: Reproduce the following Gurobi modeling example in Python using gurobipy.\n\n    Scenario description (from source):\n    Copyright © 2023 Gurobi Optimization, LLC\n\n# Airline planning after flight disruption\n\nWeather events are a major threat to the airline industry. The unpredictable nature of snowstorms, heavy rains, and icy runways make it difficult for aviation planners to make accurate schedules. \nThese events can lead to flight delays and cancellations, causing not only inconvenience for passengers but also significant financial losses for airlines. \nThe 2014 winter polar vortex, for instance, is estimated to have cost the industry and passengers a staggering $1.4 billion in losses due to disrupted flights [(CNBC, 2014)](https://www.cnbc.com/2014/01/08/weather-flight-disruptions-cost-14-billion-data.html). \nThus, managing weather-related issues and having contingency plans in place is critical for the success of any airline business.\n\n<!--  <img height=\"227.4774774774775px\" src=\"https://media3.giphy.com/media/gkAEM5sXCFqB465YWg/giphy.gif?cid=de9bf95e87544fzo1lm01e68i3mxxou95x5zgiewz66hwi45&amp;rid=giphy.gif&amp;ct=g\" width=\"700px\" itemtype=\"http://schema.skype.com/Giphy\" key=\"gif_0\"> -->\n\n |<img src=\"https://raw.githubusercontent.com/Gurobi/modeling-examples/master/aviation_planning/image_snowstorm.jpeg\" width=\"500\" align=\"center\">| \n|:--:|\n| <b>Flight cancellations due to weather delays are more common than we think. Image Credits: [Travel Refund](https://travelrefund.com/articles/when-do-flights-get-cancelled-due-to-weather/) </b>|\n\n    Requirements:\n    - Use gurobipy (Model, GRB, addVar/addConstr, etc.)\n    - Make the script runnable as a standalone Python file if possible.\n    - Keep the code faithful to the example.\n"}, {"role": "assistant", "content": "import pandas as pd    \nimport matplotlib.pyplot as plt  \nimport seaborn as sns  \nimport warnings\nwarnings.filterwarnings(\"ignore\")\nfrom datetime import datetime, timedelta\nimport random\nimport csv\nimport plotly.express as px\n\ndf_current_plan = pd.read_csv('https://raw.githubusercontent.com/Gurobi/modeling-examples/master/aviation_planning/data/flight_rotations_2006-07-01.csv') \n# if you run this notebook locally, you can also use\n#df_current_plan = pd.read_csv('data/flight_rotations_2006-07-01.csv') \n\ndf_current_plan['start_time'] = pd.to_datetime(df_current_plan['start_time'], format='%H:%M')\ndf_current_plan['start_time'] = df_current_plan['start_time'].dt.time\ndf_current_plan['end_time'] = pd.to_datetime(df_current_plan['end_time'], format='%H:%M')\ndf_current_plan['end_time'] = df_current_plan['end_time'].dt.time\ndf_current_plan['duration'] = pd.to_datetime(df_current_plan['duration'], format='%H:%M')\ndf_current_plan['duration'] = df_current_plan['duration'].dt.time\ndf_current_plan\n\nflights = df_current_plan['flight'].unique()\naircrafts = df_current_plan['aircraft'].unique()\nairports = set(df_current_plan['ori'].unique()+df_current_plan['des'].unique())\n\nprint(len(flights),\"flights between\",len(airports),\"airports operated with\",len(aircrafts),\"aircrafts\")\n\nfrom IPython.display import Image, display\nimport networkx as nx\nfrom networkx.drawing.nx_agraph import graphviz_layout\nfrom networkx.drawing.nx_agraph import to_agraph \n \narcs = list(df_current_plan[['ori','des']].itertuples(index=False, name=None)) # store the origin-destination pairs of all the flights\n\nn_airports = 4 # specify how many airports to pick\n    \nG = nx.MultiDiGraph() # create an empty directed graph\nG.add_edges_from(arcs) # add the origin-destination pairs to the graph as directed edges\n\ntop_airports = [i for (i,j) in sorted(G.degree, key=lambda x: x[1], reverse=True)[:n_airports]] # pre-select top airports by their degree\n\nG = G.subgraph(top_airports) # reduce the graph to just the top few airports\n \n# reduce the current plan dataframe to just the top few airports    \ndf_current_plan = df_current_plan[df_current_plan['ori'].isin(top_airports)] \ndf_current_plan = df_current_plan[df_current_plan['des'].isin(top_airports)]\n\n# # visualize the network\n# A_graph = to_agraph(G) \n# A_graph.layout('dot')    \n# display(A_graph) \n \n\nflights = df_current_plan['flight'].unique()\naircrafts = df_current_plan['aircraft'].unique()\nairports = set(df_current_plan['ori'].unique()+df_current_plan['des'].unique())\n\nprint(\"The reduced data has\",len(flights),\"flights between\",len(airports),\"airports operated with\",len(aircrafts),\"aircrafts\")\n\nflight_origin = df_current_plan.set_index('flight')['ori'].to_dict()\nflight_dest = df_current_plan.set_index('flight')['des'].to_dict()\nflight_start_time = df_current_plan.set_index('flight')['start_time'].to_dict()\nflight_end_time = df_current_plan.set_index('flight')['end_time'].to_dict()\n\ndf_starting_positions = pd.read_csv('https://raw.githubusercontent.com/Gurobi/modeling-examples/master/aviation_planning/data/starting_positions.csv')  \n# if you run this notebook locally, you can also use\n#df_starting_positions = pd.read_csv('data/starting_positions.csv')  \naircrafts_startpositions_airc = df_starting_positions.set_index('aircraft')['airport'].to_dict()\n\ndf_ending_positions = pd.read_csv('https://raw.githubusercontent.com/Gurobi/modeling-examples/master/aviation_planning/data/ending_positions.csv')\n# if you run this notebook locally, you can also use\n#df_ending_positions = pd.read_csv('data/ending_positions.csv')\naircrafts_endpositions_airc = df_ending_positions.set_index('aircraft')['airport'].to_dict()\n\ndf_iterinaries = pd.read_csv('https://raw.githubusercontent.com/Gurobi/modeling-examples/master/aviation_planning/data/flight_iterinaries.csv')\n#df_iterinaries = pd.read_csv('data/flight_iterinaries.csv')\ndf_iterinaries['total_cost'] = df_iterinaries['cost']*df_iterinaries['n_pass']\nflight_revenue = df_iterinaries.groupby(['flight'])['total_cost'].agg('sum').to_dict() \nflight_n_pass = df_iterinaries.groupby(['flight'])['n_pass'].agg('sum').to_dict() \ndf_iterinaries\n\nfrom ipywidgets import interact, interactive, fixed, interact_manual\n\naircraft_flights = df_current_plan.groupby(['aircraft']).apply(lambda x: x['flight'].tolist()).to_dict()\nflight_arcs_for_each_aircraft = {}\ndeltaplus_flightarcs = {}\ndeltaminus_flightarcs = {}\nfor a in aircraft_flights:\n    aircraft_flights[a] += ['source_%s'%a,'sink_%s'%a]\n    flight_origin['source_%s'%a] = aircrafts_endpositions_airc[a]\n    flight_dest['source_%s'%a] = aircrafts_startpositions_airc[a]\n    flight_origin['sink_%s'%a] = aircrafts_endpositions_airc[a]\n    flight_dest['sink_%s'%a] = aircrafts_startpositions_airc[a]\n\n    flight_start_time['source_%s'%a] = datetime.strptime('0:0', '%H:%M').time()\n    flight_end_time['source_%s'%a] = datetime.strptime('0:0', '%H:%M').time()\n\n    flight_start_time['sink_%s'%a] = datetime.strptime('23:59', '%H:%M').time()\n    flight_end_time['sink_%s'%a] = datetime.strptime('23:59', '%H:%M').time()\n\n    flight_arcs_for_each_aircraft[a] = []\n    deltaplus_flightarcs[a] = {f: [] for f in aircraft_flights[a]}\n    deltaminus_flightarcs[a] = {f: [] for f in aircraft_flights[a]}\n\n    for f1 in aircraft_flights[a]:\n        for f2 in aircraft_flights[a]:\n            if f1!=f2 and flight_end_time[f1] < flight_start_time[f2] and flight_dest[f1] == flight_origin[f2]: \n                flight_arcs_for_each_aircraft[a].append((f1,f2))\n                deltaplus_flightarcs[a][f1].append(f2)\n                deltaminus_flightarcs[a][f2].append(f1) \n            # allow to connect source and target directly for the case that aircraft is not used at all    \n            elif str(f1).startswith('source') and str(f2).startswith('sink'):\n                flight_arcs_for_each_aircraft[a].append((f1,f2))\n                deltaplus_flightarcs[a][f1].append(f2)\n                deltaminus_flightarcs[a][f2].append(f1)\n\n# packages needed to visualize the DAG\n# uncomment the whole cell in case of troubles\n\ndef visualize_aircraft_network(x): \n    G = nx.DiGraph()\n    G.add_edges_from(flight_arcs_for_each_aircraft[x])\n    plt.figure(figsize=(20,14)) \n    A_graph = to_agraph(G) \n    A_graph.layout('dot')    \n    display(A_graph)             \n    plt.show()\n \ninteract(visualize_aircraft_network, x=aircraft_flights.keys())\n\nimport gurobipy as gp\nfrom gurobipy import GRB\nmodel = gp.Model(\"airline_disruption\")\n \nN = G.nodes()\n\nx, y = {}, {}\nfor a in aircrafts:\n    for f in aircraft_flights[a]:\n        x[a,f] = model.addVar(name=\"x_%s,%s\"%(a,f), vtype=GRB.BINARY)\n\n    for (f1,f2) in flight_arcs_for_each_aircraft[a]:\n        y[a,f1,f2] = model.addVar(name=\"y_%s,%s,%s\"%(a,f1,f2), vtype=GRB.BINARY)\n\nmodel.update()\n\nobjective = gp.quicksum((1-x[a,f])*flight_revenue[f] for a in aircrafts for f in aircraft_flights[a] if f in flight_revenue) # operating cost\nmodel.setObjective(objective, sense=GRB.MINIMIZE)\n\nfor a in aircrafts:\n    model.addConstr(sum(y[a,'source_%s'%a,f2] for f2 in deltaplus_flightarcs[a]['source_%s'%a]) == 1)\n    model.addConstr(sum(y[a,f1,'sink_%s'%a] for f1 in deltaminus_flightarcs[a]['sink_%s'%a]) == 1)\n    for f in aircraft_flights[a]: \n        if str(f)[0] != 's':\n            model.addConstr(sum(y[a,f,f2] for f2 in deltaplus_flightarcs[a][f]) == sum(y[a,f1,f] for f1 in deltaminus_flightarcs[a][f]))\n\nfor a in aircrafts:\n    for f in aircraft_flights[a]:\n        model.addConstr(x[a,f] <= sum(y[a,f,f2] for f2 in deltaplus_flightarcs[a][f])) # flight f is chosen only if it is traversed\n\nalpha = .5 \n\nfor i in N:\n    total_departures = len([f for a in aircrafts for f in aircraft_flights[a] if flight_origin[f] == i])\n    total_arrivals = len([f for a in aircrafts for f in aircraft_flights[a] if flight_dest[f] == i])\n\n    model.addConstr(sum(x[a,f] for a in aircrafts for f in aircraft_flights[a] if flight_origin[f] == i) <= alpha*total_departures)\n    model.addConstr(sum(x[a,f] for a in aircrafts for f in aircraft_flights[a] if flight_dest[f] == i) <= alpha*total_arrivals)\n\nmodel.optimize()\n\noperated_flights = {a: [f for f in aircraft_flights[a] if x[a,f].X > .5 if str(f)[0] != 's'] for a in aircrafts}\n\nprint(\"\\nNet revenue total loss: $\",round(model.objVal/10**6,2),'million')\nprint(\"Optimal number of flights served:\",sum(len(operated_flights[a]) for a in aircrafts))\nprint(\"Optimal number of passengers transported:\",sum(sum(flight_n_pass[f] for f in aircraft_flights[a] if x[a,f].X > .5) for a in aircrafts))\nprint(\"Optimal number of aircrafts utilized:\",sum([1 if len(operated_flights[a]) > 0 else 0 for a in aircrafts]))\n\nimport gurobipy as gp\nfrom gurobipy import GRB\nfrom ipywidgets import interact, interactive, fixed, interact_manual, widgets\n \nN = G.nodes() \n \ndef solve_flight_planning(x):    \n    alpha = x \n    \n    model = gp.Model(\"airline_disruption\")\n    x, y = {}, {}\n    for a in aircrafts:\n        for f in aircraft_flights[a]:\n            x[a,f] = model.addVar(name=\"x_%s,%s\"%(a,f), vtype=GRB.BINARY)\n\n        for (f1,f2) in flight_arcs_for_each_aircraft[a]:\n            y[a,f1,f2] = model.addVar(name=\"y_%s,%s,%s\"%(a,f1,f2), vtype=GRB.BINARY)\n\n    model.update()\n\n    objective = gp.quicksum((1-x[a,f])*flight_revenue[f] for a in aircrafts for f in aircraft_flights[a] if f in flight_revenue) # operating cost\n    model.setObjective(objective, sense=GRB.MINIMIZE)\n\n    for a in aircrafts:\n        model.addConstr(sum(y[a,'source_%s'%a,f2] for f2 in deltaplus_flightarcs[a]['source_%s'%a]) == 1)\n        model.addConstr(sum(y[a,f1,'sink_%s'%a] for f1 in deltaminus_flightarcs[a]['sink_%s'%a]) == 1)\n        for f in aircraft_flights[a]: \n            if str(f)[0] != 's':\n                model.addConstr(sum(y[a,f,f2] for f2 in deltaplus_flightarcs[a][f]) == sum(y[a,f1,f] for f1 in deltaminus_flightarcs[a][f]))\n\n    for a in aircrafts:\n        for f in aircraft_flights[a]:\n            model.addConstr(x[a,f] <= sum(y[a,f,f2] for f2 in deltaplus_flightarcs[a][f])) # flight f is chosen only if it is traversed\n\n\n    for i in N:\n        total_departures = len([f for a in aircrafts for f in aircraft_flights[a] if flight_origin[f] == i])\n        total_arrivals = len([f for a in aircrafts for f in aircraft_flights[a] if flight_dest[f] == i]) \n\n        model.addConstr(sum(x[a,f] for a in aircrafts for f in aircraft_flights[a] if flight_origin[f] == i) <= alpha*total_departures)\n        model.addConstr(sum(x[a,f] for a in aircrafts for f in aircraft_flights[a] if flight_dest[f] == i) <= alpha*total_arrivals)\n\n    model.setParam('OutputFlag', 0)\n    model.optimize()\n\n    operated_flights = {a: [f for f in aircraft_flights[a] if x[a,f].X > .5 if str(f)[0] != 's'] for a in aircrafts}\n    actual_rev = sum(flight_revenue[f] for f in flight_revenue) # operating cost\n    print(\"Loss ($): \",round(model.objVal/10**6,2),'million')\n    print(\"Optimal number of flights served:\",sum(len(operated_flights[a]) for a in aircrafts))\n    print(\"Optimal number of passengers transported:\",sum(sum(flight_n_pass[f] for f in aircraft_flights[a] if x[a,f].X > .5) for a in aircrafts))\n    print(\"Optimal number of aircrafts utilized:\",sum([1 if len(operated_flights[a]) > 0 else 0 for a in aircrafts]))\n    \n    # the following lines are for visualization and needs the package pygraphviz (can be commented in case of troubles)\n    print(\"Full network of operated flights:\")\n    G = nx.MultiDiGraph()\n    arcs=[(flight_origin[f],flight_dest[f]) for a in aircrafts for f in operated_flights[a]] \n     \n    aircraft_color = {aircrafts[i]:\"#\"+''.join([random.choice('0123456789ABCDEF') for j in range(6)]) for i in range(len(aircrafts))}\n    for a in aircrafts:\n        for f in operated_flights[a]:\n            G.add_edge(flight_origin[f],flight_dest[f],color=aircraft_color[a])\n    A_graph = to_agraph(G) \n    A_graph.layout('dot')  \n    display(A_graph)\n\nprint(\"Select a value for the level of disruption at the airports:\\n\")\nprint(\"Select 0 for complete shutdown of all airports; select 1 for business-as-usual.\\n\")\n\ninteract(solve_flight_planning, x=(0,1,0.05))\n\nmodel.dispose()\ngp.disposeDefaultEnv()"}]}
{"meta": {"source_path": "/Users/sunyujun03/Desktop/ReLoop/gurobi-modeling-examples/customer_assignment/customer_assignment.ipynb", "kind": "ipynb", "title": "Customer Assignment Problem"}, "messages": [{"role": "system", "content": "You are an optimization engineer. Write correct and runnable Python code using gurobipy (Gurobi Python API). Be concise. Output only what is requested."}, {"role": "user", "content": "    Task: Reproduce the following Gurobi modeling example in Python using gurobipy.\n\n    Scenario description (from source):\n    # Customer Assignment Problem\n\n## Objective and Prerequisites\n\nSharpen your mathematical optimization modeling skills with this example, in which you will learn how to select the location of facilities based on their proximity to customers. We’ll demonstrate how you can construct a mixed-integer programming (MIP) model of this facility location problem, implement this model in the Gurobi Python API, and generate an optimal solution using the Gurobi Optimizer.\n\nThis modeling example is at the intermediate level, where we assume that you know Python and are familiar with the Gurobi Python API. In addition, you should have some knowledge about building mathematical optimization models.\n\n**Download the Repository** <br /> \nYou can download the repository containing this and other examples by clicking [here](https://github.com/Gurobi/modeling-examples/archive/master.zip). \n\n---\n## Motivation\n\nMany companies in various industries must, at some point, make strategic decisions about where to build facilities to support their operations. For example:\n\n- Producers of goods need to decide how to design their supply chains – which encompass factories, distribution centers, warehouses, and retail stores.\n- Healthcare providers need to determine where to build hospitals to maximize their population coverage.\n\nThese are strategic decisions that are difficult to implement and costly to change because they entail long-term investments. Furthermore, these decisions have a significant impact, both in terms of customer satisfaction and cost management. One of the critical factors to consider in this process is the location of the customers that the company is planning to serve.\n\n---\n## Problem Description\n\nThe Customer Assignment Problem is closely related to the Facility Location Problem, which is concerned with the optimal placement of facilities (from a set of candidate locations) in order to minimize the distance between the company's facilities and the customers. When the facilities have unlimited capacity, customers are assumed to be served by the closest facility. \n\nIn cases where the number of customers considered is too big, the customers can be grouped into clusters. Then, the cluster centers can be used in lieu of the individual customer locations. This pre-processing makes the assumption that all customers belonging to a given cluster will be served by the facility assigned to that cluster. The k-means algorithm can be used for this task, which aims to partition $n$ objects into $k$ distinct and non-overlapping clusters.\n\n---\n## Solution Approach\n\nMathematical optimization is a declarative approach where the modeler formulates a mathematical optimization model that captures the key aspects of a complex decision problem. The Gurobi Optimizer solves such models using state-of-the-art mathematics and computer science. \n\nA mathematical optimization model has five components, namely:\n\n- Sets and indices.\n- Parameters.\n- Decision variables.\n- Objective function(s).\n- Constraints.\n\nWe now present a Binary Integer Programming (BIP) formulation:\n\n### Sets and Indices\n$i \\in I$: Set of customer clusters.\n\n$j \\in J$: Set of potential facility locations.\n\n$\\text{Pairings}= \\{(i,j) \\in I \\times J: \\text{dist}_{i,j} \\leq \\text{threshold}\\}$: Set of allowed pairings\n\n### Parameters\n$\\text{threshold} \\in \\mathbb{R}^+$: Maximum distance for a cluster-facility pairing to be considered.\n\n$\\text{max_facilities} \\in \\mathbb{N}$: Maximum number of facilities to be opened.\n\n$\\text{weight}_i \\in \\mathbb{N}$: Number of customers in cluster $i$.\n\n$\\text{dist}_{i,j} \\in \\mathbb{R}^+$: Distance from cluster $i$ to facility location $j$.\n\n### Decision Variables\n$\\text{select}_j \\in \\{0,1\\}$: 1 if facility location $j$ is selected; 0 otherwise.\n\n$\\text{assign}_{i,j} \\in \\{0,1\\}$: 1 if cluster $i$ is assigned to facility location $j$; 0 otherwise.\n\n### Objective Function\n\n- **Total distance**: Minimize the total distance from clusters to their assigned facility:\n\n\\begin{equation}\n\\text{Min} \\quad Z = \\sum_{(i,j) \\in \\text{Pairings}}\\text{weight}_i \\cdot \\text{dist}_{i,j} \\cdot \\text{assign}_{i,j}\n\\tag{0}\n\\end{equation}\n\n### Constraints\n\n- **Facility limit**: The number of facilities built cannot exceed the limit:\n\n\\begin{equation}\n\\sum_{j}\\text{select}_j \\leq \\text{max_facilities}\n\\tag{1}\n\\end{equation}\n\n- **Open to assign**: Cluster $i$ can only be assigned to facility $j$ if we decide to build that facility:\n\n\\begin{equation}\n\\text{assign}_{i,j} \\leq \\text{select}_{j} \\quad \\forall (i,j) \\in \\text{Pairings}\n\\tag{2}\n\\end{equation}\n\n- **Closest store**: Cluster $i$ must be assigned to exactly one facility:\n\n\\begin{equation}\n\\sum_{j:(i,j) \\in \\text{Pairings}}\\text{assign}_{i,j} = 1 \\quad \\forall i \\in I\n\\tag{3}\n\\end{equation}\n\n---\n## Python Implementation\n\n### Dataset Generation\n\nIn this simple example, we choose random locations for customers and facility candidates. Customers are distributed using Gaussian distributions around a few randomly chosen population centers, whereas facility locations are uniformly distributed.\n\n### Preprocessing\n**Clustering**\n\nTo limit the size of the optimization model, we group individual customers into clusters and optimize on these clusters. Clusters are computed using the K-means algorithm, as implemented in the scikit-learn package.\n\n***Viable Customer-Store Pairings***\n\nSome facilities are just too far away from a cluster center to be relevant, so let's heuristically filter all distances that exceed a given `threshold`:\n\n###  Model Deployment\n\nBuild facilities from among candidate locations to minimize total distance to cluster centers:\n\n    Requirements:\n    - Use gurobipy (Model, GRB, addVar/addConstr, etc.)\n    - Make the script runnable as a standalone Python file if possible.\n    - Keep the code faithful to the example.\n"}, {"role": "assistant", "content": "import random\n\nimport gurobipy as gp\nfrom gurobipy import GRB\n\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom sklearn.cluster import MiniBatchKMeans\n\n# Tested with Gurobi v9.0.0 and Python 3.7.0\n\nseed = 10101\nnum_customers = 50000\nnum_candidates = 20\nmax_facilities = 8\nnum_clusters = 50\nnum_gaussians = 10\nthreshold = 0.99\n\nrandom.seed(seed)\ncustomers_per_gaussian = np.random.multinomial(num_customers,\n                                               [1/num_gaussians]*num_gaussians)\ncustomer_locs = []\nfor i in range(num_gaussians):\n    # each center coordinate in [-0.5, 0.5]\n    center = (random.random()-0.5, random.random()-0.5)\n    customer_locs += [(random.gauss(0,.1) + center[0], random.gauss(0,.1) + center[1])\n                  for i in range(customers_per_gaussian[i])]\n# each candidate coordinate in [-0.5, 0.5]\nfacility_locs = [(random.random()-0.5, random.random()-0.5)\n              for i in range(num_candidates)]\nprint('First customer location:', customer_locs[0])\n\nkmeans = MiniBatchKMeans(n_clusters=num_clusters, init_size=3*num_clusters,\n                         random_state=seed).fit(customer_locs)\nmemberships = list(kmeans.labels_)\ncentroids = list(kmeans.cluster_centers_) # Center point for each cluster\nweights = list(np.histogram(memberships, bins=num_clusters)[0]) # Number of customers in each cluster\nprint('First cluster center:', centroids[0])\nprint('Weights for first 10 clusters:', weights[:10])\n\ndef dist(loc1, loc2):\n    return np.linalg.norm(loc1-loc2, ord=2) # Euclidean distance\n\npairings = {(facility, cluster): dist(facility_locs[facility], centroids[cluster])\n            for facility in range(num_candidates)\n            for cluster in range(num_clusters) \n            if  dist(facility_locs[facility], centroids[cluster]) < threshold}\nprint(\"Number of viable pairings: {0}\".format(len(pairings.keys())))\n\nm = gp.Model(\"Facility location\")\n\n# Decision variables: select facility locations\nselect = m.addVars(range(num_candidates), vtype=GRB.BINARY, name='select')\n# Decision variables: assign customer clusters to a facility location\nassign = m.addVars(pairings.keys(), vtype=GRB.BINARY, name='assign')\n\n# Deploy Objective Function\n# 0. Total distance\nobj = gp.quicksum(weights[cluster]\n               *pairings[facility, cluster]\n               *assign[facility, cluster]\n               for facility, cluster in pairings.keys())\nm.setObjective(obj, GRB.MINIMIZE)\n\n# 1. Facility limit\nm.addConstr(select.sum() <= max_facilities, name=\"Facility_limit\")\n\n# 2. Open to assign\nm.addConstrs((assign[facility, cluster] <= select[facility]\n             for facility, cluster in pairings.keys()),\n            name=\"Open2assign\")\n\n# 3. Closest store\nm.addConstrs((assign.sum('*', cluster) == 1\n             for cluster in range(num_clusters)),\n            name=\"Closest_store\")\n\n# Find the optimal solution\nm.optimize()\n\nplt.figure(figsize=(8,8), dpi=150)\nplt.scatter(*zip(*customer_locs), c='Pink', s=0.5)\nplt.scatter(*zip(*centroids), c='Red', s=10)\nplt.scatter(*zip(*facility_locs), c='Green', s=10)\nassignments = [p for p in pairings if assign[p].x > 0.5]\nfor p in assignments:\n    pts = [facility_locs[p[0]], centroids[p[1]]]\n    plt.plot(*zip(*pts), c='Black', linewidth=0.1)\n\nm.dispose()\ngp.disposeDefaultEnv()"}]}
{"meta": {"source_path": "/Users/sunyujun03/Desktop/ReLoop/gurobi-modeling-examples/food_manufacturing/food_manufacture_1.ipynb", "kind": "ipynb", "title": "Food Manufacture I"}, "messages": [{"role": "system", "content": "You are an optimization engineer. Write correct and runnable Python code using gurobipy (Gurobi Python API). Be concise. Output only what is requested."}, {"role": "user", "content": "    Task: Reproduce the following Gurobi modeling example in Python using gurobipy.\n\n    Scenario description (from source):\n    # Food Manufacture I\n\n## Objective and Prerequisites \n\nIf you’re hungry for a mathematical optimization challenge, then try this food manufacturing problem. You’ll learn how to create an optimal multi-period production plan for a product that requires a number of ingredients – each of which has different costs, restrictions, and features.\n\nMore information on this type of model can be found in example #1 of the fifth edition of Modeling Building in Mathematical Programming by H. P. Williams on pages 253 – 254 and 296 – 298.\n\nThis modeling example is at the intermediate level, where we assume that you know Python and are familiar with the Gurobi Python API. In addition, you should have some knowledge about building mathematical optimization models.\n\n**Download the Repository** <br />\nYou can download the repository containing this and other examples by clicking [here](https://github.com/Gurobi/modeling-examples/archive/master.zip). \n\n---\n## Problem Description\n\nA manufacturer needs to refine several raw oils and blend them together to produce a given food product that can be sold. The raw oils required can be divided into two categories:\n\n| Category        | Oil         |\n| ------------- |-------------| \n| Vegetable oils:|  VEG 1<br>VEG 2 | \n| Non-vegetable oils:     | OIL 1<br>OIL 2<br>OIL 3      |\n\nThe manufacturer can choose to buy raw oils for the current month and/or buy them on the futures market for delivery in a subsequent month. Prices for immediate delivery and in the futures market are given below in USD/ton:\n\n| Month |\tVEG 1 |\tVEG 2 |\tOIL 1 |\tOIL 2 |\tOIL 3|\n| ------------- |-------------| -------------| -------------| -------------| -------------| \n| January| 110 |\t120 |\t130 |\t110 |\t115|\n| February |130 |\t130 |\t110 |\t90|\t115|\n| March |110 |\t140 |\t130 |\t100 |\t95|\n| April |120 |\t110 |\t120 |\t120 |\t125|\n| May | 100 |\t120 |\t150 |\t110 |\t105|\n| June |  \t90 |\t100 |\t140 |\t80| \t135 |\n\nThere are a number of additional factors that must be taken into account. These include:\n\n1. The final food product sells for $\\$150$ per ton.\n2. Each category of oil (vegetable and non-vegetable) needs to be refined on a different production line.\n3. There is limited refinement capacity such that in any given month a maximum of 200 tons of vegetable oils and 250 tons of non-vegetable oils can be refined.\n4. Also, there is no waste in the refinement process, so the sum of the raw oils refined will equal the amount of refined oils available.\n5. The cost of refining the oils may be ignored.\n\nIn addition to the refining limits above, there are limits to the amount of raw oils that can be stored for future use, and there is a cost associated with each ton of oil stored. The limit is 1,000 tons of each raw oil and the storage cost is $\\$5$ per ton per month. The manufacturer cannot store the produced food product or the refined oils.\n\nThe final food product must have a hardness between three and six on a given hardness scale. For the purposes of the model, hardness blends linearly and the hardness of each raw oil is:\n\n|Oils |\tHardness|\n| ------------- |-------------| \n|VEG 1 |\t8.8|\n|VEG 2 |\t6.1|\n|OIL 1 |\t2.0|\n|OIL2 |\t4.2|\n|OIL 3| \t5.0|\n\nAt the start of January, there are 500 tons of each type of raw oil in storage. For the purpose of the model, this should also be the level of raw oils in storage at the end of June.\n\nGiven the above information, what monthly buying and manufacturing decisions should be made in order to maximize profit?\n\n---\n## Model Formulation\n\n### Sets and Indices\n\n$t \\in \\text{Months}=\\{\\text{Jan},\\text{Feb},\\text{Mar},\\text{Apr},\\text{May},\\text{Jun}\\}$: Set of months.\n\n$V=\\{\\text{VEG1},\\text{VEG2}\\}$: Set of vegetable oils.\n\n$N=\\{\\text{OIL1},\\text{OIL2},\\text{OIL3}\\}$: Set of non-vegetable oils.\n\n$o \\in \\text{Oils} = V \\cup N$: Set of oils.\n\n### Parameters\n\n$\\text{price} \\in \\mathbb{R}^+$: Sale price of the final product.\n\n$\\text{init_store} \\in \\mathbb{R}^+$: Initial storage amount in tons.\n\n$\\text{target_store} \\in \\mathbb{R}^+$: Target storage amount in tons.\n\n$\\text{holding_cost} \\in \\mathbb{R}^+$: Monthly cost (in USD/ton/month) of keeping in inventory a ton of oil.\n\n$\\text{veg_cap} \\in \\mathbb{R}^+$: Installed capacity (in tons) to refine vegetable oils.\n\n$\\text{oil_cap} \\in \\mathbb{R}^+$: Installed capacity (in tons) to refine non-vegetable oils.\n\n$\\text{min_hardness} \\in \\mathbb{R}^+$: lowest hardness allowed for the final product.\n\n$\\text{max_hardness} \\in \\mathbb{R}^+$: highest hardness allowed for the final product.\n\n$\\text{hardness}_o \\in \\mathbb{R}^+$: Hardness of oil $o$.\n\n$\\text{cost}_{t,o} \\in \\mathbb{R}^+$: Estimated purchase price for oil $o$ at month $t$.\n\n### Decision Variables\n\n$\\text{produce}_t \\in \\mathbb{R}^+$: Tons of food to produce at month $t$.\n\n$\\text{buy}_{t,o} \\in \\mathbb{R}^+$: Tons of oil $o$ to buy at month $t$.\n\n$\\text{consume}_{t,o} \\in \\mathbb{R}^+$: Tons of oil $o$ to use at month $t$.\n\n$\\text{store}_{t,o} \\in \\mathbb{R}^+$: Tons of oil $o$ to store at month $t$.\n\n### Objective Function\n\n- **Profit**: Maximize the total profit (in USD) of the planning horizon.\n\n\\begin{equation}\n\\text{Maximize} \\quad Z = \\sum_{t \\in \\text{Months}}\\text{price}*\\text{produce}_t - \\sum_{t \\in \\text{Months}}\\sum_{o \\in \\text{Oils}}(\\text{cost}_{t,o}*\\text{consume}_{t,o} + \\text{holding_cost}*\\text{store}_{t,o})\n\\tag{0}\n\\end{equation}\n\n### Constraints\n\n- **Initial Balance:** The Tons of oil $o$ purchased in January and the ones previously stored should be equal to the Tons of said oil consumed and stored in that month.\n\n\\begin{equation}\n\\text{init_store} + \\text{buy}_{Jan,o} = \\text{consume}_{Jan,o} + \\text{store}_{Jan,o} \\quad \\forall o \\in \\text{Oils}\n\\tag{1}\n\\end{equation}\n\n- **Balance:** The Tons of oil $o$ purchased in month $t$ and the ones previously stored should be equal to the Tons of said oil consumed and stored in that month.\n\n\\begin{equation}\n\\text{store}_{t-1,o} + \\text{buy}_{t,o} = \\text{consume}_{t,o} + \\text{store}_{t,o} \\quad \\forall (t,o) \\in \\text{Months} \\setminus \\{\\text{Jan}\\} \\times \\text{Oils}\n\\tag{2}\n\\end{equation}\n\n- **Inventory Target**: The Tons of oil $o$ kept in inventory at the end of the planning horizon should hit the target.\n\n\\begin{equation}\n\\text{store}_{Jun,o} = \\text{target_store} \\quad \\forall o \\in \\text{Oils}\n\\tag{3}\n\\end{equation}\n\n- **Refinement Capacity**: Total Tons of oil $o$ consumed in month $t$ cannot exceed the refinement capacity.\n\n\\begin{equation}\n\\sum_{o \\in V}\\text{consume}_{t,o} \\leq \\text{veg_cap} \\quad \\forall t \\in \\text{Months}\n\\tag{4.1}\n\\end{equation}\n\n\\begin{equation}\n\\sum_{o \\in N}\\text{consume}_{t,o} \\leq \\text{oil_cap} \\quad \\forall t \\in \\text{Months}\n\\tag{4.2}\n\\end{equation}\n\n- **Hardness**: The hardness value of the food produced in month $t$ should be within tolerances.\n\n\\begin{equation}\n\\text{min_hardness}*\\text{produce}_t \\leq \\sum_{o \\in \\text{Oils}} \\text{hardness}_o*\\text{consume}_{t,o} \\leq \\text{max_hardness}*\\text{produce}_t \\quad \\forall t \\in \\text{Months}\n\\tag{5}\n\\end{equation}\n\n- **Mass Conservation**: Total Tons of oil consumed in month $t$ should be equal to the Tons of the food produced in that month.\n\n\\begin{equation}\n\\sum_{o \\in \\text{Oils}}\\text{consume}_{t,o} = \\text{produce}_t \\quad \\forall t \\in \\text{Months}\n\\tag{6}\n\\end{equation}\n\n---\n## Python Implementation\n\nWe import the Gurobi Python Module and other Python libraries.\n\n## Input Data\nWe define all the input data of the model.\n\n## Model Deployment\nWe create a model and the variables. For each period, we create a variable which will take into account the value of the food produced. For each product (5 kinds of oils) and each period, we will create variables for the amount that gets bought, used and, stored.\n\nNext, we insert the constraints. The balance constraints ensure that the amount of oil that is in the storage in the previous period plus the amount that gets purchased equals the amount that is used plus the amount that is stored in the current period (for each oil).\n\n    Requirements:\n    - Use gurobipy (Model, GRB, addVar/addConstr, etc.)\n    - Make the script runnable as a standalone Python file if possible.\n    - Keep the code faithful to the example.\n"}, {"role": "assistant", "content": "import numpy as np\nimport pandas as pd\n\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# tested with Python 3.7 & Gurobi 9\n\n# Parameters\n\nmonths = [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\"]\n\noils = [\"VEG1\", \"VEG2\", \"OIL1\", \"OIL2\", \"OIL3\"]\n\ncost = {\n    ('Jan', 'VEG1'): 110,\n    ('Jan', 'VEG2'): 120,\n    ('Jan', 'OIL1'): 130,\n    ('Jan', 'OIL2'): 110,\n    ('Jan', 'OIL3'): 115,\n    ('Feb', 'VEG1'): 130,\n    ('Feb', 'VEG2'): 130,\n    ('Feb', 'OIL1'): 110,\n    ('Feb', 'OIL2'): 90,\n    ('Feb', 'OIL3'): 115,\n    ('Mar', 'VEG1'): 110,\n    ('Mar', 'VEG2'): 140,\n    ('Mar', 'OIL1'): 130,\n    ('Mar', 'OIL2'): 100,\n    ('Mar', 'OIL3'): 95,\n    ('Apr', 'VEG1'): 120,\n    ('Apr', 'VEG2'): 110,\n    ('Apr', 'OIL1'): 120,\n    ('Apr', 'OIL2'): 120,\n    ('Apr', 'OIL3'): 125,\n    ('May', 'VEG1'): 100,\n    ('May', 'VEG2'): 120,\n    ('May', 'OIL1'): 150,\n    ('May', 'OIL2'): 110,\n    ('May', 'OIL3'): 105,\n    ('Jun', 'VEG1'): 90,\n    ('Jun', 'VEG2'): 100,\n    ('Jun', 'OIL1'): 140,\n    ('Jun', 'OIL2'): 80,\n    ('Jun', 'OIL3'): 135\n}\n\n\nhardness = {\"VEG1\": 8.8, \"VEG2\": 6.1, \"OIL1\": 2.0, \"OIL2\": 4.2, \"OIL3\": 5.0}\n\nprice = 150\ninit_store = 500\ntarget_store = 500\nveg_cap = 200\noil_cap = 250\n\nmin_hardness = 3\nmax_hardness = 6\nholding_cost = 5\n\nfood = gp.Model('Food Manufacture I')\n# Quantity of food produced in each period\nproduce = food.addVars(months, name=\"Produce\")\n# Quantity bought of each product in each period\nbuy = food.addVars(months, oils, name = \"Buy\")\n# Quantity used of each product  in each period\nconsume = food.addVars(months, oils, name = \"Use\")\n# Quantity stored of each product  in each period\nstore = food.addVars(months, oils, name = \"Store\")\n\n#1. Initial Balance\nBalance0 = food.addConstrs((init_store + buy[months[0], oil]\n                 == consume[months[0], oil] + store[months[0], oil]\n                 for oil in oils), \"Initial_Balance\")\n\n#2. Balance\nBalance = food.addConstrs((store[months[months.index(month)-1], oil] + buy[month, oil]\n                 == consume[month, oil] + store[month, oil]\n                 for oil in oils for month in months if month != month[0]), \"Balance\")\n\n#3. Inventory Target\nTargetInv = food.addConstrs((store[months[-1], oil] == target_store for oil in oils),\"End_Balance\")\n\n#4.1 Vegetable Oil Capacity\nVegCapacity = food.addConstrs((gp.quicksum(consume[month, oil] for oil in oils if \"VEG\" in oil)\n                 <= veg_cap for month in months), \"Capacity_Veg\")\n\n#4.2 Non-vegetable Oil Capacity\nNonVegCapacity = food.addConstrs((gp.quicksum(consume[month, oil] for oil in oils if \"OIL\" in oil)\n                 <= oil_cap for month in months), \"Capacity_Oil\")\n\n#5. Hardness\nHardnessMin = food.addConstrs((gp.quicksum(hardness[oil]*consume[month, oil] for oil in oils)\n                 >= min_hardness*produce[month] for month in months), \"Hardness_lower\")\nHardnessMax = food.addConstrs((gp.quicksum(hardness[oil]*consume[month, oil] for oil in oils)\n                 <= max_hardness*produce[month] for month in months), \"Hardness_upper\")\n\n#6. Mass Conservation\nMassConservation = food.addConstrs((consume.sum(month) == produce[month] for month in months), \"Mass_conservation\")\n\n#0. Objective Function\nobj = price*produce.sum() - buy.prod(cost) - holding_cost*store.sum()\nfood.setObjective(obj, GRB.MAXIMIZE) # maximize profit\n\nfood.optimize()\n\nrows = months.copy()\ncolumns = oils.copy()\npurchase_plan = pd.DataFrame(columns=columns, index=rows, data=0.0)\n\nfor month, oil in buy.keys():\n    if (abs(buy[month, oil].x) > 1e-6):\n        purchase_plan.loc[month, oil] = np.round(buy[month, oil].x, 1)\npurchase_plan\n\nrows = months.copy()\ncolumns = oils.copy()\nreqs = pd.DataFrame(columns=columns, index=rows, data=0.0)\n\nfor month, oil in consume.keys():\n    if (abs(consume[month, oil].x) > 1e-6):\n        reqs.loc[month, oil] = np.round(consume[month, oil].x, 1)\nreqs\n\nrows = months.copy()\ncolumns = oils.copy()\nstore_plan = pd.DataFrame(columns=columns, index=rows, data=0.0)\n\nfor month, oil in store.keys():\n    if (abs(store[month, oil].x) > 1e-6):\n        store_plan.loc[month, oil] = np.round(store[month, oil].x, 1)\nstore_plan"}]}
{"meta": {"source_path": "/Users/sunyujun03/Desktop/ReLoop/gurobi-modeling-examples/food_manufacturing/food_manufacture_2.ipynb", "kind": "ipynb", "title": "Food Manufacture II"}, "messages": [{"role": "system", "content": "You are an optimization engineer. Write correct and runnable Python code using gurobipy (Gurobi Python API). Be concise. Output only what is requested."}, {"role": "user", "content": "    Task: Reproduce the following Gurobi modeling example in Python using gurobipy.\n\n    Scenario description (from source):\n    # Food Manufacture II\n\n## Objective and Prerequisites\n\nIn this example, you’ll have to tackle the same problem that you did in “Food Manufacturing I,” but with additional constraints that change the problem type from a linear program (LP) problem to a mixed-integer program (MIP) problem, making it harder to solve.\n\nMore information on this type of model can be found in example #2 of the fifth edition of Modeling Building in Mathematical Programming by H. P. Williams on pages 255 and 299 – 300.\n\nThis modeling example is at the intermediate level, where we assume that you know Python and are familiar with the Gurobi Python API. In addition, you should have some knowledge about building mathematical optimization models.\n\n**Download the Repository** <br /> \nYou can download the repository containing this and other examples by clicking [here](https://github.com/Gurobi/modeling-examples/archive/master.zip). \n\n---\n## Problem Description\n\nA manufacturer needs to refine several raw oils and blend them together to produce a given food product that can be sold. The raw oils needed can be divided into two categories:\n\n| Category        | Oil         |\n| ------------- |-------------| \n| Vegetable oils:|  VEG 1<br>VEG 2 | \n| Non-vegetable oils:     | OIL 1<br>OIL 2<br>OIL 3      |\n\nThe manufacturer can choose to buy raw oils for the current month and/or buy them on the futures market for delivery in a subsequent month. Prices for immediate delivery and in the futures market are given below in USD/ton:\n\n| Month |\tVEG 1 |\tVEG 2 |\tOIL 1 |\tOIL 2 |\tOIL 3|\n| ------------- |-------------| -------------| -------------| -------------| -------------| \n| January| 110 |\t120 |\t130 |\t110 |\t115|\n| February |130 |\t130 |\t110 |\t90|\t115|\n| March |110 |\t140 |\t130 |\t100 |\t95|\n| April |120 |\t110 |\t120 |\t120 |\t125|\n| May | 100 |\t120 |\t150 |\t110 |\t105|\n| June |  \t90 |\t100 |\t140 |\t80| \t135 |\n\nThere are a number of additional factors that must be taken into account. These include:\n\n1. The final food product sells for $\\$150$ per ton.\n2. Each category of oil (vegetable and non-vegetable) needs to be refined on a different production line.\n3. There is limited refinement capacity such that in any given month a maximum of 200 tons of vegetable oils and 250 tons of non-vegetable oils can be refined.\n4. Also, there is no waste in the refinement process, so the sum of the raw oils refined will equal the amount of refined oils available.\n5. The cost of refining the oils may be ignored.\n\nIn addition to the refining limits above, there are limits to the amount of raw oils that can be stored for future use, and there is a cost associated with each ton of oil stored. The limit is 1,000 tons of each raw oil and the storage cost is $\\$5$ per ton per month. The manufacturer cannot store the produced food product or the refined oils.\n\nThe final food product must have a hardness between three and six on a given hardness scale. For the purposes of the model, hardness blends linearly and the hardness of each raw oil is:\n\n|Oils |\tHardness|\n| ------------- |-------------| \n|VEG 1 |\t8.8|\n|VEG 2 |\t6.1|\n|OIL 1 |\t2.0|\n|OIL2 |\t4.2|\n|OIL 3| \t5.0|\n\nAt the start of January, there are 500 tons of each type of raw oil in storage. For the purpose of the model, this should also be the level of raw oils in storage at the end of June.\n\nThis version of the Food Manufacture problem adds the following additional constraints to the first version:\n\n- Condition 1: If an oil is used during a month, the minimum quantity used must be 20 tons.\n- Condition 2: The maximum number of oils used in a month is three.\n- Condition 3: The use of VEG1 or VEG2 in a given month requires the use of OIL3 in that same month.\n\nGiven the above information, what monthly buying and manufacturing decisions should be made in order to maximize profit?\n\n---\n## Model Formulation\n\n### Sets and Indices\n\n$t \\in \\text{Months}=\\{\\text{Jan},\\text{Feb},\\text{Mar},\\text{Apr},\\text{May},\\text{Jun}\\}$: Set of months.\n\n$V=\\{\\text{VEG1},\\text{VEG2}\\}$: Set of vegetable oils.\n\n$N=\\{\\text{OIL1},\\text{OIL2},\\text{OIL3}\\}$: Set of non-vegetable oils.\n\n$o \\in \\text{Oils} = V \\cup N$: Set of oils.\n\n### Parameters\n\n$\\text{price} \\in \\mathbb{R}^+$: Sale price of the final product.\n\n$\\text{init_store} \\in \\mathbb{R}^+$: Initial storage amount in tons.\n\n$\\text{target_store} \\in \\mathbb{R}^+$: Target storage amount in tons.\n\n$\\text{holding_cost} \\in \\mathbb{R}^+$: Monthly cost (in USD/ton/month) of keeping in inventory a ton of oil.\n\n$\\text{min_consume} \\in \\mathbb{R}^+$: Minimum number of tons to consume of a given oil in a month.\n\n$\\text{veg_cap} \\in \\mathbb{R}^+$: Installed capacity (in tons) to refine vegetable oils.\n\n$\\text{oil_cap} \\in \\mathbb{R}^+$: Installed capacity (in tons) to refine non-vegetable oils.\n\n$\\text{min_hardness} \\in \\mathbb{R}^+$: lowest hardness allowed for the final product.\n\n$\\text{max_hardness} \\in \\mathbb{R}^+$: highest hardness allowed for the final product.\n\n$\\text{hardness}_o \\in \\mathbb{R}^+$: Hardness of oil $o$.\n\n$\\text{max_ingredients} \\in \\mathbb{N}$: Maximum number of oil types to consume in a given month.\n\n$\\text{cost}_{t,o} \\in \\mathbb{R}^+$: Estimated purchase price for oil $o$ at month $t$.\n\n### Decision Variables\n\n$\\text{produce}_t \\in \\mathbb{R}^+$: Tons of food to produce at month $t$.\n\n$\\text{buy}_{t,o} \\in \\mathbb{R}^+$: Tons of oil $o$ to buy at month $t$.\n\n$\\text{consume}_{t,o} \\in \\mathbb{R}^+$: Tons of oil $o$ to use at month $t$.\n\n$\\text{store}_{t,o} \\in \\mathbb{R}^+$: Tons of oil $o$ to store at month $t$.\n\n$\\text{use}_{t,o} \\in \\{0,1\\}$: 1 if oil $o$ is used on month $t$, 0 otherwise. \n\n### Objective Function\n\n- **Profit**: Maximize the total profit (in USD) of the planning horizon.\n\n\\begin{equation}\n\\text{Maximize} \\quad Z = \\sum_{t \\in \\text{Months}}\\text{price}*\\text{produce}_t - \\sum_{t \\in \\text{Months}}\\sum_{o \\in \\text{Oils}}(\\text{cost}_{t,o}*\\text{consume}_{t,o} + \\text{holding_cost}*\\text{store}_{t,o})\n\\tag{0}\n\\end{equation}\n\n### Constraints\n\n- **Initial Balance:** The Tons of oil $o$ purchased in January and the ones previously stored should be equal to the Tons of said oil consumed and stored in that month.\n\n\\begin{equation}\n\\text{init store} + \\text{buy}_{Jan,o} = \\text{consume}_{Jan,o} + \\text{store}_{Jan,o} \\quad \\forall o \\in \\text{Oils}\n\\tag{1}\n\\end{equation}\n\n- **Balance:** The Tons of oil $o$ purchased in month $t$ and the ones previously stored should be equal to the Tons of said oil consumed and stored in that month.\n\n\\begin{equation}\n\\text{store}_{t-1,o} + \\text{buy}_{t,o} = \\text{consume}_{t,o} + \\text{store}_{t,o} \\quad \\forall (t,o) \\in \\text{Months} \\setminus \\{\\text{Jan}\\} \\times \\text{Oils}\n\\tag{2}\n\\end{equation}\n\n- **Inventory Target**: The Tons of oil $o$ kept in inventory at the end of the planning horizon should hit the target.\n\n\\begin{equation}\n\\text{store}_{Jun,o} = \\text{target_store} \\quad \\forall o \\in \\text{Oils}\n\\tag{3}\n\\end{equation}\n\n- **Refinement Capacity**: Total Tons of oil $o$ consumed in month $t$ cannot exceed the refinement capacity.\n\n\\begin{equation}\n\\sum_{o \\in V}\\text{consume}_{t,o} \\leq \\text{veg_cap} \\quad \\forall t \\in \\text{Months}\n\\tag{4.1}\n\\end{equation}\n\n\\begin{equation}\n\\sum_{o \\in N}\\text{consume}_{t,o} \\leq \\text{oil_cap} \\quad \\forall t \\in \\text{Months}\n\\tag{4.2}\n\\end{equation}\n\n- **Hardness**: The hardness value of the food produced in month $t$ should be within tolerances.\n\n\\begin{equation}\n\\text{min_hardness}*\\text{produce}_t \\leq \\sum_{o \\in \\text{Oils}} \\text{hardness}_o*\\text{consume}_{t,o} \\leq \\text{max_hardness}*\\text{produce}_t \\quad \\forall t \\in \\text{Months}\n\\tag{5}\n\\end{equation}\n\n- **Mass Conservation**: Total Tons of oil consumed in month $t$ should be equal to the Tons of the food produced in that month.\n\n\\begin{equation}\n\\sum_{o \\in \\text{Oils}}\\text{consume}_{t,o} = \\text{produce}_t \\quad \\forall t \\in \\text{Months}\n\\tag{6}\n\\end{equation}\n\n- **Consumption Range**: Oil $o$ can be consumed in month $t$ if we decide to use it in that month, and the Tons consumed should be between 20 and the refinement capacity for its type. \n\n\\begin{equation}\n\\text{min_consume}*\\text{use}_{t,o} \\leq \\text{consume}_{t,o} \\leq \\text{veg_cap}*\\text{use}_{t,o} \\quad \\forall (t,o) \\in V \\times \\text{Months}\n\\tag{7.1}\n\\end{equation}\n\n\\begin{equation}\n\\text{min_consume}*\\text{use}_{t,o} \\leq \\text{consume}_{t,o} \\leq \\text{oil_cap}*\\text{use}_{t,o} \\quad \\forall (t,o) \\in N \\times \\text{Months}\n\\tag{7.2}\n\\end{equation}\n\n- **Recipe**: The maximum number of oils used in month $t$ must be three.\n\n\\begin{equation}\n\\sum_{o \\in \\text{Oils}}\\text{use}_{t,o} \\leq \\text{max_ingredients} \\quad \\forall t \\in \\text{Months}\n\\tag{8}\n\\end{equation}\n\n- **If-then Constraint**: If oils VEG1 or VEG2 are used in month $t$, then OIL3 must be used in that month.\n\n\\begin{equation}\n\\text{use}_{t,\\text{VEG1}} \\leq \\text{use}_{t,\\text{OIL3}} \\quad \\forall t \\in \\text{Months}\n\\tag{9.1}\n\\end{equation}\n\n\\begin{equation}\n\\text{use}_{t,\\text{VEG2}} \\leq \\text{use}_{t,\\text{OIL3}} \\quad \\forall t \\in \\text{Months}\n\\tag{9.2}\n\\end{equation}\n\n---\n## Python Implementation\nWe import the Gurobi Python Module and other Python libraries.\n\n## Input Data\nWe define all the input data of the model.\n\n## Model Deployment\n\nFor each period, we create a variable which will take into account the value of the food produced. For each product (five kinds of oils) and each period we will create variables for the amount that gets purchased, used, and stored.\n\nFor each period and each product, we need a binary variable, which indicates if this product is used in the current period.\n\nNext, we insert the constraints. The balance constraints ensure that the amount of oil that is in the storage in the previous period plus the amount that gets purchased equals the amount that is used plus the amount that is stored in the current period (for each oil).\n\n    Requirements:\n    - Use gurobipy (Model, GRB, addVar/addConstr, etc.)\n    - Make the script runnable as a standalone Python file if possible.\n    - Keep the code faithful to the example.\n"}, {"role": "assistant", "content": "import numpy as np\nimport pandas as pd\n\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# tested with Python 3.7 & Gurobi 9\n\n# Parameters\n\nmonths = [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\"]\n\noils = [\"VEG1\", \"VEG2\", \"OIL1\", \"OIL2\", \"OIL3\"]\n\ncost = {\n    ('Jan', 'VEG1'): 110,\n    ('Jan', 'VEG2'): 120,\n    ('Jan', 'OIL1'): 130,\n    ('Jan', 'OIL2'): 110,\n    ('Jan', 'OIL3'): 115,\n    ('Feb', 'VEG1'): 130,\n    ('Feb', 'VEG2'): 130,\n    ('Feb', 'OIL1'): 110,\n    ('Feb', 'OIL2'): 90,\n    ('Feb', 'OIL3'): 115,\n    ('Mar', 'VEG1'): 110,\n    ('Mar', 'VEG2'): 140,\n    ('Mar', 'OIL1'): 130,\n    ('Mar', 'OIL2'): 100,\n    ('Mar', 'OIL3'): 95,\n    ('Apr', 'VEG1'): 120,\n    ('Apr', 'VEG2'): 110,\n    ('Apr', 'OIL1'): 120,\n    ('Apr', 'OIL2'): 120,\n    ('Apr', 'OIL3'): 125,\n    ('May', 'VEG1'): 100,\n    ('May', 'VEG2'): 120,\n    ('May', 'OIL1'): 150,\n    ('May', 'OIL2'): 110,\n    ('May', 'OIL3'): 105,\n    ('Jun', 'VEG1'): 90,\n    ('Jun', 'VEG2'): 100,\n    ('Jun', 'OIL1'): 140,\n    ('Jun', 'OIL2'): 80,\n    ('Jun', 'OIL3'): 135\n}\n\n\nhardness = {\"VEG1\": 8.8, \"VEG2\": 6.1, \"OIL1\": 2.0, \"OIL2\": 4.2, \"OIL3\": 5.0}\n\nprice = 150\ninit_store = 500\nveg_cap = 200\noil_cap = 250\n\nmin_hardness = 3\nmax_hardness = 6\nmax_ingredients = 3\nholding_cost = 5\nmin_consume = 20\n\nfood = gp.Model('Food Manufacture II')\n# Quantity of food produced in each period\nproduce = food.addVars(months, name=\"Food\")\n# Quantity bought of each product in each period\nbuy = food.addVars(months, oils, name = \"Buy\")\n# Quantity used of each product  in each period\nconsume = food.addVars(months, oils, name = \"Consume\")\n# Quantity stored of each product  in each period\nstore = food.addVars(months, oils, name = \"Store\")\n# binary variables =1, if consume > 0\nuse = food.addVars(months, oils, vtype=GRB.BINARY, name = \"Use\")\n\n#1. Initial Balance\nBalance0 = food.addConstrs((init_store + buy[months[0], oil]\n                 == consume[months[0], oil] + store[months[0], oil]\n                 for oil in oils), \"Initial_Balance\")\n\n#2.  Balance\nBalance = food.addConstrs((store[months[months.index(month)-1], oil] + buy[month, oil]\n                 == consume[month, oil] + store[month, oil]\n                 for oil in oils for month in months if month != months[0]), \"Balance\")\n\n#3. Inventory Target\nTargetInv = food.addConstrs((store[months[-1], oil] == init_store for oil in oils), \"End_Balance\")\n\n#4.1 Vegetable Oil Capacity\nVegCapacity = food.addConstrs((gp.quicksum(consume[month, oil] for oil in oils if \"VEG\" in oil)\n                 <= veg_cap for month in months), \"Capacity_Veg\")\n\n#4.2 Non-vegetable Oil Capacity\nNonVegCapacity = food.addConstrs((gp.quicksum(consume[month, oil] for oil in oils if \"OIL\" in oil)\n                 <= oil_cap for month in months), \"Capacity_Oil\")\n\n#5. Hardness\nHardnessMin = food.addConstrs((gp.quicksum(hardness[oil]*consume[month, oil] for oil in oils)\n                 >= min_hardness*produce[month] for month in months), \"Hardness_lower\")\nHardnessMax = food.addConstrs((gp.quicksum(hardness[oil]*consume[month, oil] for oil in oils)\n                 <= max_hardness*produce[month] for month in months), \"Hardness_upper\")\n\n#6. Mass Conservation\nMassConservation = food.addConstrs((consume.sum(month) == produce[month] for month in months), \"Mass_conservation\")\n\n#7.1 & 7.2 Consumption Range - Using Gurobi's General Constraints\nfor month in months:\n    for oil in oils:\n        food.addGenConstrIndicator(use[month, oil], 0,\n                                   consume[month, oil] == 0,\n                                   name=\"Lower_bound_{}_{}\".format(month, oil))\n        food.addGenConstrIndicator(use[month, oil], 1,\n                                   consume[month, oil] >=  min_consume,\n                                   name=\"Upper_bound_{}_{}\".format(month, oil))\n\n#8. Recipe\ncondition2 = food.addConstrs((use.sum(month) <= max_ingredients for month in months),\"Recipe\")\n\n#9.1 & 9.2 If-then Constraint\nfor month in months:\n    food.addGenConstrIndicator(use[month, \"VEG1\"], 1,\n                               use[month, \"OIL3\"] == 1,\n                               name = \"If_then_a_{}\".format(month))\n    food.addGenConstrIndicator(use[month, \"VEG2\"], 1,\n                               use[month, \"OIL3\"] == 1,\n                               name = \"If_then_b_{}\".format(month))\n\n#0. Objective Function\nobj = price*produce.sum() - buy.prod(cost) - holding_cost*store.sum()\nfood.setObjective(obj, GRB.MAXIMIZE) # maximize profit\n\nfood.optimize()\n\nrows = months.copy()\ncolumns = oils.copy()\npurchase_plan = pd.DataFrame(columns=columns, index=rows, data=0.0)\n\nfor month, oil in buy.keys():\n    if (abs(buy[month, oil].x) > 1e-6):\n        purchase_plan.loc[month, oil] = np.round(buy[month, oil].x, 1)\npurchase_plan\n\nrows = months.copy()\ncolumns = oils.copy()\nreqs = pd.DataFrame(columns=columns, index=rows, data=0.0)\n\nfor month, oil in consume.keys():\n    if (abs(consume[month, oil].x) > 1e-6):\n        reqs.loc[month, oil] = np.round(consume[month, oil].x, 1)\nreqs\n\nrows = months.copy()\ncolumns = oils.copy()\nstore_plan = pd.DataFrame(columns=columns, index=rows, data=0.0)\n\nfor month, oil in store.keys():\n    if (abs(store[month, oil].x) > 1e-6):\n        store_plan.loc[month, oil] = np.round(store[month, oil].x, 1)\nstore_plan"}]}
{"meta": {"source_path": "/Users/sunyujun03/Desktop/ReLoop/gurobi-modeling-examples/intro_to_gurobipy/intro_to_gurobipy.ipynb", "kind": "ipynb", "title": "Introduction to Gurobi Python API"}, "messages": [{"role": "system", "content": "You are an optimization engineer. Write correct and runnable Python code using gurobipy (Gurobi Python API). Be concise. Output only what is requested."}, {"role": "user", "content": "    Task: Reproduce the following Gurobi modeling example in Python using gurobipy.\n\n    Scenario description (from source):\n    # Introduction to Gurobi Python API\n\n###### Gurobi Days Digital\n###### June 24, 2026\n###### Maliheh Aramon, PhD, Optimization Engineer\n###### aramon@gurobi.com\n\n## How to Run the Notebook locally?\n- Visit [Gurobi modeling-examples](https://github.com/Gurobi/modeling-examples) repository \n- Clone the repository which contains this notebook and other examples or download it\nby clicking [here](https://github.com/Gurobi/modeling-examples/archive/refs/heads/master.zip)\n- Navigate to folder __intro_to_gurobipy__\n- [Start Jupyter Notebook Server](https://docs.jupyter.org/en/latest/running.html#id2)\n- Open the notebook in Jupyter Notebook\n- The notebook will install the gurobipy package and other dependencies. The Gurobi pip package includes a size-limited trial license that will allow you to run the notebook\n\n# Gurobi Python API\n\nGurobi Python API, also known as _gurobipy_ is the most popular Gurobi API because it allows building the model with\n- individual variables and constraints like other Guorbi's object-oriented APIs such as C, C++, Java, and .NET\n- matrices like other Gurobi's matrix-oriented interfaces such as MATLAB and R\n- more detailed mathematical syntax like traditional modeling languages\n\nIn this session, we will walk you through the basics of the Gurobi Python API.\n\n## How to Install gurobipy?\n\nThere are two main approaches to install gurobipy on any operating systems such as Linux, Windows, or macOS.\n\n- Pip\n- Conda\n\nRelevant Knowledge Base (KB) articles:\n- [Which Python versions are supported by Gurobi?](https://support.gurobi.com/hc/en-us/articles/360013195212)\n- [How do I install Gurobi for Python?](https://support.gurobi.com/hc/en-us/articles/360044290292-How-do-I-install-Gurobi-for-Python-)\n\n    Requirements:\n    - Use gurobipy (Model, GRB, addVar/addConstr, etc.)\n    - Make the script runnable as a standalone Python file if possible.\n    - Keep the code faithful to the example.\n"}, {"role": "assistant", "content": "# Install other dependencies\n\n# Import gurobipy package as gp for convenience\nimport gurobipy as gp\n\n# GRB is the list of all Gurobi constants\nfrom gurobipy import GRB\n\n# Create a Gurobi environment and a model object\nwith gp.Env() as env, gp.Model(\"simple-example\", env=env) as model:\n    # Define decision variables\n    x = model.addVar(vtype=GRB.BINARY, name=\"x\")\n    y = model.addVar(vtype=GRB.BINARY, name=\"y\")\n    z = model.addVar(vtype=GRB.BINARY, name=\"z\")\n\n    # Define constraints\n    model.addConstr(x + 2 * y + 3 * z <= 4, name=\"c0\")\n    model.addConstr(x + y >= 1, name=\"c1\")\n\n    # Define objective\n    model.setObjective(x + y + 2 * z, sense=GRB.MAXIMIZE)\n\n    # Optimize model\n    model.optimize()\n\n    print(\"******* Solution *******\")\n    for var in model.getVars():\n        print(f\"{var.VarName}: {var.X}\")\n    print(\"************************\")\n\nimport gurobipy as gp\nfrom gurobipy import GRB\n\ndata = gp.tupledict(\n    [\n        ((\"a\", \"b\", \"c\"), 3),\n        ((\"a\", \"c\", \"b\"), 4),\n        ((\"b\", \"a\", \"c\"), 5),\n        ((\"b\", \"c\", \"a\"), 6),\n        ((\"c\", \"a\", \"b\"), 7),\n        ((\"c\", \"b\", \"a\"), 3),\n    ]\n)\nprint(f\"data: {data}\")\n\nprint(\"\\nTuplelist:\")\nkeys = gp.tuplelist(data.keys())\nprint(f\"\\tselect: {keys.select('a', '*', '*')}\")\n\nprint(\"\\nTupledict:\")\nprint(f\"\\tselect  : {data.select('a', '*', '*')}\")\nprint(f\"\\tsum     : {data.sum('*', '*', '*')}\")\ncoeff = {(\"a\", \"c\", \"b\"): 6, (\"b\", \"c\", \"a\"): -4}\nprint(f\"\\tprod    : {data.prod(coeff, '*', 'c', '*')}\")\n\narcs, capacity, cost = gp.multidict(\n    {\n        (\"Detroit\", \"Boston\"): [100, 7],\n        (\"Detroit\", \"New York\"): [80, 5],\n        (\"Detroit\", \"Seattle\"): [120, 4],\n        (\"Denver\", \"Boston\"): [120, 8],\n        (\"Denver\", \"New York\"): [120, 11],\n        (\"Denver\", \"Seattle\"): [120, 4],\n    }\n)\nprint(\"\\nMultidict:\")\nprint(f\"\\tcapacity: {capacity}\")\nprint(\"\\n\")\nprint(f\"\\tcost: {cost}\")\n\nimport gurobipy as gp\n\n# Build a model object with the default environment\nwith gp.Model(name=\"model\") as model:\n    pass\n\nmodel = gp.Model(name=\"model\")\nmodel.dispose()\ngp.disposeDefaultEnv()\n\n# Build a model object with a new environment\nwith gp.Env() as env, gp.Model(name=\"model\", env=env) as model:\n    pass\n\nenv = gp.Env()\nmodel = gp.Model(name=\"model\", env=env)\nmodel.dispose()\nenv.dispose()\n\nimport gurobipy as gp\nfrom gurobipy import GRB\n\nwith gp.Model(name=\"model\") as model:\n    # Define a binary decision variable\n    x = model.addVar(vtype=GRB.BINARY, name=\"x\")\n    # Define an integer variable with lb=-1, ub=100\n    y = model.addVar(lb=-1, ub=100, vtype=GRB.INTEGER, name=\"y\")\n\nimport gurobipy as gp\nfrom gurobipy import GRB\n\nwith gp.Model(name=\"model\") as model:\n    # 3D array of binary variables\n    x = model.addVars(2, 3, 4, vtype=GRB.BINARY, name=\"x\")\n    model.update()\n    print(model.getAttr(\"VarName\", model.getVars()))\n\n    # Use arbitrary lists of immutable objects to create a tupledict of 6 variables\n    y = model.addVars([1, 5], [7, 3, 2], ub=range(6), name=[f\"y_{i}\" for i in range(6)])\n    model.update()\n    print(\"\\nVariables names, upper bounds, and indices:\")\n    for index, var in y.items():\n        print(f\"name: {var.VarName}, ub: {var.UB}, index: {index}\")\n\n    # Use arbitrary list of tuples as indices\n    z = model.addVars(\n        [(3, \"a\"), (3, \"b\"), (7, \"b\"), (7, \"c\")],\n        lb=-GRB.INFINITY,\n        ub=GRB.INFINITY,\n        name=\"z\",\n    )\n    model.update()\n    print(\"\\nVariables names and lower and upper bounds:\")\n    for index, var in z.items():\n        print(f\"name: {var.VarName}, lb: {var.LB}, ub: {var.UB}\")\n\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# Add constraint \"\\sum_{i=1}^{n} x_i <= b\" for any given n and b. Assume x_i are binary variables\nn, b = 10, 4\nwith gp.Model(\"model\") as model:\n    x = model.addVars(n, vtype=GRB.BINARY, name=\"x\")\n    model.addConstr(gp.quicksum(x[i] for i in range(n)) <= b, name=\"c1\")\n    model.update()\n\n    # Print the LHS, Sense, and RHS of c1\n    c1 = model.getConstrByName(\"c1\")\n    print(f\"RHS, sense = {c1.RHS}, {c1.Sense}\")\n    print(f\"row: {model.getRow(c1)}\")\n    print(\"\\n\\n\")\n\n# Add constraints \"x_i + y_j - x_i*y_j >= 3\". Asssume x_i and y_j are continuous\nn, m = 5, 4\nwith gp.Model(\"model\") as model:\n    x = model.addVars(n, name=\"x\")\n    y = model.addVars(m, name=\"y\")\n\n    for i in range(n):\n        for j in range(m):\n            model.addConstr(x[i] + y[j] - x[i] * y[j] >= 3, name=f\"c_{i}{j}\")\n\n    model.update()\n\n    # Print the LHS, Sense, and RHS of all c_ij constraints\n    for c in model.getQConstrs():\n        print(f\"Name: {c.QCName}\")\n        print(f\"\\tRHS, sense = {c.QCRHS}, {c.QCSense}\")\n        print(f\"\\trow: {model.getQCRow(c)}\")\n\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# Add constraints x_i + y_j <= 1 for all (i, j). Assume x_i and y_j are binary variables\nI = range(5)\nJ = [\"a\", \"b\", \"c\"]\nwith gp.Model(\"model\") as model:\n    x = model.addVars(I, vtype=GRB.BINARY, name=\"x\")\n    y = model.addVars(J, vtype=GRB.BINARY, name=\"y\")\n\n    generator = (x[i] + y[j] <= 1 for i in I for j in J)\n    model.addConstrs(generator, name=\"c\")\n    model.update()\n\n    # Print constraint names\n    print(model.getAttr(\"ConstrName\", model.getConstrs()))\n\nimport gurobipy as gp\nfrom gurobipy import GRB\n\nimport numpy as np\n\n# Add linear objectives in the form c^Tx and quadratic objective in the form x^T Q x\nn = 10\nc = np.random.rand(n)\nQ = np.random.rand(n, n)\n\nwith gp.Model(\"model\") as model:\n    x = model.addVars(n, name=\"x\")\n    linexpr = gp.quicksum(c[i] * x[i] for i in range(n))\n    # linexpr = gp.quicksum(c_i * x_i for c_i, x_i in zip(c, x.values()))\n    model.setObjective(linexpr)\n    model.update()\n\n    # Print objective expression\n    obj = model.getObjective()\n    print(f\"obj: {obj}\")\n\nwith gp.Model(\"model\") as model:\n    x = model.addVars(n, name=\"x\")\n    quadexpr = 0\n    for i in range(n):\n        for j in range(n):\n            quadexpr += x[i] * Q[i, j] * x[j]\n    model.setObjective(quadexpr)\n    model.update()\n\n    # Print objective expression\n    obj = model.getObjective()\n    print(f\"\\nobj: {obj}\")\n\nimport urllib.request\nimport gurobipy as gp\nfrom gurobipy import GRB\n\nurl = \"https://raw.githubusercontent.com/Gurobi/modeling-examples/master/intro_to_gurobipy/data/glass4.mps.bz2\"\npath_to_file, _ = urllib.request.urlretrieve(url, \"./glass4.mps.bz2\")\n\n# running notebook locally:\n# with gp.read(\"data/glass4.mps.bz2\") as model:\nwith gp.read(path_to_file) as model:\n    model.optimize()\n\n    print(\"****************** SOLUTION ******************\")\n    print(f\"\\tStatus       : {model.Status}\")\n    print(f\"\\tObj          : {model.ObjVal}\")\n    print(f\"\\tSolutionCount: {model.SolCount}\")\n    print(f\"\\tRuntime      : {model.Runtime}\")\n    print(f\"\\tMIPGap       : {model.MIPGap}\")\n\n    print(\"\\n\")\n    for var in model.getVars()[:20]:\n        print(f\"\\t{var.VarName} = {var.X}\")\n\nimport urllib.request\nimport gurobipy as gp\nfrom gurobipy import GRB\n\nurl = \"https://raw.githubusercontent.com/Gurobi/modeling-examples/master/intro_to_gurobipy/data/glass4.mps.bz2\"\npath_to_file, _ = urllib.request.urlretrieve(url, \"./glass4.mps.bz2\")\n\n# running notebook locally:\n# with gp.read(\"data/glass4.mps.bz2\") as model:\nwith gp.read(path_to_file) as model:\n    model.params.Threads = 1\n    model.params.TimeLimit = 10\n    model.optimize()\n\n# Consider the following nonconvex nonlinear problem\n#\n#  maximize    2 x    + y\n#  subject to  exp(x) + 4 sqrt(y) <= 9\n#              x, y >= 0\n\nimport gurobipy as gp\nfrom gurobipy import GRB\nimport math\n\nwith gp.Model(\"model\") as model:\n    x = model.addVar(name=\"x\")\n    y = model.addVar(name=\"y\")\n    u = model.addVar(name=\"u\")\n    v = model.addVar(name=\"v\")\n\n    # Set objective\n    model.setObjective(2 * x + y, GRB.MAXIMIZE)\n\n    # u = exp(x)\n    gcf1 = model.addGenConstrExp(x, u, name=\"gcf1\")\n    # v = y^(0.5)\n    gcf2 = model.addGenConstrPow(y, v, 0.5, name=\"gcf2\")\n    c = model.addConstr(u + 4 * v <= 9)\n\n    # Use the equal piece length approach with the length = 1e-3\n    model.Params.FuncPieces = 1\n    model.Params.FuncPieceLength = 1e-3\n\n    # Optimize the model\n    model.optimize()\n\n    print(\"****************** SOLUTION ******************\")\n    print(f\"x = {x.X}, u = {u.X}\")\n    print(f\"y = {y.X}, v = {v.X}\")\n    print(f\"Obj = {model.ObjVal}\")\n\n    # Calculate violation of exp(x) + 4 sqrt(y) <= 9\n    vio = math.exp(x.X) + 4 * math.sqrt(y.X) - 9\n    if vio < 0:\n        vio = 0\n    print(f\"Vio = {vio}\")\n\nimport json\nfrom urllib.request import urlopen\nimport numpy as np\n\nurl = \"https://raw.githubusercontent.com/Gurobi/modeling-examples/master/intro_to_gurobipy/data/portfolio-example.json\"\nresponse = urlopen(url)\ndata = json.loads(response.read())\n\nn = data[\"num_assets\"]\nsigma = np.array(data[\"covariance\"])\nmu = np.array(data[\"expected_return\"])\nmu_0 = data[\"target_return\"]\nk = data[\"portfolio_max_size\"]\n\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# Write the solution to a pandas.DataFrame\nimport pandas as pd\n\nwith gp.Model(\"term-based\") as model:\n    x = model.addVars(n, ub=1, name=\"x\")\n    y = model.addVars(n, vtype=GRB.BINARY, name=\"y\")\n\n    risk = gp.quicksum(x[i] * sigma[i, j] * x[j] for i in range(n) for j in range(n))\n    # Another approach to build the risk expression\n    # risk = gp.QuadExpr()\n    # for i in range(n):\n    #    for j in range(n):\n    #        risk.addTerms(sigma[i, j], x[i], x[j])\n    model.setObjective(risk)\n\n    expected_return = gp.quicksum(mu[i] * x[i] for i in range(n))\n    model.addConstr(expected_return >= mu_0, name=\"return\")\n\n    model.addConstr(x.sum() == 1, name=\"budget\")\n    # Another approach to build the budget constraint\n    # model.addConstr(gp.quicksum(x[i] for i in range(n)) == 1, name=\"budget\")\n\n    model.addConstr(y.sum() <= k, name=\"cardinality\")\n\n    model.addConstrs((x[i] <= y[i] for i in range(n)), name=\"is_allocated\")\n\n    model.optimize()\n\n    # Write the solution into a DataFrame\n    portfolio = [var.X for var in model.getVars() if \"x\" in var.VarName]\n    risk = model.ObjVal\n    expected_return = model.getRow(model.getConstrByName(\"return\")).getValue()\n    df = pd.DataFrame(\n        data=portfolio + [risk, expected_return],\n        index=[f\"asset_{i}\" for i in range(n)] + [\"risk\", \"return\"],\n        columns=[\"Portfolio\"],\n    )\n\n    print(df)"}]}
{"meta": {"source_path": "/Users/sunyujun03/Desktop/ReLoop/gurobi-modeling-examples/farm_planning/farm_planning.ipynb", "kind": "ipynb", "title": "Farm Planning"}, "messages": [{"role": "system", "content": "You are an optimization engineer. Write correct and runnable Python code using gurobipy (Gurobi Python API). Be concise. Output only what is requested."}, {"role": "user", "content": "    Task: Reproduce the following Gurobi modeling example in Python using gurobipy.\n\n    Scenario description (from source):\n    # Farm Planning\n\n## Objective and Prerequisites\n\nCultivate your modeling skills with this example, where you’ll learn how to solve a complex, multi-period production planning problem that involves optimizing the operations of a farm over five years.\n\nMore information on this type of model can be found in example #8 of the fifth edition of Model Building in Mathematical Programming by H. Paul Williams on pages 262 – 263 and 312 – 315.\n\nThis modeling example is at the advanced level, where we assume that you know Python and the Gurobi Python API and that you have advanced knowledge of building mathematical optimization models. Typically, the objective function and/or constraints of these examples are complex or require advanced features of the Gurobi Python API.\n\n**Download the Repository** <br /> You can download the repository containing this and other examples by clicking [here](https://github.com/Gurobi/modeling-examples/archive/master.zip). \n\n---\n## Problem Description\n\nA farmer with a 200-acre farm wishes to create a five-year production plan.\n\nCurrently, he has a herd of 120 cows comprising 20 heifers (young female cows) and 100 adult dairy cows. Each heifer requires 2/3 of an acre to support it and each dairy cow requires one acre.\n\nOn average, a dairy cow produces 1.1 calves per year. Half of these calves will be bullocks that are sold shortly after birth for an average of $\\$30$ each. The remaining calves, heifers, can either be sold for $\\$40$ or raised until age two when they will become dairy cows. For the current year, all heifers identified for sale have already been sold.\n\nThe general practice is to sell all dairy cows at the age of 12 for an average of $\\$120$ each. However, each year an average of $5\\%$ of heifers and $2\\%$ of dairy cows die. At present, the farmer’s herd of 120 cows is evenly distributed with 10 cows per age from newborn to 11 years old.\n\nThe milk from a dairy cow can be sold for $\\$370$ annually. The farmer can currently house up to 130 cows, but this capacity limit can be increased for $\\$200$ per additional cow.\n\nEach dairy cow requires 0.6 tons of grain and 0.7 tons of sugar beet per year. Both of these can be grown on the farm. Each acre can yield 1.5 tons of sugar beet. However, only 80 acres are suitable for growing grain, and those acres have different levels of productivity as follows:\n\n| Land Group | Area (Acres) | Grain Production (Tons/Acre) |\n| --- | --- | --- |\n| Group 1 | 20 | 1.10 |\n| Group 2 | 30 | 0.90 |\n| Group 3 | 20 | 0.80 |\n| Group 4 | 10 | 0.65 |\n\nSugar beet can be bought for $\\$70$ a ton and sold for $\\$58$ a ton. Grain can be bought for $\\$90$ a ton and sold for $\\$75$ a ton.\n\nThe annual labor requirements for cows as well as grain and sugar beet production are as follows:\n\n| <i></i> | Labor Required (Hr/Year) |\n| --- | --- |\n| Heifer | 10 |\n| Milk-producing Cow | 42 |\n| Acre Devoted to Grain | 4 |\n| Acre Devoted to Sugar Beet| 14 |\n\nOther annual costs are as follows:\n\n| <i></i> | Cost (USD/Year) |\n| --- | --- |\n| Heifer | 50 |\n| Milk-producing Cow | 100 |\n| Acre Devoted to Grain | 15 |\n| Acre Devoted to Sugar Beet| 10 |\n\nLabor currently costs the farmer $\\$4000$ per year and that cost provides 5,500 hours of labor. Additional labor can be paid for at the rate of $\\$1.20$ per hour.\n\nAny capital expenditure can be financed with a 10-year loan at $15\\%$ interest annually. The interest and principal are paid back in 10 equal annual payments. It is prohibited for the annual cash flow to be negative.\n\nThe farmer does not want to reduce the total number of dairy cows at the end of the five-year period by more than $50\\%$, nor does he want to increase their number by more than $75\\%$.\n\nWhat plan should the farmer follow over the next five years in order to maximize profit?\n\n---\n## Model Formulation\n\n### Sets and Indices\n\n$t \\in \\text{Years}=\\{1,2,\\dots,5\\}$: Set of years.\n\n$l \\in \\text{Lands}=\\{1,2,3,4\\}$: Set of land groups.\n\n$k \\in \\text{Ages}=\\{1,2,\\dots,12\\}$: Set of cow ages.\n\n### Parameters\n\n$\\text{Installment} \\in \\mathbb{R}^+$: Annual payment for each $\\$200$ loan. It can be computed as follows.\n\n$$\n\\text{Installment}= \\text{Loan}*r*\\frac{(1+r)^n}{(1+r)^n-1},\n$$\n\nwhere $\\text{Loan}$ is the loan amount of $\\$200$, $r$ is the interest rate of $15\\%$, and $n$ represents the ten-year period. Note that the book reports a value of $\\$39.71$ instead of $\\$39.85$.\n\n$\\text{Housing_cap} \\in \\mathbb{N}$: Number of cows that can be housed.\n\n$\\text{Land_cap} \\in \\mathbb{R}^+$: Land available (in Acres).\n\n$\\text{Labor_cap} \\in \\mathbb{R}^+$: Regular labor available (in hours) in a year.\n\n$\\text{GR_intake} \\in \\mathbb{R}^+$: Tons of grain consumed by a dairy cow in a year.\n\n$\\text{SB_intake} \\in \\mathbb{R}^+$: Tons of sugar beet consumed by a dairy cow in a year.\n\n$\\text{HF_land} \\in \\mathbb{R}^+$: Acres required for sustaining each heifer.\n\n$\\text{HF_labor} \\in \\mathbb{R}^+$: Hours of labor required in a year by each heifer.\n\n$\\text{Cow_labor} \\in \\mathbb{R}^+$: Hours of labor required in a year by each dairy cow.\n\n$\\text{GR_labor} \\in \\mathbb{R}^+$: Hours of labor required in a year by each acre of land devoted to grains.\n\n$\\text{SB_labor} \\in \\mathbb{R}^+$: Hours of labor required in a year by each acre of land devoted to sugar beet.\n\n$\\text{HF_decay} \\in [0,1] \\subset \\mathbb{R}^+$: Average proportion of heifers that die in a year.\n\n$\\text{Cow_decay} \\in [0,1] \\subset \\mathbb{R}^+$: Average proportion of dairy cows that die in a year.\n\n$\\text{Birthrate} \\in \\mathbb{R}^+$: Expected number of calves produced by a dairy cow in a year.\n\n$\\text{Min_final_cows} \\in \\mathbb{N}$: Minimum number of dairy cows at the end of the planning horizon.\n\n$\\text{Max_final_cows} \\in \\mathbb{N}$: Maximum number of dairy cows at the end of the planning horizon.\n\n$\\text{Initial_HF} \\in \\mathbb{R}^+$: Number of heifers of each age at the beginning of the planning horizon.\n\n$\\text{Initial_cows} \\in \\mathbb{R}^+$: Number of dairy cows of each age at the beginning of the planning horizon.\n\n$\\text{BL_price} \\in \\mathbb{R}^+$: Price for selling one bullock.\n\n$\\text{HF_price} \\in \\mathbb{R}^+$: Price for selling one heifer.\n\n$\\text{Cow_price} \\in \\mathbb{R}^+$: Price for selling one dairy cow.\n\n$\\text{Milk_price} \\in \\mathbb{R}^+$: Price for selling the milk produced by a dairy cow in a year.\n\n$\\text{GR_price} \\in \\mathbb{R}^+$: Price for selling a ton of grain.\n\n$\\text{SB_price} \\in \\mathbb{R}^+$: Price for selling a ton of sugar beet.\n\n$\\text{GR_cost} \\in \\mathbb{R}^+$: Cost for purchasing a ton of grain.\n\n$\\text{SB_cost} \\in \\mathbb{R}^+$: Cost for purchasing a ton of sugar beet.\n\n$\\text{Overtime_cost} \\in \\mathbb{R}^+$: Cost for getting an hour of overtime.\n\n$\\text{Regular_time_cost} \\in \\mathbb{R}^+$: Cost for having 5,500 hours of labor in regular time.\n\n$\\text{HF_cost} \\in \\mathbb{R}^+$: Yearly cost for supporting a heifer.\n\n$\\text{Cow_cost} \\in \\mathbb{R}^+$: Yearly cost for supporting a dairy cow.\n\n$\\text{GR_land_cost} \\in \\mathbb{R}^+$: Yearly cost for supporting an acre of land devoted to grain.\n\n$\\text{SB_land_cost} \\in \\mathbb{R}^+$: Yearly cost for supporting an acre of land devoted to sugar beet.\n\n$\\text{SB_yield} \\in \\mathbb{R}^+$: Sugar beet yield.\n\n$\\text{GR_yield}_l \\in \\mathbb{R}^+$: Grain yield at land group $l$.\n\n$\\text{GR_area}_l \\in \\mathbb{R}^+$: Number of acres suitable for growing grain in land group $l$.\n\n### Decision Variables\n\n$\\text{Outlay}_t \\in \\mathbb{R}^+$: Amount of money (in units of $\\$200$) spent on renting houses in year $t$.\n\n$\\text{Overtime}_t \\in \\mathbb{R}^+$: Number of extra labor hours needed in year $t$.\n\n$\\text{Newborn}_t \\in \\mathbb{R}^+$: Number of newborn heifers left in year $t$ to be raised.\n\n$\\text{HF_sell}_t \\in \\mathbb{R}^+$: Number of newborn heifers to sell in year $t$.\n\n$\\text{Profit}_t \\in \\mathbb{R}^+$: Profit attained in year $t$.\n\n$\\text{SB_buy}_t \\in \\mathbb{R}^+$: Number of tons of sugar beet to buy in year $t$.\n\n$\\text{SB_sell}_t \\in \\mathbb{R}^+$: Number of tons of sugar beet to sell in year $t$.\n\n$\\text{GR_buy}_t \\in \\mathbb{R}^+$: Number of tons of grain to buy in year $t$.\n\n$\\text{GR_sell}_t \\in \\mathbb{R}^+$: Number of tons of grain to sell in year $t$.\n\n$\\text{SB}_t \\in \\mathbb{R}^+$: Number of tons of sugar beet to grow in year $t$.\n\n$\\text{GR}_{t,l} \\in \\mathbb{R}^+$: Number of tons of grain to grow in year $t$ at land group $l$.\n\n$\\text{Cows}_{t,k} \\in \\mathbb{R}^+$: Number of cows of age $k$ available in year $t$.\n\n### Objective Function\n\n- **Profit**: Maximize the total profit (in USD) of the planning horizon. Notice that, to make capital expenditure as costly in latter years as in former ones, it is necessary to subtract pending loan payments.\n\n\\begin{equation}\n\\text{Maximize} \\quad Z = \\sum_{t \\in \\text{Years}}{\\text{Profit}_t - installment*(t+4)*\\text{Outlay}_t}\n\\end{equation}\n\n### Constraints\n\n- **Housing Capacity**: Livestock cannot exceed the installed capacity plus house rental in year $t$.\n\n\\begin{equation}\n\\text{Newborn}_t + \\sum_{k \\in \\text{Ages} \\setminus \\{12\\}}{\\text{Cows}_{t,k}} \\leq \\text{Housing_cap} + \\sum_{d \\in \\text{Years}: d \\leq t}{\\text{Outlay}_d} \\quad \\forall t \\in \\text{Years}\n\\end{equation}\n\n- **Food Consumption**: There must be enough food to feed the livestock in year $t$.\n\n- Grain.\n\n\\begin{equation}\n\\sum_{k \\in \\text{Ages} \\setminus \\{1,12\\}}{\\text{GR_intake}*\\text{Cows}_{t,k}} \\leq \\text{GR_buy}_t - \\text{GR_sell}_t + \\sum_{l \\in \\text{Lands}}{\\text{GR}_{t,l}} \\quad \\forall t \\in \\text{Years}\n\\end{equation}\n\n- Sugar beet.\n\n\\begin{equation}\n\\sum_{k \\in \\text{Ages} \\setminus \\{1,12\\}}{\\text{SB_intake}*\\text{Cows}_{t,k}} \\leq \\text{SB_buy}_t - \\text{SB_sell}_t + \\text{SB}_t \\quad \\forall t \\in \\text{Years}\n\\end{equation}\n\n- **Grain Growing**: Grain produced on land $l$ cannot exceed the production capacity of year $t$.\n\n\\begin{equation}\n\\text{GR}_{t,l} \\leq \\text{GR_yield}_l*\\text{GR_area}_l \\quad \\forall (t,l) \\in \\text{Years} \\times \\text{Lands}\n\\end{equation}\n\n- **Land Capacity**: Use of space in year $t$ cannot exceed available land.\n\n\\begin{equation}\n\\frac{1}{\\text{SB_yield}}*\\text{SB}_t + \\text{HF_land}*(\\text{Newborn}_t + \\text{Cow}_{t,1}) + \n\\end{equation}\n\n\\begin{equation}\n\\sum_{k \\in \\text{Ages} \\setminus \\{1,12\\}}{\\text{Cows}_{t,k}} + \n\\end{equation}\n\n\\begin{equation}\n\\sum_{l \\in \\text{Lands}}{\\frac{\\text{GR}_{t,l}}{\\text{GR_yield}_l}} \\leq \\text{Land_cap} \\quad \\forall t \\in \\text{Years}\n\\end{equation}\n\n- **Labor**: Labor required to run the farm in year $t$ cannot exceed contracted time plus overtime.\n\n\\begin{equation}\n\\text{HF_labor}*(\\text{Newborn}_t + \\text{Cow}_{t,1}) + \n\\end{equation}\n\n\\begin{equation}\n\\sum_{k \\in \\text{Ages} \\setminus \\{1,12\\}}{\\text{Cow_labor}*\\text{Cow}_{t,k}} + \n\\end{equation}\n\n\\begin{equation}\n\\sum_{l \\in \\text{Lands}}{\\frac{\\text{GR_labor}*\\text{GR}_{t,l}}{\\text{GR_yield}_l}} + \n\\end{equation}\n\n\\begin{equation}\n\\frac{\\text{SB_labor}*\\text{SB}_t}{\\text{SB_yield}} \\leq \\text{Labor_cap} + \\text{Overtime}_t \\qquad \\forall t \\in \\text{Years}\n\\end{equation}\n\n- **Continuity**: Livestock in year $t$ have to survive the previous year.\n\n\\begin{equation}\n\\text{Cows}_{t,1} = (1-\\text{HF_decay})*\\text{Newborn}_{t-1} \\quad \\forall t \\in \\text{Years} \\setminus \\{1\\}\n\\end{equation}\n\n\\begin{equation}\n\\text{Cows}_{t,2} = (1-\\text{HF_decay})*\\text{Cows}_{t-1,1} \\quad \\forall t \\in \\text{Years} \\setminus \\{1\\}\n\\end{equation}\n\n\\begin{equation}\n\\text{Cows}_{t,k+1} = (1-\\text{Cow_decay})*\\text{Cows}_{t-1,k} \\quad \\forall (t,k) \\in \\text{Years} \\setminus \\{1\\} \\times \\text{Ages} \\setminus \\{1,12\\}\n\\end{equation}\n\n- **Heifers Birth**: Heifers born in year $t$ depend on the number of dairy cows.\n\n\\begin{equation}\n\\text{Newborn}_t + \\text{HF_sell}_t = \\sum_{k \\in \\text{Ages} \\setminus \\{1,12\\}}{\\frac{\\text{Birthrate}}{2}*\\text{Cows}_{t,k}} \\quad \\forall t \\in \\text{Years}\n\\end{equation}\n\n- **Final Dairy Cows**: The number of dairy cows at the end of the planning horizon must be within tolerances.\n\n\\begin{equation}\n\\text{Min_final_cows} \\leq \\sum_{k \\in \\text{Ages} \\setminus \\{1,12\\}}{\\text{Cows}_{5,k}} \\leq \\text{Max_final_cows}\n\\end{equation}\n\n- **Initial Conditions**: Set the number of livestock available at the beginning of the planning horizon.\n\n\\begin{equation}\n\\text{Cows}_{1,1} = \\text{Initial_HF}\n\\end{equation}\n\n\\begin{equation}\n\\text{Cows}_{1,2} = \\text{Initial_HF}\n\\end{equation}\n\n\\begin{equation}\n\\text{Cows}_{1,k} = \\text{Initial_cows} \\quad \\forall k \\in \\text{Ages} \\setminus \\{1,2\\}\n\\end{equation}\n\n- **Yearly Profit**: Profit in year $t$ is driven by operations from crops and livestock, after accounting for labor, land and financial costs.\n\n\\begin{equation}\n\\text{Profit}_t = \\frac{\\text{BL_price}*\\text{Birthrate}}{2}*\\sum_{k \\in \\text{Ages} \\setminus \\{1,12\\}}{\\text{Cows}_{t,k}}\n+ \\text{HF_price}*\\text{HF_sell}_t\n+ \\text{Cow_price}*\\text{Cows}_{t,12}\n\\end{equation}\n\n\\begin{equation}\n+ \\text{Milk_price}*\\sum_{k \\in \\text{Ages} \\setminus \\{1,12\\}}{\\text{Cows}_{t,k}}\n\\end{equation}\n\n\\begin{equation}\n+ \\text{GR_price}*\\text{GR_sell}_t\n+ \\text{SB_price}*\\text{SB_sell}_t\n\\end{equation}\n\n\\begin{equation}\n- \\text{GR_cost}*\\text{GR_buy}_t\n- \\text{SB_cost}*\\text{SB_buy}_t\n\\end{equation}\n\n\\begin{equation}\n- \\text{Overtime_cost}*\\text{Overtime}_t\n- \\text{Regular_time_cost}\n\\end{equation}\n\n\\begin{equation}\n- \\text{HF_cost}*(\\text{Newborn}_t + \\text{Cows}_{t,1})\n- \\text{Cow_cost}*\\sum_{k \\in \\text{Ages} \\setminus \\{1,12\\}}{\\text{Cows}_{t,k}}\n\\end{equation}\n\n\\begin{equation}\n- \\text{GR_land_cost}*\\sum_{l \\in \\text{Lands}}{\\frac{\\text{GR}_{t,l}}{\\text{GR_yield}_l}}\n- \\text{SB_land_cost}*\\frac{\\text{SB}_t}{\\text{SB_yield}} \\\\\n- \\text{Installment}*\\sum_{d \\in \\text{Years}:d \\leq t}{\\text{Outlay}_d}\n\\quad \\forall t \\in \\text{Years}\n\\end{equation}\n\n---\n## Python Implementation\n\nWe import the Gurobi Python Module and other Python libraries.\n\n## Input Data\nWe define all the input data of the model.\n\n## Model Deployment\n\nWe create a model and the variables. For each, year we have continuous variables, which tell us how much sugar beet is grown (in tons), how much grain is bought (in tons), how much grain is sold (in tons), how much sugar beet is bought (in tons), how much sugar beet is sold (in tons), how much extra labor is recruited, how much capital outlay there is, how many heifers are sold at birth, how much profit there is, and how many cows are newborns (age 0).\n\nFor each year and each land group, there is a continuous variable, which tells us how much grain is grown on that land group. For each year and each cow age, there is a continuous variable that tells us how many cows exists in the current year of that age.\n\nNext we insert the constraints:\n\nThere is only a housing capacity for 130 cows per year. It is possible that there are more than 130 cows, but housing these additional cows will require additional costs related to renting houses, which is covered with the `Outlay` variables.\n\n    Requirements:\n    - Use gurobipy (Model, GRB, addVar/addConstr, etc.)\n    - Make the script runnable as a standalone Python file if possible.\n    - Keep the code faithful to the example.\n"}, {"role": "assistant", "content": "import numpy as np\nimport pandas as pd\n\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# tested with Python 3.11 & Gurobi 11.0\n\n# Parameters\n\nyears = [1,2,3,4,5]\nlands = [1,2,3,4]\nages = [1,2,3,4,5,6,7,8,9,10,11,12]\ncow_ages = [2,3,4,5,6,7,8,9,10,11]\n\ngr_area = {1: 20.0, 2: 30.0, 3: 20.0, 4: 10.0}\ngr_yield = {1: 1.1,  2: 0.9, 3: 0.8, 4:0.65}\nsb_yield = 1.5\nhousing_cap = 130\ngr_intake = 0.6\nsb_intake = 0.7\nhf_land = 2/3.0\nland_cap = 200\nhf_labor = 10/100.0\ncow_labor = 42/100.0\ngr_labor = 4/100.0\nsb_labor = 14/100.0\nlabor_cap = 5500/100.0\ncow_decay = 0.02\nhf_decay = 0.05\ninitial_hf = 9.5\ninitial_cows = 9.8\nbirthrate = 1.1\nmin_final_cows = 50\nmax_final_cows = 175\nbl_price = 30\nhf_price = 40\ncow_price = 120\nmilk_price = 370\ngr_price = 75\nsb_price = 58\ngr_cost = 90\nsb_cost = 70\novertime_cost = 120\nregular_time_cost = 4000\nhf_cost = 50\ncow_cost = 100\ngr_land_cost = 15\nsb_land_cost = 10\ninstallment = 39.71\n\nmodel = gp.Model('Farming')\nsb = model.addVars(years, vtype=GRB.CONTINUOUS, name=\"SB\")\ngr_buy = model.addVars(years, vtype=GRB.CONTINUOUS, name=\"GR_buy\")\ngr_sell = model.addVars(years, vtype=GRB.CONTINUOUS, name=\"GR_sell\")\nsb_buy = model.addVars(years, vtype=GRB.CONTINUOUS, name=\"SB_buy\")\nsb_sell = model.addVars(years, vtype=GRB.CONTINUOUS, name=\"SB_sell\")\novertime = model.addVars(years, vtype=GRB.CONTINUOUS, name=\"Overtime\")\noutlay = model.addVars(years, vtype=GRB.CONTINUOUS, name=\"Outlay\")\nhf_sell = model.addVars(years, vtype=GRB.CONTINUOUS, name=\"HF_sell\")\nnewborn = model.addVars(years, vtype=GRB.CONTINUOUS, name=\"Newborn\")\nprofit = model.addVars(years, vtype=GRB.CONTINUOUS, name=\"Profit\")\ngr = model.addVars(years, lands, vtype=GRB.CONTINUOUS, name=\"GR\")\ncows = model.addVars(years, ages, vtype=GRB.CONTINUOUS, name=\"Cows\")\n\n# 1. Housing capacity\n\nHousingCap = model.addConstrs((newborn[year] +\n                    cows[year,1] +\n                    gp.quicksum(cows[year,age] for age in cow_ages) -\n                    gp.quicksum(outlay[d] for d in years if d <= year)\n                    <= housing_cap for year in years), name=\"Housing_cap\")\n\n# 2.1 Food consumption (Grain)\n\nGrainConsumption = model.addConstrs((gp.quicksum(gr_intake*cows[year, age] for age in cow_ages)\n                  <= gr_buy[year] - gr_sell[year] + gr.sum(year, '*')\n                  for year in years), name=\"Grain_consumption\")\n\n# 2.1 Food consumption (Sugar beet)\nSugarbeetConsumption = model.addConstrs((gp.quicksum(sb_intake*cows[year, age] for age in cow_ages)\n                  <= sb_buy[year] - sb_sell[year] + sb[year]\n                  for year in years), name=\"Sugar_beet_consumption\")\n\n# 3. Grain growing\n\nGrainGrowing = model.addConstrs((gr[year, land] <= gr_yield[land]*gr_area[land]\n                  for year in years for land in lands), name=\"Grain_growing\")\n\n# 4. Land capacity\n\nLandCap = model.addConstrs((sb[year]/sb_yield + hf_land*(newborn[year] + cows[year,1])\n                  + gp.quicksum((1/gr_yield[land])*gr[year, land] for land in lands)\n                  + gp.quicksum(cows[year, age] for age in cow_ages)\n                  <= land_cap for year in years), name=\"Land_capacity\")\n\n# 5. Labor\n\nLabor = model.addConstrs((hf_labor*(newborn[year] + cows[year,1])\n                  + gp.quicksum(cow_labor*cows[year, age] for age in cow_ages)\n                  + gp.quicksum(gr_labor/gr_yield[land]*gr[year,land] for land in lands)\n                  + sb_labor/sb_yield*sb[year] \n                  <= labor_cap + overtime[year] for year in years), name=\"Labor\")\n\n# 6.1 Continuity\n\nContinuity1 = model.addConstrs((cows[year,1] == (1-hf_decay)*newborn[year-1] \n                  for year in years if year > min(years)),\n                 name=\"Continuity_a\")\n\n# 6.2 Continuity\n\nContinuity2 = model.addConstrs((cows[year,2] == (1-hf_decay)*cows[year-1,1] \n                  for year in years if year > min(years)),\n                 name=\"Continuity_b\")\n\n# 6.3 Continuity\n\nContinuity3 = model.addConstrs((cows[year,age+1] == (1-cow_decay)*cows[year-1,age] \n                  for year in years for age in cow_ages if year > min(years)),\n                 name=\"Continuity_c\")\n\n# 7. Heifers birth\n\nHeifersBirth = model.addConstrs((newborn[year] + hf_sell[year] \n                  == gp.quicksum(birthrate/2*cows[year,age] for age in cow_ages) for year in years)\n                 , name=\"Heifers_birth\")\n\n# 8. Final dairy cows\nFinalDairyCows = model.addRange(gp.quicksum(cows[max(years), age] for age in cow_ages), min_final_cows, max_final_cows, name=\"Final_dairy_cows\" )\n\n# 9.1-9.2 Initial conditions\n\nInitialHeifers = model.addConstrs((initial_hf == cows[1, age] for age in ages if age < 3),\n                 name=\"Initial_conditions\")\n\n# 9.3 Initial conditions\n\nInitialCows = model.addConstrs((initial_cows == cows[1, age] for age in ages if age >= 3),\n                 name=\"Initial_condition_cows\")\n\n# 10. Yearly profit\n\nYearlyProfit = model.addConstrs((profit[year]\n                  == bl_price*birthrate/2*gp.quicksum(cows[year, age] for age in cow_ages)\n                  + hf_price*hf_sell[year] + cow_price*cows[year, 12]\n                  + milk_price*gp.quicksum(cows[year, age] for age in cow_ages)\n                  + gr_price*gr_sell[year] + sb_price*sb_sell[year]\n                  - gr_cost*gr_buy[year] - sb_cost*sb_buy[year]\n                  - overtime_cost*overtime[year] - regular_time_cost\n                  - hf_cost*(newborn[year] + cows[year,1])\n                  - cow_cost*gp.quicksum(cows[year, age] for age in cow_ages)\n                  - gr_land_cost*gp.quicksum(gr[year, land]/gr_yield[land] for land in lands)\n                  - sb_land_cost*sb[year]/sb_yield\n                  - installment*gp.quicksum(outlay[d] for d in years if d <= year)\n                  for year in years), name=\"Yearly_profit\")\n\n# 0. Total profit\n\nmodel.setObjective(gp.quicksum(profit[year] - installment*(year+4)*outlay[year] for year in years), GRB.MAXIMIZE)\n\nmodel.optimize()\n\nrows = [\"Profit\", \"Outlay\"]\ncolumns = years.copy()\nfinance_plan = pd.DataFrame(columns=columns, index=rows, data=0.0)\n\nfor year in years:\n    if (abs(profit[year].x) > 1e-6):\n        finance_plan.loc[\"Profit\", year] = np.round(profit[year].x, 1)\n    if (abs(outlay[year].x) > 1e-6):\n        finance_plan.loc[\"Outlay\", year] = np.round(outlay[year].x, 1)\nfinance_plan\n\nrows = lands.copy() + [\"Buy\", \"Sell\"]\ncolumns = years.copy()\ngr_plan = pd.DataFrame(columns=columns, index=rows, data=0.0)\n\nfor year, land in gr.keys():\n    if (abs(gr[year, land].x) > 1e-6):\n        gr_plan.loc[land, year] = np.round(gr[year, land].x, 1)\nfor year in years:\n    if (abs(gr_buy[year].x) > 1e-6):\n        gr_plan.loc[\"Buy\", year] = np.round(gr_buy[year].x, 1)\n    if (abs(gr_sell[year].x) > 1e-6):\n        gr_plan.loc[\"Sell\", year] = np.round(gr_sell[year].x, 1)\ngr_plan\n\nrows = [\"Grow\", \"Buy\", \"Sell\"]\ncolumns = years.copy()\nsb_plan = pd.DataFrame(columns=columns, index=rows, data=0.0)\n\nfor year in years:\n    if (abs(sb[year].x) > 1e-6):\n        sb_plan.loc[\"Grow\", year] = np.round(sb[year].x, 1)\n    if (abs(sb_buy[year].x) > 1e-6):\n        sb_plan.loc[\"Buy\", year] = np.round(sb_buy[year].x, 1)\n    if (abs(sb_sell[year].x) > 1e-6):\n        sb_plan.loc[\"Sell\", year] = np.round(sb_sell[year].x, 1)\nsb_plan\n\nrows = [\"Sell\", \"Raise\"]\ncolumns = years.copy()\nlivestock_plan = pd.DataFrame(columns=columns, index=rows, data=0.0)\n\nfor year in years:\n    if (abs(hf_sell[year].x) > 1e-6):\n        livestock_plan.loc[\"Sell\", year] = np.round(hf_sell[year].x, 1)\n    if (abs(newborn[year].x) > 1e-6):\n        livestock_plan.loc[\"Raise\", year] = np.round(newborn[year].x, 1)\nlivestock_plan"}]}
{"meta": {"source_path": "/Users/sunyujun03/Desktop/ReLoop/gurobi-modeling-examples/drone_network/drone_network.ipynb", "kind": "ipynb", "title": "drone_network"}, "messages": [{"role": "system", "content": "You are an optimization engineer. Write correct and runnable Python code using gurobipy (Gurobi Python API). Be concise. Output only what is requested."}, {"role": "user", "content": "    Task: Reproduce the following Gurobi modeling example in Python using gurobipy.\n\n    Scenario description (from source):\n    ## Drone-Network Design Queueing Model\n\nThis notebook uses the model and data from the following studies:\n\n- Lejeune M.A., Margot F. 2022. Drone-Network Design for Out-of-Hospital Cardiac Arrests. Working Paper, submitted.\n- Custodio.J., Lejeune M.A. 2022. Spatiotemporal Data Set of Out-of-Hospital Cardiac Arrests. *INFORMS Journal on Computing* 34 (1), 4-10.\n\nThe data and its full description can be found here:\nhttps://github.com/INFORMSJoC/2020.1022\n\nThe example reads from the VBOHCAR Excel file that contains data for:\n- out-of-hospital cardiac arrest (OHCA) incidents\n- potential base stations for drones\n- pairwise incident/base station (Harversine) distances\n\nThe MILP reformulation is modeled in gurobipy and solved using the Gurobi Optimizer. \n\nTo begin, we import the necessary packages for data intake, modeling, and visualization. \n\n### Input Data Processing and Visualization\nWe use pandas to quickly read in the required sheets from Excel. There is a small amount of data prep needed, where some duplicate events need to be removed and text should be cleaned. For reference, an incident location encompasses a street block. \n\nThe above reads the complete data set, including all OHCAs, base stations, and respective distances. We will subset indicent data to the last month and select seven stations to get an instance that will solve in the notebook. \n\nNext, we create scatterplots to visualize the OHCA locations and stations.\n\n    Requirements:\n    - Use gurobipy (Model, GRB, addVar/addConstr, etc.)\n    - Make the script runnable as a standalone Python file if possible.\n    - Keep the code faithful to the example.\n"}, {"role": "assistant", "content": "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom matplotlib import collections as mc\nimport numpy as np\nimport gurobipy as gp\nfrom gurobipy import GRB\nfrom datetime import datetime\nfrom sklearn.mixture import GaussianMixture\nfrom sklearn.cluster import KMeans\n\n# read incident and base station data\nohca_read = pd.read_csv('https://raw.githubusercontent.com/Gurobi/modeling-examples/master/drone_network/OHCAs.csv', index_col=0)\nstations_read = pd.read_csv('https://raw.githubusercontent.com/Gurobi/modeling-examples/master/drone_network/BaseStations.csv', index_col=0)\n\n# read data on indicent-base distance\ndist_read = pd.read_csv('https://raw.githubusercontent.com/Gurobi/modeling-examples/master/drone_network/Base_to_OHCA_distance.csv', index_col=[0,1])\n\n# select a subset of OHCAs so the model can be solved in this notebook (if you have a full license then you can use all incidents)\nstart_date = '2019-05-31' \nend_date = '2019-06-30'\nn_days =  (datetime.strptime(end_date, \"%Y-%m-%d\") - datetime.strptime(start_date, \"%Y-%m-%d\")).days\nohca_df = ohca_read[(ohca_read.ReceivedTime >= start_date) & (ohca_read.ReceivedTime <= end_date)]\n\n# select a subset of base stations so the model can be solved in this notebook (if you have a full license then you can use all stations)\nstations_df = stations_read.loc[[2,3,5,14,25,31,35]]\n# some bases are different types (e.g. fire and police), add the type to create a different base name\nstations_df['Base'] = stations_df.Street + ' ' + stations_df.Type\n\ndist = dist_read.loc[dist_read.index.get_level_values(1).isin(ohca_df.index)]\ndist = dist.loc[dist.index.get_level_values(0).isin(stations_df.index)]\nprint(f\"Number of days: {n_days} \\nNumber of OHCAs: {ohca_df.shape[0]}\")\n\nplt.scatter(data = ohca_df, x = 'Longitude', y = 'Latitude', alpha = .3)\nplt.scatter(data = stations_df, x = 'Longitude', y = 'Latitude', alpha = 0.5, c = 'orange')\n\n# create a base / OHCA data frame using the location names\ndf = dist.join(ohca_df[['Incident_Location']])\ndf = df.join(stations_df['Base'])\ndf = df.drop_duplicates()\ndf = df.set_index(['Incident_Location','Base'])\n\n# limit number of drones\nn_drones = 4\n# assume a 100 km/hr drone speed (about 38 mph) for each drone\nspeed = 100\n# average time to prep, dispatch, clean, perform maintenance etc. a drone is 25 min, converted to hours\nmaintenance = 25/60\n# calculate average service time from i to j (converting to meters to kilometers)\ndistance = df['Harversine Distance (meters)']\nservice_time = maintenance + 2*0.001*distance/speed\nservice_time = service_time.rename('service_time')\n\nincident_count = ohca_df.Incident_Location.value_counts()\n# arrival rate is in hours to match drone speed units\narrival_rate = round(incident_count/(24*n_days),6) \n\nI = df.index.get_level_values(0).unique()\nJ = df.index.get_level_values(1).unique()\n\n# make list of each OHCA / base pair\nbase_to_ohca = df.index.tolist()\n\n# print DAILY arrival rates for each location \n24*arrival_rate.sort_values(ascending = False)\n\nm = gp.Model('drone_network')\n\nx = m.addVars(J, vtype=GRB.BINARY, name='x')            #selection\ny = m.addVars(base_to_ohca, vtype=GRB.BINARY, name='y') #assignment\n\nm.addConstrs((y[(i,j)] <= x[j] for i,j in base_to_ohca), name='select')\nm.addConstr(x.sum() <= n_drones, name = 'drone_limit')\nm.addConstrs((y.sum(i,'*') == 1 for i in I), name = 'ohca');\nm.addConstrs(((gp.quicksum(arrival_rate[i]*service_time[i,j]*y[(i,j)] for i in I) <= 1) for j in J), name='stability');\n\n# Auxilary variables and constraints for R-MILP\nVbar = 2*service_time.sum()\nV = m.addVars(J, ub = Vbar, name = 'V')\nnu = m.addVars(base_to_ohca, name='nu')\n\nm.addConstrs((V[j] == gp.quicksum(arrival_rate[i]*service_time[i,j]**2*y[i,j] for i in I) + gp.quicksum(arrival_rate[i]*service_time[i,j]*nu[i,j] for i in I) for j in J), name = 'aux0')\nm.addConstrs((nu[i,j] <= V[j] for i, j in base_to_ohca), name = 'aux1')\nm.addConstrs((nu[i,j] <= Vbar*y[i,j] for i, j in base_to_ohca), name = 'aux2')\nm.addConstrs((nu[i,j] >= Vbar*(y[i,j]-1) + V[j] for i, j in base_to_ohca), name = 'aux3')\n\n# for ease in setting the objective there is a bit a simplification\nL = arrival_rate.sum()\nm.setObjective((1/L)*(gp.quicksum(0.5*arrival_rate[i]*nu[(i,j)] + (arrival_rate[i]*distance[i,j]/speed)*y[(i,j)] for i, j in base_to_ohca)));\n\nm.optimize()\n\n# recover the bases used in the optimal solution\nsol_x = pd.Series(m.getAttr('X',x))\nbases_selected = sol_x[sol_x > 0.5]\nbases_selected\n\n# recover the assignment variable\nsol_y = pd.Series(m.getAttr('X',y))\nsol_y.name = 'Assignments'\nsol_y.index.names = ['Incident_Location','Base']\nassignment = sol_y[sol_y > 0.5].to_frame()\nassignment = pd.merge(assignment.reset_index()[['Incident_Location','Base']], ohca_df[['Incident_Location','Latitude','Longitude']])\nassignment.rename(columns = {'Latitude':'Inc_Latitude', 'Longitude': 'Inc_Longitude'}, inplace = True)\nassignment = pd.merge(assignment, stations_df[['Base','Latitude','Longitude']])\nassignment.rename(columns = {'Latitude':'Base_Latitude', 'Longitude': 'Base_Longitude'}, inplace = True)\n\ncoords = []\nfor r in range(assignment.shape[0]):\n    coords.append([(assignment.Base_Longitude[r],assignment.Base_Latitude[r]),(assignment.Inc_Longitude[r],assignment.Inc_Latitude[r])])\n# plot the line segments, indicent points, and base station points of the final network\nfig, ax = plt.subplots()\nax.set_xlim(-76.23, -75.93)\nax.set_ylim(36.72, 36.93)\nlc = mc.LineCollection(coords, alpha = .2)\nax.add_collection(lc)\nplt.scatter(data = ohca_df, x = 'Longitude', y = 'Latitude', alpha = .3)\nplt.scatter(data = stations_df[stations_df['Base'].isin(bases_selected.index.tolist())], x = 'Longitude', y = 'Latitude', alpha = 1, c = 'orange') \nplt.scatter(data = stations_df[~stations_df['Base'].isin(bases_selected.index.tolist())], x = 'Longitude', y = 'Latitude', alpha = 0.2, c = 'orange') \nplt.show()\n\nm.dispose()\ngp.disposeDefaultEnv()"}]}
{"meta": {"source_path": "/Users/sunyujun03/Desktop/ReLoop/gurobi-modeling-examples/marketing_campaign_optimization/marketing_campaign_optimization.ipynb", "kind": "ipynb", "title": "Marketing Campaign Optimization"}, "messages": [{"role": "system", "content": "You are an optimization engineer. Write correct and runnable Python code using gurobipy (Gurobi Python API). Be concise. Output only what is requested."}, {"role": "user", "content": "    Task: Reproduce the following Gurobi modeling example in Python using gurobipy.\n\n    Scenario description (from source):\n    # Marketing Campaign Optimization\n\n## Objective and Prerequisites\n\nCompanies across almost every industry are looking to optimize their marketing campaigns. In this Jupyter Notebook, we’ll explore a marketing campaign optimization problem that is common in the banking and financial services industry, which involves determining which products to offer to individual customers in order to maximize total expected profit while satisfying various business constraints. You’ll learn how to formulate a mathematical optimization model of the problem (using machine learning predictive response models as parameters) and solve it using the Gurobi Optimizer.\n\nThis modeling example is at the beginner level, where we assume that you know Python and that you have some knowledge about building mathematical optimization models. The reader should also consult the  [documentation](https://www.gurobi.com/resources/?category-filter=documentation)\nof the Gurobi Python API.\n\n**Download the Repository** <br />\nYou can download the repository containing this and other examples by clicking [here](https://github.com/Gurobi/modeling-examples/archive/master.zip). \n\n## Motivation\n\nThe main goal of marketing in the banking and financial services industry is to offer \"the right product to the right customer at the right time\". However, \nactually being able to achieve this goal is a complicated and challenging undertaking. What makes this particularly difficult is that companies have multiple products and operate under a complex set of business constraints. Choosing which products to offer to which customers in order to maximize the marketing return on investment and satisfy the business constraints is enormously complex.\n\nConsider a major bank  that has made a deliberate effort to become a customer-focused institution, as opposed to a vertical product driven company. The goal of the bank is \"to be the best at helping customers become financially better off by providing relevant solutions to their unique needs\". A direct consequence of this goal is that marketing campaigns are multiple product campaigns as opposed to single product campaigns. \nThis transforms the data science and campaign targeting process from a fairly simple application of individual response models into a significantly more complex process that invloves  choosing which product to offer to which customer and through which channel.\n\nThe marketing team of the bank are used to applying business rules to target customers directly. \nFor example, \nthey target \ncustomers solely on their product gaps or on marketers' business intuition. \nThe bank's\nmarketers have also applied RFM type analysis where general recency, frequency, and monetary measurements as well as product gaps are used to target customers for specific offers. \n\nThe marketing team's current approach, which \nis widely used, \nrelies on predictive response models to target customers for offers. These models estimate the probability that a customer will respond to a specific offer and can significantly increase the response rate to a product offering. However, simply knowing a customer's probability of responding to a particular offer is not enough when a company has several products to promote and other business constraints to consider in its marketing planning.\n\nGenerally speaking, marketing teams also face the problem of knowing which product to offer to a customer, not just which customer to offer a product. In practice, many ad hoc rules are used:\n\n* prioritization rules based on response rates or estimated expected profitability measures\n\n* business rules to prioritize products that can be marketed\n\n* product response models to select customers for a particular campaign. \n\nOne approach that is easily implemented but may not produce optimal customer contact plans relies on a measure of expected offer profitability to choose which products to offer customers. However, a shortcoming of this approach is its inability to effectively handle complex constraints on the customer contact plan.\n\nTo address this marketing campaign optimization problem, M. D. Cohen [1] proposed a MIP approach with data from Scotiabank. The marketing campaign optimization problem considered eleven unique offers: five investment, three lending, and three day-to-day banking offers. The investment offers included Guaranteed Investment Certificates (GICs), mutual funds, Registered Education Savings Program (RESP) and two unique discount brokerage offers. The lending offers included a mortgage and two credit card offers. \nThe day-to-day banking offers included one of two Scotia online banking service offers and a deposit account acquisition. The term campaign is used here to imply one large pro-active customer contact campaign that is comprised of eleven distinct offers; it can be thought of as eleven single product campaigns that are being offered at generally the same time to a non-overlapping set of customers. Approximately 2.5 million customers were included in the potential target market for the campaign.\n\nIn this Jupyter Notebook, we will use this MIP approach to address the bank’s marketing campaign optimization problem. It should be noted that this approach could be used by virtually any company across various industries to optimize their marketing campaigns, while taking into account their business constraints. \n\n## Problem Description\nThe bank's marketing team needs to determine what products to offer to each customer in a way that maximizes the marketing campaign return on investment while considering the following constraints: \n\n* limits on funding available for the campaign.\n* restrictions on the minimum number of product offers that can be made in a campaign.\n* campaign return-on-investment hurdle rates that must be met.\n\n    Requirements:\n    - Use gurobipy (Model, GRB, addVar/addConstr, etc.)\n    - Make the script runnable as a standalone Python file if possible.\n    - Keep the code faithful to the example.\n"}, {"role": "assistant", "content": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# tested with Gurobi v9.0.0 and Python 3.7.0\n\n### SETS\n\nproducts = ['p1', 'p2']\nclusters = ['k1', 'k2']\n\n### Parameters\n\n# Expected profit\ncp, expected_profit = gp.multidict({\n    ('k1', 'p1'): 2000,\n    ('k1', 'p2'): 1000,\n    ('k2', 'p1'): 3000,\n    ('k2', 'p2'): 2000\n})\n\n# Expected cost\n\ncp, expected_cost = gp.multidict({\n    ('k1', 'p1'): 200,\n    ('k1', 'p2'): 100,\n    ('k2', 'p1'): 300,\n    ('k2', 'p2'): 200\n})\n\n# Num of customers in each cluster\n\nclusters, number_customers = gp.multidict({\n    ('k1'): 5,\n    ('k2'): 5\n})\n\n# Minimum number offers for each product\n\nproducts, min_offers = gp.multidict({\n    ('p1'): 2,\n    ('p2'): 2\n})\n\n# Scalars\n\nR = 0.20\n\n#tight budget\nbudget = 200\n\n# Declare and initialize model\nmt = gp.Model('Tactical')\n\n### Decisions variables\n\n# Allocation of product offers to customers in clusters.\n\ny = mt.addVars(cp, name=\"allocate\")\n\n# Budget correction\n\nz = mt.addVar(name=\"budget_correction\")\n\n### Constraints\n\n# Constraint on number of offers at each cluster\n\nmaxOffers_cons = mt.addConstrs((y.sum(k,'*') <= number_customers[k]  for k in clusters), name='maxOffers')\n\n# Budget constraint\n\nbudget_con = mt.addConstr((y.prod(expected_cost) - z <= budget), name='budget')\n\n# Constraints on min number of offers of each product\n\nminOffers_cons = mt.addConstrs( (y.sum('*',j) >= min_offers[j] for j in products), name='min_offers')\n\n# Constraint to ensure minimum ROI\n\nROI_con = mt.addConstr((y.prod(expected_profit) - (1 + R)*y.prod(expected_cost) >= 0), name='ROI')\n\n### Objective function\n\n# Maximize total expected profit\n\nM = 10000\n\nmt.setObjective(y.prod(expected_profit) -M*z, GRB.MAXIMIZE)\n\n# Verify model formulation\n\nmt.write('tactical.lp')\n\n# Run optimization engine\n\nmt.optimize()\n\n### Output Reports\n\n# Optimal allocation of product offers to clusters\n\ntotal_expected_profit = 0\ntotal_expected_cost = 0\n\nprint(\"\\nOptimal allocation of product offers to clusters.\")\nprint(\"___________________________________________________\")\nfor k,p in cp:\n    if y[k,p].x > 1e-6:\n        #print(y[k,p].varName, y[k,p].x)\n        print(f\"The number of customers in cluster {k} that gets an offer of product {p} is: {y[k,p].x}\")\n        total_expected_profit += expected_profit[k,p]*y[k,p].x\n        total_expected_cost += expected_cost[k,p]*y[k,p].x\n\nincreased_budget = '${:,.2f}'.format(z.x)\nprint(f\"\\nThe increase correction in the campaign budget is {increased_budget}.\")\n\n# Financial reports\n\noptimal_ROI = round(100*total_expected_profit/total_expected_cost,2)\nmin_ROI = round(100*(1+R),2)\n\nmoney_expected_profit = '${:,.2f}'.format(total_expected_profit)\nmoney_expected_cost = '${:,.2f}'.format(total_expected_cost)\nmoney_budget = '${:,.2f}'.format(budget)\n\nprint(f\"\\nFinancial reports.\")\nprint(\"___________________________________________________\")\nprint(f\"Optimal total expected profit is {money_expected_profit}.\")\nprint(f\"Optimal total expected cost is {money_expected_cost} with a budget of {money_budget} and an extra amount of {increased_budget}.\")\nprint(f\"Optimal ROI is {optimal_ROI}% with a minimum ROI of  {min_ROI}%.\")\n\n### Sets\n\ncustomers = ['c1', 'c2','c3','c4','c5','c6','c7','c8','c9','c10']\n\n### Parameters\n\n# Expected profit from a product offering for each customer in each cluster\nccp, customer_profit = gp.multidict({\n    ('k1', 'c1', 'p1'): 2050,\n    ('k1', 'c1', 'p2'): 1050,\n    ('k1', 'c2', 'p1'): 1950,\n    ('k1', 'c2', 'p2'): 950,\n    ('k1', 'c3', 'p1'): 2000,\n    ('k1', 'c3', 'p2'): 1000,\n    ('k1', 'c4', 'p1'): 2100,\n    ('k1', 'c4', 'p2'): 1100,\n    ('k1', 'c5', 'p1'): 1900,\n    ('k1', 'c5', 'p2'): 900,\n    ('k2', 'c6', 'p1'): 3000,\n    ('k2', 'c6', 'p2'): 2000,\n    ('k2', 'c7', 'p1'): 2900,\n    ('k2', 'c7', 'p2'): 1900,\n    ('k2', 'c8', 'p1'): 3050,\n    ('k2', 'c8','p2'): 2050,\n    ('k2', 'c9', 'p1'): 3100,\n    ('k2', 'c9', 'p2'): 3100,\n    ('k2', 'c10', 'p1'): 2950,\n    ('k2', 'c10', 'p2'): 2950   \n})\n\n# Customer cost of offering a product at a cluster\n\nccp, customer_cost = gp.multidict({\n    ('k1', 'c1', 'p1'): 205,\n    ('k1', 'c1', 'p2'): 105,\n    ('k1', 'c2', 'p1'): 195,\n    ('k1', 'c2', 'p2'): 95,\n    ('k1', 'c3', 'p1'): 200,\n    ('k1', 'c3', 'p2'): 100,\n    ('k1', 'c4', 'p1'): 210,\n    ('k1', 'c4', 'p2'): 110,\n    ('k1', 'c5', 'p1'): 190,\n    ('k1', 'c5', 'p2'): 90,\n    ('k2', 'c6', 'p1'): 300,\n    ('k2', 'c6', 'p2'): 200,\n    ('k2', 'c7', 'p1'): 290,\n    ('k2', 'c7', 'p2'): 190,\n    ('k2', 'c8', 'p1'): 305,\n    ('k2', 'c8','p2'): 205,\n    ('k2', 'c9', 'p1'): 310,\n    ('k2', 'c9', 'p2'): 310,\n    ('k2', 'c10', 'p1'): 295,\n    ('k2', 'c10', 'p2'): 295   \n})\n\n# Declare and initialize model\nmo = gp.Model('Operational')\n\n### Decision variables\n\nx = mo.addVars(ccp, vtype=GRB.BINARY, name=\"assign\")\n\n# Product offers constraint\n\nproductOffers = {}\n\nfor k in clusters:\n    for j in products:\n            productOffers[k,j] = mo.addConstr(gp.quicksum(x[k,i,j] for kk,i,jj in ccp if (kk ==k and jj == j)) == \n                                              int(y[k,j].x), name='prodOffers_' + str(k) + ',' + str(j) )\n\n# limit on the number of offers to each customer in a cluster.\n\nki = [('k1', 'c1'), \n      ('k1', 'c2'), \n      ('k1', 'c3'),\n      ('k1', 'c4'), \n      ('k1', 'c5'), \n      ('k2', 'c6'), \n      ('k2', 'c7'), \n      ('k2', 'c8'), \n      ('k2', 'c9'), \n      ('k2', 'c10')]\n\ncustomerOffers = {}\n\nfor k,i in ki:\n    customerOffers[k,i] = mo.addConstr(gp.quicksum(x[k,i,j] for kk,ii,j in ccp if (kk == k and ii == i) ) <= 1, \n                                          name ='custOffers_' + str(k) + ',' + str(i) )\n\n### Objective function\n\n# Maximoze total profit\n\nmo.setObjective(x.prod(customer_profit), GRB.MAXIMIZE)\n\n# Verify model formulation\n\nmo.write('operational.lp')\n\n# Run optimization engine\n\nmo.optimize()\n\n### Output Reports\n\n# Optimal assignment of product offers to customers\n\ntotal_customer_profit = 0\ntotal_customer_cost = 0\n\nkvalue = None\nfirst = True\nnum_assignments = 0\n\nprint(\"\\nOptimal assignment of product offers to customers.\")\nprint(\"___________________________________________________\")\nfor k,i,j in ccp:\n    if k != kvalue:\n        prevk = kvalue\n        kvalue = k\n        if not first:\n            print(\"___________________________________________________\")\n            print(f\"Number of assignments in cluster {prevk} is {num_assignments}\")\n            print(\"___________________________________________________\")\n            num_assignments = 0\n        if first:\n            first = False\n    if x[k,i,j].x > 0.5:\n        #print(x[k,i,j].varName, x[k,i,j].x)\n        profit = '${:,.2f}'.format(customer_profit[k,i,j])\n        cost = '${:,.2f}'.format(customer_cost[k,i,j])\n        print(f\"Customer {i} in cluster {k} gets an offer of product {j}:\")\n        print(f\"The expected profit is {profit} at a cost of {cost}\")\n        total_customer_profit += customer_profit[k,i,j]*x[k,i,j].x\n        total_customer_cost += customer_cost[k,i,j]*x[k,i,j].x\n        num_assignments += 1\nprint(\"___________________________________________________\")\nprint(f\"Number of assignments in cluster {kvalue} is {num_assignments}\")\nprint(\"___________________________________________________\\n\")\n        \n# Financial reports\n\ncustomers_ROI = round(100*total_customer_profit/total_customer_cost,2)\n\nmoney_customers_profit = '${:,.2f}'.format(total_customer_profit)\nmoney_customers_cost = '${:,.2f}'.format(total_customer_cost)\n\nprint(f\"\\nFinancial reports.\")\nprint(\"___________________________________________________\")\nprint(f\"Optimal total customers profit is {money_customers_profit}.\")\nprint(f\"Optimal total customers cost is {money_customers_cost} with a budget of {money_budget} and an extra amount of {increased_budget}.\")\nprint(f\"Optimal ROI is {customers_ROI}% with a minimum ROI of  {min_ROI}%.\")\n\n### Operational model enforcing constraint for total budget available \n\n# Declare and initialize model\nmob = gp.Model('OperationalB')\n\n### Decision variables\n\nxb = mob.addVars(ccp, vtype=GRB.BINARY, name=\"assign\")\n\n# Product offers constraint\n\nproductOffersb = {}\n\nfor k in clusters:\n    for j in products:\n            productOffersb[k,j] = mob.addConstr(gp.quicksum(xb[k,i,j] for kk,i,jj in ccp if (kk ==k and jj == j)) == \n                                              int(y[k,j].x), name='prodOffersb_' + str(k) + ',' + str(j) )\n\n# limit on the number of offers to each customer in a cluster.\n\ncustomerOffersb = {}\n\nfor k,i in ki:\n    customerOffersb[k,i] = mob.addConstr(gp.quicksum(xb[k,i,j] for kk,ii,j in ccp if (kk == k and ii == i) ) <= 1, \n                                          name ='custOffersb_' + str(k) + ',' + str(i) )\n\n# budget constraint\n\n# New budget\nnew_budget = budget + z.x\n\ntotBudget = mob.addConstr(xb.prod(customer_cost) <= new_budget, name='total_budget')\n\n### Objective function\n\n# Maximize total profit\n\nmob.setObjective(xb.prod(customer_profit), GRB.MAXIMIZE)\n\n# Verify model formulation\n\nmob.write('operationalB.lp')\n\n# Run optimization engine\n\nmob.optimize()\n\n### Output Reports\n\n# Optimal assignment of product offers to customers\n\ntotal_customer_profitb = 0\ntotal_customer_costb = 0\n\nkvalueb = None\nfirstb = True\nnum_assignmentsb = 0\n\nprint(\"\\nOptimal assignment of product offers to customers.\")\nprint(\"___________________________________________________\")\nfor k,i,j in ccp:\n    if k != kvalueb:\n        prevkb = kvalueb\n        kvalueb = k\n        if not firstb:\n            print(\"___________________________________________________\")\n            print(f\"Number of assignments in cluster {prevkb} is {num_assignmentsb}\")\n            print(\"___________________________________________________\")\n            num_assignmentsb = 0\n        if firstb:\n            firstb = False\n    if xb[k,i,j].x > 0.5:\n        #print(x[k,i,j].varName, x[k,i,j].x)\n        profitb = '${:,.2f}'.format(customer_profit[k,i,j])\n        costb = '${:,.2f}'.format(customer_cost[k,i,j])\n        print(f\"Customer {i} in cluster {k} gets an offer of product {j}:\")\n        print(f\"The expected profit is {profitb} at a cost of {costb}\")\n        total_customer_profitb += customer_profit[k,i,j]*xb[k,i,j].x\n        total_customer_costb += customer_cost[k,i,j]*xb[k,i,j].x\n        num_assignmentsb += 1\nprint(\"___________________________________________________\")\nprint(f\"Number of assignments in cluster {kvalueb} is {num_assignmentsb}\")\nprint(\"___________________________________________________\\n\")\n        \n# Financial reports\n\ncustomers_ROIb = round(100*total_customer_profitb/total_customer_costb,2)\n\nmoney_customers_profitb = '${:,.2f}'.format(total_customer_profitb)\nmoney_customers_costb = '${:,.2f}'.format(total_customer_costb)\n\nprint(f\"\\nFinancial reports.\")\nprint(\"___________________________________________________\")\nprint(f\"Optimal total customers profit is {money_customers_profitb}.\")\nprint(f\"Optimal total customers cost is {money_customers_costb} with a budget of {money_budget} and an extra amount of {increased_budget}.\")\nprint(f\"Optimal ROI is {customers_ROIb}% with a minimum ROI of  {min_ROI}%.\")"}]}
{"meta": {"source_path": "/Users/sunyujun03/Desktop/ReLoop/gurobi-modeling-examples/burrito_optimization_game/show_map_local.py", "kind": "py", "title": "show_map_local"}, "messages": [{"role": "system", "content": "You are an optimization engineer. Write correct and runnable Python code using gurobipy (Gurobi Python API). Be concise. Output only what is requested."}, {"role": "user", "content": "Task: Reproduce the following Gurobi modeling example in Python using gurobipy.\n\nScenario description (from source):\n[no description extracted]\n\nRequirements:\n- Use gurobipy (Model, GRB, addVar/addConstr, etc.)\n- Make the script runnable as a standalone Python file if possible.\n- Keep the code faithful to the example.\n"}, {"role": "assistant", "content": "import plotly.graph_objects as go\nfrom PIL import Image\nimport gurobipy as gp\nimport requests\nimport urllib.request\nfrom io import BytesIO #try 1\n\ndef show_map(buildings, building_names, building_coordinates, demand, truck_coordinates, placed_trucks = []):\n    \"\"\"displays the Burrito Optimization map with labels for open truck locations, buildings with demand, and placed trucks [optional].  This is intended to be used in the Gurobi Days Intro to Modeling course\"\"\"\n    \n    y_max = 550\n    \n    truck_spot_x = [value[0] for key, value in truck_coordinates.items()]\n    truck_spot_y = [y_max - value[1] for key, value in truck_coordinates.items()]\n    trucks = [key for key, value in truck_coordinates.items()]\n    \n    building_x = [value[0] for key, value in building_coordinates.items()]\n    building_y = [y_max - value[1] for key, value in building_coordinates.items()]\n    demand = [value for key, value in demand.items()]\n    building_names = [value for key, value in building_names.items()]\n    \n    if placed_trucks:\n        placed_truck_spot_x = [value[0] for key, value in truck_coordinates.items() if key in placed_trucks]\n        placed_truck_spot_y = [y_max - value[1] for key, value in truck_coordinates.items() if key in placed_trucks]\n        placed_trucks = [key for key, value in truck_coordinates.items() if key in placed_trucks]\n    \n    # Create figure\n    url = 'https://raw.githubusercontent.com/Gurobi/modeling-examples/master/burrito_optimization_game/util/minimap.png'   \n    response = requests.get(url)\n    minimap = Image.open(BytesIO(response.content))\n    fig = go.Figure()\n\n    # Add trace for truck spots\n    fig.add_trace(\n        go.Scatter(x=truck_spot_x, y=truck_spot_y, \n                   hovertemplate=trucks, \n                   name=\"Open truck spots\",\n                   mode='markers',\n                   marker_color='rgba(135, 206, 250, 0.0)',\n                   marker_line_color='darkblue',\n                   marker_line_width=2, \n                   marker_size=10\n                   )\n    )\n\n    # Add trace for placed trucks\n    if placed_trucks:\n        fig.add_trace(\n            go.Scatter(x=placed_truck_spot_x, y=placed_truck_spot_y, \n                       hovertemplate=placed_trucks, \n                       name=\"Truck added to the map\",\n                       mode='markers',\n                       marker_color='darkblue',\n                       marker_line_color='darkblue',\n                       marker_line_width=2, \n                       marker_size=10\n                       )\n        )\n\n    # Add trace for buildings\n    fig.add_trace(\n        go.Scatter(x=building_x, y=building_y, \n                   hovertemplate=building_names,\n                   name=\"Buildings with customer demand\",\n                   mode='markers',\n                   marker_color='red',\n                   marker_opacity=0.5,\n                   marker_line_width=0, \n                   marker_size=demand\n                   )\n    )\n\n    # Add minimap image\n    fig.add_layout_image(\n            dict(\n                source=minimap,\n                xref=\"x\",\n                yref=\"y\",\n                x=0,\n                y=550,\n                sizex=500,\n                sizey=550,\n                sizing=\"stretch\",\n                opacity=0.9,\n                layer=\"below\")\n    )\n\n    # Set templates\n    fig.update_layout(template=\"simple_white\")\n    fig.update_xaxes(range=[0, 500], visible=False)\n    fig.update_yaxes(range=[0,550], visible=False,\n                    scaleanchor = \"x\",scaleratio = 1)\n    fig.update_layout(showlegend=True)\n    \n    fig.update_layout(\n        title=\"Burrito Optimization Game Map\",\n    )\n    \n    fig.show()"}]}
{"meta": {"source_path": "/Users/sunyujun03/Desktop/ReLoop/gurobi-modeling-examples/burrito_optimization_game/util/show_map.py", "kind": "py", "title": "show_map"}, "messages": [{"role": "system", "content": "You are an optimization engineer. Write correct and runnable Python code using gurobipy (Gurobi Python API). Be concise. Output only what is requested."}, {"role": "user", "content": "Task: Reproduce the following Gurobi modeling example in Python using gurobipy.\n\nScenario description (from source):\n[no description extracted]\n\nRequirements:\n- Use gurobipy (Model, GRB, addVar/addConstr, etc.)\n- Make the script runnable as a standalone Python file if possible.\n- Keep the code faithful to the example.\n"}, {"role": "assistant", "content": "import plotly.graph_objects as go\nfrom PIL import Image\nimport gurobipy as gp\nimport requests\nimport urllib.request\nfrom io import BytesIO #try 1\n\ndef show_map(buildings, building_names, building_coordinates, demand, truck_coordinates, placed_trucks = []):\n    \"\"\"displays the Burrito Optimization map with labels for open truck locations, buildings with demand, and placed trucks [optional].  This is intended to be used in the Gurobi Days Intro to Modeling course\"\"\"\n    \n    y_max = 550\n    \n    truck_spot_x = [value[0] for key, value in truck_coordinates.items()]\n    truck_spot_y = [y_max - value[1] for key, value in truck_coordinates.items()]\n    trucks = [key for key, value in truck_coordinates.items()]\n    \n    building_x = [value[0] for key, value in building_coordinates.items()]\n    building_y = [y_max - value[1] for key, value in building_coordinates.items()]\n    demand = [value for key, value in demand.items()]\n    building_names = [value for key, value in building_names.items()]\n    \n    if placed_trucks:\n        placed_truck_spot_x = [value[0] for key, value in truck_coordinates.items() if key in placed_trucks]\n        placed_truck_spot_y = [y_max - value[1] for key, value in truck_coordinates.items() if key in placed_trucks]\n        placed_trucks = [key for key, value in truck_coordinates.items() if key in placed_trucks]\n    \n    # Create figure\n    url = 'https://raw.githubusercontent.com/Gurobi/modeling-examples/master/burrito_optimization_game/util/minimap.png'   \n    response = requests.get(url)\n    minimap = Image.open(BytesIO(response.content))\n    fig = go.Figure()\n\n    # Add trace for truck spots\n    fig.add_trace(\n        go.Scatter(x=truck_spot_x, y=truck_spot_y, \n                   hovertemplate=trucks, \n                   name=\"Open truck spots\",\n                   mode='markers',\n                   marker_color='rgba(135, 206, 250, 0.0)',\n                   marker_line_color='darkblue',\n                   marker_line_width=2, \n                   marker_size=10\n                   )\n    )\n\n    # Add trace for placed trucks\n    if placed_trucks:\n        fig.add_trace(\n            go.Scatter(x=placed_truck_spot_x, y=placed_truck_spot_y, \n                       hovertemplate=placed_trucks, \n                       name=\"Truck added to the map\",\n                       mode='markers',\n                       marker_color='darkblue',\n                       marker_line_color='darkblue',\n                       marker_line_width=2, \n                       marker_size=10\n                       )\n        )\n\n    # Add trace for buildings\n    fig.add_trace(\n        go.Scatter(x=building_x, y=building_y, \n                   hovertemplate=building_names,\n                   name=\"Buildings with customer demand\",\n                   mode='markers',\n                   marker_color='red',\n                   marker_opacity=0.5,\n                   marker_line_width=0, \n                   marker_size=demand\n                   )\n    )\n\n    # Add minimap image\n    fig.add_layout_image(\n            dict(\n                source=minimap,\n                xref=\"x\",\n                yref=\"y\",\n                x=0,\n                y=550,\n                sizex=500,\n                sizey=550,\n                sizing=\"stretch\",\n                opacity=0.9,\n                layer=\"below\")\n    )\n\n    # Set templates\n    fig.update_layout(template=\"simple_white\")\n    fig.update_xaxes(range=[0, 500], visible=False)\n    fig.update_yaxes(range=[0,550], visible=False,\n                    scaleanchor = \"x\",scaleratio = 1)\n    fig.update_layout(showlegend=True)\n    \n    fig.update_layout(\n        title=\"Burrito Optimization Game Map\",\n    )\n    \n    fig.show()"}]}
{"meta": {"source_path": "/Users/sunyujun03/Desktop/ReLoop/gurobi-modeling-examples/optimization202/ESUPS_case_study/src/solving.py", "kind": "py", "title": "solving"}, "messages": [{"role": "system", "content": "You are an optimization engineer. Write correct and runnable Python code using gurobipy (Gurobi Python API). Be concise. Output only what is requested."}, {"role": "user", "content": "Task: Reproduce the following Gurobi modeling example in Python using gurobipy.\n\nScenario description (from source):\n[no description extracted]\n\nRequirements:\n- Use gurobipy (Model, GRB, addVar/addConstr, etc.)\n- Make the script runnable as a standalone Python file if possible.\n- Keep the code faithful to the example.\n"}, {"role": "assistant", "content": "from dataclasses import dataclass\nfrom enum import IntEnum\nfrom typing import Tuple, Union\n\nimport gurobipy as gp\nfrom gurobipy import GRB, tupledict\n\nfrom src.data import Depot, Disaster, DisasterImpact, Location, TransportMode\n\n\nclass AllocationStrategy(IntEnum):\n    MinimizeTwoStage = 0\n    MinimizeFixedInventory = 1\n    WorstDepot = 2\n\n\n@dataclass(frozen=True)\nclass SolverParameters:\n    \"\"\"\n    Parameters that influence how the solver transforms the Problem into a mathematical model.\n\n    Attributes\n    ----------\n    allocation_strategy\n        If and how inventory can be reallocated\n    scale_demand\n        Whether demand should be scaled (down) to not exceed supply\n    \"\"\"\n\n    allocation_strategy: AllocationStrategy = (\n        AllocationStrategy.MinimizeFixedInventory,\n    )\n    scale_demand: bool = False\n\n\nCostMatrix = dict[Tuple[Location, Location, TransportMode], float]\n\n\n@dataclass(frozen=True)\nclass Problem:\n    depots: list[Depot]\n    inventory: dict[Depot, int]\n    demand: dict[DisasterImpact, float]\n    disasters: list[Disaster]\n    probabilities: dict[Disaster, float]\n    transport_modes: list[TransportMode]\n    cost: CostMatrix\n\n\n@dataclass(frozen=True)\nclass Solution:\n    \"\"\"\n    Result of solving a single Problem with specific SolverParameters\n\n    Attributes\n    ----------\n    total_cost_inc_dummy\n        Total transportation cost including artificial cost for using the dummy node (myObj)\n    total_cost_exc_dummy\n        Total transportation cost from the real depots (myObjNoDum)\n    total_demand\n        Total demand in the input data (myWeightedDemand)\n    covered_demand_exc_dummy\n        Demand served from real depots, averaged over all scenarios (myWeightedDemandMetNoDum)\n    fraction_of_disasters_using_dummy\n        Fraction of disaster scenarios for which not enough real inventory is available (myFractionOfDisastersUsingDummy)\n    duals_inventory_exc_dummy_plus_dummy_cost\n        Adjusted dual variables for the inventory constraints (values are independent of dummy costs) (dualsInvNoDum_PlusDummyCost)\n    duals_inventory_exc_dummy_unadjusted\n        Original dual variables for the inventory constraints, aggregated over disaster scenarios (dualsInvNoDum_UnAdj)\n    duals_inventory_exc_dummy_all\n        All original dual variables for the inventory constraints (dualsInvNoDum_All)\n    flow_exc_dummy\n        Allocation of depot inventory to disaster locations in each scenario, excluding the dummy depot (myFlowNoDum)\n    flow\n        Allocation of depot inventory to disaster locations in each scenario (myFlow)\n    optimal_inventory\n        Optimal or fixed allocation of inventory to depots (myOptInvNoDum)\n    dual_total_inventory\n        Dual variable for the total inventory constraint (dualTotInv)\n    \"\"\"\n\n    total_cost_inc_dummy: float\n    total_cost_exc_dummy: float\n    total_demand: float\n    covered_demand_exc_dummy: float\n    fraction_of_disasters_using_dummy: float\n    duals_inventory_exc_dummy_plus_dummy_cost: dict[Depot, float]\n    duals_inventory_exc_dummy_unadjusted: dict[Depot, float]\n    duals_inventory_exc_dummy_all: dict[Tuple[Disaster, Depot], float]\n    flow_exc_dummy: dict[Tuple[Disaster, Depot, DisasterImpact, TransportMode], float]\n    flow: dict[Tuple[Disaster, Depot, DisasterImpact, TransportMode], float]\n    optimal_inventory: dict[Depot, float]\n    dual_total_inventory: float\n\n    _dummy_depot: Depot\n\n\nclass StochasticSolver:\n    _threshold_cost_elim: float = 1e9\n    _threshold_cost_dummy: float = 1e9\n\n    def __init__(self):\n        self._dummy = Location(\"DUMMY\", \"\", \"\", 0, 0)\n        self._env = gp.Env(params={\"OutputFlag\": 0, \"Threads\": 1})\n\n    def dispose(self):\n        self._env.dispose()\n        self._env = None\n\n    def solve(self, problem: Problem, parameters: SolverParameters) -> Solution:\n        sources = problem.depots + [self._dummy]\n\n        demand = (\n            self._scale_demand(problem) if parameters.scale_demand else problem.demand\n        )\n\n        arcs = gp.tuplelist(\n            [\n                (k, i, j, v)\n                for i in sources\n                for k in problem.disasters\n                for j in k.impacted_locations\n                for v in problem.transport_modes\n                if (\n                    self._get_arc_cost(problem.cost, i, j, v)\n                    < self._threshold_cost_elim\n                )\n                or (i == self._dummy)\n            ]\n        )\n\n        arc_cost = {\n            (k, i, j, v): self._get_arc_cost(problem.cost, i, j, v)\n            * problem.probabilities[k]\n            for (k, i, j, v) in arcs\n        }\n\n        model = gp.Model(\"StochLP\", env=self._env)\n\n        # First stage variable: Quantity to be allocated to each depot\n        x: tupledict[Depot, gp.Var] = model.addVars(problem.depots, lb=0, name=\"x\")\n\n        # Second stage variable: Quantity transported from (real or dummy) depot to disaster locations using each mode of transport\n        y: tupledict[\n            Tuple[Disaster, Union[Depot, Location], DisasterImpact, TransportMode],\n            gp.Var,\n        ] = model.addVars(arcs, lb=0, obj=arc_cost, name=\"y\")\n\n        # Constraint: Total incoming arc flow must cover demand for each disaster location\n        model.addConstrs(\n            (\n                y.sum(k, \"*\", j, \"*\") == demand[j]\n                for k in problem.disasters\n                for j in k.impacted_locations\n            ),\n            name=\"satisfyDemand\",\n        )\n\n        # Constraint: Total outgoing arc flow must match initial or reallocated inventory\n        inventory_balance: tupledict[\n            Tuple[Disaster, Depot], gp.Constr\n        ] = model.addConstrs(\n            (\n                y.sum(k, i, \"*\", \"*\") <= x[i]\n                for k in problem.disasters\n                for i in problem.depots\n            ),\n            name=\"satisfySupply\",\n        )\n\n        # Constraint: Ensure inventory reallocation matches total existing inventory\n        total_initial_inventory = sum(problem.inventory.values())\n        match_total_inventory = model.addConstr(x.sum() == total_initial_inventory)\n\n        def fix_inventory_balance(values: dict[Disaster, float]):\n            for key, value in values.items():\n                x[key].LB = x[key].UB = value\n\n        if parameters.allocation_strategy == AllocationStrategy.MinimizeFixedInventory:\n            fix_inventory_balance(problem.inventory)\n        elif parameters.allocation_strategy == AllocationStrategy.WorstDepot:\n            worst_depot = None\n            worst_objective = -1e100\n            for depot in problem.depots:\n                centralized_inventory = {\n                    other: total_initial_inventory if other == depot else 0\n                    for other in problem.depots\n                }\n                fix_inventory_balance(centralized_inventory)\n                model.optimize()\n                if model.Status != GRB.Status.OPTIMAL:\n                    raise RuntimeError(\"Could not solve model to optimality\")\n                if model.ObjVal > worst_objective:\n                    worst_depot = depot\n                    worst_objective = model.ObjVal\n            centralized_inventory = {\n                other: total_initial_inventory if other == worst_depot else 0\n                for other in problem.depots\n            }\n            fix_inventory_balance(centralized_inventory)\n\n        model.optimize()\n        if model.Status != GRB.Status.OPTIMAL:\n            raise RuntimeError(\"Could not solve model to optimality\")\n\n        # Total transport cost\n        total_cost_inc_dummy = model.ObjVal\n        dummy_cost = sum(\n            var.X * var.Obj for var in y.select(\"*\", self._dummy, \"*\", \"*\")\n        )\n        total_cost_exc_dummy = total_cost_inc_dummy - dummy_cost\n\n        # Demand met without using the dummy node\n        covered_demand_by_dummy = sum(\n            y[k, i, j, v].X * problem.probabilities[k]\n            for (k, i, j, v) in arcs.select(\"*\", self._dummy, \"*\", \"*\")\n        )\n        total_demand = sum(\n            local_demand * problem.probabilities[j.disaster]\n            for (j, local_demand) in demand.items()\n        )\n        covered_demand_exc_dummy = total_demand - covered_demand_by_dummy\n\n        # Flow in solution\n        solution_y = {key: y[key].X for key in arcs}\n\n        # Fraction of disaster scenarios in which the dummy supply is used\n        fraction_of_disasters_using_dummy = len(\n            [\n                disaster\n                for disaster in problem.disasters\n                if sum(\n                    solution_y[key]\n                    for key in arcs.select(disaster, self._dummy, \"*\", \"*\")\n                )\n                > 0\n            ]\n        ) / len(problem.disasters)\n\n        # Dual variables for the inventory balance constraints\n        dual_correction = fraction_of_disasters_using_dummy * self._threshold_cost_dummy\n        duals_inventory_exc_dummy_unadjusted = {\n            i: sum(inventory_balance[k, i].Pi for k in problem.disasters)\n            for i in problem.depots\n        }\n        duals_inventory_exc_dummy_plus_dummy_cost = {\n            i: dual_correction + pi\n            for (i, pi) in duals_inventory_exc_dummy_unadjusted.items()\n        }\n        duals_inventory_exc_dummy_all = {\n            (k, i): constr.Pi for (k, i), constr in inventory_balance.items()\n        }\n\n        flow = {(k, i, j, v): var.X for (k, i, j, v), var in y.items() if var.X > 0}\n\n        flow_exc_dummy = {\n            (k, i, j, v): value\n            for (k, i, j, v), value in flow.items()\n            if i != self._dummy\n        }\n\n        optimal_inventory = {depot: var.X for depot, var in x.items()}\n\n        dual_total_inventory = (\n            match_total_inventory.Pi\n            if parameters.allocation_strategy\n            == AllocationStrategy.MinimizeFixedInventory\n            else None\n        )\n\n        return Solution(\n            total_cost_inc_dummy,\n            total_cost_exc_dummy,\n            total_demand,\n            covered_demand_exc_dummy,\n            fraction_of_disasters_using_dummy,\n            duals_inventory_exc_dummy_plus_dummy_cost,\n            duals_inventory_exc_dummy_unadjusted,\n            duals_inventory_exc_dummy_all,\n            flow_exc_dummy,\n            flow,\n            optimal_inventory,\n            dual_total_inventory,\n            self._dummy,\n        )\n\n    def _get_arc_cost(\n        self,\n        cost: CostMatrix,\n        source: Location,\n        target: DisasterImpact,\n        mode: TransportMode,\n    ):\n        if source == self._dummy:\n            return self._threshold_cost_dummy\n        cell = cost.get((source, target.location, mode))\n        return self._threshold_cost_elim if cell == None else cell\n\n    def _scale_demand(self, problem: Problem) -> dict[DisasterImpact, float]:\n        supply = sum(problem.inventory.values())\n        result: dict[DisasterImpact, float] = {}\n        for disaster in problem.disasters:\n            total_demand = sum(\n                problem.demand[location] for location in disaster.impacted_locations\n            )\n            factor = min(1, supply / total_demand) if total_demand > 1e-6 else 1\n            for location in disaster.impacted_locations:\n                result[location] = factor * problem.demand[location]\n        return result"}]}

[SCENARIO]
Family: F1 (Core Operations)
Archetype: retail_f1_base
Scenario ID: retail_f1_base_v2

[BUSINESS DESCRIPTION]
Business narrative:
The retailer manages weekly inventory for several products across multiple distribution centers that directly serve final customer demand. Demand for each product at each location is seasonal and exogenous. Products are replenished each period up to a per-product production or procurement capacity, and any demand that is not served immediately in the period is permanently lost and penalized. Customers are never backlogged or promised future delivery. Inventory is held locally at each distribution center, and there is no movement of stock between locations in this archetype.

Structure cues:
- Time is a discrete sequence of periods defined in the JSON. Decisions about how much to produce or procure and how much to ship to each location are made at the beginning of each period; demand is realized and served within that same period.
- Inventory evolves by carrying over what remains from the previous period, adding any new production assigned to the location, and subtracting units that are sold or intentionally discarded as waste. On-hand stock is never allowed to become negative.
- Shelf life: Each product has a shelf life in periods. Inventory must be tracked by age (cohorts). Units produced in period t can only be sold or held for shelf_life[p] periods; after that they expire and must be discarded as waste. The model must use age-indexed inventory I[p,l,t,a] where a is age 1..shelf_life[p], with FIFO sales (oldest first) and automatic expiry when age exceeds shelf life.
- Any demand that cannot be met from available local inventory in the period is treated as lost sales and incurs the lost sales penalty. There is no concept of backorders, reservations, or delayed fulfillment.
- Production for each product in each period cannot exceed the given production capacity. Production is available without delay in this archetype because lead times are effectively zero.
- Storage capacity at each location and period limits the total volume of on-hand inventory using product-specific storage usage coefficients and location capacities from the JSON: sum over products of (cold_usage[p] * total_inventory[p,l,t]) <= cold_capacity[l]. These limits must be respected even in periods where they do not bind.
- Substitution: Edge [Basic, Premium] means Basic's demand can be served by Premium's inventory when Basic stock is insufficient. S[Basic, Premium] represents units of Basic's demand fulfilled by Premium.
- There is no transshipment of inventory between locations; each location can only serve its own local demand from its own inventory.
- Labor capacity is set high enough that it does not bind in this archetype, but if labor constraints are included they must be consistent with the JSON parameters.
- The objective is to minimize total cost over the horizon, including inventory holding costs, waste costs, and lost sales penalties. No fixed ordering costs, minimum order quantities, lead times, reverse flows, or global budgets are active here.

[DATA SCHEMA]
{
  "name": str,                          # scenario identifier
  "periods": int,                       # number of time periods
  "products": [str, ...],               # list of product IDs
  "locations": [str, ...],              # list of location IDs

  "shelf_life": {p: int},               # shelf life in periods per product
  "lead_time": {p: int},                # order lead time per product (0 = same-period arrival)

  "demand_curve": {p: [float, ...]},    # demand per product per period (0-indexed list)
  "demand_share": {l: float},           # fraction of total demand at each location

  "production_cap": {p: [float, ...]},  # max production per product per period (0-indexed list)
  "cold_capacity": {l: float},          # storage capacity per location
  "cold_usage": {p: float},             # storage units per unit of product

  "labor_cap": {l: [float, ...]},       # labor hours per location per period (0-indexed list)
  "labor_usage": {p: float},            # labor hours per unit sold
  "return_rate": {p: float},            # fraction of sales returned next period

  "costs": {
    "purchasing": {p: float},           # cost per unit ordered
    "inventory": {p: float},            # holding cost per unit per period
    "waste": {p: float},                # cost per unit expired
    "lost_sales": {p: float},           # penalty per unit of unmet demand
    "fixed_order": float,               # fixed cost per order placed
    "transshipment": float              # cost per unit transshipped
  },

  "constraints": {
    "moq": float,                       # minimum order quantity (0 = no MOQ)
    "pack_size": int,                   # order must be multiple of this (1 = no constraint)
    "budget_per_period": float|null,    # max purchasing cost per period
    "waste_limit_pct": float|null       # max waste as fraction of total demand
  },

  "network": {
    "sub_edges": [[p_from, p_to], ...], # substitution: p_from's demand can be served by p_to
    "trans_edges": [[l_from, l_to], ...]# transshipment: can ship from l_from to l_to
  }
}

[DATA ACCESS]
- The variable `data` is pre-loaded. Do NOT use file I/O.
- Network data is nested: use data.get('network', {}).get('sub_edges', [])
- IMPORTANT: sub_edges and trans_edges are lists of lists [[a,b], ...].
  Convert to tuples for Gurobi indexing: [tuple(e) for e in edges]
- Lists are 0-indexed

[OUTPUT FORMAT]
- Output ONLY Python code
- Use GurobiPy
- Print status and objective

[TASK]
Write a GurobiPy script that models and solves this optimization problem.

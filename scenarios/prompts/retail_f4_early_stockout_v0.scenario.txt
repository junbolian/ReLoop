[SCENARIO]
Family: F4 (Dynamics and Disruptions)
Archetype: retail_f4_early_stockout
Scenario ID: retail_f4_early_stockout_v0

[BUSINESS DESCRIPTION]
Business narrative:
The retailer experiences an upstream supply failure at launch. For several initial periods, no production is possible for any product, but customer demand already exists at the locations. The retailer must decide how much inventory to build before the disruption and how to ration demand while supply is temporarily unavailable. Unserved demand in the disruption window is lost and penalized; customers are not backordered.

Structure cues:
- The inventory, storage, and lost sales framework matches the base scenario: single-echelon, local inventories, and no transshipment.
- Shelf life: Each product has a shelf life in periods. Inventory must be tracked by age (cohorts). Units produced in period t can only be held for shelf_life[p] periods; after that they expire and must be discarded as waste. Use age-indexed inventory I[p,l,t,a] with FIFO sales and automatic expiry.
- Storage capacity: sum over products of (cold_usage[p] * total_inventory[p,l,t]) <= cold_capacity[l]. These limits must be respected.
- In the JSON, production capacity for all products is set to zero in early periods. The model must respect this by not assigning any new production in those periods.
- Inventory remains non-negative and changes from period to period based on previous stock, any allowed production (zero during the disruption), sales, and waste.
- Substitution behavior and zero lead times remain unchanged from the baseline.
- Labor capacity is generous and does not bind.
- The objective is to minimize total cost while capturing the trade-off between carrying inventory into the supply failure (and paying holding or waste costs) and accepting lost sales during the disruption.

[DATA SCHEMA]
{
  "name": str,                          # scenario identifier
  "periods": int,                       # number of time periods
  "products": [str, ...],               # list of product IDs
  "locations": [str, ...],              # list of location IDs

  "shelf_life": {p: int},               # shelf life in periods per product
  "lead_time": {p: int},                # order lead time per product (0 = same-period arrival)

  "demand_curve": {p: [float, ...]},    # demand per product per period (0-indexed list)
  "demand_share": {l: float},           # fraction of total demand at each location

  "production_cap": {p: [float, ...]},  # max production per product per period (0-indexed list)
  "cold_capacity": {l: float},          # storage capacity per location
  "cold_usage": {p: float},             # storage units per unit of product

  "labor_cap": {l: [float, ...]},       # labor hours per location per period (0-indexed list)
  "labor_usage": {p: float},            # labor hours per unit sold
  "return_rate": {p: float},            # fraction of sales returned next period

  "costs": {
    "purchasing": {p: float},           # cost per unit ordered
    "inventory": {p: float},            # holding cost per unit per period
    "waste": {p: float},                # cost per unit expired
    "lost_sales": {p: float},           # penalty per unit of unmet demand
    "fixed_order": float,               # fixed cost per order placed
    "transshipment": float              # cost per unit transshipped
  },

  "constraints": {
    "moq": float,                       # minimum order quantity (0 = no MOQ)
    "pack_size": int,                   # order must be multiple of this (1 = no constraint)
    "budget_per_period": float|null,    # max purchasing cost per period
    "waste_limit_pct": float|null       # max waste as fraction of total demand
  },

  "network": {
    "sub_edges": [[p_from, p_to], ...], # substitution: p_from's demand can be served by p_to
    "trans_edges": [[l_from, l_to], ...]# transshipment: can ship from l_from to l_to
  }
}

[DATA ACCESS]
- The variable `data` is pre-loaded. Do NOT use file I/O.
- Network data is nested: use data.get('network', {}).get('sub_edges', [])
- Lists are 0-indexed

[OUTPUT FORMAT]
- Output ONLY Python code
- Use GurobiPy
- Print status and objective

[TASK]
Write a GurobiPy script that models and solves this optimization problem.

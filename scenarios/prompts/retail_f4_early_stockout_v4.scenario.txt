[SCENARIO]
Family: F4 (Dynamics and Disruptions)
Archetype: retail_f4_early_stockout
Scenario ID: retail_f4_early_stockout_v4

Business narrative:
The retailer experiences an upstream supply failure at launch. For several initial periods, no production is possible for any product, but customer demand already exists at the locations. The retailer must decide how much inventory to build before the disruption and how to ration demand while supply is temporarily unavailable. Unserved demand in the disruption window is lost and penalized; customers are not backordered.

Structure cues:
- The inventory, storage, and lost sales framework matches the base scenario: single-echelon, local inventories, and no transshipment.
- In the JSON, production capacity for all products is set to zero in early periods. The model must respect this by not assigning any new production in those periods.
- Inventory remains non-negative and changes from period to period based on previous stock, any allowed production (zero during the disruption), sales, and waste.
- Storage capacity, substitution behavior, and zero lead times remain unchanged from the baseline.
- Labor capacity is generous and does not bind.
- The objective is to minimize total cost while capturing the trade-off between carrying inventory into the supply failure (and paying holding or waste costs) and accepting lost sales during the disruption.

=============================================================================
MODELING GUIDELINES
=============================================================================
[CORE RULES]
- `data` is a pre-loaded Python dict. Do not modify it.
- No file I/O. Never invent missing data.
- Never hard-code numeric values.
- Output must be plain Python code. No prose, no markdown, no comments.

[DATA FORMAT]
- sub_edges: [[p_from, p_to], ...] defines substitution pairs
- trans_edges: [[loc_from, loc_to], ...] defines transshipment pairs
- demand_share: {location: scalar}, NOT nested by product
- demand[p,l,t] = demand_curve[p][t-1] * demand_share[l]
- Time indexing: 1-based (t = 1, 2, ..., T)
- production_cap[p] is a list (0-indexed), access with [t-1]

[DECISION VARIABLES]
- I[p,l,t,a]: inventory by product, location, period, remaining life bucket
- y[p,l,t,a]: sales from each life bucket
- W[p,l,t]: waste (expired inventory from bucket a=1)
- Q[p,l,t]: orders/production quantity
- L[p,l,t]: lost sales (slack variable for unmet demand)
- S[p_from,p_to,l,t]: substitution flow (only if sub_edges nonempty)
- X[p,l_from,l_to,t]: transshipment flow (only if trans_edges nonempty)

=============================================================================
OBJECTIVE FUNCTION (MINIMIZE TOTAL COST)
=============================================================================

Include ALL applicable cost terms from data["costs"]:

1. PURCHASING COST: cost incurred when ordering/producing units
   - Read from costs["purchasing"]

2. INVENTORY HOLDING COST: cost of keeping inventory overnight
   - Read from costs["inventory"]
   - Apply to END-OF-PERIOD inventory = (I - y), NOT just I
   - Apply ONLY to buckets a >= 2 (bucket a=1 expires, not held overnight)
   - CRITICAL: Holding cost is on (I[p,l,t,a] - y[p,l,t,a]), the inventory AFTER sales

3. WASTE COST: penalty for units that expire
   - Read from costs["waste"]

4. LOST SALES PENALTY: penalty for demand that cannot be fulfilled
   - Read from costs["lost_sales"]

5. TRANSSHIPMENT COST (if trans_edges nonempty):
   - Read from costs["transshipment"] if present

6. FIXED ORDER COST (if constraints.fixed_order_cost exists):
   - Incur fixed cost whenever a positive order is placed

=============================================================================
SUBSTITUTION SEMANTICS (CRITICAL)
=============================================================================

Edge [p_from, p_to] means: p_from's demand can be served by p_to's inventory.
This is "upward substitution" - premium product serves basic product's demand.

S[p_from, p_to, l, t] = quantity of p_from's demand fulfilled by p_to

For each product p, compute:
- outbound: total substitution flow where p is the source (p sends demand out)
- inbound: total substitution flow where p is the target (p receives demand in)

Two key constraints involving substitution:
1. Cannot substitute more demand than the product actually has
2. Sales conservation must account for substitution flows

=============================================================================
CORE CONSTRAINTS
=============================================================================

1. DEMAND ROUTE (only when substitution edges exist for product p):
   The total demand that product p redirects to substitutes cannot exceed p's own demand

2. SALES CONSERVATION (always):
   Total sales from all life buckets plus lost sales equals effective demand
   Effective demand = original demand + inbound substitution - outbound substitution

3. AVAILABILITY (always):
   Sales from any life bucket cannot exceed inventory in that bucket

4. EXPIRE/WASTE (always):
   Waste equals unsold inventory from the expiring bucket (a=1)

5. AGING (for t < T, a < shelf_life[p]):
   Inventory in bucket a at period t+1 equals inventory from bucket a+1 at period t
   minus sales from that bucket. This represents aging by one bucket per period.
   DO NOT add aging constraints for t = T (would reference t+1 which doesn't exist)

6. FRESH INFLOW:
   Fresh inventory enters at the highest life bucket (a = shelf_life[p])
   If lead_time = 0: fresh equals current period order
   If lead_time > 0 and t > lead_time: fresh equals order from t - lead_time
   If t <= lead_time: no fresh inventory arrives yet
   NEVER access Q[p,l,0] or negative time indices

7. INITIALIZATION at t=1:
   All non-fresh inventory buckets start empty: I[p,l,1,a] = 0 for a < shelf_life[p]
   This is CRITICAL - without this, the model may have unbounded "free" inventory

=============================================================================
CAPACITY CONSTRAINTS
=============================================================================

8. PRODUCTION CAPACITY:
   Total orders across all locations cannot exceed production capacity per product per period
   Check: production_cap[p][t-1] (0-indexed list)

9. STORAGE CAPACITY:
   Total weighted inventory at each location cannot exceed cold storage capacity
   Weight = sum over products and life buckets of (inventory * cold_usage[p])
   Limit = cold_capacity[l]

=============================================================================
OPTIONAL CONSTRAINTS (check if data fields exist)
=============================================================================

10. LABOR CAPACITY (if labor_cap and labor_usage in data):
    Total labor used for handling products cannot exceed location capacity
    Labor use is typically proportional to sales volume

11. MOQ - Minimum Order Quantity (if constraints.moq exists):
    Orders must be either zero or at least the minimum quantity
    Requires binary variable to enforce all-or-nothing logic

12. PACK SIZE (if constraints.pack_size exists):
    Orders must be integer multiples of pack size

13. FIXED ORDER COST (if costs.fixed_order exists):
    Incur fixed cost whenever a positive order is placed
    Requires binary variable to track order placement

14. BUDGET (if constraints.budget_per_period exists):
    Total purchasing cost per period cannot exceed budget

15. WASTE LIMIT (if constraints.waste_limit_pct exists):
    Total waste over horizon cannot exceed percentage of total demand

16. TRANSSHIPMENT (if trans_edges nonempty):
    Create flow variables for inventory movement between locations
    Flow from a location cannot exceed available inventory
    Add transshipment flows to inventory balance equations

=============================================================================
BOUNDARY CONDITIONS SUMMARY
=============================================================================

- t = 1: Initialize I[p,l,1,a] = 0 for a < shelf_life[p]
- t = T: No aging constraints (would reference t+1)
- t <= lead_time: Fresh inflow = 0 (orders haven't arrived)
- Empty sub_edges: No S variables, no substitution constraints
- Empty trans_edges: No X variables, no transshipment constraints

[SOLVING]
- Set Gurobi params: OutputFlag=0, Threads=1, Seed=0
- Print status: print(f"status: {m.Status}")
- If OPTIMAL: print(f"objective: {m.ObjVal}")

=============================================================================
DATA ACCESS
=============================================================================

The evaluation harness loads the JSON into a Python variable called `data`.
Read all parameters from `data`. Do not use file I/O.

Key fields:
- data["periods"]: int (number of time periods)
- data["products"]: list of product IDs
- data["locations"]: list of location IDs
- data["shelf_life"][p]: int, life buckets per product
- data["lead_time"][p]: int, delivery delay (may be 0)
- data["demand_curve"][p]: list (0-indexed, use [t-1] for period t)
- data["demand_share"][l]: scalar share per location
- data["network"]["sub_edges"]: [[p_from, p_to], ...]
- data["network"]["trans_edges"]: [[l_from, l_to], ...]
- data["costs"]["inventory"][p], ["waste"][p], ["lost_sales"][p], ["purchasing"][p]
- data["production_cap"][p]: list (per period, 0-indexed)
- data["cold_capacity"][l], data["cold_usage"][p]
- data["labor_cap"][l] (if exists), data["labor_usage"][p] (if exists)
- data["constraints"] (may contain moq, pack_size, budget_per_period, waste_limit_pct)



[INSTRUCTION]
Write a complete GurobiPy script that:
1) Imports gurobipy (import gurobipy as gp; from gurobipy import GRB)
2) Reads all parameters from `data` (already loaded)
3) Creates all necessary decision variables with correct indices
4) Sets objective function with all applicable cost terms
5) Adds all constraints respecting boundary conditions
6) Handles optional constraints based on what exists in data
7) Sets Gurobi params and prints results

Return ONLY Python code. No markdown, no comments, no explanations.

[SCENARIO]
Family: F3 (Shared Resources and Capacity)
Archetype: retail_f3_volumetric_constraint
Scenario ID: retail_f3_volumetric_constraint_v3

[BUSINESS DESCRIPTION]
Business narrative:
One product—typically a bulky premium item—uses much more storage volume per unit than the others. Storage capacity at each location becomes tight primarily because of this product, forcing the retailer to choose between stocking bulky high-margin units and smaller items. All demand remains local and exogenous, with no transshipment or backorders.

Structure cues:
- The overall structure and shared storage framework match retail_f3_storage_bottleneck.
- Shelf life: Each product has a shelf life in periods. Inventory must be tracked by REMAINING LIFE.

  DECISION VARIABLES - define EXACTLY as specified:
  - Q[p,l,t] = order quantity for product p at location l in period t
    CRITICAL: Q is indexed over (products, locations, periods), NOT just (products, periods)!
    Define as: Q = m.addVars(P, L, T, ...) NOT m.addVars(P, T, ...)
  - I[p,l,t,r] = inventory at START of period t with r periods remaining
  - sales[p,l,t,r] = units sold from inventory cohort with r remaining life
  - W[p,l,t] = waste (expired units)
  - L[p,l,t] = lost sales (unmet demand)

  Convention: r=1 is OLDEST (sell first FIFO), r=shelf_life[p] is FRESHEST.

  KEY EQUATIONS - implement EXACTLY as written, do NOT add or remove terms:

  (1) Fresh inflow: I[p,l,t,SL] = Q[p,l,t]
      - Each location places its OWN orders. Q[p,l,t] is already per-location.
      - Do NOT multiply by demand_share. demand_share is ONLY for calculating demand values.

  (2) Aging: I[p,l,t+1,r] = I[p,l,t,r+1] - sales[p,l,t,r+1] for r=1..SL-1
      - Inventory tomorrow with r remaining = inventory today with r+1 remaining - sales

  (3) Waste: W[p,l,t] = I[p,l,t,1] - sales[p,l,t,1]
      - Items with r=1 that aren't sold become waste

  (4) Sales availability: sales[p,l,t,r] <= I[p,l,t,r]
      - Can only sell what you have in inventory

  (5) Inventory holding cost: charged on (I[p,l,t,r] - sales[p,l,t,r]) for r >= 2
      - Charge on END-of-period inventory (after sales), exclude expiring items (r=1)
- Storage capacity: sum over products of (cold_usage[p] * total_inventory[p,l,t]) <= cold_capacity[l]. Product-specific storage usage parameters in the JSON are much larger for the premium product than for other SKUs.
- Inventory cannot be negative and is updated based on previous stock, local production, sales, and waste.
- There is no transshipment, lead times are zero, and substitution behavior follows the JSON graph with standard semantics.
- The objective is to minimize total cost under capacity constraints that make the volumetrically heavy premium product particularly expensive in terms of space.

[SCENARIO]
Family: F5 (Feasibility and Model Repair)
Archetype: retail_f5_ultimate_stress
Scenario ID: retail_f5_ultimate_stress_v4

[BUSINESS DESCRIPTION]
Business narrative:
This is a composite stress test that combines three stressors: tight storage capacity, a mid-horizon production failure during a peak period, and the absence of any substitution between products. Demand is local and exogenous at each location. The scenario is designed as a boss-level test where the only viable strategy is to accept significant lost sales while respecting all physical constraints.

Structure cues:
- The archetype combines the storage bottleneck of retail_f3_storage_bottleneck (30% capacity), the peak supply failure of retail_f4_peak_failure (production=0 for periods 8-11), and the no-substitution structure of retail_f2_no_substitution (sub_edges=[]).
- Shelf life: Each product has a shelf life in periods. Inventory must be tracked by age (cohorts). Units produced in period t can only be held for shelf_life[p] periods; after that they expire and must be discarded as waste. Use age-indexed inventory I[p,l,t,a] with FIFO sales and automatic expiry.
- Storage capacity: sum over products of (cold_usage[p] * total_inventory[p,l,t]) <= cold_capacity[l]. Storage capacities are scaled to 30% of normal values and must be enforced as binding constraints.
- Production capacities are set to zero during a mid-horizon peak window (periods 8-11), so no new units can be produced in those periods.
- The substitution graph is empty (sub_edges = []), so each product's demand can only be served by its own inventory at the location.
- Inventory at each product, location, and period remains non-negative and reflects previous stock, allowed production, sales, and waste. Unmet demand is explicitly treated as lost sales.
- There is no transshipment and lead times are zero. Labor capacity remains generous.
- The objective is to minimize total cost while handling simultaneous capacity, supply, and assortment stress without violating feasibility.

[DATA SCHEMA]
{
  "name": str,                          # scenario identifier
  "periods": int,                       # number of time periods
  "products": [str, ...],               # list of product IDs
  "locations": [str, ...],              # list of location IDs

  "shelf_life": {p: int},               # shelf life in periods per product
  "lead_time": {p: int},                # order lead time per product (0 = same-period arrival)

  "demand_curve": {p: [float, ...]},    # demand per product per period (0-indexed list)
  "demand_share": {l: float},           # fraction of total demand at each location

  "production_cap": {p: [float, ...]},  # max production per product per period (0-indexed list)
  "cold_capacity": {l: float},          # storage capacity per location
  "cold_usage": {p: float},             # storage units per unit of product

  "labor_cap": {l: [float, ...]},       # labor hours per location per period (0-indexed list)
  "labor_usage": {p: float},            # labor hours per unit sold
  "return_rate": {p: float},            # fraction of sales returned next period

  "costs": {
    "purchasing": {p: float},           # cost per unit ordered
    "inventory": {p: float},            # holding cost per unit per period
    "waste": {p: float},                # cost per unit expired
    "lost_sales": {p: float},           # penalty per unit of unmet demand
    "fixed_order": float,               # fixed cost per order placed
    "transshipment": float              # cost per unit transshipped
  },

  "constraints": {
    "moq": float,                       # minimum order quantity (0 = no MOQ)
    "pack_size": int,                   # order must be multiple of this (1 = no constraint)
    "budget_per_period": float|null,    # max purchasing cost per period
    "waste_limit_pct": float|null       # max waste as fraction of total demand
  },

  "network": {
    "sub_edges": [[p_from, p_to], ...], # substitution: p_from's demand can be served by p_to
    "trans_edges": [[l_from, l_to], ...]# transshipment: can ship from l_from to l_to
  }
}

[DATA ACCESS]
- The variable `data` is pre-loaded. Do NOT use file I/O.
- Network data is nested: use data.get('network', {}).get('sub_edges', [])
- IMPORTANT: sub_edges and trans_edges are lists of lists [[a,b], ...].
  Convert to tuples for Gurobi indexing: [tuple(e) for e in edges]
- Lists are 0-indexed

[OUTPUT FORMAT]
- Output ONLY Python code
- Use GurobiPy
- Print status and objective

[TASK]
Write a GurobiPy script that models and solves this optimization problem.

[SCENARIO]
Family: F7 (Network and Multi Echelon)
Archetype: retail_f7_transshipment
Scenario ID: retail_f7_transshipment_v3

[BUSINESS DESCRIPTION]
Business narrative:
The retailer operates a fully connected lateral transshipment network among all locations. Inventory can be moved between any pair of locations at a transshipment cost, allowing local surpluses to be reallocated to locations facing shortages. Demand remains local and exogenous at each site, and unsatisfied demand after considering local stock and inbound transshipments is lost and penalized.

Structure cues:
- This archetype extends the single-echelon inventory model by allowing transshipment flows along directed edges given in the JSON; in this case, all ordered pairs of distinct locations are connected.
- For each product and period, inventory at a location changes according to incoming production, incoming transshipments, outgoing transshipments, sales, and waste, and must remain non-negative.
- Transshipment flows from a location in a period cannot exceed that location's available inventory for the product. All such moves incur transshipment costs as specified in the JSON.
- Demand remains local: each location's demand must be met from its own on-hand inventory and inbound transshipments, if available.
- Storage capacity constraints apply to on-hand inventory at each location, while in-transit units can be treated separately if desired.
- Lead times for transshipment are effectively zero in this archetype, so shipments dispatched in a period are available at the destination within the same period.
- The objective is to minimize total cost including holding, waste, lost sales, and transshipment costs.

[DATA SCHEMA]
{
  "name": str,                          # scenario identifier
  "periods": int,                       # number of time periods
  "products": [str, ...],               # list of product IDs
  "locations": [str, ...],              # list of location IDs

  "shelf_life": {p: int},               # shelf life in periods per product
  "lead_time": {p: int},                # order lead time per product (0 = same-period arrival)

  "demand_curve": {p: [float, ...]},    # demand per product per period (0-indexed list)
  "demand_share": {l: float},           # fraction of total demand at each location

  "production_cap": {p: [float, ...]},  # max production per product per period (0-indexed list)
  "cold_capacity": {l: float},          # storage capacity per location
  "cold_usage": {p: float},             # storage units per unit of product

  "labor_cap": {l: [float, ...]},       # labor hours per location per period (0-indexed list)
  "labor_usage": {p: float},            # labor hours per unit sold
  "return_rate": {p: float},            # fraction of sales returned next period

  "costs": {
    "purchasing": {p: float},           # cost per unit ordered
    "inventory": {p: float},            # holding cost per unit per period
    "waste": {p: float},                # cost per unit expired
    "lost_sales": {p: float},           # penalty per unit of unmet demand
    "fixed_order": float,               # fixed cost per order placed
    "transshipment": float              # cost per unit transshipped
  },

  "constraints": {
    "moq": float,                       # minimum order quantity (0 = no MOQ)
    "pack_size": int,                   # order must be multiple of this (1 = no constraint)
    "budget_per_period": float|null,    # max purchasing cost per period
    "waste_limit_pct": float|null       # max waste as fraction of total demand
  },

  "network": {
    "sub_edges": [[p_from, p_to], ...], # substitution: p_from's demand can be served by p_to
    "trans_edges": [[l_from, l_to], ...]# transshipment: can ship from l_from to l_to
  }
}

[DATA ACCESS]
- The variable `data` is pre-loaded. Do NOT use file I/O.
- Network data is nested: use data.get('network', {}).get('sub_edges', [])
- Lists are 0-indexed

[OUTPUT FORMAT]
- Output ONLY Python code
- Use GurobiPy
- Print status and objective

[TASK]
Write a GurobiPy script that models and solves this optimization problem.

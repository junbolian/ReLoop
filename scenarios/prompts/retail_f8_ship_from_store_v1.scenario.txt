[SCENARIO]
Family: F8 (Omni channel and Store Operations)
Archetype: retail_f8_ship_from_store
Scenario ID: retail_f8_ship_from_store_v1

[BUSINESS DESCRIPTION]
Business narrative:
Stores fulfill both walk-in traffic and online orders, effectively acting as small fulfillment centers that ship from store. Storage capacity and labor capacity at stores are scaled up, but labor usage per unit is higher when stores serve both channels. Demand from walk-in and online customers is aggregated into a single local demand stream per product and location, and unmet demand is lost and penalized.

Structure cues:
- The inventory structure is single-echelon with local demand at each location, storage capacity, and lost sales.
- The JSON increases storage and labor capacities at all locations while also increasing per-unit labor usage. Both storage and labor constraints must be enforced using these parameters.
- Stores conceptually serve two demand streams, but the model treats them as a single aggregated demand per product and location. Higher labor usage reflects the additional work from online fulfillment.
- Inventory remains non-negative and is updated from previous stock and production, minus sales and waste.
- There is no transshipment; lead times are zero, and substitution behavior remains as encoded.
- The objective is to minimize total cost while balancing higher labor intensity against increased capacity.

[DATA SCHEMA]
{
  "name": str,                          # scenario identifier
  "periods": int,                       # number of time periods
  "products": [str, ...],               # list of product IDs
  "locations": [str, ...],              # list of location IDs

  "shelf_life": {p: int},               # shelf life in periods per product
  "lead_time": {p: int},                # order lead time per product (0 = same-period arrival)

  "demand_curve": {p: [float, ...]},    # demand per product per period (0-indexed list)
  "demand_share": {l: float},           # fraction of total demand at each location

  "production_cap": {p: [float, ...]},  # max production per product per period (0-indexed list)
  "cold_capacity": {l: float},          # storage capacity per location
  "cold_usage": {p: float},             # storage units per unit of product

  "labor_cap": {l: [float, ...]},       # labor hours per location per period (0-indexed list)
  "labor_usage": {p: float},            # labor hours per unit sold
  "return_rate": {p: float},            # fraction of sales returned next period

  "costs": {
    "purchasing": {p: float},           # cost per unit ordered
    "inventory": {p: float},            # holding cost per unit per period
    "waste": {p: float},                # cost per unit expired
    "lost_sales": {p: float},           # penalty per unit of unmet demand
    "fixed_order": float,               # fixed cost per order placed
    "transshipment": float              # cost per unit transshipped
  },

  "constraints": {
    "moq": float,                       # minimum order quantity (0 = no MOQ)
    "pack_size": int,                   # order must be multiple of this (1 = no constraint)
    "budget_per_period": float|null,    # max purchasing cost per period
    "waste_limit_pct": float|null       # max waste as fraction of total demand
  },

  "network": {
    "sub_edges": [[p_from, p_to], ...], # substitution: p_from's demand can be served by p_to
    "trans_edges": [[l_from, l_to], ...]# transshipment: can ship from l_from to l_to
  }
}

[DATA ACCESS]
- The variable `data` is pre-loaded. Do NOT use file I/O.
- Network data is nested: use data.get('network', {}).get('sub_edges', [])
- Lists are 0-indexed

[OUTPUT FORMAT]
- Output ONLY Python code
- Use GurobiPy
- Print status and objective

[TASK]
Write a GurobiPy script that models and solves this optimization problem.

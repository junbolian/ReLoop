You are an optimization modeling assistant specialized in retail supply chains.

Goal: semantic fidelity. The MILP must implement the structurally active mechanisms implied by `data` and the scenario text, not merely compile.

Execution contract:
- The scenario JSON is pre-loaded as a Python dict named `data`. Do NOT modify `data`.
- Do NOT perform any file I/O (no open(), json.load(), Path.read_text(), etc.).
- If the prompt includes a JSON preview, it is for reference only. Do NOT hard-code numeric constants from it.
  Always read sets/parameters from `data` at runtime.

Modeling requirements (Strict Flow Logic):
- Implement a mixed-integer linear program (MILP) in Python using gurobipy.
- **Variable Granularity:** If `shelf_life` is active, both Inventory (I) AND Sales (y) must be indexed by remaining life (a). This allows precise FIFO tracking and holding cost calculation.
- **Strict Aging Equality:** Use exact flow conservation for inventory aging: I[p,l,t+1,a] = I[p,l,t,a+1] - y[p,l,t,a+1] for a < shelf_life. 
- **Weighted Capacity:** If `cold_usage` exists for products, storage capacity constraints must use it as a coefficient: sum(I * cold_usage) <= capacity.
- **Financial Precision:** Holding costs (inv_cost) must be applied only to stock that remains after sales and will not expire in the next period (typically I - y for a >= 2).

Naming contract (required for automatic semantic checking):
- Use the following variable dictionaries with exactly these names when active:
  I (inventory by remaining life), y (sales/consumption by remaining life), W (waste),
  Q (orders), L (lost sales), d (direct demand served),
  S (substitution routing), X (transshipment), z (order trigger), n (pack integer).
- When adding constraints, set the `name=` field using these prefixes (plus indices):
  demand_route, sales_conservation, availability, expire_clear, leadtime, returns,
  init, fresh_inflow, aging, storage_cap, prod_cap, labor_cap, moq_lb, moq_ub,
  pack, budget, wastecap.

Data structure notes:
- JSON fields may use different indexing schemes. Always check the actual structure at runtime using isinstance().
- Product parameters (shelf_life, lead_time, return_rate, labor_usage, cold_usage) are indexed by product only, not by location: {product: value}.
- Capacity fields may be static or time-varying. Check if the value is a scalar, list, or nested dict:
  * cold_capacity: {location: number} or {location: {period: number}}
  * production_cap: {product: [values]} (list indexed by period) or {product: number}
  * labor_cap: {location: [values]} or {period: number}
- Demand: if a `demand` field exists as {product: {location: {period: value}}}, use it directly. Otherwise construct from demand_curve and demand_share.
- Cost and constraint parameters are in the `costs` and `constraints` sections respectively.
- Network structure (substitution, transshipment) is in the `network` section as lists of edge pairs.

Critical semantic clarifications:
- demand_share is indexed by location only: {location: fraction}. Demand for product p at location l in period t equals demand_curve[p][t] * demand_share[l].
- production_cap is a GLOBAL constraint per product per period: the sum of production across ALL locations for product p in period t must not exceed production_cap[p][t].
- Substitution edges [p_from, p_to] mean: demand for p_to can be served by p_from's inventory when p_to is unavailable. Example: [SKU_Basic, SKU_Premium] means Basic inventory can satisfy Premium demand (not the reverse).
- costs.inventory is the holding cost (same as inv_cost). costs.lost_sales is the penalty for unmet demand.

Objective (reference semantics):
- Minimize total cost including all cost terms present in `data`: holding/inventory, waste, and lost-sales penalties;
  plus purchasing/ordering costs if provided; plus (if enabled) transshipment cost and fixed ordering cost.
- If a cost term is missing in `data`, treat it as zero; do not invent extra data.

Solving and reporting contract (required for comparability):
- Set Gurobi parameters for reproducibility unless explicitly overridden by the evaluation harness:
  OutputFlag=0, Threads=1, Seed=0.
  Do NOT set TimeLimit unless provided by the harness/environment.
- Always print the solver status code.
- Only treat the printed objective as "final" when status == GRB.OPTIMAL.
- If status is not GRB.OPTIMAL, also print (when available) the best incumbent objective (ObjVal),
  the best bound (ObjBound), and the MIP gap (MIPGap). Do not pretend it is optimal.

Return:
- Output a single Python script as plain text.
- No Markdown, no code fences, and no comments in the returned code.

[SCENARIO]
Family: F2 (Assortment and Substitution)
Archetype: retail_f2_circular_sub
Scenario ID: retail_f2_circular_sub_v4

Business narrative:
The retailer offers several products in a category where customers are willing to switch along a circular pattern when their first choice is unavailable. The basic, premium, and short-life products form a directed substitution ring, so demand may move from one item to the next according to that ring. Demand remains exogenous by product and location, and any demand that cannot be satisfied even after considering allowed substitution is treated as a lost sale.

Structure cues:
- The overall structure is still single-echelon inventory with per-product production capacities, local storage, and lost sales when demand is not met.
- Inventory at each location evolves from carried-over stock, new production, sales to customers who originally requested that product, and sales to customers diverted from other products along the substitution ring, minus any discarded units. Inventory must remain non-negative.
- The substitution graph in the JSON defines a directed ring among the basic, premium, and short-life products. When demand for a product cannot be fully served from its own stock, the model may serve part of that demand from substitute products along these directed edges, subject to available inventory of those substitutes.
- Any remaining unmet demand after using all allowed substitutions becomes lost sales with a penalty cost. Customers are not backordered.
- Storage capacity constraints and zero lead times remain in effect, and there is no transshipment between locations.
- The objective is to minimize total cost including holding, waste, and lost sales while respecting the substitution pattern encoded in the JSON.

Operational context:
- The JSON contains the number of time periods, the list of products, and the list of locations
  directly as top-level fields (for example: "periods", "products", "locations").
- Cost parameters such as holding, lost-sales, waste, purchasing, and any fixed ordering costs
  are stored in the "costs" section of the JSON.
- Capacity and operational limits such as storage capacity, production capacity, labor capacity,
  shelf life, lead times, minimum order quantities, pack sizes, and any waste or budget limits
  are stored in fields such as "cold_capacity", "production_cap", "labor_cap", "shelf_life",
  "lead_time", "constraints", and "network".
- Scenario-level control parameters such as global minimum order quantities, pack sizes, fixed
  ordering costs, per-period budgets, and waste caps are provided as scalar fields inside the
  "constraints" and "costs" sections and should be applied uniformly across products and locations
  unless the scenario description explicitly specifies otherwise.
- Substitution and transshipment structures are encoded in the "network" section, for example
  as substitution edges or transshipment edges between locations.
- The model should respect all of these fields exactly as given and interpret them in a way
  consistent with the scenario description.

JSON data (do not modify):
The evaluation harness loads the JSON for this scenario into a Python variable
called `data`. Your code should read all sets and parameters from `data` using
these fields and must not change any numeric values or perform any file I/O
(for example, do not call open or json.load).



[INSTRUCTION]
Using ONLY the information above, write a complete Python script that:

1) Imports gurobipy (import gurobipy as gp; from gurobipy import GRB),
2) Assumes the JSON has already been loaded into a Python variable called `data`,
3) Builds and solves a mixed-integer linear program that reflects the business
   description and the structure implied by the JSON fields (including capacities,
   shelf life, lead times, substitution edges, transshipment edges, and other keys/conditions present in `data`),
4) Sets reproducibility parameters (OutputFlag=0, Threads=1, Seed=0) unless the harness overrides them,
5) Prints: status always; objective only as final if OPTIMAL; otherwise also print ObjVal/ObjBound/MIPGap when available.

Do not invent extra data. Do not change any numbers from the JSON.
Return ONLY the Python source code as plain text, with no comments and no Markdown.

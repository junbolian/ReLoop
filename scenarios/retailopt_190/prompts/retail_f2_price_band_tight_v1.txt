### SYSTEM PROMPT ###
You are an optimization modeling assistant specialized in retail supply chains.

Goal: semantic fidelity. The MILP must implement the structurally active mechanisms implied by `data` and the scenario text, not merely compile.

Execution contract:
- The scenario JSON is pre-loaded as a Python dict named `data`. Do NOT modify `data`.
- Do NOT perform any file I/O (no open(), json.load(), Path.read_text(), etc.).

Modeling requirements:
- Implement a mixed-integer linear program (MILP) in Python using gurobipy.
- Include all modules that are structurally active in `data` (and omit inactive ones), such as:
  perishability with remaining-life indexing and aging transitions, shared-capacity coupling,
  directed substitution routing with demand/sales conservation, transshipment flows,
  lead times, discrete procurement (MOQ / pack size / fixed ordering), budgets, and waste caps.

Naming contract (required for automatic semantic checking):
- Use the following variable dictionaries with exactly these names when active:
  I (inventory by remaining life), y (sales/consumption), W (waste),
  Q (orders), L (lost sales), d (direct demand served),
  S (substitution routing), X (transshipment), z (order trigger), n (pack integer).
- When adding constraints, set the `name=` field using these prefixes (plus indices):
  demand_route, sales_conservation, availability, expire_clear, leadtime, returns,
  fresh_inflow, aging, storage_cap, prod_cap, labor_cap, moq_lb, moq_ub,
  pack, budget, wastecap.

Objective (reference semantics):
- Minimize total cost = purchasing + holding/inventory + waste + lost sales
  + (if enabled) transshipment cost + fixed ordering cost.
- If a cost term is missing in `data`, treat it as zero; do not invent extra data.

Return:
- Output a single Python script as plain text.
- No Markdown, no code fences, and no comments in the returned code.

### USER PROMPT ###
[SCENARIO]
Family: F2 (Assortment and Substitution)
Archetype: retail_f2_price_band_tight
Scenario ID: retail_f2_price_band_tight_v1

Business narrative:
The retailer operates a category with a value-oriented basic product and a premium product that are sold under tight price bands and margin trade-offs. Premium carries higher effective margin and stricter implicit service expectations, while basic is cheaper but more price sensitive. When the basic product is unavailable, some customers will upgrade to the premium product; the reverse does not occur. Unmet demand after this limited upgrade behavior is lost and penalized.

Structure cues:
- The physical and inventory structure follows the same pattern as in retail_f1_base: single-echelon, local demand, local inventory, shared storage, and no transshipment.
- The substitution graph is a single directed edge from the basic product to the premium product. When basic inventory is insufficient, some customers who cannot be served by basic may be served by premium if premium stock is available.
- Lost sales penalties and purchasing or production costs in the JSON make premium more valuable to protect and basic cheaper but more elastic. This asymmetry is expressed through cost parameters, not through any special-case constraints.
- Inventory remains non-negative; any demand that cannot be satisfied even after allowing the basic-to-premium shift is recorded as lost sales.
- There is no transshipment, lead times are effectively zero, and labor capacity is non-binding.
- The objective is to minimize total cost including holding, waste, and lost sales while respecting the one-way substitution rule and storage capacity limits.

Operational context:
- The JSON contains the number of time periods, the list of products, and the list of locations
  directly as top-level fields (for example: "periods", "products", "locations").
- Cost parameters such as holding, lost-sales, waste, purchasing, and any fixed ordering costs
  are stored in the "costs" section of the JSON.
- Capacity and operational limits such as storage capacity, production capacity, labor capacity,
  shelf life, lead times, minimum order quantities, pack sizes, and any waste or budget limits
  are stored in fields such as "cold_capacity", "production_cap", "labor_cap", "shelf_life",
  "lead_time", "constraints", and "network".
- Scenario-level control parameters such as global minimum order quantities, pack sizes, fixed
  ordering costs, per-period budgets, and waste caps are provided as scalar fields inside the
  "constraints" and "costs" sections and should be applied uniformly across products and locations
  unless the scenario description explicitly specifies otherwise.
- Substitution and transshipment structures are encoded in the "network" section, for example
  as substitution edges or transshipment edges between locations.
- The model should respect all of these fields exactly as given and interpret them in a way
  consistent with the scenario description.

JSON data (do not modify):
The evaluation harness loads the JSON for this scenario into a Python variable
called `data`. Your code should read all sets and parameters from `data` using
these fields and must not change any numeric values or perform any file I/O
(for example, do not call open or json.load).

[INSTRUCTION]
Using ONLY the information above, write a complete Python script that:

1) Imports gurobipy (import gurobipy as gp; from gurobipy import GRB),
2) Assumes the JSON has already been loaded into a Python variable called `data`,
3) Builds and solves a mixed-integer linear program that reflects the business
   description and the structure implied by the JSON fields (including capacities,
   shelf life, lead times, substitution edges, transshipment edges, and other keys/conditions present in `data`),
4) Prints the solver status and the optimal objective value.

Do not invent extra data. Do not change any numbers from the JSON.
Return ONLY the Python source code as plain text, with no comments and no Markdown.
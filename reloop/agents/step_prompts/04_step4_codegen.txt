STEP 4 - GENERATE GUROBIPY SCRIPT

Output ONLY raw Python code. No markdown, no comments.
First character must be: import

=============================================================================
TASK
=============================================================================

Translate the constraint templates from Step 3 into GurobiPy code.
Read all parameters from `data` dict. No file I/O.

=============================================================================
DATA ACCESS (CRITICAL)
=============================================================================

Network data is NESTED - use safe access:
  sub_edges = data.get('network', {}).get('sub_edges', [])
  trans_edges = data.get('network', {}).get('trans_edges', [])

DO NOT use data['sub_edges'] - this will cause KeyError!

=============================================================================
OUTPUT FORMAT
=============================================================================

End your code with:
- Set Gurobi params: OutputFlag=0, Threads=1, Seed=0
- Call optimize()
- Print status (always)
- Print objective (only if OPTIMAL)

=============================================================================
VARIABLE NAMING
=============================================================================

Use dictionary-style variables with tuple keys:
- I[p,l,t,a]: inventory by remaining life bucket
- y[p,l,t,a]: sales from each life bucket
- W[p,l,t]: waste
- Q[p,l,t]: orders/production
- L[p,l,t]: lost sales
- S[p_from,p_to,l,t]: substitution flow (only if sub_edges nonempty)
- X[p,src,dst,t]: transshipment (only if trans_edges nonempty)
- z[p,l,t]: binary order indicator (only if moq > 0 or fixed_order > 0)
- n[p,l,t]: integer pack count (only if pack_size > 1)

=============================================================================
OPTIONAL FEATURES (check data and implement if present)
=============================================================================

Check these fields and implement constraints ONLY if active:
- moq = data.get('constraints',{}).get('moq',0) → if >0: Q >= moq*z, Q <= bigM*z
- pack_size = data.get('constraints',{}).get('pack_size',1) → if >1: Q = pack_size*n
- fixed_order = data['costs'].get('fixed_order',0) → if >0: add to objective
- trans_edges → if nonempty: create X, include in inventory balance
- budget = data.get('constraints',{}).get('budget_per_period') → if set: cost <= budget
- labor_usage/labor_cap → if labor_usage > 0: labor constraint
- return_rate → if > 0: add returns to fresh inflow
- waste_limit_pct → if set: total waste <= limit * total_demand

=============================================================================
SUBSTITUTION IMPLEMENTATION
=============================================================================

sub_edges = [[p_from, p_to], ...] means p_from's demand served by p_to.

If sub_edges is empty, do NOT create S variables or substitution constraints.

Before creating constraints, build mappings to know:
- For each product, which products can serve its demand (outgoing)
- For each product, which products' demand it serves (incoming)

=============================================================================
BOUNDARY RULES (CRITICAL)
=============================================================================

1. INITIALIZATION at t=1:
   - Non-fresh buckets must be zero: for a < shelf_life[p], set I[p,l,1,a] = 0
   - This is MANDATORY - without it, model may have unbounded free inventory
   - This causes objective = 0 if missing

2. AGING at t=T:
   - Do NOT create aging constraints for the final period
   - They would reference period T+1 which does not exist

3. FRESH INFLOW:
   - Check if t > lead_time before accessing past orders
   - If t <= lead_time: fresh inflow = 0
   - Never access Q[p,l,0] or negative period indices

4. HOLDING COST:
   - Apply only to life buckets a >= 2
   - Bucket a=1 is expiring and not held overnight

=============================================================================
CONSTRAINT CHECKLIST
=============================================================================

Verify you have implemented ALL of these:

[ ] Initialization: I[p,l,1,a] = 0 for a < shelf_life[p]
[ ] Fresh inflow: I[p,l,t,shelf_life] from orders (with lead_time check)
[ ] Aging: inventory moves between buckets (only for t < T)
[ ] Expire/waste: W = unsold from bucket a=1
[ ] Availability: y[p,l,t,a] <= I[p,l,t,a]
[ ] Sales conservation: sum(y) + L = demand + inbound - outbound
[ ] Demand route: outbound substitution <= demand (if sub_edges nonempty)
[ ] Storage capacity: weighted inventory sum <= cold_capacity
[ ] Production capacity: sum of Q <= production_cap

=============================================================================
OBJECTIVE FUNCTION
=============================================================================

Minimize total cost including:
- Purchasing: read from costs["purchasing"]
- Holding: read from costs["inventory"], apply to (I - y) for a >= 2
  CRITICAL: Holding cost = cost * (I[p,l,t,a] - y[p,l,t,a]), NOT cost * I[p,l,t,a]
- Waste: read from costs["waste"]
- Lost sales: read from costs["lost_sales"]
- Fixed order: costs.get("fixed_order", 0) * z (if z exists)
- Transshipment: costs.get("transshipment", 0) * X (if X exists)

=============================================================================
DO NOT
=============================================================================
- Hard-code any numeric values
- Use markdown or comments in output
- Skip any constraints from Step 3
- Forget the initialization constraints at t=1
- Access negative or zero time indices
- Access data['sub_edges'] directly (use data.get('network', {}).get('sub_edges', []))
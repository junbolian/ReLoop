STEP 4 - GENERATE GUROBIPY SCRIPT

Output ONLY raw Python code. No markdown, no comments.
First character must be: import

=============================================================================
TASK
=============================================================================

Translate the constraint templates from Step 3 into GurobiPy code.
Read all parameters from `data` dict. No file I/O.

=============================================================================
OUTPUT FORMAT
=============================================================================

End your code with:
- Set Gurobi params: OutputFlag=0, Threads=1, Seed=0
- Call optimize()
- Print status (always)
- Print objective (only if OPTIMAL)

=============================================================================
VARIABLE NAMING
=============================================================================

Use dictionary-style variables with tuple keys:
- I[p,l,t,a]: inventory by remaining life bucket
- y[p,l,t,a]: sales from each life bucket
- W[p,l,t]: waste
- Q[p,l,t]: orders/production
- L[p,l,t]: lost sales
- S[p_from,p_to,l,t]: substitution flow (only if sub_edges nonempty)

=============================================================================
SUBSTITUTION IMPLEMENTATION
=============================================================================

sub_edges = [[p_from, p_to], ...] means p_from's demand served by p_to.

Before creating constraints, build mappings to know:
- For each product, which products can serve its demand (outgoing)
- For each product, which products' demand it serves (incoming)

=============================================================================
BOUNDARY RULES (CRITICAL)
=============================================================================

1. INITIALIZATION at t=1:
   - Non-fresh buckets must be zero: for a < shelf_life[p], set I[p,l,1,a] = 0
   - This is MANDATORY - without it, model may have unbounded free inventory
   - This causes objective = 0 if missing

2. AGING at t=T:
   - Do NOT create aging constraints for the final period
   - They would reference period T+1 which does not exist

3. FRESH INFLOW:
   - Check if t > lead_time before accessing past orders
   - If t <= lead_time: fresh inflow = 0
   - Never access Q[p,l,0] or negative period indices

4. HOLDING COST:
   - Apply only to life buckets a >= 2
   - Bucket a=1 is expiring and not held overnight

=============================================================================
CONSTRAINT CHECKLIST
=============================================================================

Verify you have implemented ALL of these:

[ ] Initialization: I[p,l,1,a] = 0 for a < shelf_life[p]
[ ] Fresh inflow: I[p,l,t,shelf_life] from orders (with lead_time check)
[ ] Aging: inventory moves between buckets (only for t < T)
[ ] Expire/waste: W = unsold from bucket a=1
[ ] Availability: y[p,l,t,a] <= I[p,l,t,a]
[ ] Sales conservation: sum(y) + L = demand + inbound - outbound
[ ] Demand route: outbound substitution <= demand (if sub_edges nonempty)
[ ] Storage capacity: weighted inventory sum <= cold_capacity
[ ] Production capacity: sum of Q <= production_cap

=============================================================================
OBJECTIVE FUNCTION
=============================================================================

Minimize total cost including:
- Purchasing: read from costs["purchasing"]
- Holding: read from costs["inventory"], apply to (I - y) for a >= 2
  CRITICAL: Holding cost = cost * (I[p,l,t,a] - y[p,l,t,a]), NOT cost * I[p,l,t,a]
- Waste: read from costs["waste"]
- Lost sales: read from costs["lost_sales"]

=============================================================================
DO NOT
=============================================================================
- Write data = DATA_PLACEHOLDER(you can assume python dict "data" is already loaded).
- Hard-code any numeric values
- Use markdown or comments in output
- Skip any constraints from Step 3
- Forget the initialization constraints at t=1
- Access negative or zero time indices
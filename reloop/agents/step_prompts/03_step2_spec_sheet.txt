STEP 2 â€” BUILD THE MODEL SPEC SHEET

Task:
Produce a structured model specification (NOT code) using:
- Step0 contract
- Step1 tagged sentences
- data_profile (keys present + indexing scheme, not numeric values)

Output requirements:
- Output MUST be a single JSON object, no surrounding text.
- Must match the schema below exactly (keys and nesting).
- No numeric constants unless they are symbolic placeholders (e.g., "data['periods']").

Schema:
{
  "sets": [
    {"name": "P", "description": "products", "source": "data.products"},
    {"name": "L", "description": "locations", "source": "data.locations"},
    {"name": "T", "description": "periods index 0..T-1", "source": "data.periods"},
    {"name": "A", "description": "remaining life index per product if shelf_life active", "source": "data.shelf_life"}
  ],
  "decisions": [
    {"name": "I", "type": "continuous", "domain": ">=0", "indices": ["p","l","t","a"], "meaning": "inventory by remaining life", "active_if": "shelf_life"},
    {"name": "y", "type": "continuous", "domain": ">=0", "indices": ["p","l","t","a"], "meaning": "sales/consumption by remaining life", "active_if": "shelf_life"},
    {"name": "W", "type": "continuous", "domain": ">=0", "indices": ["p","l","t"], "meaning": "waste/disposal", "active_if": "always"},
    {"name": "Q", "type": "continuous", "domain": ">=0", "indices": ["p","l","t"], "meaning": "orders/production allocated to location", "active_if": "always"},
    {"name": "L", "type": "continuous", "domain": ">=0", "indices": ["p","l","t"], "meaning": "lost sales", "active_if": "lost_sales_allowed"},
    {"name": "d", "type": "continuous", "domain": ">=0", "indices": ["p","l","t"], "meaning": "direct demand served by same product", "active_if": "always"},
    {"name": "S", "type": "continuous", "domain": ">=0", "indices": ["p_from","p_to","l","t"], "meaning": "substitution flow serving p_to using p_from", "active_if": "sub_edges_nonempty"},
    {"name": "X", "type": "continuous", "domain": ">=0", "indices": ["l_from","l_to","p","t"], "meaning": "transshipment flow", "active_if": "trans_edges_nonempty"},
    {"name": "z", "type": "binary", "domain": "{0,1}", "indices": ["p","l","t"], "meaning": "order trigger for fixed cost / MOQ", "active_if": "moq_or_fixed_order"},
    {"name": "n", "type": "integer", "domain": ">=0", "indices": ["p","l","t"], "meaning": "pack multiple", "active_if": "pack_size"}
  ],
  "objective_terms": [
    {"name": "inventory_holding", "expression": "sum(inv_cost[p] * eligible_inventory[p,l,t,a])", "source": "costs.inventory", "active_if": "costs.inventory_present"},
    {"name": "lost_sales_penalty", "expression": "sum(lost_cost[p] * L[p,l,t])", "source": "costs.lost_sales", "active_if": "costs.lost_sales_present"},
    {"name": "waste_cost", "expression": "sum(waste_cost[p] * W[p,l,t])", "source": "costs.waste", "active_if": "costs.waste_present"},
    {"name": "purchasing_cost", "expression": "sum(purchasing[p] * Q[p,l,t])", "source": "costs.purchasing", "active_if": "costs.purchasing_present"},
    {"name": "fixed_order_cost", "expression": "sum(fixed_order * z[p,l,t])", "source": "costs.fixed_order", "active_if": "fixed_order_present"},
    {"name": "transshipment_cost", "expression": "sum(trans_cost * X[l_from,l_to,p,t])", "source": "costs.transshipment", "active_if": "trans_edges_nonempty_and_cost_present"}
  ],
  "constraint_families": [
    {"prefix": "demand_route", "meaning": "demand is split into direct served, substitution served, and lost sales", "indices": ["p","l","t"], "sense": "=", "active_if": "demand_present"},
    {"prefix": "availability", "meaning": "sales/substitution cannot exceed available inventory (by life if active)", "indices": ["p","l","t","a?"], "sense": "<=", "active_if": "always"},
    {"prefix": "aging", "meaning": "strict aging equality for inventory by remaining life", "indices": ["p","l","t","a"], "sense": "=", "active_if": "shelf_life"},
    {"prefix": "expire_clear", "meaning": "items with remaining life 1 at end of period are removed (waste)", "indices": ["p","l","t"], "sense": "=", "active_if": "shelf_life"},
    {"prefix": "fresh_inflow", "meaning": "new inflow arrives into freshest bucket (a = shelf_life)", "indices": ["p","l","t"], "sense": "=", "active_if": "shelf_life"},
    {"prefix": "storage_cap", "meaning": "weighted cold capacity across products", "indices": ["l","t"], "sense": "<=", "active_if": "cold_capacity_present"},
    {"prefix": "prod_cap", "meaning": "global production capacity per product per period across all locations", "indices": ["p","t"], "sense": "<=", "active_if": "production_cap_present"},
    {"prefix": "labor_cap", "meaning": "labor usage across products limited by labor capacity", "indices": ["l","t"], "sense": "<=", "active_if": "labor_cap_present"},
    {"prefix": "leadtime", "meaning": "orders placed arrive after lead_time", "indices": ["p","l","t"], "sense": "=", "active_if": "lead_time_positive"},
    {"prefix": "moq_lb", "meaning": "if order triggered then quantity >= MOQ", "indices": ["p","l","t"], "sense": ">=", "active_if": "moq_present"},
    {"prefix": "moq_ub", "meaning": "if not triggered then quantity = 0 (or <= M z)", "indices": ["p","l","t"], "sense": "<=", "active_if": "moq_present_or_fixed_order"},
    {"prefix": "pack", "meaning": "order quantities are integer multiples of pack size", "indices": ["p","l","t"], "sense": "=", "active_if": "pack_size_present"},
    {"prefix": "budget", "meaning": "per-period purchasing + fixed costs within budget", "indices": ["t"], "sense": "<=", "active_if": "budget_present"},
    {"prefix": "wastecap", "meaning": "waste limited by waste_limit_pct (define base explicitly)", "indices": ["p?","l?","t?"], "sense": "<=", "active_if": "waste_limit_pct_present"}
  ],
  "edge_cases": [
    {"case": "t0_init", "handling": "if initial inventory not provided, assume 0; else map into appropriate life bucket"},
    {"case": "lead_time_boundary", "handling": "for t < lead_time, arrivals are 0"},
    {"case": "shelf_life_boundary", "handling": "for a out of range, do not create variables; handle a=1 expiration explicitly"},
    {"case": "empty_edges", "handling": "if sub_edges empty then do not create S; if trans_edges empty then do not create X"}
  ],
  "open_questions": [
    {"question": "Define the denominator/base for waste_limit_pct (demand vs sales vs inflow). If not specified, choose demand for same p,l,t as base and justify."}
  ]
}

Rules:
- Must respect naming contract (variable dictionaries names and constraint name prefixes).
- Do not introduce new variables beyond the naming contract.
- If a module is not active per data_profile, keep it but set active_if accordingly; it will be skipped later by the compiler.

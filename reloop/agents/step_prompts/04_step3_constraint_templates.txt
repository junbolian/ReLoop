STEP 3 â€” MAP BUSINESS RULES TO CONSTRAINT FAMILY TEMPLATES

Task:
Using the spec_sheet, produce constraint templates that are symbolic, explicit, and checkable.
Templates represent mathematical structure, NOT executable code.

Do NOT:
- Use numeric constants.
- Resolve boundary conditions by enumeration.
- Introduce variables outside the naming contract.
- Invent mechanisms not present in the spec_sheet.

Output:
- A single JSON array.
- No surrounding text.

Element schema:
{
  "prefix": "aging",
  "template_type": "BALANCE|CAPACITY|DYNAMICS|NETWORK|SUBSTITUTION|DISCRETE",
  "applies_when": "short condition such as 'shelf_life active'",
  "indices": ["p","l","t","a"],
  "equations": [
    {
      "name_suffix": "p_l_t_a",
      "sense": "=",
      "lhs": "I[p,l,t+1,a]",
      "rhs": "I[p,l,t,a+1] - y[p,l,t,a+1]"
    }
  ],
  "notes": ["short notes about boundary handling and linkage requirements"]
}

General rules:
- Use ONLY variable names from the naming contract:
  I, y, W, Q, L, d, S, X, z, n.
- Expressions may reference data symbolically (e.g., demand[p,l,t], production_cap[p,t], cold_capacity[l,t]).
- Use symbolic time shifts such as t+1 or t-lead[p] or t-1.
- Boundary conditions (t=0, t=T-1, a limits) MUST be described in notes, not enumerated in equations.
- All templates must be consistent with spec_sheet meanings and active_if conditions.
- If any referenced parameter is list-valued per period, notes MUST state: "time series uses PAD_LAST alignment to T (and clip tail)".

Required template families and constraints:

1) Demand routing (with substitution)
- If substitution is active: d[p,l,t] + sum_{p_from can serve p} S[p_from,p,l,t] + L[p,l,t] = demand[p,l,t].
- If substitution is inactive: d[p,l,t] + L[p,l,t] = demand[p,l,t].
- template_type = BALANCE.
- Notes MUST state substitution edges are directional and determined by sub_edges.

2) sales_conservation (Supply-side consumption linkage, CRITICAL)
- Any quantity that serves demand MUST consume inventory.
- Enforce: sum_a y[p,l,t,a] = d[p,l,t] + sum_{p_to} S[p,p_to,l,t].
- template_type = BALANCE.
- Notes MUST explicitly state substitution consumes supplying product inventory via y.

3) availability (Consumption cannot exceed inventory)
- When shelf_life active: y[p,l,t,a] <= I[p,l,t,a] for all valid a.
- template_type = BALANCE or DYNAMICS.


4) Aging dynamics (perishability)
- For valid a where a+1 exists: I[p,l,t+1,a] = I[p,l,t,a+1] - y[p,l,t,a+1].
- template_type = DYNAMICS.
- Notes MUST state this is an inter-period state transition and applies only for valid indices.

5) expire_clear (Expiration / waste definition, CRITICAL)
- Waste is NOT free: W[p,l,t] = I[p,l,t,1] - y[p,l,t,1].
- template_type = DYNAMICS.
- Notes MUST state expiration is physical (defining equality).

6) Fresh inflow into inventory (CRITICAL MERGE POINT)
- All inflows enter the freshest bucket a = Amax[p].
- RHS MUST symbolically include active components:
  - arrivals from orders after lead time: Q[p,l,t-lead[p]]
  - net transshipment if transshipment active: sum_in X - sum_out X
  - returns if return_rate active: return_rate[p] * (previous-period total y)
- template_type = DYNAMICS.
- Notes MUST state this is the only entry point into inventory.
- Notes MUST state this is the only entry point into inventory.

7) storage_cap (Capacity)
- Weighted capacity: sum_p sum_a I[p,l,t,a] * cold_usage[p] <= cold_capacity[l,t].
- template_type = CAPACITY.

8) prod_cap (Capacity)
- Global per product per period: sum_l Q[p,l,t] <= production_cap[p,t].
- template_type = CAPACITY.

9) labor_cap (Capacity, if active)
- Labor usage based on volume served/consumed: sum_p labor_usage[p] * (sum_a y[p,l,t,a]) <= labor_cap[l,t].
- template_type = CAPACITY.


10) returns (If active)
- Define returns input used by fresh_inflow: returns[p,l,t] = return_rate[p] * (sum_a y[p,l,t-1,a]).
- If you do not introduce an extra variable, describe it in notes as an expression used inside fresh_inflow.
- template_type = DYNAMICS.

11) pack (Discrete)
- Q[p,l,t] = pack_size * n[p,l,t].
- template_type = DISCRETE.

12) moq_lb / moq_ub (Discrete)
- Q[p,l,t] >= moq * z[p,l,t]
- Q[p,l,t] <= M[p,t] * z[p,l,t]
- Big-M MUST be derived symbolically from data bounds (e.g., production_cap or demand upper bounds), never hard-coded.
- Notes MUST explain runtime derivation of M.

13) budget (If active)
- Per-period purchasing cost plus fixed ordering cost <= budget[t].
- template_type = CAPACITY.

14) wastecap (If active)
- Total waste bounded by waste_limit_pct times a named symbolic base (prefer total demand).
- template_type = CAPACITY.




8) Discrete ordering rules
- Pack size:
  Q[p,l,t] = pack_size * n[p,l,t].
- MOQ / fixed order trigger:
  Q[p,l,t] >= moq * z[p,l,t],
  Q[p,l,t] <= M * z[p,l,t].
- Big-M MUST be derived symbolically from data bounds (e.g., caps or demand), never hard-coded.
- Use template_type = DISCRETE.
- Notes MUST explain the source of M.

9) Budget constraint (if active)
- Per-period purchasing cost plus fixed ordering cost must not exceed budget[t].
- Use template_type = CAPACITY.

10) Waste cap (if active)
- Total waste bounded by waste_limit_pct times a specified base quantity.
- Base quantity MUST be named symbolically and referenced consistently.
- Use template_type = CAPACITY.

Final rules:
- Do NOT relax physical feasibility using penalties.
- If a mechanism is active in spec_sheet, it MUST appear in exactly one constraint family.
- Templates should be minimal but complete: no redundant equations, no missing linkages.




"""
ReLoop Repair Safety Guardrails

Prevents repair LLM from modifying input data or introducing dangerous operations.

Core principle: repair can only modify model logic (constraints, variables, objective),
not input data. The `data` variable is provided externally and must not be reassigned
or mutated by repair code.

Safety checks:
1. Regex-based pattern matching (fast, catches obvious violations)
2. AST-based analysis (precise, catches subtle violations)
3. Dangerous import detection (os, subprocess, etc.)
"""

import re
import ast
import logging
from typing import List, Tuple

logger = logging.getLogger(__name__)

# Protected variable names: these are provided externally and must not be reassigned
PROTECTED_VARIABLES = {
    'data',           # Main data variable
    'input_data',     # Possible alias
    'problem_data',   # Possible alias
    'params',         # If params is used to pass data
}

# Regex patterns for dangerous operations (checked line-by-line)
PROTECTED_PATTERNS = [
    # Redefine data variable with dict literal (fabricated data — always dangerous)
    (r'^\s*data\s*=\s*\{', 'Redefines data variable with dict literal'),
    # Note: `data = json.loads(...)` is NOT blocked here — it re-parses existing data,
    # not fabricates new values. The AST check still catches `data = <any assignment>`,
    # but the prompt now explicitly discourages json.loads usage.

    # Modify data contents: data["key"] = value
    # Note: data["key"]["subkey"] READ is fine; only top-level assignment is blocked
    (r'^\s*data\s*\[.+\]\s*=\s*(?!data)', 'Modifies data variable contents'),

    # Dangerous imports
    (r'^\s*import\s+os\b', 'Imports os module'),
    (r'^\s*import\s+subprocess\b', 'Imports subprocess module'),
    (r'^\s*from\s+os\s+import', 'Imports from os module'),
    (r'^\s*from\s+subprocess\s+import', 'Imports from subprocess module'),
]


def _is_json_loads_call(node: ast.expr) -> bool:
    """Check if an AST node is a json.loads(...) call."""
    return (
        isinstance(node, ast.Call)
        and isinstance(node.func, ast.Attribute)
        and node.func.attr == 'loads'
        and isinstance(node.func.value, ast.Name)
        and node.func.value.id == 'json'
    )


def validate_repair_code(
    repaired_code: str,
    original_code: str,
    data: dict = None,
) -> Tuple[bool, List[str]]:
    """
    Validate that repair LLM output is safe.

    Checks:
    1. No reassignment of protected variables (data, etc.)
    2. No mutation of data contents (data["key"] = ...)
    3. No dangerous imports (os, subprocess)
    4. AST-level: no assignment targets on protected variables

    Args:
        repaired_code: Code generated by repair LLM
        original_code: Code before repair (for context)
        data: External data dict (for future validation)

    Returns:
        (is_safe, violations): is_safe=True means code is safe.
                               violations is a list of violation descriptions.
    """
    violations = []

    # Check 1: Regex pattern matching (fast, line-by-line)
    for line_num, line in enumerate(repaired_code.split('\n'), 1):
        for pattern, description in PROTECTED_PATTERNS:
            if re.match(pattern, line):
                violations.append(
                    f"Line {line_num}: {description}\n  Code: {line.strip()}"
                )

    # Check 2: AST-level analysis (precise)
    try:
        tree = ast.parse(repaired_code)
        for node in ast.walk(tree):
            # Simple assignment: data = ...
            if isinstance(node, ast.Assign):
                for target in node.targets:
                    if isinstance(target, ast.Name) and target.id in PROTECTED_VARIABLES:
                        # Allow data = json.loads(...) — re-parses existing data,
                        # does not fabricate new values.  The prompt discourages
                        # this pattern, but it is not inherently dangerous.
                        if _is_json_loads_call(node.value):
                            continue
                        violations.append(
                            f"Line {node.lineno}: Assignment to protected "
                            f"variable '{target.id}'"
                        )
                    # Subscript assignment: data[...] = ...
                    if (isinstance(target, ast.Subscript)
                            and isinstance(target.value, ast.Name)
                            and target.value.id in PROTECTED_VARIABLES):
                        violations.append(
                            f"Line {node.lineno}: Modification of protected "
                            f"variable '{target.value.id}' contents"
                        )

            # Augmented assignment: data += ... or data[...] += ...
            if isinstance(node, ast.AugAssign):
                target = node.target
                if isinstance(target, ast.Name) and target.id in PROTECTED_VARIABLES:
                    violations.append(
                        f"Line {node.lineno}: Augmented assignment to "
                        f"protected variable '{target.id}'"
                    )
                if (isinstance(target, ast.Subscript)
                        and isinstance(target.value, ast.Name)
                        and target.value.id in PROTECTED_VARIABLES):
                    violations.append(
                        f"Line {node.lineno}: Augmented assignment modifying "
                        f"protected variable '{target.value.id}' contents"
                    )
    except SyntaxError:
        # If code has syntax errors, let it pass this check.
        # L1 execution will catch syntax errors.
        pass

    # Deduplicate while preserving order
    violations = list(dict.fromkeys(violations))

    is_safe = len(violations) == 0
    return is_safe, violations


# Safety rules text to embed in repair prompts
REPAIR_SAFETY_RULES = """
SAFETY RULES (violations will cause your repair to be rejected):
- Do NOT redefine the 'data' variable. Data is provided externally as a Python dict.
- Do NOT use json.loads() — 'data' is already a dict, access keys directly with data["key"].
- Do NOT modify data contents (no data[key] = new_value).
- Only modify the optimization model: variables, constraints, objective function."""

# Re-repair prompt for safety violations
SAFETY_RE_REPAIR_PROMPT = """Your previous repair was REJECTED because it violated safety rules:

{violations}

CRITICAL RULES:
1. Do NOT redefine the 'data' variable. Data is provided externally and must not be modified.
2. Do NOT use json.loads() — 'data' is ALREADY a Python dict. Access it directly: data["key"].
3. Do NOT assign new values to data[...]. Only READ from data.
4. Only modify the optimization model (variables, constraints, objective).
5. The `data` variable is PRE-DEFINED. Do NOT create `data = {{...}}`.

Please fix your code again, following these rules.

"""
